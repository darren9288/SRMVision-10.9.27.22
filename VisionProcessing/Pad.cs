
using System;
using System.Collections;
using System.Collections.Generic;
using System.Text;
using System.Drawing;
using System.IO;
#if (Debug_2_12 || Release_2_12)
using Euresys.Open_eVision_2_12;
#elif (DEBUG || RELEASE || RTXRelease || RTXDebug)
using Euresys.Open_eVision_1_2;
#endif
using Common;
using System.Windows.Forms;
using System.Linq;

namespace VisionProcessing
{
    public class Pad
    {
        #region enum

        public enum PadIndex { Top = 1, Right = 2, Bottom = 3, Left = 4 };

        #endregion

        #region Member Variables
        //Color
        private int m_intColorDefectLinkMethod = 0; // 0: No Link, 1: Nearest Neighbour
        private int m_intColorDefectLinkTolerance = 10;
        private int m_intColorPadGroupIndex = 0; // 0x01:Center, 0x02:Top, 0x04:Right, 0x08:Bottom, 0x10:Left
        private EColorLookup m_objColorLookupYSH = new EColorLookup();
        private EColorLookup m_objColorLookupLSH = new EColorLookup();
        private EColorLookup m_objColorLookupRGB = new EColorLookup();
        private EBlobs m_objColorBlobs = new EBlobs();
        private List<string> m_arrDefectColorThresName = new List<string>();
        private List<int> m_arrDefectColorSystem = new List<int>(); // 0:HSL, 1:RGB, 2:Saturation
        private List<int> m_arrDefectCloseIteration = new List<int>();
        private List<bool> m_arrDefectInvertBlackWhite = new List<bool>();
        private List<int[]> m_arrDefectColor = new List<int[]>();
        private List<int[]> m_arrDefectColorTolerance = new List<int[]>();
        private List<int> m_arrDefectColorMinArea = new List<int>();
        private List<int> m_arrDefectType = new List<int>(); //0:Defect, 1:Good
        private List<int> m_arrDefectDontCareMode = new List<int>(); //0:None, 1:Pad Area, 2:Package Area, 3:Manual Area
        private List<int> m_arrDefectColorInspection_Top = new List<int>();
        private List<int> m_arrDefectColorInspection_Right = new List<int>();
        private List<int> m_arrDefectColorInspection_Bottom = new List<int>();
        private List<int> m_arrDefectColorInspection_Left = new List<int>();
        private List<int> m_arrDefectImageNo = new List<int>();
        private List<int> m_arrDefectColorInspectionFailCondition = new List<int>(); // 0:OR, 1:AND
        private List<float> m_arrDefectColorInspectionWidth = new List<float>();
        private List<float> m_arrDefectColorInspectionLength = new List<float>();
        private List<float> m_arrDefectColorInspectionMinArea = new List<float>();
        private List<float> m_arrDefectColorInspectionMaxArea = new List<float>();
        private List<float> m_arrDefectColorInspectionTotalArea = new List<float>();
        private int m_intSelectedCopThresIndex = 0;
        private int[] m_intCopperColor = new int[3];
        private int[] m_intCopperColorTolerance = new int[3];
        // 0x01 : Threshold Set 1 Length
        // 0x02 : Threshold Set 1 Area
        // 0x04 : Threshold Set 2 Length
        // 0x08 : Threshold Set 2 Area
        // 0x10 : Threshold Set 3 Length
        // 0x20 : Threshold Set 3 Area
        // 0x40 : Threshold Set 4 Length
        // 0x80 : Threshold Set 4 Area
        // 0x100 : Threshold Set 5 Length
        // 0x200 : Threshold Set 5 Area
        private int m_intFailColorOptionMask = 0;
        private int m_intFailColorResultMask = 0; // 0x01 : Threshold Set 1, 0x02 : Threshold Set 2, 0x04 : Threshold Set 3, 0x08 : Threshold Set 4, 0x10 : Threshold Set 5
        struct ColorDefect
        {
            public string ref_strName;
            public float ref_fStartX;
            public float ref_fStartY;
            public float ref_fEndX;
            public float ref_fEndY;
            public float ref_fWidth;        // Keep defect pixel value for drawing
            public float ref_fHeight;       // Keep defect pixel value for drawing
            public float ref_fArea;
            public float ref_fAngle;
            public float ref_fCenterX;
            public float ref_fCenterY;
            public float ref_fFailValue;    // Keep fail value for display message
            public float ref_fWidthFailValue;
            public float ref_fHeightFailValue;
            public float ref_fAreaFailValue;
            public int ref_intBlobNo;
            // 0x01: Threshold Set 1
            // 0x02: Threshold Set 2
            // 0x04: Threshold Set 3
            // 0x08: Threshold Set 4
            // 0x10: Threshold Set 5
            public int ref_intFailMask;
            public int ref_intFailCriteria; // 0x01:width, 0x02:Height, 0x04:Area
            public int ref_intImageNo;
            public float ref_fWidthInMM;
            public float ref_fHeightInMM;
            public float ref_fAreaInMM2;

            public bool ref_blnFailTotalArea;
        }

        private List<ColorDefect> m_arrColorDefectList = new List<ColorDefect>();

        private bool m_blnTestAllPad = false;

        private float m_fUnitMatcherTemplateCenterX = 0;
        private float m_fUnitMatcherTemplateCenterY = 0;

        private int m_intOrientDirections = 4;       // 2 = Rectangle units and 4 = Square unit

        private int m_intPadROIStartPixelFromTop = 0;     // Tolerance edge for Pad ROI.
        private int m_intPadROIStartPixelFromRight = 0;
        private int m_intPadROIStartPixelFromBottom = 0;
        private int m_intPadROIStartPixelFromLeft = 0;

        private float m_fPackageWidthOffsetMM = 0;
        private float m_fPackageHeightOffsetMM = 0;
        private float m_fPackageThicknessOffsetMM = 0;

        private int m_intVisionIndex = 0;
        private bool m_blnWhiteOnBlack = true;
        private bool m_blnSelected = false;
        private bool m_blnPkgDefectSelected = false;
        private bool m_blnPadDefectSelected = false;
        private bool m_blnViewUnitPositionDrawing = false;
        private bool m_blnViewEdgeNotFoundDrawing = false;
        private bool m_blnViewPkgSizeDrawing = false;
        private bool m_blnViewPadResultDrawing = false;
        private bool m_blnViewPkgResultDrwaing = false;
        private bool m_blnViewGroupClassificationDrawing = false;
        private bool m_bUseEmptyUnitThreshold = false;
        private bool m_blnWantTightSetting = false;
        private bool m_blnWantGaugeMeasurePkgSize = false;
        private bool m_blnWantConsiderPadImage2 = false;
        private bool m_blnWantPRUnitLocationBeforeGauge = false;
        private bool m_blnInspectPackage;
        private bool m_blnMeasureCenterPkgSizeUsingSidePkg = false;
        private bool m_blnUseDetailDefectCriteria = false;
        private bool m_blnWantCollectPadEdgeGaugePoints = true;
        private bool m_blnWantSensitivityOnPadDuringLearning = false;
        private bool m_blnWantDontCarePadForPackage = false;
        private bool m_blnWantDontCareArea_Pad = false;
        private bool m_blnWantDontCareArea_Package = false;
        private bool m_blnWantEdgeLimit_Pad = false;
        private bool m_blnWantEdgeDistance_Pad = false;
        private bool m_blnWantSpan_Pad = false;
        private bool m_blnWantStandOff_Pad = false;
        private bool m_blnWantUseBorderLimitAsOffset = false;
        private int m_intPadOffsetReferencePoint = 0; // 0:Center Point, 1:Top Left Corner Point
        private bool m_blnWantIndividualSideThickness = false;

        /// <summary>
        /// TRUE=   Use previous closest size (area and pitch) setting as current new pads setting during learing pad.
        /// FALSE=  When pads count is not tally, then will auto define default tolerance setting to new pads.
        /// </summary>
        private bool m_blnWantUseGaugeMeasureDimension = false;
        private bool m_blnWantUseClosestSizeDefineTolerance = false;
        private bool m_blnWantAutoGauge = false;
        private bool m_blnWantRotateSidePadImage = true;    // Set default true bcos this feature is ON before set it as optional in Advance Setting.
        private bool m_blnWantLinkDifferentGroupPitchGap = false;
        private bool m_blnWantSeparateBrokenPadThresholdSetting = false;
        private bool m_blnWantUseGroupToleranceSetting = false;      // false = use pad setting (default), true = use group setting
        private bool m_blnWantShowUseGaugeCheckBox = false;
        private bool m_blnWantViewCheckForeignMaterialOptionWhenPackageON = false;

        private bool m_blnWantCheckExtraPadArea = false;
        private bool m_blnWantCheckExtraPadLength = false;
        private bool m_blnWantCheckBrokenPadArea = false;
        private bool m_blnWantCheckBrokenPadLength = false;
        private bool m_blnWantCheckExcessPadArea = false;
        private bool m_blnWantCheckExcessPadLength = false; //Redundant, only use m_blnWantCheckExcessPadArea to decide check or dont check excess
        private bool m_blnWantCheckSmearPadLength = false;
        private bool m_blnWantCheckPadEdgeLimit = false;
        private bool m_blnWantCheckPadEdgeDistance = false;
        private bool m_blnWantCheckPadSpanX = false;
        private bool m_blnWantCheckPadSpanY = false;
        private bool m_blnWantCheckPadStandOff = false;

        private bool m_blnExcessPadInspected = false;
        private bool m_blnBrokenPadInspected = false;
        private bool m_blnPadInspected = false;
        private bool m_blnPadFound = false;
        private float m_fAngleTolerance = 1;
        private float m_fXTolerance = 10;
        private float m_fYTolerance = 10;
        private float m_fEmptyMinScore = 0;
        private float m_fPadPRSScore = 0;
        private float m_fUnitAngleLimit = 0;
        private float m_fDefaultPixelTolerance = 3; // For pad dimension default min and max tolerance.
        private float m_fDefineSizePixel = 3;       // Use to define pad's direction mask(left, right, top, bottom or/and center)
        private float m_fSmearLength = 4;
        private float m_fTotalExtraPadSetArea = 0.004f;
        private float m_fExtraPadSetArea = 0.004f;
        private float m_fExtraPadSetLength = 0.001f;
        private float m_fExcessPadSetArea = 0.004f;
        private float m_fExcessPadSetLength = 0.001f;

        private float m_fEdgeDistanceMin_Top = 0;
        private float m_fEdgeDistanceMax_Top = 0;
        private float m_fEdgeDistanceMin_Right = 0;
        private float m_fEdgeDistanceMax_Right = 0;
        private float m_fEdgeDistanceMin_Bottom = 0;
        private float m_fEdgeDistanceMax_Bottom = 0;
        private float m_fEdgeDistanceMin_Left = 0;
        private float m_fEdgeDistanceMax_Left = 0;

        private float m_fMinSpanX = 0;
        private float m_fMaxSpanX = 0;
        private float m_fMinSpanY = 0;
        private float m_fMaxSpanY = 0;

        private float m_fFilterMinArea = 20; //For learning
        private float m_fBlobsMinArea = 20; //For inspection
        private float m_fImageMerge2BlobsMinArea = 20; //For inspection
        private float m_fSurfaceMinArea = 20; //For inspection
        private float m_fImage2SurfaceMinArea = 20; //For inspection
        private float m_fMoldFlashMinArea = 20; //For inspection
        private float m_fVoidMinArea = 20;//For inspection
        private int m_intForeignMaterialBrightFieldMinArea = 20;
        private float m_fCrackMinArea = 20;//For inspection
        private int m_intBrightFieldMinArea = 20;
        private int m_intDarkFieldMinArea = 20;

        private float m_fPosToleranceX = 0;
        private float m_fPosToleranceY = 0;
        private float m_fImageGain = 1f;
        private float m_fTightSettingTolerance = 0.01f;
        private int m_intSavePadTemplateImageMethod = 0; // 0=Contour , 1=Blob 
        private int m_intPadSubtractMethod = 0; // 0=Pad Individual Subtract(Default) , 1=Refer Optimum Pad 
        private int m_intPadEdgeGaugePointToPackageEdgeTolerance = -3;
        private int m_intPadWidthLengthMode = 0; // 0=Auto, 1=Length==Vertical, 2=Width==Vertical
        private int m_intPadLabelRefCorner = 0; // 0=TopLeft, 1=TopRight, 2=BottomLeft, 3=BottomRight
        private int m_intPadLabelDirection = 0; // 0=Clockwise, 1=CounterClockwise
        private int m_intSensitivityOnPadMethod = 0;    // 0=No add Sensitivity Feature On Pad, 1= Add Split Feature On Pad, 2=Add Merge Feature On Pad
        private int m_intSensitivityOnPadValue = 0;     // 1 to 10
        private int m_intTightSettingThresholdTolerance = 25;
        private int m_intInspectPadMode = 0;    // 0x00= Threshold + Sensitivity, 0x01=Threshold + Auto Sensitivity
        // 2019 08 27 - CCENG : No longer use. Replaced by m_intMPErodeHalfWidth and m_intMPDilateHalfWidth
        //private int m_intPadSizeHalfWidthTolerance = 3; // Use as HalfWidth Parameter during Dilate/Erode m_intPadSizeHalfWidthTolerance (During loading Pad) 
        private int m_intPadROIDirection = 0;  //0=Center, 1=Top, 2=Right, 3=Bottom, 4=Left
        private int m_intEmptyAreaColorTransition = 0; // 0=lower than black Color, 1=lower than white color, 2=higher than black color, 3=higher than white color.
        private int m_intEmptyAreaLimit = 0;
        private int m_intEmptyThreshold = 125;
        private int m_intThresholdValue = -4;
        //private int m_intImageMerge2ThresholdValue = -4;
        private int m_intImageMerge2ThresholdHighValue = 255;
        private int m_intImageMerge2ThresholdLowValue = 0;
        private int m_intThresholdValuePrev = -4;
        private int m_intSurfaceThresholdValue = -4;        // For Surface High Threshold as well
        private int m_intSurfaceLowThresholdValue = 0;
        private int m_intInterPadThresholdValue = -4;
        private int m_intDarkThresholdValue = -4;
        private int m_intCopperThresholdValue = -4;
        private int m_intDarkBrokenPadThresholdValue = -4;
        private int m_intMaxArea = 25000000;
        /// <summary>
        // 0x01: Foreign Material / Contamination (Represent area and length)
        // 0x02: Bridge
        // 0x04: Missing Pad
        // 0x08: Broken Pad (Splite / Scratch)  
        // 0x10: Broken Pad (Hole)  
        // 0x20: Area
        // 0x40: Width
        // 0x80: Height
        // 0x100: OffSet
        // 0x200: Pitch
        // 0x400: Gap
        // 0x800: Excess
        // 0x1000: Total Foreign Material / Contamination
        // 0x2000: Smear
        // 0x4000: Edge Limit
        // 0x8000: Stand Off
        // 0x10000: Edge distance
        // 0x20000: SpanX
        // 0x40000: SpanY
        /// </summary>
        private int m_intFailOptionMask = 0;
        private int m_intSelectedGroupNoForGrouping = 0;
        private int m_intPadROISizeTolerance = 10;
        private int m_intPadROISizeToleranceADV = 10;
        private int m_intBrokenPadImageViewNo = 0;
        private int m_intPadPkgSizeImageViewNo = 0;
        private int m_intPadPkgBrightFieldImageViewNo = 0;
        private int m_intPadPkgDarkFieldImageViewNo = 1;
        private int m_intPadPkgMoldFlashImageViewNo = 0;
        private List<List<float>> m_arrPadPointGaugeStartX = new List<List<float>>();
        private List<List<float>> m_arrPadPointGaugeStartY = new List<List<float>>();
        private List<List<float>> m_arrPadPointGaugeTolerance = new List<List<float>>();
        private List<List<float>> m_arrPadPointGaugeAngle = new List<List<float>>();
        private List<List<PointF>> m_arrPadEdgeGaugePoints = new List<List<PointF>>();
        private List<List<bool>> m_arrPadEdgeGaugePointsFound = new List<List<bool>>();
        private List<int> m_arrSelectedPadForGrouping = new List<int>();
        /// <summary>
        // 0x01: Foreign Material / Contamination
        // 0x02: Bridge
        // 0x04: Missing Pad
        // 0x08: Broken Pad (Splite / Scratch)
        // 0x10: Broken Pad (Hole)
        // 0x20: Area
        // 0x40: Width
        // 0x80: Height
        // 0x100: OffSet
        // 0x200: Pitch
        // 0x400: Gap
        // 0x800: Excess
        // 0x1000: Total Foreign Material / Contamination
        // 0x2000: Smear
        // 0x4000: Edge Limit ///Empty Unit
        // 0x8000: Stand Off ///Positioning
        // 0x10000: Positioning
        // 0x10000: Line 3
        // 0x20000: Line 4
        // 0x40000: Line 5
        // 0x80000: Line 6
        // 0x100000: Line 7
        // 0x200000: Edge Limit Top
        // 0x400000: Edge Limit Right
        // 0x800000: Edge Limit Bottom
        // 0x1000000: Edge Limit Left
        // 0x2000000: Stand Off Top
        // 0x4000000: Stand Off Bottom
        // 0x8000000: Stand Off Left
        // 0x10000000: Stand Off Right
        // 0x20000000: Edge Distance Top
        // 0x40000000: Edge Distance Right
        // 0x80000000: Edge Distance Bottom
        // 0x100000000: Edge Distance Left
        // 0x200000000: Span X
        // 0x400000000: Span Y
        // 0x800000000: Line 8
        // 0x1000000000: Line 9
        // 0x2000000000: Line 10
        // 0x4000000000: Line 11
        // 0x8000000000: Line 12
        /// </summary>
        private long m_intFailResultMask = 0;
        private bool m_blnFailForeignMaterialLength = false;
        private bool m_blnFailForeignMaterialArea = false;
        private bool m_blnFailBrokenArea = false;
        private bool m_blnFailBrokenLength = false;
        private bool m_blnFailExcessArea = false;
        private bool m_blnFailExcessLength = false;
        /// <summary>
        /// 0x01: Package Size
        /// 0x04: Chipped off Area
        /// 0x08: Scratches Area
        /// 0x10: Contamination Length
        /// 0x20: Contamination Area
        /// 0x40: Contamination Total Area
        /// 0x80: Mold Flash
        /// 0x100: Void Length
        /// 0x200: Void Area
        /// 0x400: Crack Length
        /// 0x800: Crack Area
        /// 0x1000: Scratches Length
        /// 0x10000: Bright Area
        /// 0x20000: Bright Length
        /// 0x40000: Dark Area
        /// 0x80000: Dark Length
        /// </summary>
        private int m_intFailPkgOptionMask = 0;
        /// <summary>
        // // 0x01: Package Size
        // 0x02: Crack
        // 0x04: Chipped Off
        // 0x08: Scratches
        // 0x10: Contamination
        // 0x20: Solder melt
        // 0x40: Void
        // 0x80: Mold Flash
        // 0x100: Incomplete Plating
        // 0x10000: Bright
        // 0x20000: Dark
        // 0x40000: Foreign Material
        /// </summary>
        private int m_intFailPkgResultMask = 0;
        private int m_intGaugeSizeImageIndex = 0;
        private int m_intCheckPadDimensionImageIndex = 0;
        private int[] m_intTemplateMatchStatus;
        private int[] m_intSampleMatchNumber;
        private float m_fPadRangeStartX;
        private float m_fPadRangeStartY;
        private float m_fPadRangeEndX;
        private float m_fPadRangeEndY;
        private float m_fSamplePadRangeStartX;
        private float m_fSamplePadRangeStartY;
        private float m_fSamplePadRangeEndX;
        private float m_fSamplePadRangeEndY;

        private float m_fOffSetX;
        private float m_fOffSetY;
        private float m_fOffsetOffSet;
        private float m_fWidthOffSet;
        private float m_fHeightOffSet;
        private float m_fPitchOffSet;
        private float m_fGapOffSet;
        /// <summary>
        /// Dimension 1: Golden Data Set No (e.g. Set 1, Set 2...
        /// Dimension 2: Golden Data Count (e.g. Width 1, Width 2...
        /// Dimension 3: Golden Data Type (e.g. Width, Length)
        /// </summary>
        private List<List<List<float>>> m_arrGoldenData = new List<List<List<float>>>();
        private List<bool> m_arrGoldenDataUsed = new List<bool>();

        private Color[] m_colorList = { Color.Aqua, Color.Lime, Color.DeepPink, Color.OrangeRed, Color.Aquamarine, Color.Gold, Color.Fuchsia, Color.MediumSpringGreen, Color.Blue, Color.Violet };
        private Font m_Font = new Font("Verdana", 10);
        private ArrayList m_arrTemplateBlobPads = new ArrayList();
        private ArrayList m_arrGroupTemplateBlobPads = new ArrayList();
        private ArrayList m_arrTemporaryBlobPads = new ArrayList();
        private ArrayList m_arrTemporaryBlobPads_ForReset = new ArrayList();
        private ArrayList m_arrBackupTemplateBlobPads = new ArrayList();
        private ArrayList m_arrBackupGroupTemplateBlobPads = new ArrayList();
        private ArrayList m_arrTolePitchGap = new ArrayList();
        private List<PitchGap> m_arrPitchGap = new List<PitchGap>();
        private List<PitchGap> m_arrBackupPitchGap = new List<PitchGap>();
        //private BlobsFeatures m_stcBlobPad = new BlobsFeatures();
        private ToleranceBlobsFeatures m_stcBackupTemplateBlobPad = new ToleranceBlobsFeatures();   // Keep previous tolerance setting for learning 
        private SampleBlobsFeatures[] m_arrSampleBlobPads;          // sample blobs
        private SampleBlobsFeatures[] m_arrBackupBlobPads;          // sample blobs
        private SampleBlobsFeatures[] m_arrSamplePadBroken;          // sample blobs for Broken Information each pad.
        private SampleBlobsFeatures[] m_arrSamplePadSmear;          // sample blobs for Smear Information each pad.
        private SampleBlobsFeatures[] m_arrSamplePadEdge;          // sample blobs for Edge Information each pad.
        private SampleBlobsFeatures[] m_arrSamplePadStandOff;          // sample blobs for Stand Off Information each pad.
        private SampleBlobsFeatures[] m_arrSamplePadExcess;          // sample blobs for Excess Information each pad.
        private List<SampleExtraBlobsFeatures> m_arrExtraBlobs = new List<SampleExtraBlobsFeatures>(); // Extra pad, join pad
        private List<Defect> m_arrPadDefectList = new List<Defect>(); // Broken pad, Scratch pad
        private PitchGap m_stcPitchGap = new PitchGap();
        private TolerancePitchGap m_stcTolePitchGap = new TolerancePitchGap();      // Keep previous tolerance setting for learning
        private ROI m_ErodeROI = new ROI();
        private ROI m_DilateROI = new ROI();
        private ROI m_objLocalROI = new ROI();
        private ROI m_objLocalROI2 = new ROI();
        private Contour m_objTemplateContour = new Contour();
        private Contour m_objSampleContour = new Contour();
        private List<PitchGap> m_arrFailPitchGapList = new List<PitchGap>();
        private Crosshair m_objPosCrosshair;
        private List<float> m_arrExtraBlobCenterX = new List<float>();  // Keep center X for all pass and fail extra blobs
        private List<float> m_arrExtraBlobCenterY = new List<float>();  // Keep center Y for all pass and fail extra blobs 
        private List<float> m_arrExtraBlobWidth = new List<float>();    // Keep width for all pass and fail extra blobs 
        private List<float> m_arrExtraBlobHeight = new List<float>();   // Keep Height for all pass and fail extra blobs 
        private List<GroupSetting> m_arrGroupSettings = new List<GroupSetting>();
        private PGauge m_objPointGauge;
        private PGauge m_objSettingPointGauge;

        private EBlobs m_objEBlobs = new EBlobs();
        private EBlobs m_objConvalEBlobs = new EBlobs();
        private EBlobs m_objBackupEBlobs = new EBlobs();
        private EBlobs m_objErodeEBlobs = new EBlobs();
        private EBlobs m_objDilateEBlobs = new EBlobs();
        private EBlobs m_objExtraPadEBlobs = new EBlobs();
        private EBlobs m_objSurfaceEBlobs = new EBlobs();
        private EBlobs m_objLocalUsedBlobs = new EBlobs();

        private LineROI m_objSplitPadLine = new LineROI();
        private int m_intCounttt = 0;
        private int m_intTurn = 0;
        private bool m_blnIsSplitLineDisplaying = false;
        private bool m_blnSplitHorizontal = true;
        private int m_intMaxExtraLineCount = 2;
        // Calibration
        private float m_fAreaMMPerPixel = 14;
        private float m_fMMPerPixelX = 1;
        private float m_fMMPerPixelY = 1;

        private float m_fSizeOffSetX = 0;
        private float m_fSizeOffSetY = 0;

        private float m_fMMToPixelXValue = 1;
        private float m_fMMToPixelYValue = 1;
        private float m_fMMtoPixelAreaValue = 1;

        private float m_fMMToUnitValue = 1;
        private float m_fMMToUnitValueArea = 1;

        private float m_intDecimal = 4;
        private float m_intDecimal2 = 6;
        // Error Message Used
        private string m_strErrorMessage;
        private float m_fResultExtraPadMinArea = -1;
        private float m_fResultExtraPadMaxArea = -1;
        private float m_fResultTotalExtraPadArea = -1;
        private float m_fResultBrightFieldTotalArea = -1;
        private float m_fResultDarkFieldTotalArea = -1;
        private float m_fResultBrokenMinArea = -1;
        private float m_fResultBrokenMaxArea = -1;
        private float m_fResultExcessMinArea = -1;
        private float m_fResultExcessMaxArea = -1;
        private float m_fResultSmearMinLength = -1;
        private float m_fResultSmearMaxLength = -1;
        private float m_fResultScratchMinArea = -1;
        private float m_fResultScratchMaxArea = -1;
        private float m_fResultPadEdgeDistance_Top = 0;
        private float m_fResultPadEdgeDistance_Right = 0;
        private float m_fResultPadEdgeDistance_Bottom = 0;
        private float m_fResultPadEdgeDistance_Left = 0;
        private int m_intResultPadNoEdgeDistance_Top = -1;
        private int m_intResultPadNoEdgeDistance_Right = -1;
        private int m_intResultPadNoEdgeDistance_Bottom = -1;
        private int m_intResultPadNoEdgeDistance_Left = -1;

        private float m_fResultPadSpanX = 0;
        private float m_fResultPadSpanY = 0;

        // Template Image
        private EImageBW8 m_ImgSearchROITemplateImage = new EImageBW8();
        private EImageBW8 m_ImgUnitTemplateImage = new EImageBW8();
        private EImageBW8 m_ImgUnitTemplateImage_Sat = new EImageBW8();
        private EImageBW8 m_ImgUnitTemplateImage_CleanBackground = new EImageBW8();
        private EImageBW8 m_ImgTUnitDilateThresImage = new EImageBW8();
        private EImageBW8 m_ImgTUnitErodeThresImage = new EImageBW8();
        private EImageBW8 m_ImgTUnitInvertThresImage = new EImageBW8();
        private EImageBW8 m_ImgTPadImage1 = new EImageBW8();
        private EImageBW8 m_ImgWhiteUnitTemplateImage = new EImageBW8();
        private EImageBW8 m_ImgWhiteUnitTemplateImage2 = new EImageBW8();
        private EImageBW8 m_ImgBlackUnitTemplateImage = new EImageBW8();
        private EImageBW8 m_ImgBlackUnitTemplateImage2 = new EImageBW8();
        private EImageBW8 m_ImgMPUnitTemplateImage = new EImageBW8();
        private List<EImageBW8> m_arrImgPadImage = new List<EImageBW8>();

        private EImageBW8 m_ImgUnitTemplateImagePkg = new EImageBW8(); //Package
        private EImageBW8 m_ImgTUnitDilateThresImagePkg = new EImageBW8();//Package
        private EImageBW8 m_ImgTUnitErodeThresImagePkg = new EImageBW8();//Package
        private EImageBW8 m_ImgTUnitInvertThresImagePkg = new EImageBW8();//Package
        private EImageBW8 m_ImgWhiteUnitTemplateImagePkg = new EImageBW8();//Package
        private EImageBW8 m_ImgBlackUnitTemplateImagePkg = new EImageBW8();//Package

        private ImageDrawing m_ImgTilt_Top_L = new ImageDrawing();//Tilt
        private ImageDrawing m_ImgTilt_Top_R = new ImageDrawing();//Tilt
        private ImageDrawing m_ImgTilt_Right_T = new ImageDrawing();//Tilt
        private ImageDrawing m_ImgTilt_Right_B = new ImageDrawing();//Tilt
        private ImageDrawing m_ImgTilt_Bottom_R = new ImageDrawing();//Tilt
        private ImageDrawing m_ImgTilt_Bottom_L = new ImageDrawing();//Tilt
        private ImageDrawing m_ImgTilt_Left_B = new ImageDrawing();//Tilt
        private ImageDrawing m_ImgTilt_Left_T = new ImageDrawing();//Tilt
        private ImageDrawing m_ImgTiltInverted_Top_L = new ImageDrawing();//Tilt
        private ImageDrawing m_ImgTiltInverted_Top_R = new ImageDrawing();//Tilt
        private ImageDrawing m_ImgTiltInverted_Right_T = new ImageDrawing();//Tilt
        private ImageDrawing m_ImgTiltInverted_Right_B = new ImageDrawing();//Tilt
        private ImageDrawing m_ImgTiltInverted_Bottom_R = new ImageDrawing();//Tilt
        private ImageDrawing m_ImgTiltInverted_Bottom_L = new ImageDrawing();//Tilt
        private ImageDrawing m_ImgTiltInverted_Left_B = new ImageDrawing();//Tilt
        private ImageDrawing m_ImgTiltInverted_Left_T = new ImageDrawing();//Tilt
        // Inspection Image
        private ImageDrawing m_objInsPadPkgImage1;
        private ImageDrawing m_objInsSurfacePkgImage1;
        private ImageDrawing m_objInsChipOffPkgImage1;
        private ImageDrawing m_objInsPkgImage2;
        private ImageDrawing m_objInsChipOffPkgImage2;
        private ImageDrawing m_objInsPkgImage3;
        private ImageDrawing m_objDestImage;
        private ImageDrawing m_objContaminateImage;
        private ImageDrawing m_objSampleImage;
        private ImageDrawing m_objPadThresholdImage;
        private ImageDrawing m_objInterPadThresholdImage;
        //Dont Care Image
        private ImageDrawing[] m_arrPadColorDontCareImage = new ImageDrawing[5];
        private ImageDrawing m_objPadDontCareImage = new ImageDrawing();
        private ImageDrawing m_objPackageDontCareImageWhite = new ImageDrawing();
        private ImageDrawing m_objPackageDontCareImageBlack = new ImageDrawing();

        // PRS for unit position and angle.
        private EMatcher m_objMatcher = new EMatcher();
        private PointF m_pUnitCenterPoint = new PointF();
        private float m_fUnitAngle = 0f;

        private int m_intSensitivityOnPadValue_Current = 0;
        private float m_fSmallestFailWidthLengthValue = -0;
        #endregion

        #region Struct 

        struct BlobsFeatures
        {
            // Object Data
            public int intNoID;
            public int intObjNo;
            public int intDirection;       //1 = left column, 2 = right column, 4 = high row, 8 = low row
            public int intSide;             //1 = top side, 2 = right side, 4 = bottom side, 8 = left side
            public int intSmearSide;  //1 = Left side, 2 = right side, 4 = top side, 8 = bottom side
            public int intGroupID;
            public int intLengthMode;  // 1: Length = Height, 2: Length = Width
            public int intContourX;
            public int intContourY;
            public float fArea;
            public int intStartX;
            public int intStartY;
            public int intEndX;
            public int intEndY;
            public float fStartX;
            public float fStartY;
            public float fEndX;
            public float fEndY;
            public float fCenterX;
            public float fCenterY;
            public float fLimitCenterX;
            public float fLimitCenterY;
            public float fWidth;
            public float fHeight;
            public float fWidthPercentStart1; // for pad dimension start point
            public float fHeightPercentStart1;  // for pad dimension start point
            public float fWidthPercentEnd1; // for pad dimension end point 
            public float fHeightPercentEnd1;  // for pad dimension end point
            public float fWidthPercentStart2; // for pad dimension start point
            public float fHeightPercentStart2;  // for pad dimension start point
            public float fWidthPercentEnd2; // for pad dimension end point 
            public float fHeightPercentEnd2;  // for pad dimension end point
            public float fWidthPercentStart3; // for pad dimension start point
            public float fHeightPercentStart3;  // for pad dimension start point
            public float fWidthPercentEnd3; // for pad dimension end point 
            public float fHeightPercentEnd3;  // for pad dimension end point
            public float fWidthPercentStart4; // for pad dimension start point
            public float fHeightPercentStart4;  // for pad dimension start point
            public float fWidthPercentEnd4; // for pad dimension end point 
            public float fHeightPercentEnd4;  // for pad dimension end point
            public float fWidthPercentStart5; // for pad dimension start point
            public float fHeightPercentStart5;  // for pad dimension start point
            public float fWidthPercentEnd5; // for pad dimension end point 
            public float fHeightPercentEnd5;  // for pad dimension end point
            public float fWidthPercentStart6; // for pad dimension start point
            public float fHeightPercentStart6;  // for pad dimension start point
            public float fWidthPercentEnd6; // for pad dimension end point 
            public float fHeightPercentEnd6;  // for pad dimension end point
            public float fWidthPercentStart7; // for pad dimension start point
            public float fHeightPercentStart7;  // for pad dimension start point
            public float fWidthPercentEnd7; // for pad dimension end point 
            public float fHeightPercentEnd7;  // for pad dimension end point
            public float fWidthPercentStart8; // for pad dimension start point
            public float fHeightPercentStart8;  // for pad dimension start point
            public float fWidthPercentEnd8; // for pad dimension end point 
            public float fHeightPercentEnd8;  // for pad dimension end point
            public float fWidthPercentStart9; // for pad dimension start point
            public float fHeightPercentStart9;  // for pad dimension start point
            public float fWidthPercentEnd9; // for pad dimension end point 
            public float fHeightPercentEnd9;  // for pad dimension end point
            public float fWidthPercentStart10; // for pad dimension start point
            public float fHeightPercentStart10;  // for pad dimension start point
            public float fWidthPercentEnd10; // for pad dimension end point 
            public float fHeightPercentEnd10;  // for pad dimension end point
            public float fWidthPercentStart11; // for pad dimension start point
            public float fHeightPercentStart11;  // for pad dimension start point
            public float fWidthPercentEnd11; // for pad dimension end point 
            public float fHeightPercentEnd11;  // for pad dimension end point
            public float fWidthPercentStart12; // for pad dimension start point
            public float fHeightPercentStart12;  // for pad dimension start point
            public float fWidthPercentEnd12; // for pad dimension end point 
            public float fHeightPercentEnd12;  // for pad dimension end point
            public float fInwardPercentStart1;
            public float fInwardPercentEnd1;
            public float fInwardPercentStart2;
            public float fInwardPercentEnd2;
            public float fInwardPercentStart3;
            public float fInwardPercentEnd3;
            public float fInwardPercentStart4;
            public float fInwardPercentEnd4;
            public float fInwardPercentStart5;
            public float fInwardPercentEnd5;
            public float fInwardPercentStart6;
            public float fInwardPercentEnd6;
            public float fInwardPercentStart7;
            public float fInwardPercentEnd7;
            public float fInwardPercentStart8;
            public float fInwardPercentEnd8;
            public float fInwardPercentStart9;
            public float fInwardPercentEnd9;
            public float fInwardPercentStart10;
            public float fInwardPercentEnd10;
            public float fInwardPercentStart11;
            public float fInwardPercentEnd11;
            public float fInwardPercentStart12;
            public float fInwardPercentEnd12;
            public int intMeasureMethod1; //0=Line Distance, 1=Basic XY
            public int intMeasureMethod2; //0=Line Distance, 1=Basic XY
            public int intMeasureMethod3; //0=Line Distance, 1=Basic XY
            public int intMeasureMethod4; //0=Line Distance, 1=Basic XY
            public int intMeasureMethod5; //0=Line Distance, 1=Basic XY
            public int intMeasureMethod6; //0=Line Distance, 1=Basic XY
            public int intMeasureMethod7; //0=Line Distance, 1=Basic XY
            public int intMeasureMethod8; //0=Line Distance, 1=Basic XY
            public int intMeasureMethod9; //0=Line Distance, 1=Basic XY
            public int intMeasureMethod10; //0=Line Distance, 1=Basic XY
            public int intMeasureMethod11; //0=Line Distance, 1=Basic XY
            public int intMeasureMethod12; //0=Line Distance, 1=Basic XY
            public float fAngle;
            public int intLineCount;
            public float fFeretCenterX;
            public float fFeretCenterY;
            public float fFeretWidth;
            public float fFeretHeight;
            public float fFeretAngle;
            public int intFeretLengthMode;
            public bool blnFeretActivated;
            public int P1X;
            public int P1Y;
            public int P2X;
            public int P2Y;
            public int P3X;
            public int P3Y;
            public int P4X;
            public int P4Y;
            public bool blnSelected;
            public bool ref_blnSelected { get { return blnSelected; } set { blnSelected = value; } }
            public bool blnEnable;

            // Object Relation Data
            public float fLeftDistance;
            public float fRightDistance;
            public float fTopDistance;
            public float fBottomDistance;
            public float fXDistance;
            public float fYDistance;
            public float fTemplateROICenterX;
            public float fTemplateROICenterY;
            public float fTemplateROITopLeftCornerX;
            public float fTemplateROITopLeftCornerY;
            public float fXDistance_Pattern;
            public float fYDistance_Pattern;
            public float fTemplateROICenterX_Pattern;
            public float fTemplateROICenterY_Pattern;
            public float fTemplateROITopLeftCornerX_Pattern;
            public float fTemplateROITopLeftCornerY_Pattern;
            public float fPitch;
            public float fGap;

            // Inspection Data
            public float fOffSet;
            public float fMinArea;
            public float fMaxArea;
            public float fMinWidth;
            public float fMaxWidth;
            public float fMinLength;
            public float fMaxLength;
            public float fMinPitch;
            public float fMaxPitch;
            public float fMinGap;
            public float fMaxGap;
            public float fMaxBroken;
            public float fMaxBrokenLength;
            public float fMaxExcess;
            public float fMaxSmearLength;
            public float fOffsetOffSet;
            public float fWidthOffset;
            public float fHeightOffset;
            public float fPitchOffset;
            public float fGapOffset;
            public float fMinLine3;// for pad dimension
            public float fMaxLine3;// for pad dimension
            public float fMinLine4;// for pad dimension
            public float fMaxLine4;// for pad dimension
            public float fMinLine5;// for pad dimension
            public float fMaxLine5;// for pad dimension
            public float fMinLine6;// for pad dimension
            public float fMaxLine6;// for pad dimension
            public float fMinLine7;// for pad dimension
            public float fMaxLine7;// for pad dimension
            public float fMinLine8;// for pad dimension
            public float fMaxLine8;// for pad dimension
            public float fMinLine9;// for pad dimension
            public float fMaxLine9;// for pad dimension
            public float fMinLine10;// for pad dimension
            public float fMaxLine10;// for pad dimension
            public float fMinLine11;// for pad dimension
            public float fMaxLine11;// for pad dimension
            public float fMinLine12;// for pad dimension
            public float fMaxLine12;// for pad dimension

            public float fPadInspectionAreaFromTop;
            public float fPadInspectionAreaFromRight;
            public float fPadInspectionAreaFromBottom;
            public float fPadInspectionAreaFromLeft;

            public float fEdgeLimitTop;
            public float fEdgeLimitRight;
            public float fEdgeLimitBottom;
            public float fEdgeLimitLeft;
            public float fMaxStandOffTop;
            public float fMaxStandOffBottom;
            public float fMaxStandOffLeft;
            public float fMaxStandOffRight;

            public float fEdgeDistanceTopOffset;
            public float fEdgeDistanceRightOffset;
            public float fEdgeDistanceBottomOffset;
            public float fEdgeDistanceLeftOffset;
            public float fEdgeLimitTopOffset;
            public float fEdgeLimitRightOffset;
            public float fEdgeLimitBottomOffset;
            public float fEdgeLimitLeftOffset;
            public float fStandOffTopOffset;
            public float fStandOffBottomOffset;
            public float fStandOffLeftOffset;
            public float fStandOffRightOffset;

            //Stand Off
            public int intReferTopBottom; // 0 = Top, 1 = Bottom
            public bool blnCheckTop;
            public bool blnCheckBottom;
            public int intReferLeftRight; // 0 = Left, 1 = Right
            public bool blnCheckLeft;
            public bool blnCheckRight;
        }
        struct SampleBlobsFeatures
        {
            // Result
            public float fOffSetMM;
            public float fAreaMM;
            public float fWidthMM;
            public float fHeightMM;
            public float fPitchMM;
            public float fGapMM;

            // Object Data in pixel
            public float fOffSet;
            public float fArea;
            public float fWidth;
            public float fHeight;
            public float fPitch;
            public float fGap;
            public float fLine3MM;// for pad dimension
            public float fLine4MM;// for pad dimension
            public float fLine5MM;// for pad dimension
            public float fLine6MM;// for pad dimension
            public float fLine7MM;// for pad dimension
            public float fLine8MM;// for pad dimension
            public float fLine9MM;// for pad dimension
            public float fLine10MM;// for pad dimension
            public float fLine11MM;// for pad dimension
            public float fLine12MM;// for pad dimension

            public long intFailMask;
            public float fStartX;
            public float fStartY;
            public float fEndX;
            public float fEndY;
            public float fCenterX;
            public float fCenterY;
            public float fGravityCenterX;
            public float fGravityCenterY;
            public float fFeretCenterX;
            public float fFeretCenterY;
            public float fFeretWidth;
            public float fFeretHeight;
            public float fFeretAngle;

            public float fSmearLength;

            //Edge Limit
            public float fEdgeTop;
            public float fEdgeRight;
            public float fEdgeBottom;
            public float fEdgeLeft;

            //Stand Off
            public float fStandOffTop;
            public float fStandOffBottom;
            public float fStandOffLeft;
            public float fStandOffRight;
    
            public int intContourIndex; // Keep sample blob index

            public float fStartXLine1;
            public float fStartYLine1;
            public float fEndXLine1;
            public float fEndYLine1;

            public float fStartXLine2;
            public float fStartYLine2;
            public float fEndXLine2;
            public float fEndYLine2;

            public float fStartXLine3;
            public float fStartYLine3;
            public float fEndXLine3;
            public float fEndYLine3;

            public float fStartXLine4;
            public float fStartYLine4;
            public float fEndXLine4;
            public float fEndYLine4;

            public float fStartXLine5;
            public float fStartYLine5;
            public float fEndXLine5;
            public float fEndYLine5;

            public float fStartXLine6;
            public float fStartYLine6;
            public float fEndXLine6;
            public float fEndYLine6;

            public float fStartXLine7;
            public float fStartYLine7;
            public float fEndXLine7;
            public float fEndYLine7;

            public float fStartXLine8;
            public float fStartYLine8;
            public float fEndXLine8;
            public float fEndYLine8;

            public float fStartXLine9;
            public float fStartYLine9;
            public float fEndXLine9;
            public float fEndYLine9;

            public float fStartXLine10;
            public float fStartYLine10;
            public float fEndXLine10;
            public float fEndYLine10;

            public float fStartXLine11;
            public float fStartYLine11;
            public float fEndXLine11;
            public float fEndYLine11;

            public float fStartXLine12;
            public float fStartYLine12;
            public float fEndXLine12;
            public float fEndYLine12;

            public int P1X;
            public int P1Y;
            public int P2X;
            public int P2Y;
            public int P3X;
            public int P3Y;
            public int P4X;
            public int P4Y;

            public float fBlobCenterX;
            public float fBlobCenterY;
            public float fBlobWidth;
            public float fBlobHeight;
        }
        struct SampleExtraBlobsFeatures
        {
            // Object Data
            public float fStartX;
            public float fStartY;
            public float fEndX;
            public float fEndY;
            public float fCenterX;
            public float fCenterY;
            public float fWidth;
            public float fHeight;
            public string strDefectName;
            public float fWidthInMM;
            public float fHeightInMM;
            public float fAreaInMM2;
            public int intFailMask; // 0x01=Fail WitdhInMM, 0x02=Fail HeightInMM, 0x04= Fail AreaInMM2
        }
        struct ToleranceBlobsFeatures
        {
            // Inspection Data
            public float fOffSet;
            public float fMinArea;
            public float fMaxArea;
            public float fMinWidth;
            public float fMaxWidth;
            public float fMinLength;
            public float fMaxLength;
            public float fMaxBroken;
            public float fMaxBrokenLength;
            public float fMaxExcess;
            public float fMaxSmearLength;
            public float fOffsetOffSet;
            public float fWidthOffset;
            public float fHeightOffset;
            public float fPitchOffset;
            public float fGapOffset;
            public float fStartX;
            public float fStartY;
            public float fEndX;
            public float fEndY;
            public float fLimitCenterX;
            public float fLimitCenterY;
            public float fEdgeLimitTop;
            public float fEdgeLimitRight;
            public float fEdgeLimitBottom;
            public float fEdgeLimitLeft;
            public float fMaxStandOffTop;
            public float fMaxStandOffBottom;
            public float fMaxStandOffLeft;
            public float fMaxStandOffRight;
            public int intNoID;
            public int intGroupID;
            public int intDirection;
            public int intLengthMode;  // 1: Length = Height, 2: Length = Width

            public float fLearnArea;
            public float fLearnWidth;
            public float fLearnHeight;
            public bool bEnable;

            public float fPadInspectionAreaFromTop;
            public float fPadInspectionAreaFromRight;
            public float fPadInspectionAreaFromBottom;
            public float fPadInspectionAreaFromLeft;

            public float fEdgeDistanceTopOffset;
            public float fEdgeDistanceRightOffset;
            public float fEdgeDistanceBottomOffset;
            public float fEdgeDistanceLeftOffset;
            public float fEdgeLimitTopOffset;
            public float fEdgeLimitRightOffset;
            public float fEdgeLimitBottomOffset;
            public float fEdgeLimitLeftOffset;
            public float fStandOffTopOffset;
            public float fStandOffBottomOffset;
            public float fStandOffLeftOffset;
            public float fStandOffRightOffset;
        }
        struct TolerancePitchGap
        {
            public float fMinPitch;
            public float fMaxPitch;
            public float fMinGap;
            public float fMaxGap;
        }
        struct PitchGap
        {
            public int intFromPadNo;
            public int intToPadNo;
            public int intDirection;
            public float fPitch;
            public float fGap;
            public float fPitchMM;
            public float fGapMM;
            public float fMinPitch;
            public float fMaxPitch;
            public float fMinGap;
            public float fMaxGap;
            public int intStartPointX;
            public int intStartPointY;
            public int intEndPointX;
            public int intEndPointY;
            public int intFailMask;
        }
        struct GroupSetting
        {
            // Group reference info
            public float fReferenceArea;
            public float fReferenceWidth;
            public float fReferenceHeight;

            // Setting
            public float fOffSet;
            public float fMinArea;
            public float fMaxArea;
            public float fMinWidth;
            public float fMaxWidth;
            public float fMinLength;
            public float fMaxLength;
            public float fMinPitch;
            public float fMaxPitch;
            public float fMinGap;
            public float fMaxGap;
            public float fMaxBroken;
            public float fMaxBrokenLength;
        }

        #endregion

        #region Properties
        //Color
        public int ref_intColorDefectLinkMethod { get { return m_intColorDefectLinkMethod; } set { m_intColorDefectLinkMethod = value; } }
        public int ref_intColorDefectLinkTolerance { get { return m_intColorDefectLinkTolerance; } set { m_intColorDefectLinkTolerance = value; } }
        public List<string> ref_arrDefectColorThresName { get { return m_arrDefectColorThresName; } set { m_arrDefectColorThresName = value; } }
        public List<int> ref_arrDefectColorSystem { get { return m_arrDefectColorSystem; } set { m_arrDefectColorSystem = value; } }
        public List<int>  ref_arrDefectCloseIteration { get { return m_arrDefectCloseIteration; } set { m_arrDefectCloseIteration = value; } }
        public List<bool> ref_arrDefectInvertBlackWhite { get { return m_arrDefectInvertBlackWhite; } set { m_arrDefectInvertBlackWhite = value; } }
        public List<int[]> ref_arrDefectColor { get { return m_arrDefectColor; } set { m_arrDefectColor = value; } }
        public List<int[]> ref_arrDefectColorTolerance { get { return m_arrDefectColorTolerance; } set { m_arrDefectColorTolerance = value; } }
        public List<int> ref_arrDefectColorMinArea { get { return m_arrDefectColorMinArea; } set { m_arrDefectColorMinArea = value; } }
        public List<int> ref_arrDefectType { get { return m_arrDefectType; } set { m_arrDefectType = value; } }
        public List<int> ref_arrDefectImageNo { get { return m_arrDefectImageNo; } set { m_arrDefectImageNo = value; } }
        public int ref_intColorPadGroupIndex { get { return m_intColorPadGroupIndex; } set { m_intColorPadGroupIndex = value; } }
        public List<int> ref_arrDefectDontCareMode { get { return m_arrDefectDontCareMode; } set { m_arrDefectDontCareMode = value; } }
        public List<int> ref_arrDefectColorInspection_Top { get { return m_arrDefectColorInspection_Top; } set { m_arrDefectColorInspection_Top = value; } }
        public List<int> ref_arrDefectColorInspection_Right { get { return m_arrDefectColorInspection_Right; } set { m_arrDefectColorInspection_Right = value; } }
        public List<int> ref_arrDefectColorInspection_Bottom { get { return m_arrDefectColorInspection_Bottom; } set { m_arrDefectColorInspection_Bottom = value; } }
        public List<int> ref_arrDefectColorInspection_Left { get { return m_arrDefectColorInspection_Left; } set { m_arrDefectColorInspection_Left = value; } }
        public List<int> ref_arrDefectColorInspectionFailCondition { get { return m_arrDefectColorInspectionFailCondition; } set { m_arrDefectColorInspectionFailCondition = value; } }
        public List<float> ref_arrDefectColorInspectionWidth { get { return m_arrDefectColorInspectionWidth; } set { m_arrDefectColorInspectionWidth = value; } }
        public List<float> ref_arrDefectColorInspectionLength { get { return m_arrDefectColorInspectionLength; } set { m_arrDefectColorInspectionLength = value; } }
        public List<float> ref_arrDefectColorInspectionMinArea { get { return m_arrDefectColorInspectionMinArea; } set { m_arrDefectColorInspectionMinArea = value; } }
        public List<float> ref_arrDefectColorInspectionMaxArea { get { return m_arrDefectColorInspectionMaxArea; } set { m_arrDefectColorInspectionMaxArea = value; } }
        public List<float> ref_arrDefectColorInspectionTotalArea { get { return m_arrDefectColorInspectionTotalArea; } set { m_arrDefectColorInspectionTotalArea = value; } }
        public int[] ref_intCopperColor { get { return m_intCopperColor; } set { m_intCopperColor = value; } }
        public int[] ref_intCopperColorTolerance { get { return m_intCopperColorTolerance; } set { m_intCopperColorTolerance = value; } }
        public int ref_intFailColorOptionMask { get { return m_intFailColorOptionMask; } set { m_intFailColorOptionMask = value; } }
        public int ref_intFailColorResultMask { get { return m_intFailColorResultMask; } set { m_intFailColorResultMask = value; } }

        public bool ref_blnTestAllPad { get { return m_blnTestAllPad; } set { m_blnTestAllPad = value; } }
        public int ref_intOrientDirections { get { return m_intOrientDirections; } set { m_intOrientDirections = value; } }
        public int ref_intPadROIStartPixelFromTop { get { return m_intPadROIStartPixelFromTop; } set { m_intPadROIStartPixelFromTop = value; } }
        public int ref_intPadROIStartPixelFromRight { get { return m_intPadROIStartPixelFromRight; } set { m_intPadROIStartPixelFromRight = value; } }
        public int ref_intPadROIStartPixelFromBottom { get { return m_intPadROIStartPixelFromBottom; } set { m_intPadROIStartPixelFromBottom = value; } }
        public int ref_intPadROIStartPixelFromLeft { get { return m_intPadROIStartPixelFromLeft; } set { m_intPadROIStartPixelFromLeft = value; } }
        public int ref_intMaxExtraLineCount { get { return m_intMaxExtraLineCount; } set { m_intMaxExtraLineCount = value; } }
        public int ref_intPadGroupCount { get { return m_arrGroupTemplateBlobPads.Count; } }
        public int ref_intUnitTemplateImageWidth { get { return m_ImgUnitTemplateImage.Width; } }
        public int ref_intUnitTemplateImageHeight { get { return m_ImgUnitTemplateImage.Height; } }
        public bool ref_blnPadFound { get { return m_blnPadFound; } }
        public bool ref_blnPadInspected { get { return m_blnPadInspected; } }
        public float ref_fAngleTolerance { get { return m_fAngleTolerance; } set { m_fAngleTolerance = value; } }
        public float ref_fXTolerance { get { return m_fXTolerance; } set { m_fXTolerance = value; } }
        public float ref_fYTolerance { get { return m_fYTolerance; } set { m_fYTolerance = value; } }
        public float ref_fXTolerance_Pixel { get { return m_fXTolerance * m_fMMToPixelXValue; } }
        public float ref_fYTolerance_Pixel { get { return m_fYTolerance * m_fMMToPixelYValue; } }
        public float ref_fOffSetX { get { return m_fOffSetX; } set { m_fOffSetX = value; } }
        public float ref_fOffSetY { get { return m_fOffSetY; } set { m_fOffSetY = value; } }
        public float ref_fOffsetOffSet { get { return m_fOffsetOffSet; } set { m_fOffsetOffSet = value; } }
        public float ref_fWidthOffSet { get { return m_fWidthOffSet; } set { m_fWidthOffSet = value; } }
        public float ref_fHeightOffSet { get { return m_fHeightOffSet; } set { m_fHeightOffSet = value; } }
        public float ref_fPitchOffSet { get { return m_fPitchOffSet; } set { m_fPitchOffSet = value; } }
        public float ref_fGapOffSet { get { return m_fGapOffSet; } set { m_fGapOffSet = value; } }
        public float ref_fResultPadEdgeDistance_Top { get { return m_fResultPadEdgeDistance_Top; } set { m_fResultPadEdgeDistance_Top = value; } }
        public float ref_fResultPadEdgeDistance_Right { get { return m_fResultPadEdgeDistance_Right; } set { m_fResultPadEdgeDistance_Right = value; } }
        public float ref_fResultPadEdgeDistance_Bottom { get { return m_fResultPadEdgeDistance_Bottom; } set { m_fResultPadEdgeDistance_Bottom = value; } }
        public float ref_fResultPadEdgeDistance_Left { get { return m_fResultPadEdgeDistance_Left; } set { m_fResultPadEdgeDistance_Left = value; } }
        public float ref_fResultPadSpanX { get { return m_fResultPadSpanX; } set { m_fResultPadSpanX = value; } }
        public float ref_fResultPadSpanY { get { return m_fResultPadSpanY; } set { m_fResultPadSpanY = value; } }
        public float ref_fSizeOffSetX { get { return m_fSizeOffSetX; } set { m_fSizeOffSetX = value; } }
        public float ref_fSizeOffSetY { get { return m_fSizeOffSetY; } set { m_fSizeOffSetY = value; } }
        public float ref_fDefaultPixelTolerance { get { return m_fDefaultPixelTolerance; } set { m_fDefaultPixelTolerance = value; } }
        public float ref_fDefineSizePixel { get { return m_fDefineSizePixel; } set { m_fDefineSizePixel = value; } }
        public float ref_fAreaPerPixel { get { return m_fAreaMMPerPixel; } set { m_fAreaMMPerPixel = value; } }
        public float ref_fPadRangeStartX { get { return m_fPadRangeStartX; } set { m_fPadRangeStartX = value; } }
        public float ref_fPadRangeStartY { get { return m_fPadRangeStartY; } set { m_fPadRangeStartY = value; } }
        public float ref_fPadRangeEndX { get { return m_fPadRangeEndX; } set { m_fPadRangeEndX = value; } }
        public float ref_fPadRangeEndY { get { return m_fPadRangeEndY; } set { m_fPadRangeEndY = value; } }
        public int ref_intSavePadTemplateImageMethod { get { return m_intSavePadTemplateImageMethod; } set { m_intSavePadTemplateImageMethod = value; } }
        public int ref_intPadOffsetReferencePoint{ get { return m_intPadOffsetReferencePoint; } set { m_intPadOffsetReferencePoint = value; } }
        public int ref_intPadSubtractMethod { get { return m_intPadSubtractMethod; } set { m_intPadSubtractMethod = value; } }
        public int ref_intPadWidthLengthMode { get { return m_intPadWidthLengthMode; } set { m_intPadWidthLengthMode = value; } }
        public int ref_intPadLabelRefCorner { get { return m_intPadLabelRefCorner; } set { m_intPadLabelRefCorner = value; } }
        public int ref_intPadLabelDirection { get { return m_intPadLabelDirection; } set { m_intPadLabelDirection = value; } }

        //public int ref_intPadSizeHalfWidthTolerance { get { return m_intPadSizeHalfWidthTolerance; } set { m_intPadSizeHalfWidthTolerance = value; } }
        public int ref_intFailOptionMask { get { return m_intFailOptionMask; } set { m_intFailOptionMask = value; } }
        public long ref_intFailResultMask { get { return m_intFailResultMask; } set { m_intFailResultMask = value; } }
        public int ref_intFailPkgOptionMask { get { return m_intFailPkgOptionMask; } set { m_intFailPkgOptionMask = value; } }
        public int ref_intFailPkgResultMask { get { return m_intFailPkgResultMask; } set { m_intFailPkgResultMask = value; } }
        public int ref_intGaugeSizeImageIndex { get { return m_intGaugeSizeImageIndex; } set { m_intGaugeSizeImageIndex = value; } }
        public int ref_intCheckPadDimensionImageIndex { get { return m_intCheckPadDimensionImageIndex; } set { m_intCheckPadDimensionImageIndex = value; } }
        public int ref_intPadROISizeTolerance { get { return m_intPadROISizeTolerance; } set { m_intPadROISizeTolerance = value; } }
        public int ref_intPadROISizeToleranceADV { get { return m_intPadROISizeToleranceADV; } set { m_intPadROISizeToleranceADV = value; } }
        public int ref_intBrokenPadImageViewNo { get { return m_intBrokenPadImageViewNo; } set { m_intBrokenPadImageViewNo = value; } }
        public int ref_intPadPkgSizeImageViewNo { get { return m_intPadPkgSizeImageViewNo; } set { m_intPadPkgSizeImageViewNo = value; } }
        public int ref_intPadPkgBrightFieldImageViewNo { get { return m_intPadPkgBrightFieldImageViewNo; } set { m_intPadPkgBrightFieldImageViewNo = value; } }
        public int ref_intPadPkgDarkFieldImageViewNo { get { return m_intPadPkgDarkFieldImageViewNo; } set { m_intPadPkgDarkFieldImageViewNo = value; } }
        public int ref_intPadPkgMoldFlashImageViewNo { get { return m_intPadPkgMoldFlashImageViewNo; } set { m_intPadPkgMoldFlashImageViewNo = value; } }
        public bool ref_bUseEmptyUnitThreshold { get { return m_bUseEmptyUnitThreshold; } set { m_bUseEmptyUnitThreshold = value; } }
        public bool ref_blnWantGaugeMeasurePkgSize { get { return m_blnWantGaugeMeasurePkgSize; } set { m_blnWantGaugeMeasurePkgSize = value; } }
        public bool ref_blnSelected
        {
            get
            {
                return m_blnSelected;
            }
            set
            {
                m_blnSelected = value;
            }
        }
        public bool ref_blnWantIndividualSideThickness { get { return m_blnWantIndividualSideThickness; } set { m_blnWantIndividualSideThickness = value; } }
        public bool ref_blnPadDefectSelected { get { return m_blnPadDefectSelected; } set { m_blnPadDefectSelected = value; } }
        public bool ref_blnPkgDefectSelected { get { return m_blnPkgDefectSelected; } set { m_blnPkgDefectSelected = value; } }
        public bool ref_blnWhiteOnBlack { get { return m_blnWhiteOnBlack; } set { m_blnWhiteOnBlack = value; } }
        public bool ref_blnViewPadResultDrawing { get { return m_blnViewPadResultDrawing; } set { m_blnViewPadResultDrawing = value; } }
        public bool ref_blnViewUnitPositionDrawing { get { return m_blnViewUnitPositionDrawing; } set { m_blnViewUnitPositionDrawing = value; } }
        public bool ref_blnViewEdgeNotFoundDrawing { get { return m_blnViewEdgeNotFoundDrawing; } set { m_blnViewEdgeNotFoundDrawing = value; } }
        public bool ref_blnViewPkgSizeDrawing { get { return m_blnViewPkgSizeDrawing; } set { m_blnViewPkgSizeDrawing = value; } }
        public bool ref_blnViewPkgResultDrwaing { get { return m_blnViewPkgResultDrwaing; } set { m_blnViewPkgResultDrwaing = value; } }
        public bool ref_blnWantTightSetting { get { return m_blnWantTightSetting; } set { m_blnWantTightSetting = value; } }
        public bool ref_blnWantConsiderPadImage2 { get { return m_blnWantConsiderPadImage2; } set { m_blnWantConsiderPadImage2 = value; } }
        public bool ref_blnWantPRUnitLocationBeforeGauge { get { return m_blnWantPRUnitLocationBeforeGauge; } set { m_blnWantPRUnitLocationBeforeGauge = value; } }
        public bool ref_blnMeasureCenterPkgSizeUsingSidePkg { get { return m_blnMeasureCenterPkgSizeUsingSidePkg; } set { m_blnMeasureCenterPkgSizeUsingSidePkg = value; } }
        public bool ref_blnUseDetailDefectCriteria { get { return m_blnUseDetailDefectCriteria; } set { m_blnUseDetailDefectCriteria = value; } }
        public bool ref_blnWantDontCareArea_Package { get { return m_blnWantDontCareArea_Package; } set { m_blnWantDontCareArea_Package = value; } }
        public bool ref_blnWantDontCareArea_Pad { get { return m_blnWantDontCareArea_Pad; } set { m_blnWantDontCareArea_Pad = value; } }
        public bool ref_blnWantDontCarePadForPackage { get { return m_blnWantDontCarePadForPackage; } set { m_blnWantDontCarePadForPackage = value; } }
        public bool ref_blnWantUseBorderLimitAsOffset { get { return m_blnWantUseBorderLimitAsOffset; } set { m_blnWantUseBorderLimitAsOffset = value; } }
        public bool ref_blnWantEdgeLimit_Pad { get { return m_blnWantEdgeLimit_Pad; } set { m_blnWantEdgeLimit_Pad = value; } }
        public bool ref_blnWantEdgeDistance_Pad { get { return m_blnWantEdgeDistance_Pad; } set { m_blnWantEdgeDistance_Pad = value; } }
        public bool ref_blnWantSpan_Pad { get { return m_blnWantSpan_Pad; } set { m_blnWantSpan_Pad = value; } }
        public bool ref_blnWantStandOff_Pad { get { return m_blnWantStandOff_Pad; } set { m_blnWantStandOff_Pad = value; } }
        public bool ref_blnWantSensitivityOnPadDuringLearning { get { return m_blnWantSensitivityOnPadDuringLearning; } set { m_blnWantSensitivityOnPadDuringLearning = value; } }
        public bool ref_blnWantCollectPadEdgeGaugePoints { get { return m_blnWantCollectPadEdgeGaugePoints; } set { m_blnWantCollectPadEdgeGaugePoints = value; } }
        public bool ref_blnWantUseGaugeMeasureDimension { get { return m_blnWantUseGaugeMeasureDimension; } set { m_blnWantUseGaugeMeasureDimension = value; } }
        public bool ref_blnWantUseClosestSizeDefineTolerance { get { return m_blnWantUseClosestSizeDefineTolerance; } set { m_blnWantUseClosestSizeDefineTolerance = value; } }
        public bool ref_blnWantAutoGauge { get { return m_blnWantAutoGauge; } set { m_blnWantAutoGauge = value; } }
        public bool ref_blnWantRotateSidePadImage { get { return m_blnWantRotateSidePadImage; } set { m_blnWantRotateSidePadImage = value; } }
        public bool ref_blnWantLinkDifferentGroupPitchGap { get { return m_blnWantLinkDifferentGroupPitchGap; } set { m_blnWantLinkDifferentGroupPitchGap = value; } }
        public bool ref_blnWantShowUseGaugeCheckBox { get { return m_blnWantShowUseGaugeCheckBox; } set { m_blnWantShowUseGaugeCheckBox = value; } }
        public bool ref_blnWantSeparateBrokenPadThresholdSetting { get { return m_blnWantSeparateBrokenPadThresholdSetting; } set { m_blnWantSeparateBrokenPadThresholdSetting = value; } }
        public bool ref_blnWantViewCheckForeignMaterialOptionWhenPackageON { get { return m_blnWantViewCheckForeignMaterialOptionWhenPackageON; } set { m_blnWantViewCheckForeignMaterialOptionWhenPackageON = value; } }
        public bool ref_blnWantCheckExtraPadArea { get { return m_blnWantCheckExtraPadArea; } set { m_blnWantCheckExtraPadArea = value; } }
        public bool ref_blnWantCheckExtraPadLength { get { return m_blnWantCheckExtraPadLength; } set { m_blnWantCheckExtraPadLength = value; } }
        public bool ref_blnWantCheckBrokenPadArea { get { return m_blnWantCheckBrokenPadArea; } set { m_blnWantCheckBrokenPadArea = value; } }
        public bool ref_blnWantCheckBrokenPadLength { get { return m_blnWantCheckBrokenPadLength; } set { m_blnWantCheckBrokenPadLength = value; } }
        public bool ref_blnWantCheckExcessPadArea { get { return m_blnWantCheckExcessPadArea; } set { m_blnWantCheckExcessPadArea = value; } }
        public bool ref_blnWantCheckExcessPadLength { get { return m_blnWantCheckExcessPadLength; } set { m_blnWantCheckExcessPadLength = value; } }
        public bool ref_blnWantCheckSmearPadLength { get { return m_blnWantCheckSmearPadLength; } set { m_blnWantCheckSmearPadLength = value; } }
        public bool ref_blnWantCheckPadEdgeLimit { get { return m_blnWantCheckPadEdgeLimit; } set { m_blnWantCheckPadEdgeLimit = value; } }
        public bool ref_blnWantCheckPadEdgeDistance { get { return m_blnWantCheckPadEdgeDistance; } set { m_blnWantCheckPadEdgeDistance = value; } }
        public bool ref_blnWantCheckPadSpanX { get { return m_blnWantCheckPadSpanX; } set { m_blnWantCheckPadSpanX = value; } }
        public bool ref_blnWantCheckPadSpanY { get { return m_blnWantCheckPadSpanY; } set { m_blnWantCheckPadSpanY = value; } }
        public bool ref_blnWantCheckPadStandOff { get { return m_blnWantCheckPadStandOff; } set { m_blnWantCheckPadStandOff = value; } }
        public bool ref_blnWantUseGroupToleranceSetting { get { return m_blnWantUseGroupToleranceSetting; } set { m_blnWantUseGroupToleranceSetting = value; } }
        public bool ref_blnViewGroupClassificationDrawing { get { return m_blnViewGroupClassificationDrawing; } set { m_blnViewGroupClassificationDrawing = value; } }

        public int ref_intThresholdValue { get { return m_intThresholdValue; } set { m_intThresholdValue = value; } }
        public int ref_intCopperThresholdValue { get { return m_intCopperThresholdValue; } set { m_intCopperThresholdValue = value; } }
        //public int ref_intImageMerge2ThresholdValue { get { return m_intImageMerge2ThresholdValue; } set { m_intImageMerge2ThresholdValue = value; } }
        public int ref_intImageMerge2ThresholdHighValue { get { return m_intImageMerge2ThresholdHighValue; } set { m_intImageMerge2ThresholdHighValue = value; } }
        public int ref_intImageMerge2ThresholdLowValue { get { return m_intImageMerge2ThresholdLowValue; } set { m_intImageMerge2ThresholdLowValue = value; } }
        public int ref_intSurfaceThresholdValue { get { return m_intSurfaceThresholdValue; } set { m_intSurfaceThresholdValue = value; } }
        public int ref_intSurfaceLowThresholdValue { get { return m_intSurfaceLowThresholdValue; } set { m_intSurfaceLowThresholdValue = value; } }
        public int ref_intInterPadThresholdValue { get { return m_intInterPadThresholdValue; } set { m_intInterPadThresholdValue = value; } }
        public int ref_intEmptyThreshold { get { return m_intEmptyThreshold; } set { m_intEmptyThreshold = value; } }
        public int ref_intEmptyAreaLimit { get { return m_intEmptyAreaLimit; } set { m_intEmptyAreaLimit = value; } }
        public int ref_intEmptyAreaColorTransition { get { return m_intEmptyAreaColorTransition; } set { m_intEmptyAreaColorTransition = value; } }
        public int ref_intTightSettingThresholdTolerance { get { return m_intTightSettingThresholdTolerance; } set { m_intTightSettingThresholdTolerance = value; } }
        public int ref_intInspectPadMode { get { return m_intInspectPadMode; } set { m_intInspectPadMode = value; } }
        public int ref_intSensitivityOnPadMethod { get { return m_intSensitivityOnPadMethod; } set { m_intSensitivityOnPadMethod = value; } }
        public int ref_intSensitivityOnPadValue { get { return m_intSensitivityOnPadValue; } set { m_intSensitivityOnPadValue = value; } }
        public float ref_fTightSettingTolerance { get { return m_fTightSettingTolerance; } set { m_fTightSettingTolerance = value; } }
        public float ref_fEmptyMinScore { get { return m_fEmptyMinScore; } set { m_fEmptyMinScore = value; } }
        public float ref_fPadPRSScore { get { return m_fPadPRSScore; } set { m_fPadPRSScore = value; } }
        public float ref_fUnitAngleLimit { get { return m_fUnitAngleLimit; } set { m_fUnitAngleLimit = value; } }
        public float ref_fPosToleranceX { get { return m_fPosToleranceX; } set { m_fPosToleranceX = value; } }
        public float ref_fPosToleranceY { get { return m_fPosToleranceY; } set { m_fPosToleranceY = value; } }
        public float ref_fImageGain { get { return m_fImageGain; } set { m_fImageGain = value; } }

        public float ref_fSmearLength { get { return m_fSmearLength; } set { m_fSmearLength = value; } }
        public float ref_fExcessPadSetArea { get { return m_fExcessPadSetArea; } set { m_fExcessPadSetArea = value; } }
        public float ref_fFilterMinArea { get { return m_fFilterMinArea; } set { m_fFilterMinArea = value; } }
        public float ref_fBlobsMinArea { get { return m_fBlobsMinArea; } set { m_fBlobsMinArea = value; } }
        public float ref_fImageMerge2BlobsMinArea { get { return m_fImageMerge2BlobsMinArea; } set { m_fImageMerge2BlobsMinArea = value; } }
        public float ref_fSurfaceMinArea { get { return m_fSurfaceMinArea; } set { m_fSurfaceMinArea = value; } }
        public float ref_fImage2SurfaceMinArea { get { return m_fImage2SurfaceMinArea; } set { m_fImage2SurfaceMinArea = value; } }
        public float ref_fMoldFlashMinArea { get { return m_fMoldFlashMinArea; } set { m_fMoldFlashMinArea = value; } }
        public float ref_fVoidMinArea { get { return m_fVoidMinArea; } set { m_fVoidMinArea = value; } }
        public float ref_fCrackMinArea { get { return m_fCrackMinArea; } set { m_fCrackMinArea = value; } }
        public int ref_intForeignMaterialBrightFieldMinArea { set { m_intForeignMaterialBrightFieldMinArea = value; } get { return m_intForeignMaterialBrightFieldMinArea; } }
        public int ref_intBrightFieldMinArea { set { m_intBrightFieldMinArea = value; } get { return m_intBrightFieldMinArea; } }
        public int ref_intDarkFieldMinArea { set { m_intDarkFieldMinArea = value; } get { return m_intDarkFieldMinArea; } }
        public float ref_fMinAreaMM { get { return m_fFilterMinArea * m_fAreaMMPerPixel * m_fAreaMMPerPixel * (float)1e-6; } set { m_fFilterMinArea = (int)Math.Round(value / m_fAreaMMPerPixel * m_fAreaMMPerPixel * (float)1e-6); } }
        public float ref_fMaxAreaMM { get { return m_intMaxArea * m_fAreaMMPerPixel * m_fAreaMMPerPixel * (float)1e-6; } set { m_intMaxArea = (int)Math.Round(value / m_fAreaMMPerPixel * m_fAreaMMPerPixel * (float)1e-6); } }

        public string ref_strErrorMessage { get { return m_strErrorMessage; } set { m_strErrorMessage = value; } }

        public List<List<List<float>>> ref_arrGoldenData { get { return m_arrGoldenData; } set { m_arrGoldenData = value; } }
        public List<bool> ref_arrGoldenDataUsed { get { return m_arrGoldenDataUsed; } set { m_arrGoldenDataUsed = value; } }

        public Crosshair ref_objPosCrosshair { get { return m_objPosCrosshair; } set { m_objPosCrosshair = value; } }
        public PGauge ref_objPointGauge
        {
            get
            {
                return m_objPointGauge;
            }
            set
            {
                m_objPointGauge = value;
            }
        }
        public PGauge ref_objSettingPointGauge
        {
            get
            {
                return m_objSettingPointGauge;
            }
            set
            {
                m_objSettingPointGauge = value;
            }
        }
        #endregion

        #region PACKAGE & POSITION: Private Variable

        private float m_fPkgStartPixelFromEdge = 0;             // Tolerance edge for Package ROI during package inspection. E.g If Unit pkg size is 2x2mm, and the m_fPkgStartPixelFromEdge is 0.02mm, mean the the actual area for pkg inspection is 1.98x1.98mm.
        private float m_fPkgStartPixelFromRight = 0;
        private float m_fPkgStartPixelFromBottom = 0;
        private float m_fPkgStartPixelFromLeft = 0;

        private float m_fPkgStartPixelFromEdge_Dark = 0;           
        private float m_fPkgStartPixelFromRight_Dark = 0;
        private float m_fPkgStartPixelFromBottom_Dark = 0;
        private float m_fPkgStartPixelFromLeft_Dark = 0;

        private float m_fForeignMaterialStartPixelFromEdge = 0;
        private float m_fForeignMaterialStartPixelFromRight = 0;
        private float m_fForeignMaterialStartPixelFromBottom = 0;
        private float m_fForeignMaterialStartPixelFromLeft = 0;

        private float m_fForeignMaterialStartPixelFromEdge_Pad = 0;
        private float m_fForeignMaterialStartPixelFromRight_Pad = 0;
        private float m_fForeignMaterialStartPixelFromBottom_Pad = 0;
        private float m_fForeignMaterialStartPixelFromLeft_Pad = 0;

        private int m_intPkgSizeTolerance = 3;                    // Tolerance size for unit. E.g. If unit size is 100 x 120pixels , mean the actual size to find the pads will 103x 123 pixels.

        private int m_intPkgImage1HighPadThreshold = 255;     // not using
        private int m_intPkgImage1LowPadThreshold = 0;        // not using
        private int m_intPkgImage1HighSurfaceThreshold = 255;
        private int m_intPkgImage1LowSurfaceThreshold = 0;
        private float m_fPkgImage1Gain = 1f;
        private int m_intPkgImage2HighThreshold = 255;
        private int m_intPkgImage2LowThreshold = 0;
        private int m_intPkgImage3HighThreshold = 255;
        private int m_intPkgImage3LowThreshold = 0;
        private int m_intPkgImage1MoldFlashThreshold = 125;
        private int m_intPkgImage2VoidThreshold = 125;
        private int m_intPkgImage2HighCrackThreshold = 255;
        private int m_intPkgImage2LowCrackThreshold = 0;
        private int m_intPkgImage1ChippedThreshold = 125;
        private int m_intForeignMaterialBrightFieldThreshold = 125;
        private int m_intBrightFieldLowThreshold = 50;
        private int m_intBrightFieldHighThreshold = 255;
        private int m_intDarkFieldLowThreshold = 50;
        private float m_fDarkFieldImageGain = 1f;
        private float m_fPadImageGain = 1f;
        private int m_intDarkFieldHighThreshold = 255;


        private float m_fUnitWidth;
        private float m_fUnitHeight;
        private float m_fUnitThickness;
        private float m_fUnitWidthMin;
        private float m_fUnitWidthMax;
        private float m_fUnitHeightMin;
        private float m_fUnitHeightMax;
        private float m_fUnitThicknessMin;
        private float m_fUnitThicknessMax;
        private float m_fUnitSizeLength;

        // Detail Defect Criteria Tolerance Setting
        private float m_fScratchLength;
        private float m_fScratchArea;
        private float m_fChipArea;
        private float m_fContaminationLength;
        private float m_fSolderMeltLength;
        private float m_fVoidLength;
        private float m_fVoidArea;
        private float m_fCrackLength;
        private float m_fCrackArea;
        private float m_fForeignMaterialArea;
        private float m_fMoldFlashArea;
        private float m_fMoldFlashTotalArea;
        private float m_fMoldFlashLength;
        private float m_fMoldFlashWidth;
        private float m_fInCompletePlateLength;
        private float m_fPadBrokenLength;
        private float m_fPadBrokenArea;
        private float m_fChipStartPixelFromEdge;
        private float m_fChipStartPixelFromRight;
        private float m_fChipStartPixelFromLeft;
        private float m_fChipStartPixelFromBottom;
        private float m_fChipStartPixelExtendFromEdge;
        private float m_fChipStartPixelExtendFromRight;
        private float m_fChipStartPixelExtendFromLeft;
        private float m_fChipStartPixelExtendFromBottom;
        private float m_fChipStartPixelFromEdge_Dark;
        private float m_fChipStartPixelFromRight_Dark;
        private float m_fChipStartPixelFromLeft_Dark;
        private float m_fChipStartPixelFromBottom_Dark;
        private float m_fChipStartPixelExtendFromEdge_Dark;
        private float m_fChipStartPixelExtendFromRight_Dark;
        private float m_fChipStartPixelExtendFromLeft_Dark;
        private float m_fChipStartPixelExtendFromBottom_Dark;
        private float m_fMoldStartPixelFromEdge;
        private float m_fMoldStartPixelFromRight;
        private float m_fMoldStartPixelFromLeft;
        private float m_fMoldStartPixelFromBottom;
        private float m_fMoldStartPixelInnerFromEdge;
        private float m_fMoldStartPixelInnerFromRight;
        private float m_fMoldStartPixelInnerFromLeft;
        private float m_fMoldStartPixelInnerFromBottom;
        private int m_intMPErodeHalfWidth; // Morphology Erode Half Width tolerance. (Some pads has quite large different size from one unit to another unit especially small unit)
        private int m_intMPDilateHalfWidth; // Morphology Dilate Half Width tolerance. (Some pads has quite large different size from one unit to another unit especially small unit)

        private int m_intMoldFlashDefectDimensionFailCondition = 0; // 0:OR, 1:AND
        private int m_intBrightDefectDimensionFailCondition = 0; // 0:OR, 1:AND
        private int m_intDarkDefectDimensionFailCondition = 0; // 0:OR, 1:AND
        private int m_intCrackDarkDefectDimensionFailCondition = 0; // 0:OR, 1:AND
        private int m_intForeignMaterialBrightDefectDimensionFailCondition = 0; // 0:OR, 1:AND

        // Seperate Defect Setting
        private bool m_blnSeperateCrackDefectSetting = false;
        private bool m_blnSeperateMoldFlashDefectSetting = false;
        private bool m_blnSeperateChippedOffDefectSetting = false;
        private bool m_blnSeperateBrightDarkROITolerance = false;
        private bool m_blnSeperateForeignMaterialDefectSetting = false;

        private int m_intMoldFlashDefectType = 0; //0:Bright, 1:Dark

        //Link Defect
        private bool m_blnWantLinkBrightDefect = false;
        private bool m_blnWantLinkDarkDefect = false;
        private bool m_blnWantLinkCrackDefect = false;
        private bool m_blnWantLinkMoldFlashDefect = false;
        private int m_intBrightDefectLinkTolerance = 10;
        private int m_intDarkDefectLinkTolerance = 10;
        private int m_intCrackDefectLinkTolerance = 10;
        private int m_intMoldFlashDefectLinkTolerance = 10;
        
        // Simple Defect Criteria Tolerance Setting
        private float m_fBrightLength;
        private float m_fBrightWidth;
        private float m_fBrightArea;
        private float m_fBrightTotalArea;
        private float m_fDarkLength;
        private float m_fDarkWidth;
        private float m_fDarkArea;
        private float m_fDarkTotalArea;
        private float m_fBrightChippedOffArea;
        private float m_fDarkChippedOffArea;
        private float m_fDarkVerticalCrack;
        private float m_fDarkHorizontalCrack;
        private float m_fBrightVerticalForeignMaterial;
        private float m_fBrightHorizontalForeignMaterial;

        private EBlobs m_objImage1PadEBlobs = new EBlobs();
        private EBlobs m_objImage1ChipOffEBlobs = new EBlobs();
        private EBlobs m_objImage1ChipOffEBlobsFor2Pixel = new EBlobs();
        private EBlobs m_objImage1SurfaceEBlobs = new EBlobs();
        private EBlobs m_objImage2SurfaceEBlobs = new EBlobs();
        private EBlobs m_objImage2ChipOffEBlobs = new EBlobs();
        private EBlobs m_objImage3EBlobs = new EBlobs();
        private EBlobs m_objImage1MoldFlashEBlobs = new EBlobs();

        struct Defect
        {
            public string ref_strName;
            public float ref_fStartX;
            public float ref_fStartY;
            public float ref_fEndX;
            public float ref_fEndY;
            public float ref_fWidth;        // Keep defect pixel value for drawing
            public float ref_fHeight;       // Keep defect pixel value for drawing
            public float ref_fArea;
            public float ref_fAngle;
            public float ref_fCenterX;
            public float ref_fCenterY;
            public float ref_fFailValue;    // Keep fail value for display message
            public float ref_fWidthFailValue;
            public float ref_fHeightFailValue;
            public float ref_fAreaFailValue;
            public int ref_intBlobNo;
            // 0x01: Package Size
            // 0x02: Crack
            // 0x04: Chipped Off
            // 0x08: Scratches
            // 0x10: Contamination
            // 0x20: Solder melt
            // 0x40: Void
            // 0x80: Mold Flash
            // 0x100: Incomplete Plating
            // 0x10000: Bright
            // 0x20000: Dark
            public int ref_intFailMask;
            public int ref_intFailCriteria; // 0x01:width, 0x02:Height, 0x04:Area
            public int ref_intImageNo;
            public float ref_fWidthInMM;
            public float ref_fHeightInMM;
            public float ref_fAreaInMM2;
            public bool ref_blnFailTotalArea;
        }

        private List<Defect> m_arrPkgDefectList = new List<Defect>();

        #endregion

        #region PACKAGE & POSITION: Properties
        public int ref_intMoldFlashDefectDimensionFailCondition { set { m_intMoldFlashDefectDimensionFailCondition = value; } get { return m_intMoldFlashDefectDimensionFailCondition; } }
        public int ref_intBrightDefectDimensionFailCondition { set { m_intBrightDefectDimensionFailCondition = value; } get { return m_intBrightDefectDimensionFailCondition; } }
        public int ref_intForeignMaterialBrightDefectDimensionFailCondition { set { m_intForeignMaterialBrightDefectDimensionFailCondition = value; } get { return m_intForeignMaterialBrightDefectDimensionFailCondition; } }
        public int ref_intDarkDefectDimensionFailCondition { set { m_intDarkDefectDimensionFailCondition = value; } get { return m_intDarkDefectDimensionFailCondition; } }
        public int ref_intCrackDarkDefectDimensionFailCondition { set { m_intCrackDarkDefectDimensionFailCondition = value; } get { return m_intCrackDarkDefectDimensionFailCondition; } }
        public bool ref_blnSeperateForeignMaterialDefectSetting { set { m_blnSeperateForeignMaterialDefectSetting = value; } get { return m_blnSeperateForeignMaterialDefectSetting; } }
        public int ref_intBrightDefectLinkTolerance { set { m_intBrightDefectLinkTolerance = value; } get { return m_intBrightDefectLinkTolerance; } }
        public int ref_intDarkDefectLinkTolerance { set { m_intDarkDefectLinkTolerance = value; } get { return m_intDarkDefectLinkTolerance; } }
        public int ref_intCrackDefectLinkTolerance { set { m_intCrackDefectLinkTolerance = value; } get { return m_intCrackDefectLinkTolerance; } }
        public int ref_intMoldFlashDefectLinkTolerance { set { m_intMoldFlashDefectLinkTolerance = value; } get { return m_intMoldFlashDefectLinkTolerance; } }
        public bool ref_blnSeperateBrightDarkROITolerance { set { m_blnSeperateBrightDarkROITolerance = value; } get { return m_blnSeperateBrightDarkROITolerance; } }
        public bool ref_blnWantLinkBrightDefect { set { m_blnWantLinkBrightDefect = value; } get { return m_blnWantLinkBrightDefect; } }
        public bool ref_blnWantLinkDarkDefect { set { m_blnWantLinkDarkDefect = value; } get { return m_blnWantLinkDarkDefect; } }
        public bool ref_blnWantLinkCrackDefect { set { m_blnWantLinkCrackDefect = value; } get { return m_blnWantLinkCrackDefect; } }
        public bool ref_blnWantLinkMoldFlashDefect { set { m_blnWantLinkMoldFlashDefect = value; } get { return m_blnWantLinkMoldFlashDefect; } }
        public bool ref_blnSeperateCrackDefectSetting { set { m_blnSeperateCrackDefectSetting = value; } get { return m_blnSeperateCrackDefectSetting; } }
        public bool ref_blnSeperateMoldFlashDefectSetting { set { m_blnSeperateMoldFlashDefectSetting = value; } get { return m_blnSeperateMoldFlashDefectSetting; } }
        public int ref_intMoldFlashDefectType { set { m_intMoldFlashDefectType = value; } get { return m_intMoldFlashDefectType; } }
        public float ref_fMoldStartPixelFromEdge { get { return m_fMoldStartPixelFromEdge; } set { m_fMoldStartPixelFromEdge = value; } }
        public float ref_fMoldStartPixelFromRight { get { return m_fMoldStartPixelFromRight; } set { m_fMoldStartPixelFromRight = value; } }
        public float ref_fMoldStartPixelFromBottom { get { return m_fMoldStartPixelFromBottom; } set { m_fMoldStartPixelFromBottom = value; } }
        public float ref_fMoldStartPixelFromLeft { get { return m_fMoldStartPixelFromLeft; } set { m_fMoldStartPixelFromLeft = value; } }
        public float ref_fMoldStartPixelInnerFromEdge { get { return m_fMoldStartPixelInnerFromEdge; } set { m_fMoldStartPixelInnerFromEdge = value; } }
        public float ref_fMoldStartPixelInnerFromRight { get { return m_fMoldStartPixelInnerFromRight; } set { m_fMoldStartPixelInnerFromRight = value; } }
        public float ref_fMoldStartPixelInnerFromBottom { get { return m_fMoldStartPixelInnerFromBottom; } set { m_fMoldStartPixelInnerFromBottom = value; } }
        public float ref_fMoldStartPixelInnerFromLeft { get { return m_fMoldStartPixelInnerFromLeft; } set { m_fMoldStartPixelInnerFromLeft = value; } }
        public bool ref_blnSeperateChippedOffDefectSetting { set { m_blnSeperateChippedOffDefectSetting = value; } get { return m_blnSeperateChippedOffDefectSetting; } }
        public float ref_fChipStartPixelFromEdge { get { return m_fChipStartPixelFromEdge; } set { m_fChipStartPixelFromEdge = value; } }
        public float ref_fChipStartPixelFromRight { get { return m_fChipStartPixelFromRight; } set { m_fChipStartPixelFromRight = value; } }
        public float ref_fChipStartPixelFromBottom { get { return m_fChipStartPixelFromBottom; } set { m_fChipStartPixelFromBottom = value; } }
        public float ref_fChipStartPixelFromLeft { get { return m_fChipStartPixelFromLeft; } set { m_fChipStartPixelFromLeft = value; } }
        public float ref_fChipStartPixelExtendFromEdge { get { return m_fChipStartPixelExtendFromEdge; } set { m_fChipStartPixelExtendFromEdge = value; } }
        public float ref_fChipStartPixelExtendFromRight { get { return m_fChipStartPixelExtendFromRight; } set { m_fChipStartPixelExtendFromRight = value; } }
        public float ref_fChipStartPixelExtendFromBottom { get { return m_fChipStartPixelExtendFromBottom; } set { m_fChipStartPixelExtendFromBottom = value; } }
        public float ref_fChipStartPixelExtendFromLeft { get { return m_fChipStartPixelExtendFromLeft; } set { m_fChipStartPixelExtendFromLeft = value; } }
        public float ref_fChipStartPixelFromEdge_Dark { get { return m_fChipStartPixelFromEdge_Dark; } set { m_fChipStartPixelFromEdge_Dark = value; } }
        public float ref_fChipStartPixelFromRight_Dark { get { return m_fChipStartPixelFromRight_Dark; } set { m_fChipStartPixelFromRight_Dark = value; } }
        public float ref_fChipStartPixelFromBottom_Dark { get { return m_fChipStartPixelFromBottom_Dark; } set { m_fChipStartPixelFromBottom_Dark = value; } }
        public float ref_fChipStartPixelFromLeft_Dark { get { return m_fChipStartPixelFromLeft_Dark; } set { m_fChipStartPixelFromLeft_Dark = value; } }
        public float ref_fChipStartPixelExtendFromEdge_Dark { get { return m_fChipStartPixelExtendFromEdge_Dark; } set { m_fChipStartPixelExtendFromEdge_Dark = value; } }
        public float ref_fChipStartPixelExtendFromRight_Dark { get { return m_fChipStartPixelExtendFromRight_Dark; } set { m_fChipStartPixelExtendFromRight_Dark = value; } }
        public float ref_fChipStartPixelExtendFromBottom_Dark { get { return m_fChipStartPixelExtendFromBottom_Dark; } set { m_fChipStartPixelExtendFromBottom_Dark = value; } }
        public float ref_fChipStartPixelExtendFromLeft_Dark { get { return m_fChipStartPixelExtendFromLeft_Dark; } set { m_fChipStartPixelExtendFromLeft_Dark = value; } }
        public float ref_fPkgStartPixelFromEdge { get { return m_fPkgStartPixelFromEdge; } set { m_fPkgStartPixelFromEdge = value; } }
        public float ref_fPkgStartPixelFromRight { get { return m_fPkgStartPixelFromRight; } set { m_fPkgStartPixelFromRight = value; } }
        public float ref_fPkgStartPixelFromBottom { get { return m_fPkgStartPixelFromBottom; } set { m_fPkgStartPixelFromBottom = value; } }
        public float ref_fPkgStartPixelFromLeft { get { return m_fPkgStartPixelFromLeft; } set { m_fPkgStartPixelFromLeft = value; } }
        public float ref_fPkgStartPixelFromEdge_Dark { get { return m_fPkgStartPixelFromEdge_Dark; } set { m_fPkgStartPixelFromEdge_Dark = value; } }
        public float ref_fPkgStartPixelFromRight_Dark { get { return m_fPkgStartPixelFromRight_Dark; } set { m_fPkgStartPixelFromRight_Dark = value; } }
        public float ref_fPkgStartPixelFromBottom_Dark { get { return m_fPkgStartPixelFromBottom_Dark; } set { m_fPkgStartPixelFromBottom_Dark = value; } }
        public float ref_fPkgStartPixelFromLeft_Dark { get { return m_fPkgStartPixelFromLeft_Dark; } set { m_fPkgStartPixelFromLeft_Dark = value; } }
        public float ref_fForeignMaterialStartPixelFromEdge { get { return m_fForeignMaterialStartPixelFromEdge; } set { m_fForeignMaterialStartPixelFromEdge = value; } }
        public float ref_fForeignMaterialStartPixelFromRight { get { return m_fForeignMaterialStartPixelFromRight; } set { m_fForeignMaterialStartPixelFromRight = value; } }
        public float ref_fForeignMaterialStartPixelFromBottom { get { return m_fForeignMaterialStartPixelFromBottom; } set { m_fForeignMaterialStartPixelFromBottom = value; } }
        public float ref_fForeignMaterialStartPixelFromLeft { get { return m_fForeignMaterialStartPixelFromLeft; } set { m_fForeignMaterialStartPixelFromLeft = value; } }
        public float ref_fForeignMaterialStartPixelFromEdge_Pad { get { return m_fForeignMaterialStartPixelFromEdge_Pad; } set { m_fForeignMaterialStartPixelFromEdge_Pad = value; } }
        public float ref_fForeignMaterialStartPixelFromRight_Pad { get { return m_fForeignMaterialStartPixelFromRight_Pad; } set { m_fForeignMaterialStartPixelFromRight_Pad = value; } }
        public float ref_fForeignMaterialStartPixelFromBottom_Pad { get { return m_fForeignMaterialStartPixelFromBottom_Pad; } set { m_fForeignMaterialStartPixelFromBottom_Pad = value; } }
        public float ref_fForeignMaterialStartPixelFromLeft_Pad { get { return m_fForeignMaterialStartPixelFromLeft_Pad; } set { m_fForeignMaterialStartPixelFromLeft_Pad = value; } }
        public int ref_intPkgImage1HighPadThreshold { get { return m_intPkgImage1HighPadThreshold; } set { m_intPkgImage1HighPadThreshold = value; } }
        public int ref_intPkgImage1LowPadThreshold { get { return m_intPkgImage1LowPadThreshold; } set { m_intPkgImage1LowPadThreshold = value; } }
        public int ref_intPkgImage1HighSurfaceThreshold { get { return m_intPkgImage1HighSurfaceThreshold; } set { m_intPkgImage1HighSurfaceThreshold = value; } }
        public int ref_intPkgImage1LowSurfaceThreshold { get { return m_intPkgImage1LowSurfaceThreshold; } set { m_intPkgImage1LowSurfaceThreshold = value; } }
        public int ref_intPkgImage2HighCrackThreshold { get { return m_intPkgImage2HighCrackThreshold; } set { m_intPkgImage2HighCrackThreshold = value; } }
        public int ref_intPkgImage2LowCrackThreshold { get { return m_intPkgImage2LowCrackThreshold; } set { m_intPkgImage2LowCrackThreshold = value; } }
        public float ref_fPkgImage1Gain { get { return m_fPkgImage1Gain; } set { m_fPkgImage1Gain = value; } }
        public int ref_intPkgImage2HighThreshold { get { return m_intPkgImage2HighThreshold; } set { m_intPkgImage2HighThreshold = value; } }
        public int ref_intPkgImage2LowThreshold { get { return m_intPkgImage2LowThreshold; } set { m_intPkgImage2LowThreshold = value; } }
        public int ref_intPkgImage3HighThreshold { get { return m_intPkgImage3HighThreshold; } set { m_intPkgImage3HighThreshold = value; } }
        public int ref_intPkgImage3LowThreshold { get { return m_intPkgImage3LowThreshold; } set { m_intPkgImage3LowThreshold = value; } }
        public int ref_intPkgImage1MoldFlashThreshold { get { return m_intPkgImage1MoldFlashThreshold; } set { m_intPkgImage1MoldFlashThreshold = value; } }
        public int ref_intPkgImage2VoidThreshold { get { return m_intPkgImage2VoidThreshold; } set { m_intPkgImage2VoidThreshold = value; } }
        public int ref_intPkgImage1ChippedThreshold { get { return m_intPkgImage1ChippedThreshold; } set { m_intPkgImage1ChippedThreshold = value; } }
        public int ref_intForeignMaterialBrightFieldThreshold { set { m_intForeignMaterialBrightFieldThreshold = value; } get { return m_intForeignMaterialBrightFieldThreshold; } }
        public int ref_intBrightFieldLowThreshold { set { m_intBrightFieldLowThreshold = value; } get { return m_intBrightFieldLowThreshold; } }
        public int ref_intBrightFieldHighThreshold { set { m_intBrightFieldHighThreshold = value; } get { return m_intBrightFieldHighThreshold; } }
        public int ref_intDarkFieldLowThreshold { set { m_intDarkFieldLowThreshold = value; } get { return m_intDarkFieldLowThreshold; } }
        public float ref_fDarkFieldImageGain { set { m_fDarkFieldImageGain = value; } get { return m_fDarkFieldImageGain; } }
        public float ref_fPadImageGain { set { m_fPadImageGain = value; } get { return m_fPadImageGain; } }
        public int ref_intDarkFieldHighThreshold { set { m_intDarkFieldHighThreshold = value; } get { return m_intDarkFieldHighThreshold; } }


        public float ref_fUnitWidth { get { return m_fUnitWidth; } set { m_fUnitWidth = value; } }
        public float ref_fUnitHeight { get { return m_fUnitHeight; } set { m_fUnitHeight = value; } }
        public float ref_fUnitThickness { get { return m_fUnitThickness; } set { m_fUnitThickness = value; } }
        public float ref_fUnitWidthMin { get { return m_fUnitWidthMin; } set { m_fUnitWidthMin = value; } }
        public float ref_fUnitWidthMax { get { return m_fUnitWidthMax; } set { m_fUnitWidthMax = value; } }
        public float ref_fUnitHeightMin { get { return m_fUnitHeightMin; } set { m_fUnitHeightMin = value; } }
        public float ref_fUnitHeightMax { get { return m_fUnitHeightMax; } set { m_fUnitHeightMax = value; } }
        public float ref_fUnitThicknessMin { get { return m_fUnitThicknessMin; } set { m_fUnitThicknessMin = value; } }
        public float ref_fUnitThicknessMax { get { return m_fUnitThicknessMax; } set { m_fUnitThicknessMax = value; } }
        public float ref_fUnitSizeLength { get { return m_fUnitSizeLength; } set { m_fUnitSizeLength = value; } }   // no use
        public float ref_fScratchArea { get { return m_fScratchArea; } set { m_fScratchArea = value; } }
        public float ref_fScratchLength { get { return m_fScratchLength; } set { m_fScratchLength = value; } }
        public float ref_fChipArea { get { return m_fChipArea; } set { m_fChipArea = value; } }
        public float ref_fContaminationLength { get { return m_fContaminationLength; } set { m_fContaminationLength = value; } }
        public float ref_fSolderMeltLength { get { return m_fSolderMeltLength; } set { m_fSolderMeltLength = value; } }
        public float ref_fVoidLength { get { return m_fVoidLength; } set { m_fVoidLength = value; } }
        public float ref_fVoidArea { get { return m_fVoidArea; } set { m_fVoidArea = value; } }
        public float ref_fCrackLength { get { return m_fCrackLength; } set { m_fCrackLength = value; } }
        public float ref_fCrackArea { get { return m_fCrackArea; } set { m_fCrackArea = value; } }
        public float ref_fMoldFlashLength { get { return m_fMoldFlashArea; } set { m_fMoldFlashArea = value; } }
        public float ref_fInCompletePlateLength { get { return m_fInCompletePlateLength; } set { m_fInCompletePlateLength = value; } }
        public float ref_fPadBrokenLength { get { return m_fPadBrokenLength; } set { m_fPadBrokenLength = value; } }
        public float ref_fPadBrokenArea { get { return m_fPadBrokenArea; } set { m_fPadBrokenArea = value; } }
        public int ref_intMPErodeHalfWidth { get { return m_intMPErodeHalfWidth; } set { m_intMPErodeHalfWidth = value; } }
        public int ref_intMPDilateHalfWidth { get { return m_intMPDilateHalfWidth; } set { m_intMPDilateHalfWidth = value; } }


        #endregion

        #region PACKAGE SIZE: Private Variables

        private RectGauge4L m_objRectGauge4L;
        private bool m_blnDrawSamplingPoint = false;
        private bool m_blnDrawDraggingBox = false;
        private bool m_blnDrawTransitionTypeArrow = false;
        private int m_intSelectedGaugeEdgeMask = 0x0F;  // 0x01=Top edge, 0x02=Right edge, 0x04=Bottom edge, 0x08=Left edge
        #endregion

        #region PACKAGE sIZE: Properties
        public float ref_fPackageWidthOffsetMM { set { m_fPackageWidthOffsetMM = value; } get { return m_fPackageWidthOffsetMM; } }
        public float ref_fPackageHeightOffsetMM { set { m_fPackageHeightOffsetMM = value; } get { return m_fPackageHeightOffsetMM; } }
        public float ref_fPackageThicknessOffsetMM { set { m_fPackageThicknessOffsetMM = value; } get { return m_fPackageThicknessOffsetMM; } }
        public RectGauge4L ref_objRectGauge4L { get { return m_objRectGauge4L; } set { m_objRectGauge4L = value; } }
        public bool ref_blnDrawSamplingPoint { get { return m_blnDrawSamplingPoint; } set { m_blnDrawSamplingPoint = value; } }
        public bool ref_blnDrawDraggingBox { get { return m_blnDrawDraggingBox; } set { m_blnDrawDraggingBox = value; } }
        public bool ref_blnDrawTransitionTypeArrow { get { return m_blnDrawTransitionTypeArrow; } set { m_blnDrawTransitionTypeArrow = value; } }
        public int ref_intSelectedGaugeEdgeMask {
            get { return m_intSelectedGaugeEdgeMask; }
            set { m_intSelectedGaugeEdgeMask = value; } }

        #endregion

        private bool m_blnWriteDebug = false;
        public bool ref_blnWriteDebug { get { return m_blnWriteDebug; } set { m_blnWriteDebug = value; } }
        TrackLog m_objPosTL;
        private int m_intDebugHour = 0;
        private Object m_objLockBlobs = new Object();
        private bool m_blnInspectLock = false;
        private bool m_blnDrawingLock = false;
        public string m_strTrack = "";

        private HiPerfTimer m_T2 = new HiPerfTimer();
        private float m_fTimingPrev = 0, m_fTimingPrev2 = 0;
        private float m_fTiming = 0, m_fTiming2 = 0;
        public List<string> m_arrTrack = new List<string>();
        //public string m_strTrack2 = "";

        public bool ref_blnInspectLock { get { return m_blnInspectLock; } set { m_blnInspectLock = value; } }
        public bool ref_blnDrawingLock { get { return m_blnDrawingLock; } set { m_blnDrawingLock = value; } }
        /// <summary>
        /// 
        /// </summary>
        /// <param name="intPadDirection">0=Center, 1=Top, 2=Right, 3=Bottom, 4=Left</param>
        public Pad(int intPadROIDirection)
        {
            m_intPadROIDirection = intPadROIDirection;
        }

        public Pad(GaugeWorldShape objWorldShape, int intImageWidth, int intImageHeight, int intPadROIDirection, int intVisionIndex)
        {
            if (m_objColorLookupYSH.ColorSystemOut != EColorSystem.Ysh)
                m_objColorLookupYSH.ConvertFromRgb(EColorSystem.Ysh);
            if (m_objColorLookupLSH.ColorSystemOut != EColorSystem.Lsh)
                m_objColorLookupLSH.ConvertFromRgb(EColorSystem.Lsh);
            if (m_objColorLookupRGB.ColorSystemOut != EColorSystem.Rgb)
                m_objColorLookupRGB.ConvertFromRgb(EColorSystem.Rgb);
            m_objInsPadPkgImage1 = new ImageDrawing(true, intImageWidth, intImageHeight);
            m_objInsSurfacePkgImage1 = new ImageDrawing(true, intImageWidth, intImageHeight);
            m_objInsChipOffPkgImage1 = new ImageDrawing(true, intImageWidth, intImageHeight);
            m_objInsPkgImage2 = new ImageDrawing(true, intImageWidth, intImageHeight);
            m_objInsChipOffPkgImage2 = new ImageDrawing(true, intImageWidth, intImageHeight);
            m_objInsPkgImage3 = new ImageDrawing(true, intImageWidth, intImageHeight);
            m_objDestImage = new ImageDrawing(true, intImageWidth, intImageHeight);
            m_objContaminateImage = new ImageDrawing(true, intImageWidth, intImageHeight);
            m_objSampleImage = new ImageDrawing(true, intImageWidth, intImageHeight);
            m_objPadThresholdImage = new ImageDrawing(true, intImageWidth, intImageHeight);
            m_objInterPadThresholdImage = new ImageDrawing(true, intImageWidth, intImageHeight);
            for (int i = 0; i < m_arrPadColorDontCareImage.Length; i++)
            {
                m_arrPadColorDontCareImage[i] = new ImageDrawing(true, intImageWidth, intImageHeight);
            }
            m_objRectGauge4L = new RectGauge4L(objWorldShape, intPadROIDirection, intVisionIndex);
            m_objPointGauge = new PGauge(objWorldShape);
            m_objSettingPointGauge = new PGauge(objWorldShape);
            m_intVisionIndex = intVisionIndex;
            m_intPadROIDirection = intPadROIDirection;
        }

        public Pad(GaugeWorldShape objWorldShape, bool blnInitPositioning, int intImageWidth, int intImageHeight, int intPadROIDirection, int intVisionIndex)
        {
            if (m_objColorLookupYSH.ColorSystemOut != EColorSystem.Ysh)
                m_objColorLookupYSH.ConvertFromRgb(EColorSystem.Ysh);
            if (m_objColorLookupLSH.ColorSystemOut != EColorSystem.Lsh)
                m_objColorLookupLSH.ConvertFromRgb(EColorSystem.Lsh);
            if (m_objColorLookupRGB.ColorSystemOut != EColorSystem.Rgb)
                m_objColorLookupRGB.ConvertFromRgb(EColorSystem.Rgb);
            m_objInsPadPkgImage1 = new ImageDrawing(true, intImageWidth, intImageHeight);
            m_objInsSurfacePkgImage1 = new ImageDrawing(true, intImageWidth, intImageHeight);
            m_objInsChipOffPkgImage1 = new ImageDrawing(true, intImageWidth, intImageHeight);
            m_objInsPkgImage2 = new ImageDrawing(true, intImageWidth, intImageHeight);
            m_objInsChipOffPkgImage2 = new ImageDrawing(true, intImageWidth, intImageHeight);
            m_objInsPkgImage3 = new ImageDrawing(true, intImageWidth, intImageHeight);
            m_objDestImage = new ImageDrawing(true, intImageWidth, intImageHeight);
            m_objContaminateImage = new ImageDrawing(true, intImageWidth, intImageHeight);
            m_objSampleImage = new ImageDrawing(true, intImageWidth, intImageHeight);
            m_objPadThresholdImage = new ImageDrawing(true, intImageWidth, intImageHeight);
            m_objInterPadThresholdImage = new ImageDrawing(true, intImageWidth, intImageHeight);
            for (int i = 0; i < m_arrPadColorDontCareImage.Length; i++)
            {
                m_arrPadColorDontCareImage[i] = new ImageDrawing(true, intImageWidth, intImageHeight);
            }
            m_objRectGauge4L = new RectGauge4L(objWorldShape, intPadROIDirection, intVisionIndex);
            m_objPointGauge = new PGauge(objWorldShape);
            m_objSettingPointGauge = new PGauge(objWorldShape);

            if (blnInitPositioning)
                m_objPosCrosshair = new Crosshair(false, intImageWidth, intImageHeight);
            m_intVisionIndex = intVisionIndex;
            m_intPadROIDirection = intPadROIDirection;
        }

        public void OnWriteDebug(bool blnON)
        {
            m_blnWriteDebug = blnON;
        }

        public bool AddTemplateImage(string strTemplateImagePath)
        {
            try
            {
                m_ImgUnitTemplateImage.Load(strTemplateImagePath);
            }
            catch (Exception ex)
            {
                SRMMessageBox.Show("[Recipe is corrupted. Pad > AddTemplateImage > Exception = " + ex.ToString());
                STTrackLog.WriteLine("Pad > AddTemplateImage > Exception = " + ex.ToString());
                return false;
            }

            // Get threshold value
            int intThresholdValue;
            if (m_intThresholdValue < 0)
            {
                EBW8 objBW8 = EasyImage.AutoThreshold(m_ImgUnitTemplateImage, EThresholdMode.MinResidue);
                intThresholdValue = objBW8.Value;
            }
            else
                intThresholdValue = m_intThresholdValue;
#if (Debug_2_12 || Release_2_12)
            // Get template unit image with Dilate and threshold
            m_ImgTUnitDilateThresImage.SetSize(m_ImgUnitTemplateImage.Width, m_ImgUnitTemplateImage.Height);
            EasyImage.Copy(m_ImgUnitTemplateImage, m_ImgTUnitDilateThresImage);
            if (m_fPadImageGain != 1f)
            {
                EasyImage.GainOffset(m_ImgUnitTemplateImage, m_ImgTUnitDilateThresImage, m_fPadImageGain);
                EasyImage.DilateDisk(m_ImgTUnitDilateThresImage, m_ImgTUnitDilateThresImage, (uint)m_intMPDilateHalfWidth);
            }
            else
                EasyImage.DilateDisk(m_ImgUnitTemplateImage, m_ImgTUnitDilateThresImage, (uint)m_intMPDilateHalfWidth);
            EasyImage.Threshold(m_ImgTUnitDilateThresImage, m_ImgTUnitDilateThresImage, (uint)intThresholdValue);

            // Get template unit image with Erode and threshold
            m_ImgTUnitErodeThresImage.SetSize(m_ImgUnitTemplateImage.Width, m_ImgUnitTemplateImage.Height);
            EasyImage.Copy(m_ImgUnitTemplateImage, m_ImgTUnitErodeThresImage);
            if (m_fPadImageGain != 1f)
            {
                EasyImage.GainOffset(m_ImgUnitTemplateImage, m_ImgTUnitErodeThresImage, m_fPadImageGain);
                EasyImage.ErodeDisk(m_ImgTUnitErodeThresImage, m_ImgTUnitErodeThresImage, (uint)m_intMPErodeHalfWidth);
            }
            else
                EasyImage.ErodeDisk(m_ImgUnitTemplateImage, m_ImgTUnitErodeThresImage, (uint)m_intMPErodeHalfWidth);
            EasyImage.Threshold(m_ImgTUnitErodeThresImage, m_ImgTUnitErodeThresImage, (uint)intThresholdValue);

            // Get template unit image with Erode, threshold and inverted
            m_ImgTUnitInvertThresImage.SetSize(m_ImgUnitTemplateImage.Width, m_ImgUnitTemplateImage.Height);
            EasyImage.Copy(m_ImgUnitTemplateImage, m_ImgTUnitInvertThresImage);
            if (m_fPadImageGain != 1f)
            {
                EasyImage.GainOffset(m_ImgUnitTemplateImage, m_ImgTUnitInvertThresImage, m_fPadImageGain);
                EasyImage.ErodeDisk(m_ImgTUnitInvertThresImage, m_ImgTUnitInvertThresImage, (uint)m_intMPErodeHalfWidth);
            }
            else
                EasyImage.ErodeDisk(m_ImgUnitTemplateImage, m_ImgTUnitInvertThresImage, (uint)m_intMPErodeHalfWidth);
            EasyImage.Threshold(m_ImgTUnitInvertThresImage, m_ImgTUnitInvertThresImage, (uint)intThresholdValue);
            EasyImage.Oper(EArithmeticLogicOperation.Invert, m_ImgTUnitInvertThresImage, m_ImgTUnitInvertThresImage);

#elif (DEBUG || RELEASE || RTXRelease || RTXDebug)
            // Get template unit image with Dilate and threshold
            m_ImgTUnitDilateThresImage.SetSize(m_ImgUnitTemplateImage.Width, m_ImgUnitTemplateImage.Height);
            EasyImage.Copy(m_ImgUnitTemplateImage, m_ImgTUnitDilateThresImage);
              if (m_fPadImageGain != 1f)
            {
                EasyImage.GainOffset(m_ImgUnitTemplateImage, m_ImgTUnitDilateThresImage, m_fPadImageGain);
                EasyImage.DilateDisk(m_ImgTUnitDilateThresImage, m_ImgTUnitDilateThresImage, (uint)m_intMPDilateHalfWidth);
            }
            else
            EasyImage.DilateDisk(m_ImgUnitTemplateImage, m_ImgTUnitDilateThresImage, m_intMPDilateHalfWidth);
            EasyImage.Threshold(m_ImgTUnitDilateThresImage, m_ImgTUnitDilateThresImage, intThresholdValue);
            
            // Get template unit image with Erode and threshold
            m_ImgTUnitErodeThresImage.SetSize(m_ImgUnitTemplateImage.Width, m_ImgUnitTemplateImage.Height);
            EasyImage.Copy(m_ImgUnitTemplateImage, m_ImgTUnitErodeThresImage);
              if (m_fPadImageGain != 1f)
            {
                EasyImage.GainOffset(m_ImgUnitTemplateImage, m_ImgTUnitErodeThresImage, m_fPadImageGain);
                EasyImage.ErodeDisk(m_ImgTUnitErodeThresImage, m_ImgTUnitErodeThresImage, (uint)m_intMPErodeHalfWidth);
            }
            else
            EasyImage.ErodeDisk(m_ImgUnitTemplateImage, m_ImgTUnitErodeThresImage, m_intMPErodeHalfWidth);
            EasyImage.Threshold(m_ImgTUnitErodeThresImage, m_ImgTUnitErodeThresImage, intThresholdValue);

            // Get template unit image with Erode, threshold and inverted
            m_ImgTUnitInvertThresImage.SetSize(m_ImgUnitTemplateImage.Width, m_ImgUnitTemplateImage.Height);
            EasyImage.Copy(m_ImgUnitTemplateImage, m_ImgTUnitInvertThresImage);
             if (m_fPadImageGain != 1f)
            {
                EasyImage.GainOffset(m_ImgUnitTemplateImage, m_ImgTUnitInvertThresImage, m_fPadImageGain);
                EasyImage.ErodeDisk(m_ImgTUnitInvertThresImage, m_ImgTUnitInvertThresImage, (uint)m_intMPErodeHalfWidth);
            }
            else
            EasyImage.ErodeDisk(m_ImgUnitTemplateImage, m_ImgTUnitInvertThresImage, m_intMPErodeHalfWidth);
            EasyImage.Threshold(m_ImgTUnitInvertThresImage, m_ImgTUnitInvertThresImage, intThresholdValue);
            EasyImage.Oper(EArithmeticLogicOperation.Invert, m_ImgTUnitInvertThresImage, m_ImgTUnitInvertThresImage);

#endif

            // Get whole white background unit template image
            m_ImgWhiteUnitTemplateImage.Load(strTemplateImagePath);
            m_ImgBlackUnitTemplateImage.Load(strTemplateImagePath);
            EBW8 pixelWhite = new EBW8();
            EBW8 pixelBlack = new EBW8();
            pixelWhite.Value = 255;
            pixelBlack.Value = 0;
            for (int x = 0; x < m_ImgBlackUnitTemplateImage.Width; x++)
            {
                for (int y = 0; y < m_ImgBlackUnitTemplateImage.Height; y++)
                {
                    m_ImgWhiteUnitTemplateImage.SetPixel(pixelWhite, x, y);
                    m_ImgBlackUnitTemplateImage.SetPixel(pixelBlack, x, y);
                }
            }

            m_objInsPadPkgImage1.LoadImage_AdjustByCameraResolution(strTemplateImagePath);
            m_objInsSurfacePkgImage1.LoadImage_AdjustByCameraResolution(strTemplateImagePath);
            m_objInsChipOffPkgImage1.LoadImage_AdjustByCameraResolution(strTemplateImagePath);
            m_objInsPkgImage2.LoadImage_AdjustByCameraResolution(strTemplateImagePath);
            m_objInsChipOffPkgImage2.LoadImage_AdjustByCameraResolution(strTemplateImagePath);
            m_objInsPkgImage3.LoadImage_AdjustByCameraResolution(strTemplateImagePath);

            return true;
        }
        public bool AddPackageTemplateImage(string strTemplateImagePath)
        {
            int intThresholdValue = m_intThresholdValue;
            try
            {


                m_ImgUnitTemplateImagePkg.Load(strTemplateImagePath);

            }
            catch (Exception ex)
            {
                SRMMessageBox.Show("AddPackageTemplateImage Exception 1 = " + ex.ToString());
                return false;
            }

            try
            {
                // Get threshold value

                if (m_intThresholdValue < 0)
                {
                    EBW8 objBW8 = EasyImage.AutoThreshold(m_ImgUnitTemplateImagePkg, EThresholdMode.MinResidue);
                    intThresholdValue = objBW8.Value;
                }
                else
                    intThresholdValue = m_intThresholdValue;
            }
            catch (Exception ex)
            {
                SRMMessageBox.Show("AddPackageTemplateImage Exception 1 = " + ex.ToString());
                return false;
            }

            try
            {

                // Get template unit image with Dilate and threshold
                m_ImgTUnitDilateThresImagePkg.SetSize(m_ImgUnitTemplateImagePkg.Width, m_ImgUnitTemplateImagePkg.Height);
            }
            catch (Exception ex)
            {
                SRMMessageBox.Show("AddPackageTemplateImage Exception 1 = " + ex.ToString());
                return false;
            }

            try
            {
                EasyImage.Copy(m_ImgUnitTemplateImagePkg, m_ImgTUnitDilateThresImagePkg);
            }
            catch (Exception ex)
            {
                SRMMessageBox.Show("AddPackageTemplateImage Exception 1 = " + ex.ToString());
                return false;
            }

            try
            {
#if (Debug_2_12 || Release_2_12)
                EasyImage.DilateDisk(m_ImgUnitTemplateImagePkg, m_ImgTUnitDilateThresImagePkg, (uint)m_intMPDilateHalfWidth);
#elif (DEBUG || RELEASE || RTXRelease || RTXDebug)
                EasyImage.DilateDisk(m_ImgUnitTemplateImagePkg, m_ImgTUnitDilateThresImagePkg, m_intMPDilateHalfWidth);
#endif

            }
            catch (Exception ex)
            {
                SRMMessageBox.Show("AddPackageTemplateImage Exception 1 = " + ex.ToString());
                return false;
            }

            try
            {
#if (Debug_2_12 || Release_2_12)
                EasyImage.Threshold(m_ImgTUnitDilateThresImagePkg, m_ImgTUnitDilateThresImagePkg, (uint)intThresholdValue);
#elif (DEBUG || RELEASE || RTXRelease || RTXDebug)
                EasyImage.Threshold(m_ImgTUnitDilateThresImagePkg, m_ImgTUnitDilateThresImagePkg, intThresholdValue);
#endif

            }
            catch (Exception ex)
            {
                SRMMessageBox.Show("AddPackageTemplateImage Exception 1 = " + ex.ToString());
                return false;
            }

            try
            {

                // Get template unit image with Erode and threshold
                m_ImgTUnitErodeThresImagePkg.SetSize(m_ImgUnitTemplateImagePkg.Width, m_ImgUnitTemplateImagePkg.Height);
            }
            catch (Exception ex)
            {
                SRMMessageBox.Show("AddPackageTemplateImage Exception 1 = " + ex.ToString());
                return false;
            }

            try
            {
                EasyImage.Copy(m_ImgUnitTemplateImagePkg, m_ImgTUnitErodeThresImagePkg);
            }
            catch (Exception ex)
            {
                SRMMessageBox.Show("AddPackageTemplateImage Exception 1 = " + ex.ToString());
                return false;
            }

            try
            {
#if (Debug_2_12 || Release_2_12)
                EasyImage.ErodeDisk(m_ImgUnitTemplateImagePkg, m_ImgTUnitErodeThresImagePkg, (uint)m_intMPErodeHalfWidth);
#elif (DEBUG || RELEASE || RTXRelease || RTXDebug)
                EasyImage.ErodeDisk(m_ImgUnitTemplateImagePkg, m_ImgTUnitErodeThresImagePkg, m_intMPErodeHalfWidth);
#endif

            }
            catch (Exception ex)
            {
                SRMMessageBox.Show("AddPackageTemplateImage Exception 1 = " + ex.ToString());
                return false;
            }

            try
            {
#if (Debug_2_12 || Release_2_12)
                EasyImage.Threshold(m_ImgTUnitErodeThresImagePkg, m_ImgTUnitErodeThresImagePkg, (uint)intThresholdValue);
#elif (DEBUG || RELEASE || RTXRelease || RTXDebug)
                EasyImage.Threshold(m_ImgTUnitErodeThresImagePkg, m_ImgTUnitErodeThresImagePkg, intThresholdValue);
#endif

            }
            catch (Exception ex)
            {
                SRMMessageBox.Show("AddPackageTemplateImage Exception 1 = " + ex.ToString());
                return false;
            }

            try
            {

                // Get template unit image with Erode, threshold and inverted
                m_ImgTUnitInvertThresImagePkg.SetSize(m_ImgUnitTemplateImagePkg.Width, m_ImgUnitTemplateImagePkg.Height);
            }
            catch (Exception ex)
            {
                SRMMessageBox.Show("AddPackageTemplateImage Exception 1 = " + ex.ToString());
                return false;
            }

            try
            {
                EasyImage.Copy(m_ImgUnitTemplateImagePkg, m_ImgTUnitInvertThresImagePkg);
            }
            catch (Exception ex)
            {
                SRMMessageBox.Show("AddPackageTemplateImage Exception 1 = " + ex.ToString());
                return false;
            }

            try
            {
#if (Debug_2_12 || Release_2_12)
                EasyImage.ErodeDisk(m_ImgUnitTemplateImagePkg, m_ImgTUnitInvertThresImagePkg, (uint)m_intMPErodeHalfWidth);
#elif (DEBUG || RELEASE || RTXRelease || RTXDebug)
                EasyImage.ErodeDisk(m_ImgUnitTemplateImagePkg, m_ImgTUnitInvertThresImagePkg, m_intMPErodeHalfWidth);
#endif

            }
            catch (Exception ex)
            {
                SRMMessageBox.Show("AddPackageTemplateImage Exception 1 = " + ex.ToString());
                return false;
            }

            try
            {
#if (Debug_2_12 || Release_2_12)
                EasyImage.Threshold(m_ImgTUnitInvertThresImagePkg, m_ImgTUnitInvertThresImagePkg, (uint)intThresholdValue);
#elif (DEBUG || RELEASE || RTXRelease || RTXDebug)
                EasyImage.Threshold(m_ImgTUnitInvertThresImagePkg, m_ImgTUnitInvertThresImagePkg, intThresholdValue);
#endif

            }
            catch (Exception ex)
            {
                SRMMessageBox.Show("AddPackageTemplateImage Exception 1 = " + ex.ToString());
                return false;
            }

            try
            {
                EasyImage.Oper(EArithmeticLogicOperation.Invert, m_ImgTUnitInvertThresImagePkg, m_ImgTUnitInvertThresImagePkg);
            }
            catch (Exception ex)
            {
                SRMMessageBox.Show("AddPackageTemplateImage Exception 1 = " + ex.ToString());
                return false;
            }

            try
            {

                // Get whole white background unit template image
                m_ImgWhiteUnitTemplateImagePkg.Load(strTemplateImagePath);
            }
            catch (Exception ex)
            {
                SRMMessageBox.Show("AddPackageTemplateImage Exception 1 = " + ex.ToString());
                return false;
            }

            try
            {
                m_ImgBlackUnitTemplateImagePkg.Load(strTemplateImagePath);
            }
            catch (Exception ex)
            {
                SRMMessageBox.Show("AddPackageTemplateImage Exception 1 = " + ex.ToString());
                return false;
            }

            try
            {
                EBW8 pixelWhite = new EBW8();
                EBW8 pixelBlack = new EBW8();
                pixelWhite.Value = 255;
                pixelBlack.Value = 0;
                for (int x = 0; x < m_ImgBlackUnitTemplateImagePkg.Width; x++)
                {
                    for (int y = 0; y < m_ImgBlackUnitTemplateImagePkg.Height; y++)
                    {
                        m_ImgWhiteUnitTemplateImagePkg.SetPixel(pixelWhite, x, y);
                        m_ImgBlackUnitTemplateImagePkg.SetPixel(pixelBlack, x, y);
                    }
                }
            }
            catch (Exception ex)
            {
                SRMMessageBox.Show("AddPackageTemplateImage Exception 1 = " + ex.ToString());
                return false;
            }


            //m_objInsPadPkgImage1.LoadImage_AdjustByCameraResolution(strTemplateImagePath);
            //m_objInsSurfacePkgImage1.LoadImage_AdjustByCameraResolution(strTemplateImagePath);
            //m_objInsChipOffPkgImage1.LoadImage_AdjustByCameraResolution(strTemplateImagePath);
            //m_objInsPkgImage2.LoadImage_AdjustByCameraResolution(strTemplateImagePath);
            //m_objInsChipOffPkgImage2.LoadImage_AdjustByCameraResolution(strTemplateImagePath);
            //m_objInsPkgImage3.LoadImage_AdjustByCameraResolution(strTemplateImagePath);

            return true;
        }
        /// <summary>
        /// Build object in ROI
        /// </summary>
        /// <param name="objROI">ROI</param>
        /// <returns>true = selected objects > 0, false = otherwise</returns>
        public bool BuildOnlyPadObjects(ROI objROI)
        {
            if ((m_intPadROIDirection > 0) && (m_objRectGauge4L.GetGaugeTiltAngle() > 0))
            {
                ROI objROI2 = new ROI();
                objROI2.LoadROISetting(objROI.ref_ROITotalX, objROI.ref_ROITotalY, objROI.ref_ROIWidth, objROI.ref_ROIHeight);
                ImageDrawing objImage = new ImageDrawing(objROI.ref_ROI.TopParent.Width, objROI.ref_ROI.TopParent.Height);
                EasyImage.Copy(objROI.ref_ROI.TopParent, objImage.ref_objMainImage);
                objROI2.AttachImage(objImage);

                TrimPadROIUsingTiltedAngle(objROI2);

                if (m_fPadImageGain != 1f)
                    EasyImage.GainOffset(objROI2.ref_ROI, objROI2.ref_ROI, m_fPadImageGain);

                m_objEBlobs.BuildObjects_Filter_GetElement(objROI2, !m_blnWhiteOnBlack, true, 0, m_intThresholdValue,
                Convert.ToInt32(Math.Floor(m_fFilterMinArea)), m_intMaxArea, false, 0xFF); // 13-08-2019 ZJYEOH : Changed 1F to FF to get Feret data

                objROI2.Dispose();
                objImage.Dispose();
            }
            else
            {
                if (m_fPadImageGain != 1f)
                {
                    ROI objROI2 = new ROI();
                    objROI2.LoadROISetting(objROI.ref_ROITotalX, objROI.ref_ROITotalY, objROI.ref_ROIWidth, objROI.ref_ROIHeight);
                    ImageDrawing objImage = new ImageDrawing(objROI.ref_ROI.TopParent.Width, objROI.ref_ROI.TopParent.Height);
                    EasyImage.Copy(objROI.ref_ROI.TopParent, objImage.ref_objMainImage);
                    objROI2.AttachImage(objImage);

                    EasyImage.GainOffset(objROI2.ref_ROI, objROI2.ref_ROI, m_fPadImageGain);

                    m_objEBlobs.BuildObjects_Filter_GetElement(objROI2, !m_blnWhiteOnBlack, true, 0, m_intThresholdValue,
                        Convert.ToInt32(Math.Floor(m_fFilterMinArea)), m_intMaxArea, false, 0xFF); // 13-08-2019 ZJYEOH : Changed 1F to FF to get Feret data

                    objROI2.Dispose();
                    objImage.Dispose();
                }
                else
                {
                    m_objEBlobs.BuildObjects_Filter_GetElement(objROI, !m_blnWhiteOnBlack, true, 0, m_intThresholdValue,
                        Convert.ToInt32(Math.Floor(m_fFilterMinArea)), m_intMaxArea, false, 0xFF); // 13-08-2019 ZJYEOH : Changed 1F to FF to get Feret data
                }
            }

            if (m_objEBlobs.ref_intNumSelectedObject > 0)
                return true;
            else
                return false;
        }

        public bool BuildLearnPadObjects(ROI objROI)
        {
            if (m_fPadImageGain != 1f)
            {
                ROI objROI2 = new ROI();
                objROI2.LoadROISetting(objROI.ref_ROITotalX, objROI.ref_ROITotalY, objROI.ref_ROIWidth, objROI.ref_ROIHeight);
                ImageDrawing objImage = new ImageDrawing(objROI.ref_ROI.TopParent.Width, objROI.ref_ROI.TopParent.Height);
                EasyImage.Copy(objROI.ref_ROI.TopParent, objImage.ref_objMainImage);
                objROI2.AttachImage(objImage);

                EasyImage.GainOffset(objROI2.ref_ROI, objROI2.ref_ROI, m_fPadImageGain);

                m_objEBlobs.BuildObjects_Filter_GetElement(objROI2, !m_blnWhiteOnBlack, true, 0, m_intThresholdValue,
                Convert.ToInt32(Math.Floor(m_fFilterMinArea)), m_intMaxArea, false, 0x1F);

                objROI2.Dispose();
                objImage.Dispose();
            }
            else
            {
                m_objEBlobs.BuildObjects_Filter_GetElement(objROI, !m_blnWhiteOnBlack, true, 0, m_intThresholdValue,
                Convert.ToInt32(Math.Floor(m_fFilterMinArea)), m_intMaxArea, false, 0x1F);
            }

            if (m_objEBlobs.ref_intNumSelectedObject > 0)
                return true;
            else
                return false;
        }

        public bool BuildOnlyPadObjects_ConsiderImage2(ROI objROI, ImageDrawing objImage2, int intPadIndex)
        {
            BuildOnlyPadObjects(objROI);

            AddImage2PadToImage1(objROI, objImage2, intPadIndex);

            if (m_fPadImageGain != 1f)
            {
                ROI objROI2 = new ROI();
                objROI2.LoadROISetting(objROI.ref_ROITotalX, objROI.ref_ROITotalY, objROI.ref_ROIWidth, objROI.ref_ROIHeight);
                ImageDrawing objImage = new ImageDrawing(objROI.ref_ROI.TopParent.Width, objROI.ref_ROI.TopParent.Height);
                EasyImage.Copy(objROI.ref_ROI.TopParent, objImage.ref_objMainImage);
                objROI2.AttachImage(objImage);

                EasyImage.GainOffset(objROI2.ref_ROI, objROI2.ref_ROI, m_fPadImageGain);

                m_objEBlobs.BuildObjects_Filter_GetElement(objROI2, !m_blnWhiteOnBlack, true, 0, m_intThresholdValue,
                 Convert.ToInt32(Math.Floor(m_fFilterMinArea)), m_intMaxArea, false, 0xFF); // 13-08-2019 ZJYEOH : Changed 1F to FF to get Feret data

                objROI2.Dispose();
                objImage.Dispose();
            }
            else
            {
                m_objEBlobs.BuildObjects_Filter_GetElement(objROI, !m_blnWhiteOnBlack, true, 0, m_intThresholdValue,
                Convert.ToInt32(Math.Floor(m_fFilterMinArea)), m_intMaxArea, false, 0xFF); // 13-08-2019 ZJYEOH : Changed 1F to FF to get Feret data
            }

            if (m_objEBlobs.ref_intNumSelectedObject > 0)
                return true;
            else
                return false;
        }

        public bool BuildDoubleThresholdPadObjects(ROI objROI, int intPadIndex)
        {

#if (Debug_2_12 || Release_2_12)
            // Threshold unit edge (image 1)
            ROI objThresholdROI = new ROI();
            objThresholdROI.AttachImage(m_objPadThresholdImage);
            objThresholdROI.LoadROISetting(objROI.ref_ROITotalX, objROI.ref_ROITotalY, objROI.ref_ROIWidth, objROI.ref_ROIHeight);
            if (m_fPadImageGain != 1f)
            {
                EasyImage.GainOffset(objROI.ref_ROI, objThresholdROI.ref_ROI, m_fPadImageGain);
                EasyImage.Threshold(objThresholdROI.ref_ROI, objThresholdROI.ref_ROI, (uint)m_intThresholdValue);
            }
            else
            {
                EasyImage.Threshold(objROI.ref_ROI, objThresholdROI.ref_ROI, (uint)m_intThresholdValue);
            }

            // Threshold unit surface (image 2)
            ROI objInterThresholdROI = new ROI();
            objInterThresholdROI.AttachImage(m_objInterPadThresholdImage);
            objInterThresholdROI.LoadROISetting(objROI.ref_ROITotalX, objROI.ref_ROITotalY, objROI.ref_ROIWidth, objROI.ref_ROIHeight);
            EasyImage.Threshold(objROI.ref_ROI, objInterThresholdROI.ref_ROI, (uint)m_intInterPadThresholdValue);

#elif (DEBUG || RELEASE || RTXRelease || RTXDebug)
            // Threshold unit edge (image 1)
            ROI objThresholdROI = new ROI();
            objThresholdROI.AttachImage(m_objPadThresholdImage);
            objThresholdROI.LoadROISetting(objROI.ref_ROITotalX, objROI.ref_ROITotalY, objROI.ref_ROIWidth, objROI.ref_ROIHeight);
            if (m_fPadImageGain != 1f)
            {
                EasyImage.GainOffset(objROI.ref_ROI, objThresholdROI.ref_ROI, m_fPadImageGain);
                EasyImage.Threshold(objThresholdROI.ref_ROI, objThresholdROI.ref_ROI, m_intThresholdValue);
            }
            else
            {
            EasyImage.Threshold(objROI.ref_ROI, objThresholdROI.ref_ROI, m_intThresholdValue);
            }

            // Threshold unit surface (image 2)
            ROI objInterThresholdROI = new ROI();
            objInterThresholdROI.AttachImage(m_objInterPadThresholdImage);
            objInterThresholdROI.LoadROISetting(objROI.ref_ROITotalX, objROI.ref_ROITotalY, objROI.ref_ROIWidth, objROI.ref_ROIHeight);
            EasyImage.Threshold(objROI.ref_ROI, objInterThresholdROI.ref_ROI, m_intInterPadThresholdValue);

#endif

            // Get inter unit ROI on image 2 based on gauge unit measurement, and unit bright tolerance, 
            int intInterTolerance = 5;
            switch (intPadIndex)
            {
                case 1:

                    objThresholdROI.LoadROISetting((int)Math.Round(m_objRectGauge4L.ref_pRectCenterPoint.X - m_objRectGauge4L.ref_fRectWidth / 2 + intInterTolerance, 0, MidpointRounding.AwayFromZero),
                                                   (int)Math.Round(m_objRectGauge4L.ref_pRectCenterPoint.Y - m_objRectGauge4L.ref_fRectHeight / 2 + intInterTolerance, 0, MidpointRounding.AwayFromZero),
                                                        (int)Math.Round(m_objRectGauge4L.ref_fRectWidth - intInterTolerance * 2, 0, MidpointRounding.AwayFromZero),
                                                        (int)Math.Round(m_objRectGauge4L.ref_fRectHeight - intInterTolerance, 0, MidpointRounding.AwayFromZero));

                    //objThresholdROI.LoadROISetting(objInterThresholdROI.ref_ROITotalX,
                    //                                    objInterThresholdROI.ref_ROITotalY + intInterTolerance,
                    //                                    objInterThresholdROI.ref_ROIWidth,
                    //                                    objInterThresholdROI.ref_ROIHeight - intInterTolerance);
                    //objInterThresholdROI.LoadROISetting(objInterThresholdROI.ref_ROITotalX, 
                    //                                    objInterThresholdROI.ref_ROITotalY + intInterTolerance,
                    //                                    objInterThresholdROI.ref_ROIWidth,
                    //                                    objInterThresholdROI.ref_ROIHeight - intInterTolerance);
                    break;
                case 2:
                    objThresholdROI.LoadROISetting((int)Math.Round(m_objRectGauge4L.ref_pRectCenterPoint.X - m_objRectGauge4L.ref_fRectWidth / 2, 0, MidpointRounding.AwayFromZero),
                                                   (int)Math.Round(m_objRectGauge4L.ref_pRectCenterPoint.Y - m_objRectGauge4L.ref_fRectHeight / 2 + intInterTolerance, 0, MidpointRounding.AwayFromZero),
                                                        (int)Math.Round(m_objRectGauge4L.ref_fRectWidth - intInterTolerance, 0, MidpointRounding.AwayFromZero),
                                                        (int)Math.Round(m_objRectGauge4L.ref_fRectHeight - intInterTolerance * 2, 0, MidpointRounding.AwayFromZero));

                    //objThresholdROI.LoadROISetting(objInterThresholdROI.ref_ROITotalX,
                    //                                    objInterThresholdROI.ref_ROITotalY,
                    //                                    objInterThresholdROI.ref_ROIWidth - intInterTolerance,
                    //                                    objInterThresholdROI.ref_ROIHeight);
                    //objInterThresholdROI.LoadROISetting(objInterThresholdROI.ref_ROITotalX,
                    //                                    objInterThresholdROI.ref_ROITotalY,
                    //                                    objInterThresholdROI.ref_ROIWidth - intInterTolerance,
                    //                                    objInterThresholdROI.ref_ROIHeight);
                    break;
                case 3:
                    objThresholdROI.LoadROISetting((int)Math.Round(m_objRectGauge4L.ref_pRectCenterPoint.X - m_objRectGauge4L.ref_fRectWidth / 2 + intInterTolerance, 0, MidpointRounding.AwayFromZero),
                                                   (int)Math.Round(m_objRectGauge4L.ref_pRectCenterPoint.Y - m_objRectGauge4L.ref_fRectHeight / 2, 0, MidpointRounding.AwayFromZero),
                                                        (int)Math.Round(m_objRectGauge4L.ref_fRectWidth - intInterTolerance * 2, 0, MidpointRounding.AwayFromZero),
                                                        (int)Math.Round(m_objRectGauge4L.ref_fRectHeight - intInterTolerance, 0, MidpointRounding.AwayFromZero));


                    //objThresholdROI.LoadROISetting(objInterThresholdROI.ref_ROITotalX,
                    //                                    objInterThresholdROI.ref_ROITotalY,
                    //                                    objInterThresholdROI.ref_ROIWidth,
                    //                                    objInterThresholdROI.ref_ROIHeight - intInterTolerance);
                    //objInterThresholdROI.LoadROISetting(objInterThresholdROI.ref_ROITotalX,
                    //                                    objInterThresholdROI.ref_ROITotalY,
                    //                                    objInterThresholdROI.ref_ROIWidth,
                    //                                    objInterThresholdROI.ref_ROIHeight - intInterTolerance);
                    break;
                case 4:
                    objThresholdROI.LoadROISetting((int)Math.Round(m_objRectGauge4L.ref_pRectCenterPoint.X - m_objRectGauge4L.ref_fRectWidth / 2 + intInterTolerance, 0, MidpointRounding.AwayFromZero),
                               (int)Math.Round(m_objRectGauge4L.ref_pRectCenterPoint.Y - m_objRectGauge4L.ref_fRectHeight / 2 + intInterTolerance, 0, MidpointRounding.AwayFromZero),
                                    (int)Math.Round(m_objRectGauge4L.ref_fRectWidth - intInterTolerance, 0, MidpointRounding.AwayFromZero),
                                    (int)Math.Round(m_objRectGauge4L.ref_fRectHeight - intInterTolerance * 2, 0, MidpointRounding.AwayFromZero));

                    //objThresholdROI.LoadROISetting(objInterThresholdROI.ref_ROITotalX + intInterTolerance,
                    //                                    objInterThresholdROI.ref_ROITotalY,
                    //                                    objInterThresholdROI.ref_ROIWidth - intInterTolerance,
                    //                                    objInterThresholdROI.ref_ROIHeight);
                    //objInterThresholdROI.LoadROISetting(objInterThresholdROI.ref_ROITotalX + intInterTolerance,
                    //                                    objInterThresholdROI.ref_ROITotalY,
                    //                                    objInterThresholdROI.ref_ROIWidth - intInterTolerance,
                    //                                    objInterThresholdROI.ref_ROIHeight);
                    break;
            }

            objInterThresholdROI.LoadROISetting_MustSameSize(objThresholdROI, objThresholdROI.ref_ROITotalX,
                                    objThresholdROI.ref_ROITotalY,
                                    objThresholdROI.ref_ROIWidth,
                                    objThresholdROI.ref_ROIHeight);

            // Add inter unit ROI to image 1
            EasyImage.Oper(EArithmeticLogicOperation.Add, objThresholdROI.ref_ROI, objInterThresholdROI.ref_ROI, objThresholdROI.ref_ROI);

            // Resize threshold ROI same as unit ROI
            objThresholdROI.LoadROISetting(objROI.ref_ROITotalX, objROI.ref_ROITotalY, objROI.ref_ROIWidth, objROI.ref_ROIHeight);

            // build blobs on inter unit ROI
            m_objEBlobs.BuildObjects_Filter_GetElement(objThresholdROI, !m_blnWhiteOnBlack, true, 0, m_intThresholdValue,
                    Convert.ToInt32(Math.Floor(m_fFilterMinArea)), m_intMaxArea, false, 0xFF);// 13-08-2019 ZJYEOH : Changed 1F to FF to get Feret data

            objThresholdROI.Dispose();
            objInterThresholdROI.Dispose();

            if (m_objEBlobs.ref_intNumSelectedObject > 0)
                return true;
            else
                return false;

        }

        /// <summary>
        /// Build objects and objects with hole in ROI
        /// </summary>
        /// <param name="objROI">ROI</param>
        /// <returns>true</returns>
        public bool BuildObjectsWithHole(ROI objROI, int intMinArea)
        {
            //if (m_blnWhiteOnBlack)
            //    m_objBlobs.SetClassSelection(2);
            //else
            //    m_objBlobs.SetClassSelection(1);

            //int intThresholdValue;
            //if (m_intThresholdValue > 0)
            //{
            //    // Easy object will build object > threshold, not >=threshold. But thresholding will include =, 
            //    // so -1 to threshold value before build object will ensure the objects area same as threshoding area.
            //    intThresholdValue = m_intThresholdValue - 1; 
            //}
            //else
            //    intThresholdValue = 0;

            //if (m_objBlobs.ref_intThreshold != intThresholdValue)
            //    m_objBlobs.ref_intThreshold = intThresholdValue;
            //m_objBlobs.SetConnexity(4);
            //m_objBlobs.SetObjectAreaRange(intMinArea, m_intMaxArea);
            ////m_objBlobs.SetObjectAreaRange(Convert.ToInt32(Math.Floor(m_fFilterMinArea)), m_intMaxArea);
            //if (m_objBlobs.ref_intFeature != 0x0F)
            //    m_objBlobs.ref_intFeature = 0x0F;

            //try
            //{
            //    //objROI.SaveImage("D:\\TS\\objROI.bmp");
            //    if (objROI.ref_ROIWidth > 0 && objROI.ref_ROIHeight > 0)
            //        m_objBlobs.BuildObjectsAndHole(objROI, false, false);
            //}
            //catch
            //{
            //    return false;
            //}
            return true;
        }

        /// <summary>
        /// Check no of objects is it tally with previous setting
        /// </summary>
        /// <param name="intCount">no of previous objects</param>
        /// <returns>true = objects no is tally, false = otherwise</returns>
        public bool CheckPadTally(ref int intCount)
        {
            intCount = m_arrBackupTemplateBlobPads.Count;
            int intNewCount = GetSelectedObjectNumber();

            if (intNewCount == m_arrBackupTemplateBlobPads.Count)
                return true;
            else
                return false;
        }

        /// <summary>
        /// Check whether pitch gap link is exist
        /// </summary>
        /// <param name="intFromPadNo">from pad no</param>
        /// <param name="intToPadNo">to pad no</param>
        /// <returns>true = pitch gap link exist, false = otherwise</returns>
        public bool CheckPitchGapLinkExist(int intFromPadNo, int intToPadNo)
        {
            for (int i = 0; i < m_arrPitchGap.Count; i++)
            {
                if ((m_arrPitchGap[i].intFromPadNo == (intFromPadNo)) &&
                    (m_arrPitchGap[i].intToPadNo == (intToPadNo)) ||
                    (m_arrPitchGap[i].intFromPadNo == (intToPadNo)) &&
                    (m_arrPitchGap[i].intToPadNo == (intFromPadNo)))
                {
                    return true;
                }
            }
            return false;
        }

        /// <summary>
        /// Check whether this pad has already link with other pad
        /// </summary>
        /// <param name="intFromPadNo">from pad no</param>
        /// <returns>true = pad has link with other pad, false = otherwise</returns>
        public bool CheckPitchGapLinkInPadAlready(int intFromPadNo)
        {
            for (int i = 0; i < m_arrPitchGap.Count; i++)
            {
                if (m_arrPitchGap[i].intFromPadNo == intFromPadNo)
                {
                    return true;
                }
            }
            return false;
        }

        /// <summary>
        /// Verify whether pitch gap allow to be created between two pads
        /// </summary>
        /// <param name="intFromPadNo">from pad no</param>
        /// <param name="intToPadNo">to pad no</param>
        /// <returns>true = valid pitch gap link, false = invalid pitch gap link</returns>
        public bool CheckPitchGapLinkAvailable(int intFromPadNo, int intToPadNo)
        {
            /*
             * 0x01 - pad at unit left only
             * 0x02 - pad at unit right only
             * 0x04 - pad at unit top only
             * 0x08 - pad at unit bottom only
             * 0x05 - pad at unit top left
             * 0x06 - pad at unit top right
             * 0x0A - pad at unit bottom right
             * 0x09 - pad at unit bottom left
             */

            m_stcPitchGap = new PitchGap();
            m_stcPitchGap.intFromPadNo = intFromPadNo;
            m_stcPitchGap.intToPadNo = intToPadNo;

            if ((intFromPadNo < m_arrTemplateBlobPads.Count) && (intToPadNo < m_arrTemplateBlobPads.Count))
            {
                int intDrawPoint;
                bool blnUpDownFound = false;
                bool blnLeftRightFound = false;
                BlobsFeatures stcFromBlobsFeatures = (BlobsFeatures)m_arrTemplateBlobPads[intFromPadNo];
                BlobsFeatures stcToBlobsFeatures = (BlobsFeatures)m_arrTemplateBlobPads[intToPadNo];

                // 2019 04 26-CCENG: Pitch Gap Link available if both pads are border edge and corner.
                bool blnSameDirectionGroup = false;
                // Check both pads are in same direction group (group = 5-4. 4-6, 6-2, 2-A, A-8, 8-9, 9-1, 1-5)
                if ((stcFromBlobsFeatures.intDirection == 5 || stcFromBlobsFeatures.intDirection == 4) &&
                    (stcToBlobsFeatures.intDirection == 5 || stcToBlobsFeatures.intDirection == 4))
                {
                    //if (stcFromBlobsFeatures.intGroupID == stcToBlobsFeatures.intGroupID || m_blnWantLinkDifferentGroupPitchGap)   // 2020 03 24 - CCENG: only same group can link each other. This is to prevent same group pad need to have different pitch setting
                    // 2020 12 07 - CCENG: if link border pad and corner pad, need to make sure they are same length mode
                    if ((stcFromBlobsFeatures.intGroupID == stcToBlobsFeatures.intGroupID && (stcFromBlobsFeatures.intLengthMode == stcToBlobsFeatures.intLengthMode)) || m_blnWantLinkDifferentGroupPitchGap)

                        blnSameDirectionGroup = true;
                }
                else if ((stcFromBlobsFeatures.intDirection == 4 || stcFromBlobsFeatures.intDirection == 6) &&
                    (stcToBlobsFeatures.intDirection == 4 || stcToBlobsFeatures.intDirection == 6))
                {
                    //if (stcFromBlobsFeatures.intGroupID == stcToBlobsFeatures.intGroupID || m_blnWantLinkDifferentGroupPitchGap)
                    // 2020 12 07 - CCENG: if link border pad and corner pad, need to make sure they are same length mode
                    if ((stcFromBlobsFeatures.intGroupID == stcToBlobsFeatures.intGroupID && (stcFromBlobsFeatures.intLengthMode == stcToBlobsFeatures.intLengthMode)) || m_blnWantLinkDifferentGroupPitchGap)

                        blnSameDirectionGroup = true;
                }
                else if ((stcFromBlobsFeatures.intDirection == 6 || stcFromBlobsFeatures.intDirection == 2) &&
               (stcToBlobsFeatures.intDirection == 6 || stcToBlobsFeatures.intDirection == 2))
                {
                    //if (stcFromBlobsFeatures.intGroupID == stcToBlobsFeatures.intGroupID || m_blnWantLinkDifferentGroupPitchGap)
                    // 2020 12 07 - CCENG: if link border pad and corner pad, need to make sure they are same length mode
                    if ((stcFromBlobsFeatures.intGroupID == stcToBlobsFeatures.intGroupID && (stcFromBlobsFeatures.intLengthMode == stcToBlobsFeatures.intLengthMode)) || m_blnWantLinkDifferentGroupPitchGap)

                        blnSameDirectionGroup = true;
                }
                else if ((stcFromBlobsFeatures.intDirection == 2 || stcFromBlobsFeatures.intDirection == 0xA) &&
               (stcToBlobsFeatures.intDirection == 2 || stcToBlobsFeatures.intDirection == 0xA))
                {
                    // 2020 12 07 - CCENG: if link border pad and corner pad, need to make sure they are same length mode
                    //if (stcFromBlobsFeatures.intGroupID == stcToBlobsFeatures.intGroupID && || m_blnWantLinkDifferentGroupPitchGap)
                    if ((stcFromBlobsFeatures.intGroupID == stcToBlobsFeatures.intGroupID && (stcFromBlobsFeatures.intLengthMode == stcToBlobsFeatures.intLengthMode)) || m_blnWantLinkDifferentGroupPitchGap)
                        blnSameDirectionGroup = true;
                }
                else if ((stcFromBlobsFeatures.intDirection == 0xA || stcFromBlobsFeatures.intDirection == 8) &&
               (stcToBlobsFeatures.intDirection == 0xA || stcToBlobsFeatures.intDirection == 8))
                {
                    //if (stcFromBlobsFeatures.intGroupID == stcToBlobsFeatures.intGroupID || m_blnWantLinkDifferentGroupPitchGap)
                    // 2020 12 07 - CCENG: if link border pad and corner pad, need to make sure they are same length mode
                    if ((stcFromBlobsFeatures.intGroupID == stcToBlobsFeatures.intGroupID && (stcFromBlobsFeatures.intLengthMode == stcToBlobsFeatures.intLengthMode)) || m_blnWantLinkDifferentGroupPitchGap)

                        blnSameDirectionGroup = true;
                }
                else if ((stcFromBlobsFeatures.intDirection == 8 || stcFromBlobsFeatures.intDirection == 9) &&
                    (stcToBlobsFeatures.intDirection == 8 || stcToBlobsFeatures.intDirection == 9))
                {
                    //if (stcFromBlobsFeatures.intGroupID == stcToBlobsFeatures.intGroupID || m_blnWantLinkDifferentGroupPitchGap)
                    // 2020 12 07 - CCENG: if link border pad and corner pad, need to make sure they are same length mode
                    if ((stcFromBlobsFeatures.intGroupID == stcToBlobsFeatures.intGroupID && (stcFromBlobsFeatures.intLengthMode == stcToBlobsFeatures.intLengthMode)) || m_blnWantLinkDifferentGroupPitchGap)

                        blnSameDirectionGroup = true;
                }
                else if ((stcFromBlobsFeatures.intDirection == 9 || stcFromBlobsFeatures.intDirection == 1) &&
               (stcToBlobsFeatures.intDirection == 9 || stcToBlobsFeatures.intDirection == 1))
                {
                    //if (stcFromBlobsFeatures.intGroupID == stcToBlobsFeatures.intGroupID || m_blnWantLinkDifferentGroupPitchGap)
                    // 2020 12 07 - CCENG: if link border pad and corner pad, need to make sure they are same length mode
                    if ((stcFromBlobsFeatures.intGroupID == stcToBlobsFeatures.intGroupID && (stcFromBlobsFeatures.intLengthMode == stcToBlobsFeatures.intLengthMode)) || m_blnWantLinkDifferentGroupPitchGap)

                        blnSameDirectionGroup = true;
                }
                else if ((stcFromBlobsFeatures.intDirection == 1 || stcFromBlobsFeatures.intDirection == 5) &&
               (stcToBlobsFeatures.intDirection == 1 || stcToBlobsFeatures.intDirection == 5))
                {
                    //if (stcFromBlobsFeatures.intGroupID == stcToBlobsFeatures.intGroupID || m_blnWantLinkDifferentGroupPitchGap)
                    // 2020 12 07 - CCENG: if link border pad and corner pad, need to make sure they are same length mode
                    if ((stcFromBlobsFeatures.intGroupID == stcToBlobsFeatures.intGroupID && (stcFromBlobsFeatures.intLengthMode == stcToBlobsFeatures.intLengthMode)) || m_blnWantLinkDifferentGroupPitchGap)

                        blnSameDirectionGroup = true;
                }
                //       else if ((stcFromBlobsFeatures.intDirection == 7 || stcFromBlobsFeatures.intDirection == 11) &&
                //(stcToBlobsFeatures.intDirection == 7 || stcToBlobsFeatures.intDirection == 11))
                //       {
                //           blnSameDirectionGroup = true;
                //       }
                //       else if ((stcFromBlobsFeatures.intDirection == 13 || stcFromBlobsFeatures.intDirection == 14) &&
                // (stcToBlobsFeatures.intDirection == 14 || stcToBlobsFeatures.intDirection == 13))
                //       {
                //           blnSameDirectionGroup = true;
                //       }

                // Check pitch available between up and down pads
                if ((stcFromBlobsFeatures.intStartX >= stcToBlobsFeatures.intStartX) && (stcFromBlobsFeatures.intStartX <= stcToBlobsFeatures.intEndX) ||
                    (stcFromBlobsFeatures.intEndX >= stcToBlobsFeatures.intStartX) && (stcFromBlobsFeatures.intEndX <= stcToBlobsFeatures.intEndX) ||
                    (stcToBlobsFeatures.intStartX >= stcFromBlobsFeatures.intStartX) && (stcToBlobsFeatures.intEndX <= stcFromBlobsFeatures.intEndX) ||
                    (stcToBlobsFeatures.intEndX >= stcFromBlobsFeatures.intStartX) && (stcToBlobsFeatures.intEndX <= stcFromBlobsFeatures.intEndX))
                {
                    blnUpDownFound = true;
                    //if (stcFromBlobsFeatures.intGroupID == stcToBlobsFeatures.intGroupID || m_blnWantLinkDifferentGroupPitchGap)
                    // 2020 12 07 - CCENG: if link border pad and corner pad, need to make sure they are same length mode
                    if ((stcFromBlobsFeatures.intGroupID == stcToBlobsFeatures.intGroupID && (stcFromBlobsFeatures.intLengthMode == stcToBlobsFeatures.intLengthMode)) || m_blnWantLinkDifferentGroupPitchGap)
                    {
                        blnSameDirectionGroup = true;
                    }

                }

                // Check pitch available between left and right pads
                if ((stcFromBlobsFeatures.intStartY >= stcToBlobsFeatures.intStartY) && (stcFromBlobsFeatures.intStartY <= stcToBlobsFeatures.intEndY) ||
                    (stcFromBlobsFeatures.intEndY >= stcToBlobsFeatures.intStartY) && (stcFromBlobsFeatures.intEndY <= stcToBlobsFeatures.intEndY) ||
                    (stcToBlobsFeatures.intStartY >= stcFromBlobsFeatures.intStartY) && (stcToBlobsFeatures.intEndY <= stcFromBlobsFeatures.intEndY) ||
                    (stcToBlobsFeatures.intEndY >= stcFromBlobsFeatures.intStartY) && (stcToBlobsFeatures.intEndY <= stcFromBlobsFeatures.intEndY))
                {
                    blnLeftRightFound = true;
                    //if (stcFromBlobsFeatures.intGroupID == stcToBlobsFeatures.intGroupID || m_blnWantLinkDifferentGroupPitchGap)
                    // 2020 12 07 - CCENG: if link border pad and corner pad, need to make sure they are same length mode
                    if ((stcFromBlobsFeatures.intGroupID == stcToBlobsFeatures.intGroupID && (stcFromBlobsFeatures.intLengthMode == stcToBlobsFeatures.intLengthMode)) || m_blnWantLinkDifferentGroupPitchGap)
                        blnSameDirectionGroup = true;
                }

                // Pitch only available in up down or left right only
                if (((blnLeftRightFound && !blnUpDownFound) || (!blnLeftRightFound && blnUpDownFound)) && blnSameDirectionGroup)
                {
                    if (blnUpDownFound)
                    {
                        // Pitch only available if distance gap between pads > 1 pixel
                        if ((stcToBlobsFeatures.intStartY - stcFromBlobsFeatures.intEndY) > 1)
                        {
                            intDrawPoint = GetDrawPoint(stcFromBlobsFeatures.intStartX, stcFromBlobsFeatures.intEndX, stcToBlobsFeatures.intStartX, stcToBlobsFeatures.intEndX);
                            m_stcPitchGap.intStartPointX = intDrawPoint;
                            m_stcPitchGap.intEndPointX = intDrawPoint;
                            m_stcPitchGap.intStartPointY = stcFromBlobsFeatures.intEndY;
                            m_stcPitchGap.intEndPointY = stcToBlobsFeatures.intStartY;
                            m_stcPitchGap.fGap = stcToBlobsFeatures.intStartY - stcFromBlobsFeatures.intEndY;
                            m_stcPitchGap.fPitch = stcToBlobsFeatures.fLimitCenterY - stcFromBlobsFeatures.fLimitCenterY;
                            m_stcPitchGap.intDirection = 180;
                            return true;
                        }
                        else if ((stcFromBlobsFeatures.intStartY - stcToBlobsFeatures.intEndY) > 1)
                        {
                            intDrawPoint = GetDrawPoint(stcFromBlobsFeatures.intStartX, stcFromBlobsFeatures.intEndX, stcToBlobsFeatures.intStartX, stcToBlobsFeatures.intEndX);
                            m_stcPitchGap.intStartPointX = intDrawPoint;
                            m_stcPitchGap.intEndPointX = intDrawPoint;
                            m_stcPitchGap.intStartPointY = stcFromBlobsFeatures.intStartY;
                            m_stcPitchGap.intEndPointY = stcToBlobsFeatures.intEndY;
                            m_stcPitchGap.fGap = stcFromBlobsFeatures.intStartY - stcToBlobsFeatures.intEndY;
                            m_stcPitchGap.fPitch = stcFromBlobsFeatures.fLimitCenterY - stcToBlobsFeatures.fLimitCenterY;
                            m_stcPitchGap.intDirection = 0;
                            return true;
                        }
                        else
                        {
                            return false;
                        }
                    }
                    else
                    {
                        // Pitch only available if distance gap between pads > 1 pixel
                        if ((stcToBlobsFeatures.intStartX - stcFromBlobsFeatures.intEndX) > 1)
                        {
                            intDrawPoint = GetDrawPoint(stcFromBlobsFeatures.intStartY, stcFromBlobsFeatures.intEndY, stcToBlobsFeatures.intStartY, stcToBlobsFeatures.intEndY);
                            m_stcPitchGap.intStartPointX = stcFromBlobsFeatures.intEndX;
                            m_stcPitchGap.intEndPointX = stcToBlobsFeatures.intStartX;
                            m_stcPitchGap.intStartPointY = intDrawPoint;
                            m_stcPitchGap.intEndPointY = intDrawPoint;
                            m_stcPitchGap.fGap = stcToBlobsFeatures.intStartX - stcFromBlobsFeatures.intEndX;
                            m_stcPitchGap.fPitch = stcToBlobsFeatures.fLimitCenterX - stcFromBlobsFeatures.fLimitCenterX;
                            m_stcPitchGap.intDirection = 90;
                            return true;
                        }
                        else if ((stcFromBlobsFeatures.intStartX - stcToBlobsFeatures.intEndX) > 1)
                        {
                            intDrawPoint = GetDrawPoint(stcFromBlobsFeatures.intStartY, stcFromBlobsFeatures.intEndY, stcToBlobsFeatures.intStartY, stcToBlobsFeatures.intEndY);
                            m_stcPitchGap.intStartPointX = stcFromBlobsFeatures.intStartX;
                            m_stcPitchGap.intEndPointX = stcToBlobsFeatures.intEndX;
                            m_stcPitchGap.intStartPointY = intDrawPoint;
                            m_stcPitchGap.intEndPointY = intDrawPoint;
                            m_stcPitchGap.fGap = stcFromBlobsFeatures.intStartX - stcToBlobsFeatures.intEndX;
                            m_stcPitchGap.fPitch = stcFromBlobsFeatures.fLimitCenterX - stcToBlobsFeatures.fLimitCenterX;
                            m_stcPitchGap.intDirection = 270;
                            return true;
                        }
                        else
                        {
                            return false;
                        }
                    }
                }
                else
                    return false;
            }
            return true;
        }
        public bool CheckPitchGapLinkAvailable_LinkDifferentGroup(int intFromPadNo, int intToPadNo)
        {
            /*
             * 0x01 - pad at unit left only
             * 0x02 - pad at unit right only
             * 0x04 - pad at unit top only
             * 0x08 - pad at unit bottom only
             * 0x05 - pad at unit top left
             * 0x06 - pad at unit top right
             * 0x0A - pad at unit bottom right
             * 0x09 - pad at unit bottom left
             */

            m_stcPitchGap = new PitchGap();
            m_stcPitchGap.intFromPadNo = intFromPadNo;
            m_stcPitchGap.intToPadNo = intToPadNo;

            if ((intFromPadNo < m_arrTemplateBlobPads.Count) && (intToPadNo < m_arrTemplateBlobPads.Count))
            {
                int intDrawPoint;
                bool blnUpDownFound = false;
                bool blnLeftRightFound = false;
                BlobsFeatures stcFromBlobsFeatures = (BlobsFeatures)m_arrTemplateBlobPads[intFromPadNo];
                BlobsFeatures stcToBlobsFeatures = (BlobsFeatures)m_arrTemplateBlobPads[intToPadNo];

                // 2019 04 26-CCENG: Pitch Gap Link available if both pads are border edge and corner.
                bool blnSameDirectionGroup = false;
                // Check both pads are in same direction group (group = 5-4. 4-6, 6-2, 2-A, A-8, 8-9, 9-1, 1-5)
                if ((stcFromBlobsFeatures.intDirection == 5 || stcFromBlobsFeatures.intDirection == 4) &&
                    (stcToBlobsFeatures.intDirection == 5 || stcToBlobsFeatures.intDirection == 4))
                {
                    //if (stcFromBlobsFeatures.intGroupID == stcToBlobsFeatures.intGroupID || m_blnWantLinkDifferentGroupPitchGap)   // 2020 03 24 - CCENG: only same group can link each other. This is to prevent same group pad need to have different pitch setting
                    // 2020 12 07 - CCENG: if link border pad and corner pad, need to make sure they are same length mode
                    if ((stcFromBlobsFeatures.intGroupID == stcToBlobsFeatures.intGroupID && (stcFromBlobsFeatures.intLengthMode == stcToBlobsFeatures.intLengthMode)) || true)

                        blnSameDirectionGroup = true;
                }
                else if ((stcFromBlobsFeatures.intDirection == 4 || stcFromBlobsFeatures.intDirection == 6) &&
                    (stcToBlobsFeatures.intDirection == 4 || stcToBlobsFeatures.intDirection == 6))
                {
                    //if (stcFromBlobsFeatures.intGroupID == stcToBlobsFeatures.intGroupID || m_blnWantLinkDifferentGroupPitchGap)
                    // 2020 12 07 - CCENG: if link border pad and corner pad, need to make sure they are same length mode
                    if ((stcFromBlobsFeatures.intGroupID == stcToBlobsFeatures.intGroupID && (stcFromBlobsFeatures.intLengthMode == stcToBlobsFeatures.intLengthMode)) || true)

                        blnSameDirectionGroup = true;
                }
                else if ((stcFromBlobsFeatures.intDirection == 6 || stcFromBlobsFeatures.intDirection == 2) &&
               (stcToBlobsFeatures.intDirection == 6 || stcToBlobsFeatures.intDirection == 2))
                {
                    //if (stcFromBlobsFeatures.intGroupID == stcToBlobsFeatures.intGroupID || m_blnWantLinkDifferentGroupPitchGap)
                    // 2020 12 07 - CCENG: if link border pad and corner pad, need to make sure they are same length mode
                    if ((stcFromBlobsFeatures.intGroupID == stcToBlobsFeatures.intGroupID && (stcFromBlobsFeatures.intLengthMode == stcToBlobsFeatures.intLengthMode)) || true)

                        blnSameDirectionGroup = true;
                }
                else if ((stcFromBlobsFeatures.intDirection == 2 || stcFromBlobsFeatures.intDirection == 0xA) &&
               (stcToBlobsFeatures.intDirection == 2 || stcToBlobsFeatures.intDirection == 0xA))
                {
                    // 2020 12 07 - CCENG: if link border pad and corner pad, need to make sure they are same length mode
                    //if (stcFromBlobsFeatures.intGroupID == stcToBlobsFeatures.intGroupID && || m_blnWantLinkDifferentGroupPitchGap)
                    if ((stcFromBlobsFeatures.intGroupID == stcToBlobsFeatures.intGroupID && (stcFromBlobsFeatures.intLengthMode == stcToBlobsFeatures.intLengthMode)) || true)
                        blnSameDirectionGroup = true;
                }
                else if ((stcFromBlobsFeatures.intDirection == 0xA || stcFromBlobsFeatures.intDirection == 8) &&
               (stcToBlobsFeatures.intDirection == 0xA || stcToBlobsFeatures.intDirection == 8))
                {
                    //if (stcFromBlobsFeatures.intGroupID == stcToBlobsFeatures.intGroupID || m_blnWantLinkDifferentGroupPitchGap)
                    // 2020 12 07 - CCENG: if link border pad and corner pad, need to make sure they are same length mode
                    if ((stcFromBlobsFeatures.intGroupID == stcToBlobsFeatures.intGroupID && (stcFromBlobsFeatures.intLengthMode == stcToBlobsFeatures.intLengthMode)) || true)

                        blnSameDirectionGroup = true;
                }
                else if ((stcFromBlobsFeatures.intDirection == 8 || stcFromBlobsFeatures.intDirection == 9) &&
                    (stcToBlobsFeatures.intDirection == 8 || stcToBlobsFeatures.intDirection == 9))
                {
                    //if (stcFromBlobsFeatures.intGroupID == stcToBlobsFeatures.intGroupID || m_blnWantLinkDifferentGroupPitchGap)
                    // 2020 12 07 - CCENG: if link border pad and corner pad, need to make sure they are same length mode
                    if ((stcFromBlobsFeatures.intGroupID == stcToBlobsFeatures.intGroupID && (stcFromBlobsFeatures.intLengthMode == stcToBlobsFeatures.intLengthMode)) || true)

                        blnSameDirectionGroup = true;
                }
                else if ((stcFromBlobsFeatures.intDirection == 9 || stcFromBlobsFeatures.intDirection == 1) &&
               (stcToBlobsFeatures.intDirection == 9 || stcToBlobsFeatures.intDirection == 1))
                {
                    //if (stcFromBlobsFeatures.intGroupID == stcToBlobsFeatures.intGroupID || m_blnWantLinkDifferentGroupPitchGap)
                    // 2020 12 07 - CCENG: if link border pad and corner pad, need to make sure they are same length mode
                    if ((stcFromBlobsFeatures.intGroupID == stcToBlobsFeatures.intGroupID && (stcFromBlobsFeatures.intLengthMode == stcToBlobsFeatures.intLengthMode)) || true)

                        blnSameDirectionGroup = true;
                }
                else if ((stcFromBlobsFeatures.intDirection == 1 || stcFromBlobsFeatures.intDirection == 5) &&
               (stcToBlobsFeatures.intDirection == 1 || stcToBlobsFeatures.intDirection == 5))
                {
                    //if (stcFromBlobsFeatures.intGroupID == stcToBlobsFeatures.intGroupID || m_blnWantLinkDifferentGroupPitchGap)
                    // 2020 12 07 - CCENG: if link border pad and corner pad, need to make sure they are same length mode
                    if ((stcFromBlobsFeatures.intGroupID == stcToBlobsFeatures.intGroupID && (stcFromBlobsFeatures.intLengthMode == stcToBlobsFeatures.intLengthMode)) || true)

                        blnSameDirectionGroup = true;
                }
                //       else if ((stcFromBlobsFeatures.intDirection == 7 || stcFromBlobsFeatures.intDirection == 11) &&
                //(stcToBlobsFeatures.intDirection == 7 || stcToBlobsFeatures.intDirection == 11))
                //       {
                //           blnSameDirectionGroup = true;
                //       }
                //       else if ((stcFromBlobsFeatures.intDirection == 13 || stcFromBlobsFeatures.intDirection == 14) &&
                // (stcToBlobsFeatures.intDirection == 14 || stcToBlobsFeatures.intDirection == 13))
                //       {
                //           blnSameDirectionGroup = true;
                //       }

                // Check pitch available between up and down pads
                if ((stcFromBlobsFeatures.intStartX >= stcToBlobsFeatures.intStartX) && (stcFromBlobsFeatures.intStartX <= stcToBlobsFeatures.intEndX) ||
                    (stcFromBlobsFeatures.intEndX >= stcToBlobsFeatures.intStartX) && (stcFromBlobsFeatures.intEndX <= stcToBlobsFeatures.intEndX) ||
                    (stcToBlobsFeatures.intStartX >= stcFromBlobsFeatures.intStartX) && (stcToBlobsFeatures.intEndX <= stcFromBlobsFeatures.intEndX) ||
                    (stcToBlobsFeatures.intEndX >= stcFromBlobsFeatures.intStartX) && (stcToBlobsFeatures.intEndX <= stcFromBlobsFeatures.intEndX))
                {
                    blnUpDownFound = true;
                    //if (stcFromBlobsFeatures.intGroupID == stcToBlobsFeatures.intGroupID || m_blnWantLinkDifferentGroupPitchGap)
                    // 2020 12 07 - CCENG: if link border pad and corner pad, need to make sure they are same length mode
                    if ((stcFromBlobsFeatures.intGroupID == stcToBlobsFeatures.intGroupID && (stcFromBlobsFeatures.intLengthMode == stcToBlobsFeatures.intLengthMode)) || true)
                    {
                        blnSameDirectionGroup = true;
                    }

                }

                // Check pitch available between left and right pads
                if ((stcFromBlobsFeatures.intStartY >= stcToBlobsFeatures.intStartY) && (stcFromBlobsFeatures.intStartY <= stcToBlobsFeatures.intEndY) ||
                    (stcFromBlobsFeatures.intEndY >= stcToBlobsFeatures.intStartY) && (stcFromBlobsFeatures.intEndY <= stcToBlobsFeatures.intEndY) ||
                    (stcToBlobsFeatures.intStartY >= stcFromBlobsFeatures.intStartY) && (stcToBlobsFeatures.intEndY <= stcFromBlobsFeatures.intEndY) ||
                    (stcToBlobsFeatures.intEndY >= stcFromBlobsFeatures.intStartY) && (stcToBlobsFeatures.intEndY <= stcFromBlobsFeatures.intEndY))
                {
                    blnLeftRightFound = true;
                    //if (stcFromBlobsFeatures.intGroupID == stcToBlobsFeatures.intGroupID || m_blnWantLinkDifferentGroupPitchGap)
                    // 2020 12 07 - CCENG: if link border pad and corner pad, need to make sure they are same length mode
                    if ((stcFromBlobsFeatures.intGroupID == stcToBlobsFeatures.intGroupID && (stcFromBlobsFeatures.intLengthMode == stcToBlobsFeatures.intLengthMode)) || true)
                        blnSameDirectionGroup = true;
                }

                // Pitch only available in up down or left right only
                if (((blnLeftRightFound && !blnUpDownFound) || (!blnLeftRightFound && blnUpDownFound)) && blnSameDirectionGroup)
                {
                    if (blnUpDownFound)
                    {
                        // Pitch only available if distance gap between pads > 1 pixel
                        if ((stcToBlobsFeatures.intStartY - stcFromBlobsFeatures.intEndY) > 1)
                        {
                            intDrawPoint = GetDrawPoint(stcFromBlobsFeatures.intStartX, stcFromBlobsFeatures.intEndX, stcToBlobsFeatures.intStartX, stcToBlobsFeatures.intEndX);
                            m_stcPitchGap.intStartPointX = intDrawPoint;
                            m_stcPitchGap.intEndPointX = intDrawPoint;
                            m_stcPitchGap.intStartPointY = stcFromBlobsFeatures.intEndY;
                            m_stcPitchGap.intEndPointY = stcToBlobsFeatures.intStartY;
                            m_stcPitchGap.fGap = stcToBlobsFeatures.intStartY - stcFromBlobsFeatures.intEndY;
                            m_stcPitchGap.fPitch = stcToBlobsFeatures.fLimitCenterY - stcFromBlobsFeatures.fLimitCenterY;
                            m_stcPitchGap.intDirection = 180;
                            return true;
                        }
                        else if ((stcFromBlobsFeatures.intStartY - stcToBlobsFeatures.intEndY) > 1)
                        {
                            intDrawPoint = GetDrawPoint(stcFromBlobsFeatures.intStartX, stcFromBlobsFeatures.intEndX, stcToBlobsFeatures.intStartX, stcToBlobsFeatures.intEndX);
                            m_stcPitchGap.intStartPointX = intDrawPoint;
                            m_stcPitchGap.intEndPointX = intDrawPoint;
                            m_stcPitchGap.intStartPointY = stcFromBlobsFeatures.intStartY;
                            m_stcPitchGap.intEndPointY = stcToBlobsFeatures.intEndY;
                            m_stcPitchGap.fGap = stcFromBlobsFeatures.intStartY - stcToBlobsFeatures.intEndY;
                            m_stcPitchGap.fPitch = stcFromBlobsFeatures.fLimitCenterY - stcToBlobsFeatures.fLimitCenterY;
                            m_stcPitchGap.intDirection = 0;
                            return true;
                        }
                        else
                        {
                            return false;
                        }
                    }
                    else
                    {
                        // Pitch only available if distance gap between pads > 1 pixel
                        if ((stcToBlobsFeatures.intStartX - stcFromBlobsFeatures.intEndX) > 1)
                        {
                            intDrawPoint = GetDrawPoint(stcFromBlobsFeatures.intStartY, stcFromBlobsFeatures.intEndY, stcToBlobsFeatures.intStartY, stcToBlobsFeatures.intEndY);
                            m_stcPitchGap.intStartPointX = stcFromBlobsFeatures.intEndX;
                            m_stcPitchGap.intEndPointX = stcToBlobsFeatures.intStartX;
                            m_stcPitchGap.intStartPointY = intDrawPoint;
                            m_stcPitchGap.intEndPointY = intDrawPoint;
                            m_stcPitchGap.fGap = stcToBlobsFeatures.intStartX - stcFromBlobsFeatures.intEndX;
                            m_stcPitchGap.fPitch = stcToBlobsFeatures.fLimitCenterX - stcFromBlobsFeatures.fLimitCenterX;
                            m_stcPitchGap.intDirection = 90;
                            return true;
                        }
                        else if ((stcFromBlobsFeatures.intStartX - stcToBlobsFeatures.intEndX) > 1)
                        {
                            intDrawPoint = GetDrawPoint(stcFromBlobsFeatures.intStartY, stcFromBlobsFeatures.intEndY, stcToBlobsFeatures.intStartY, stcToBlobsFeatures.intEndY);
                            m_stcPitchGap.intStartPointX = stcFromBlobsFeatures.intStartX;
                            m_stcPitchGap.intEndPointX = stcToBlobsFeatures.intEndX;
                            m_stcPitchGap.intStartPointY = intDrawPoint;
                            m_stcPitchGap.intEndPointY = intDrawPoint;
                            m_stcPitchGap.fGap = stcFromBlobsFeatures.intStartX - stcToBlobsFeatures.intEndX;
                            m_stcPitchGap.fPitch = stcFromBlobsFeatures.fLimitCenterX - stcToBlobsFeatures.fLimitCenterX;
                            m_stcPitchGap.intDirection = 270;
                            return true;
                        }
                        else
                        {
                            return false;
                        }
                    }
                }
                else
                    return false;
            }
            return true;
        }

        /// <summary>
        /// Check whether all previous blobs are matched with current selected blobs
        /// </summary>
        /// <returns>true = all previous blobs match, false = otherwise</returns>
        public bool MatchPrevSettings()
        {
            float fStartX, fStartY, fEndX, fEndY, fCenterX, fCenterY, fWidth, fHeight;
            int intCount = 0, intNo;

            for (int i = 0; i < m_arrBackupTemplateBlobPads.Count; i++)
            {
                m_stcBackupTemplateBlobPad = (ToleranceBlobsFeatures)m_arrBackupTemplateBlobPads[i];

                fStartX = m_stcBackupTemplateBlobPad.fStartX;
                fStartY = m_stcBackupTemplateBlobPad.fStartY;
                fEndX = m_stcBackupTemplateBlobPad.fEndX;
                fEndY = m_stcBackupTemplateBlobPad.fEndY;
                fCenterX = m_stcBackupTemplateBlobPad.fLimitCenterX;
                fCenterY = m_stcBackupTemplateBlobPad.fLimitCenterY;
                fWidth = m_stcBackupTemplateBlobPad.fLearnWidth;
                fHeight = m_stcBackupTemplateBlobPad.fLearnHeight;

                // Get current blobs number
                intNo = MatchTemplateObjects_IgnoreBigOverlapPad(fStartX, fStartY, fEndX, fEndY, fCenterX, fCenterY);
                //List<int> arrMatch = MatchTemplateObjects(fStartX, fStartY, fEndX, fEndY, fCenterX, fCenterY);
                //if (arrMatch.Count == 0)
                //    continue;
                //else if (arrMatch.Count > 1)
                //    intNo = -2;
                //else
                //    intNo = arrMatch[0];

                if (intNo >= 0)
                {
                    BlobsFeatures m_stcBlobPad = (BlobsFeatures)m_arrTemplateBlobPads[intNo];
                    m_stcBackupTemplateBlobPad = (ToleranceBlobsFeatures)m_arrBackupTemplateBlobPads[i];

                    m_stcBlobPad.intDirection = m_stcBackupTemplateBlobPad.intDirection;
                    m_stcBlobPad.intNoID = m_stcBackupTemplateBlobPad.intNoID;
                    m_stcBlobPad.intLengthMode = m_stcBackupTemplateBlobPad.intLengthMode;
                    m_arrTemplateBlobPads.RemoveAt(intNo);
                    m_arrTemplateBlobPads.Insert(intNo, m_stcBlobPad);
                    intCount++;
                }
            }

            // All previous blobs are matched with current selected blobs
            if (intCount == m_arrBackupTemplateBlobPads.Count)
                return true;

            return false;
        }

        public bool MatchPrevSettings2()
        {
            float fStartX, fStartY, fEndX, fEndY, fCenterX, fCenterY;
            int intCount = 0, intNo;

            for (int i = 0; i < m_arrBackupTemplateBlobPads.Count; i++)
            {
                m_stcBackupTemplateBlobPad = (ToleranceBlobsFeatures)m_arrBackupTemplateBlobPads[i];

                fStartX = m_stcBackupTemplateBlobPad.fStartX;
                fStartY = m_stcBackupTemplateBlobPad.fStartY;
                fEndX = m_stcBackupTemplateBlobPad.fEndX;
                fEndY = m_stcBackupTemplateBlobPad.fEndY;
                fCenterX = m_stcBackupTemplateBlobPad.fLimitCenterX;
                fCenterY = m_stcBackupTemplateBlobPad.fLimitCenterY;

                // Get current blobs number
                List<int> arrMatch = MatchTemplateObjects(fStartX, fStartY, fEndX, fEndY, fCenterX, fCenterY);

                if (arrMatch.Count == 0)
                    continue;
                else if (arrMatch.Count > 1)
                    intNo = -2;
                else
                    intNo = arrMatch[0];

                if (intNo >= 0)
                {
                    if (!((BlobsFeatures)m_arrTemplateBlobPads[intNo]).blnSelected)
                        continue;

                    BlobsFeatures m_stcBlobPad = (BlobsFeatures)m_arrTemplateBlobPads[intNo];
                    m_stcBackupTemplateBlobPad = (ToleranceBlobsFeatures)m_arrBackupTemplateBlobPads[i];

                    m_stcBlobPad.intDirection = m_stcBackupTemplateBlobPad.intDirection;
                    m_stcBlobPad.intNoID = m_stcBackupTemplateBlobPad.intNoID;
                    m_stcBlobPad.intLengthMode = m_stcBackupTemplateBlobPad.intLengthMode;
                    m_arrTemplateBlobPads.RemoveAt(intNo);
                    m_arrTemplateBlobPads.Insert(intNo, m_stcBlobPad);
                    intCount++;
                }
            }

            // All previous blobs are matched with current selected blobs
            if (intCount == m_arrBackupTemplateBlobPads.Count)
                return true;

            return false;
        }

        public void MatchPrevSettings_AutoGenerate()
        {
            float fStartX, fStartY, fEndX, fEndY, fCenterX, fCenterY, fWidth, fHeight;
            int intCount = 0, intNo;

            for (int i = 0; i < m_arrTemplateBlobPads.Count; i++)
            {
                if (!((BlobsFeatures)m_arrTemplateBlobPads[i]).blnSelected)
                    continue;

                BlobsFeatures m_stcBlobPad = (BlobsFeatures)m_arrTemplateBlobPads[i];

                fStartX = m_stcBlobPad.fStartX;
                fStartY = m_stcBlobPad.fStartY;
                fEndX = m_stcBlobPad.fEndX;
                fEndY = m_stcBlobPad.fEndY;
                fCenterX = m_stcBlobPad.fLimitCenterX;
                fCenterY = m_stcBlobPad.fLimitCenterY;
                fWidth = m_stcBlobPad.fWidth;

                // Get current blobs number
                int intMatchTemplateBlobPadIndex = MatchTemplateObjects_BasedOnPositionAndSize(m_stcBlobPad.fStartX, m_stcBlobPad.fStartY,
                                                                                m_stcBlobPad.fEndX, m_stcBlobPad.fEndY,
                                                                                fCenterX, fCenterY,
                                                                                m_stcBlobPad.fWidth, m_stcBlobPad.fHeight);

                if (intMatchTemplateBlobPadIndex >= 0)
                {
                    m_stcBlobPad = (BlobsFeatures)m_arrTemplateBlobPads[i];
                    m_stcBackupTemplateBlobPad = (ToleranceBlobsFeatures)m_arrBackupTemplateBlobPads[intMatchTemplateBlobPadIndex];

                    m_stcBlobPad.intDirection = m_stcBackupTemplateBlobPad.intDirection;
                    m_stcBlobPad.intNoID = m_stcBackupTemplateBlobPad.intNoID;
                    m_stcBlobPad.intGroupID = m_stcBackupTemplateBlobPad.intGroupID;
                    m_stcBlobPad.fOffSet = m_stcBackupTemplateBlobPad.fOffSet;
                    m_stcBlobPad.fMinArea = m_stcBackupTemplateBlobPad.fMinArea;
                    m_stcBlobPad.fMaxArea = m_stcBackupTemplateBlobPad.fMaxArea;
                    m_stcBlobPad.fMinWidth = m_stcBackupTemplateBlobPad.fMinWidth;
                    m_stcBlobPad.fMaxWidth = m_stcBackupTemplateBlobPad.fMaxWidth;
                    m_stcBlobPad.fMinLength = m_stcBackupTemplateBlobPad.fMinLength;
                    m_stcBlobPad.fMaxLength = m_stcBackupTemplateBlobPad.fMaxLength;
                    m_stcBlobPad.fMaxBroken = m_stcBackupTemplateBlobPad.fMaxBroken;
                    m_stcBlobPad.fMaxBrokenLength = m_stcBackupTemplateBlobPad.fMaxBrokenLength;

                    m_stcBlobPad.fPadInspectionAreaFromTop = m_stcBackupTemplateBlobPad.fPadInspectionAreaFromTop;
                    m_stcBlobPad.fPadInspectionAreaFromRight = m_stcBackupTemplateBlobPad.fPadInspectionAreaFromRight;
                    m_stcBlobPad.fPadInspectionAreaFromBottom = m_stcBackupTemplateBlobPad.fPadInspectionAreaFromBottom;
                    m_stcBlobPad.fPadInspectionAreaFromLeft = m_stcBackupTemplateBlobPad.fPadInspectionAreaFromLeft;

                    m_stcBlobPad.blnSelected = true;

                    m_arrTemplateBlobPads.RemoveAt(i);
                    m_arrTemplateBlobPads.Insert(i, m_stcBlobPad);
                }
                else
                {
                    // Generate default setting


                }

            }
        }
        public float GetMinSpanX(int intValueType)
        {
            switch (intValueType)
            {
                case 0: // Pixel
                    return m_fMinSpanX * m_fMMToPixelXValue;
                case 1: // mm
                case 2: // mil
                case 3: // micron
                    return m_fMinSpanX * m_fMMToUnitValue;
                default:
                    return 0;
            }
        }
        public float GetMaxSpanX(int intValueType)
        {
            switch (intValueType)
            {
                case 0: // Pixel
                    return m_fMaxSpanX * m_fMMToPixelXValue;
                case 1: // mm
                case 2: // mil
                case 3: // micron
                    return m_fMaxSpanX * m_fMMToUnitValue;
                default:
                    return 0;
            }
        }
        public float GetMinSpanY(int intValueType)
        {
            switch (intValueType)
            {
                case 0: // Pixel
                    return m_fMinSpanY * m_fMMToPixelYValue;
                case 1: // mm
                case 2: // mil
                case 3: // micron
                    return m_fMinSpanY * m_fMMToUnitValue;
                default:
                    return 0;
            }
        }
        public float GetMaxSpanY(int intValueType)
        {
            switch (intValueType)
            {
                case 0: // Pixel
                    return m_fMaxSpanY * m_fMMToPixelYValue;
                case 1: // mm
                case 2: // mil
                case 3: // micron
                    return m_fMaxSpanY * m_fMMToUnitValue;
                default:
                    return 0;
            }
        }
        public void SetMinSpanX(float fValue, int intFromValueType)
        {
            switch (intFromValueType)
            {
                case 0: // Pixel
                    m_fMinSpanX = fValue / m_fMMToPixelXValue;
                    break;
                case 1: // mm
                case 2: // mil
                case 3: // micron
                default:
                    m_fMinSpanX = fValue / m_fMMToUnitValue;
                    break;
            }
        }
        public void SetMaxSpanX(float fValue, int intFromValueType)
        {
            switch (intFromValueType)
            {
                case 0: // Pixel
                    m_fMaxSpanX = fValue / m_fMMToPixelXValue;
                    break;
                case 1: // mm
                case 2: // mil
                case 3: // micron
                default:
                    m_fMaxSpanX = fValue / m_fMMToUnitValue;
                    break;
            }
        }
        public void SetMinSpanY(float fValue, int intFromValueType)
        {
            switch (intFromValueType)
            {
                case 0: // Pixel
                    m_fMinSpanY = fValue / m_fMMToPixelYValue;
                    break;
                case 1: // mm
                case 2: // mil
                case 3: // micron
                default:
                    m_fMinSpanY = fValue / m_fMMToUnitValue;
                    break;
            }
        }
        public void SetMaxSpanY(float fValue, int intFromValueType)
        {
            switch (intFromValueType)
            {
                case 0: // Pixel
                    m_fMaxSpanY = fValue / m_fMMToPixelYValue;
                    break;
                case 1: // mm
                case 2: // mil
                case 3: // micron
                default:
                    m_fMaxSpanY = fValue / m_fMMToUnitValue;
                    break;
            }
        }
        public float GetPadEdgeDistanceMin_Top(int intValueType)
        {
            switch (intValueType)
            {
                case 0: // Pixel
                    return m_fEdgeDistanceMin_Top * m_fMMToPixelYValue;
                case 1: // mm
                case 2: // mil
                case 3: // micron
                    return m_fEdgeDistanceMin_Top * m_fMMToUnitValue;
                default:
                    return 0;
            }
        }
        public float GetPadEdgeDistanceMax_Top(int intValueType)
        {
            switch (intValueType)
            {
                case 0: // Pixel
                    return m_fEdgeDistanceMax_Top * m_fMMToPixelYValue;
                case 1: // mm
                case 2: // mil
                case 3: // micron
                    return m_fEdgeDistanceMax_Top * m_fMMToUnitValue;
                default:
                    return 0;
            }
        }
        public float GetPadEdgeDistanceMin_Right(int intValueType)
        {
            switch (intValueType)
            {
                case 0: // Pixel
                    return m_fEdgeDistanceMin_Right * m_fMMToPixelXValue;
                case 1: // mm
                case 2: // mil
                case 3: // micron
                    return m_fEdgeDistanceMin_Right * m_fMMToUnitValue;
                default:
                    return 0;
            }
        }
        public float GetPadEdgeDistanceMax_Right(int intValueType)
        {
            switch (intValueType)
            {
                case 0: // Pixel
                    return m_fEdgeDistanceMax_Right * m_fMMToPixelXValue;
                case 1: // mm
                case 2: // mil
                case 3: // micron
                    return m_fEdgeDistanceMax_Right * m_fMMToUnitValue;
                default:
                    return 0;
            }
        }
        public float GetPadEdgeDistanceMin_Bottom(int intValueType)
        {
            switch (intValueType)
            {
                case 0: // Pixel
                    return m_fEdgeDistanceMin_Bottom * m_fMMToPixelYValue;
                case 1: // mm
                case 2: // mil
                case 3: // micron
                    return m_fEdgeDistanceMin_Bottom * m_fMMToUnitValue;
                default:
                    return 0;
            }
        }
        public float GetPadEdgeDistanceMax_Bottom(int intValueType)
        {
            switch (intValueType)
            {
                case 0: // Pixel
                    return m_fEdgeDistanceMax_Bottom * m_fMMToPixelYValue;
                case 1: // mm
                case 2: // mil
                case 3: // micron
                    return m_fEdgeDistanceMax_Bottom * m_fMMToUnitValue;
                default:
                    return 0;
            }
        }
        public float GetPadEdgeDistanceMin_Left(int intValueType)
        {
            switch (intValueType)
            {
                case 0: // Pixel
                    return m_fEdgeDistanceMin_Left * m_fMMToPixelXValue;
                case 1: // mm
                case 2: // mil
                case 3: // micron
                    return m_fEdgeDistanceMin_Left * m_fMMToUnitValue;
                default:
                    return 0;
            }
        }
        public float GetPadEdgeDistanceMax_Left(int intValueType)
        {
            switch (intValueType)
            {
                case 0: // Pixel
                    return m_fEdgeDistanceMax_Left * m_fMMToPixelXValue;
                case 1: // mm
                case 2: // mil
                case 3: // micron
                    return m_fEdgeDistanceMax_Left * m_fMMToUnitValue;
                default:
                    return 0;
            }
        }
        public void SetPadEdgeDistanceMin_Top(float fValue, int intFromValueType)
        {
            switch (intFromValueType)
            {
                case 0: // Pixel
                    m_fEdgeDistanceMin_Top = fValue / m_fMMToPixelYValue;
                    break;
                case 1: // mm
                case 2: // mil
                case 3: // micron
                default:
                    m_fEdgeDistanceMin_Top = fValue / m_fMMToUnitValue;
                    break;
            }
        }
        public void SetPadEdgeDistanceMax_Top(float fValue, int intFromValueType)
        {
            switch (intFromValueType)
            {
                case 0: // Pixel
                    m_fEdgeDistanceMax_Top = fValue / m_fMMToPixelYValue;
                    break;
                case 1: // mm
                case 2: // mil
                case 3: // micron
                default:
                    m_fEdgeDistanceMax_Top = fValue / m_fMMToUnitValue;
                    break;
            }
        }
        public void SetPadEdgeDistanceMin_Right(float fValue, int intFromValueType)
        {
            switch (intFromValueType)
            {
                case 0: // Pixel
                    m_fEdgeDistanceMin_Right = fValue / m_fMMToPixelYValue;
                    break;
                case 1: // mm
                case 2: // mil
                case 3: // micron
                default:
                    m_fEdgeDistanceMin_Right = fValue / m_fMMToUnitValue;
                    break;
            }
        }
        public void SetPadEdgeDistanceMax_Right(float fValue, int intFromValueType)
        {
            switch (intFromValueType)
            {
                case 0: // Pixel
                    m_fEdgeDistanceMax_Right = fValue / m_fMMToPixelYValue;
                    break;
                case 1: // mm
                case 2: // mil
                case 3: // micron
                default:
                    m_fEdgeDistanceMax_Right = fValue / m_fMMToUnitValue;
                    break;
            }
        }
        public void SetPadEdgeDistanceMin_Bottom(float fValue, int intFromValueType)
        {
            switch (intFromValueType)
            {
                case 0: // Pixel
                    m_fEdgeDistanceMin_Bottom = fValue / m_fMMToPixelYValue;
                    break;
                case 1: // mm
                case 2: // mil
                case 3: // micron
                default:
                    m_fEdgeDistanceMin_Bottom = fValue / m_fMMToUnitValue;
                    break;
            }
        }
        public void SetPadEdgeDistanceMax_Bottom(float fValue, int intFromValueType)
        {
            switch (intFromValueType)
            {
                case 0: // Pixel
                    m_fEdgeDistanceMax_Bottom = fValue / m_fMMToPixelYValue;
                    break;
                case 1: // mm
                case 2: // mil
                case 3: // micron
                default:
                    m_fEdgeDistanceMax_Bottom = fValue / m_fMMToUnitValue;
                    break;
            }
        }
        public void SetPadEdgeDistanceMin_Left(float fValue, int intFromValueType)
        {
            switch (intFromValueType)
            {
                case 0: // Pixel
                    m_fEdgeDistanceMin_Left = fValue / m_fMMToPixelYValue;
                    break;
                case 1: // mm
                case 2: // mil
                case 3: // micron
                default:
                    m_fEdgeDistanceMin_Left = fValue / m_fMMToUnitValue;
                    break;
            }
        }
        public void SetPadEdgeDistanceMax_Left(float fValue, int intFromValueType)
        {
            switch (intFromValueType)
            {
                case 0: // Pixel
                    m_fEdgeDistanceMax_Left = fValue / m_fMMToPixelYValue;
                    break;
                case 1: // mm
                case 2: // mil
                case 3: // micron
                default:
                    m_fEdgeDistanceMax_Left = fValue / m_fMMToUnitValue;
                    break;
            }
        }
        /// <summary>
        /// Get extra pad min area settings
        /// </summary>
        /// <param name="intValueType">0=Pixel, 1=mm, 2=mil, 3=um</param>
        /// <returns></returns>
        public float GetExtraPadMinArea(int intValueType)
        {
            switch (intValueType)
            {
                case 0: // Pixel
                    return m_fExtraPadSetArea * m_fMMtoPixelAreaValue;
                case 1: // mm
                case 2: // mil
                case 3: // micron
                    return m_fExtraPadSetArea * m_fMMToUnitValueArea;
                default:
                    return 0;
            }
        }

        /// <summary>
        /// Get extra pad total min area settings
        /// </summary>
        /// <param name="intValueType">0=Pixel, 1=mm, 2=mil, 3=um</param>
        /// <returns></returns>
        public float GetTotalExtraPadMinArea(int intValueType)
        {
            switch (intValueType)
            {
                case 0: // Pixel
                    return m_fTotalExtraPadSetArea * m_fMMtoPixelAreaValue;
                case 1: // mm
                case 2: // mil
                case 3: // micron
                    return m_fTotalExtraPadSetArea * m_fMMToUnitValueArea;
                default:
                    return 0;
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="fValue"></param>
        /// <param name="intFromValueType">0=Pixel, 1=mm, 2=mil, 3=um</param>
        public void SetExtraPadMinArea(float fValue, int intFromValueType)
        {
            switch (intFromValueType)
            {
                case 0: // Pixel
                    m_fExtraPadSetArea = fValue / m_fMMtoPixelAreaValue;
                    break;
                case 1: // mm
                case 2: // mil
                case 3: // micron
                default:
                    m_fExtraPadSetArea = fValue / m_fMMToUnitValueArea;
                    break;
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="fValue"></param>
        /// <param name="intFromValueType">0=Pixel, 1=mm, 2=mil, 3=um</param>
        public void SetTotalExtraPadMinArea(float fValue, int intFromValueType)
        {
            switch (intFromValueType)
            {
                case 0: // Pixel
                    m_fTotalExtraPadSetArea = fValue / m_fMMtoPixelAreaValue;
                    break;
                case 1: // mm
                case 2: // mil
                case 3: // micron
                default:
                    m_fTotalExtraPadSetArea = fValue / m_fMMToUnitValueArea;
                    break;
            }
        }

        /// <summary>
        /// Get excess pad min area settings
        /// </summary>
        /// <param name="intValueType">0=Pixel, 1=mm, 2=mil, 3=um</param>
        /// <returns></returns>
        public float GetExcessPadMinArea(int intValueType)
        {
            switch (intValueType)
            {
                case 0: // Pixel
                    return m_fExcessPadSetArea * m_fMMtoPixelAreaValue;
                case 1: // mm
                case 2: // mil
                case 3: // micron
                    return m_fExcessPadSetArea * m_fMMToUnitValueArea;
                default:
                    return 0;
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="fValue"></param>
        /// <param name="intFromValueType">0=Pixel, 1=mm, 2=mil, 3=um</param>
        public void SetExcessPadMinArea(float fValue, int intFromValueType)
        {
            switch (intFromValueType)
            {
                case 0: // Pixel
                    m_fExcessPadSetArea = fValue / m_fMMtoPixelAreaValue;
                    break;
                case 1: // mm
                case 2: // mil
                case 3: // micron
                default:
                    m_fExcessPadSetArea = fValue / m_fMMToUnitValueArea;
                    break;
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="intValueType">0=Pixel, 1=mm, 2=mil, 3=um</param>
        /// <returns></returns>
        public float GetUnitWidthMin(int intValueType)
        {
            switch (intValueType)
            {
                case 0: // Pixel
                    return m_fUnitWidthMin * m_fMMToPixelXValue;
                case 1: // mm
                case 2: // mil
                case 3: // micron
                    return m_fUnitWidthMin * m_fMMToUnitValue;
                default:
                    return 0;
            }
        }
        /// <summary>
        /// 
        /// </summary>
        /// <param name="fValue"></param>
        /// <param name="intFromValueType">0=Pixel, 1=mm, 2=mil, 3=um</param>
        public void SetUnitWidthMin(float fValue, int intFromValueType)
        {
            switch (intFromValueType)
            {
                case 0: // Pixel
                    m_fUnitWidthMin = fValue / m_fMMToPixelXValue;
                    break;
                case 1: // mm
                case 2: // mil
                case 3: // micron
                default:
                    m_fUnitWidthMin = fValue / m_fMMToUnitValue;
                    break;
            }
        }
        /// <summary>
        /// 
        /// </summary>
        /// <param name="intValueType">0=Pixel, 1=mm, 2=mil, 3=um</param>
        /// <returns></returns>
        public float GetUnitWidthMax(int intValueType)
        {
            switch (intValueType)
            {
                case 0: // Pixel
                    return m_fUnitWidthMax * m_fMMToPixelXValue;
                case 1: // mm
                case 2: // mil
                case 3: // micron
                    return m_fUnitWidthMax * m_fMMToUnitValue;
                default:
                    return 0;
            }
        }
        /// <summary>
        /// 
        /// </summary>
        /// <param name="fValue"></param>
        /// <param name="intFromValueType">0=Pixel, 1=mm, 2=mil, 3=um</param>
        public void SetUnitWidthMax(float fValue, int intFromValueType)
        {
            switch (intFromValueType)
            {
                case 0: // Pixel
                    m_fUnitWidthMax = fValue / m_fMMToPixelXValue;
                    break;
                case 1: // mm
                case 2: // mil
                case 3: // micron
                default:
                    m_fUnitWidthMax = fValue / m_fMMToUnitValue;
                    break;
            }
        }
        /// <summary>
        /// 
        /// </summary>
        /// <param name="intValueType">0=Pixel, 1=mm, 2=mil, 3=um</param>
        /// <returns></returns>
        public float GetUnitHeightMin(int intValueType)
        {
            switch (intValueType)
            {
                case 0: // Pixel
                    return m_fUnitHeightMin * m_fMMToPixelYValue;
                case 1: // mm
                case 2: // mil
                case 3: // micron
                    return m_fUnitHeightMin * m_fMMToUnitValue;
                default:
                    return 0;
            }
        }
        /// <summary>
        /// 
        /// </summary>
        /// <param name="fValue"></param>
        /// <param name="intFromValueType">0=Pixel, 1=mm, 2=mil, 3=um</param>
        public void SetUnitHeightMin(float fValue, int intFromValueType)
        {
            switch (intFromValueType)
            {
                case 0: // Pixel
                    m_fUnitHeightMin = fValue / m_fMMToPixelYValue;
                    break;
                case 1: // mm
                case 2: // mil
                case 3: // micron
                default:
                    m_fUnitHeightMin = fValue / m_fMMToUnitValue;
                    break;
            }
        }
        /// <summary>
        /// 
        /// </summary>
        /// <param name="intValueType">0=Pixel, 1=mm, 2=mil, 3=um</param>
        /// <returns></returns>
        public float GetUnitHeightMax(int intValueType)
        {
            switch (intValueType)
            {
                case 0: // Pixel
                    return m_fUnitHeightMax * m_fMMToPixelYValue;
                case 1: // mm
                case 2: // mil
                case 3: // micron
                    return m_fUnitHeightMax * m_fMMToUnitValue;
                default:
                    return 0;
            }
        }
        /// <summary>
        /// 
        /// </summary>
        /// <param name="fValue"></param>
        /// <param name="intFromValueType">0=Pixel, 1=mm, 2=mil, 3=um</param>
        public void SetUnitHeightMax(float fValue, int intFromValueType)
        {
            switch (intFromValueType)
            {
                case 0: // Pixel
                    m_fUnitHeightMax = fValue / m_fMMToPixelYValue;
                    break;
                case 1: // mm
                case 2: // mil
                case 3: // micron
                default:
                    m_fUnitHeightMax = fValue / m_fMMToUnitValue;
                    break;
            }
        }
        /// <summary>
        /// 
        /// </summary>
        /// <param name="intValueType">0=Pixel, 1=mm, 2=mil, 3=um</param>
        /// <returns></returns>
        public float GetUnitThicknessMin(int intValueType)
        {
            switch (intValueType)
            {
                case 0: // Pixel
                    return m_fUnitThicknessMin * m_fMMToPixelYValue;
                case 1: // mm
                case 2: // mil
                case 3: // micron
                    return m_fUnitThicknessMin * m_fMMToUnitValue;
                default:
                    return 0;
            }
        }
        /// <summary>
        /// 
        /// </summary>
        /// <param name="fValue"></param>
        /// <param name="intFromValueType">0=Pixel, 1=mm, 2=mil, 3=um</param>
        public void SetUnitThicknessMin(float fValue, int intFromValueType)
        {
            switch (intFromValueType)
            {
                case 0: // Pixel
                    m_fUnitThicknessMin = fValue / m_fMMToPixelYValue;
                    break;
                case 1: // mm
                case 2: // mil
                case 3: // micron
                default:
                    m_fUnitThicknessMin = fValue / m_fMMToUnitValue;
                    break;
            }
        }
        /// <summary>
        /// 
        /// </summary>
        /// <param name="intValueType">0=Pixel, 1=mm, 2=mil, 3=um</param>
        /// <returns></returns>
        public float GetUnitThicknessMax(int intValueType)
        {
            switch (intValueType)
            {
                case 0: // Pixel
                    return m_fUnitThicknessMax * m_fMMToPixelYValue;
                case 1: // mm
                case 2: // mil
                case 3: // micron
                    return m_fUnitThicknessMax * m_fMMToUnitValue;
                default:
                    return 0;
            }
        }
        /// <summary>
        /// 
        /// </summary>
        /// <param name="fValue"></param>
        /// <param name="intFromValueType">0=Pixel, 1=mm, 2=mil, 3=um</param>
        public void SetUnitThicknessMax(float fValue, int intFromValueType)
        {
            switch (intFromValueType)
            {
                case 0: // Pixel
                    m_fUnitThicknessMax = fValue / m_fMMToPixelYValue;
                    break;
                case 1: // mm
                case 2: // mil
                case 3: // micron
                default:
                    m_fUnitThicknessMax = fValue / m_fMMToUnitValue;
                    break;
            }
        }
        /// <summary>
        /// 
        /// </summary>
        /// <param name="intValueType">-1=pixel X, -2=pixel Y, 0=Pixel(not available), 1=mm, 2=mil, 3=um</param>
        /// <returns></returns>
        public float GetChipStartPixelFromEdge(int intValueType)
        {
            switch (intValueType)
            {
                case -1: // Pixel X
                    return m_fChipStartPixelFromEdge * m_fMMToPixelXValue;
                case -2: // Pixel Y
                    return m_fChipStartPixelFromEdge * m_fMMToPixelYValue;
                case 1: // mm
                case 2: // mil
                case 3: // micron
                    return m_fChipStartPixelFromEdge * m_fMMToUnitValue;
                default:
                    return 0;
            }
        }
        
        /// <summary>
        /// 
        /// </summary>
        /// <param name="fValue"></param>
        /// <param name="intFromValueType">0=Pixel(not available), 1=mm, 2=mil, 3=um</param>
        public void SetChipStartPixelFromEdge(float fValue, int intFromValueType)
        {
            switch (intFromValueType)
            {
                //Note* fValue should not be converted to pixel unless the m_fMMToPixelXValue == m_fMMToPixelYValue
                //case -1: // Pixel X
                //    m_fChipStartPixelFromEdge = fValue / m_fMMToPixelXValue;
                //    break;
                //case -2: // Pixel Y
                //    m_fChipStartPixelFromEdge = fValue / m_fMMToPixelYValue;
                //    break;
                case 1: // mm
                case 2: // mil
                case 3: // micron
                default:
                    m_fChipStartPixelFromEdge = fValue / m_fMMToUnitValue;
                    break;
            }
        }
       
        /// <summary>
        /// 
        /// </summary>
        /// <param name="intValueType">-1=pixel X, -2=pixel Y, 0=Pixel(not available), 1=mm, 2=mil, 3=um</param>
        /// <returns></returns>
        public float GetPkgStartPixelFromEdge(int intValueType)
        {
            switch (intValueType)
            {
                case -1: // Pixel X
                    return m_fPkgStartPixelFromEdge * m_fMMToPixelXValue;
                case -2: // Pixel Y
                    return m_fPkgStartPixelFromEdge * m_fMMToPixelYValue;
                case 1: // mm
                case 2: // mil
                case 3: // micron
                    return m_fPkgStartPixelFromEdge * m_fMMToUnitValue;
                default:
                    return 0;
            }
        }
        public float GetPkgStartPixelFromRight(int intValueType)
        {
            switch (intValueType)
            {
                case -1: // Pixel X
                    return m_fPkgStartPixelFromRight * m_fMMToPixelXValue;
                case -2: // Pixel Y
                    return m_fPkgStartPixelFromRight * m_fMMToPixelYValue;
                case 1: // mm
                case 2: // mil
                case 3: // micron
                    return m_fPkgStartPixelFromRight * m_fMMToUnitValue;
                default:
                    return 0;
            }
        }
        public float GetPkgStartPixelFromBottom(int intValueType)
        {
            switch (intValueType)
            {
                case -1: // Pixel X
                    return m_fPkgStartPixelFromBottom * m_fMMToPixelXValue;
                case -2: // Pixel Y
                    return m_fPkgStartPixelFromBottom * m_fMMToPixelYValue;
                case 1: // mm
                case 2: // mil
                case 3: // micron
                    return m_fPkgStartPixelFromBottom * m_fMMToUnitValue;
                default:
                    return 0;
            }
        }
        public float GetPkgStartPixelFromLeft(int intValueType)
        {
            switch (intValueType)
            {
                case -1: // Pixel X
                    return m_fPkgStartPixelFromLeft * m_fMMToPixelXValue;
                case -2: // Pixel Y
                    return m_fPkgStartPixelFromLeft * m_fMMToPixelYValue;
                case 1: // mm
                case 2: // mil
                case 3: // micron
                    return m_fPkgStartPixelFromLeft * m_fMMToUnitValue;
                default:
                    return 0;
            }
        }
        /// <summary>
        /// 
        /// </summary>
        /// <param name="fValue"></param>
        /// <param name="intFromValueType">0=Pixel(not available), 1=mm, 2=mil, 3=um</param>
        public void SetPkgStartPixelFromEdge(float fValue, int intFromValueType)
        {
            switch (intFromValueType)
            {
                //Note* fValue should not be converted to pixel unless the m_fMMToPixelXValue == m_fMMToPixelYValue
                //case -1: // Pixel X
                //    m_fPkgStartPixelFromEdge = fValue / m_fMMToPixelXValue;
                //    break;
                //case -2: // Pixel Y
                //    m_fPkgStartPixelFromEdge = fValue / m_fMMToPixelYValue;
                //    break;
                case 1: // mm
                case 2: // mil
                case 3: // micron
                default:
                    m_fPkgStartPixelFromEdge = fValue / m_fMMToUnitValue;
                    break;
            }
        }

        public void SetPkgStartPixelFromRight(float fValue, int intFromValueType)
        {
            switch (intFromValueType)
            {
                //Note* fValue should not be converted to pixel unless the m_fMMToPixelXValue == m_fMMToPixelYValue
                //case -1: // Pixel X
                //    m_fPkgStartPixelFromEdge = fValue / m_fMMToPixelXValue;
                //    break;
                //case -2: // Pixel Y
                //    m_fPkgStartPixelFromEdge = fValue / m_fMMToPixelYValue;
                //    break;
                case 1: // mm
                case 2: // mil
                case 3: // micron
                default:
                    m_fPkgStartPixelFromRight = fValue / m_fMMToUnitValue;
                    break;
            }
        }
        public void SetPkgStartPixelFromBottom(float fValue, int intFromValueType)
        {
            switch (intFromValueType)
            {
                //Note* fValue should not be converted to pixel unless the m_fMMToPixelXValue == m_fMMToPixelYValue
                //case -1: // Pixel X
                //    m_fPkgStartPixelFromEdge = fValue / m_fMMToPixelXValue;
                //    break;
                //case -2: // Pixel Y
                //    m_fPkgStartPixelFromEdge = fValue / m_fMMToPixelYValue;
                //    break;
                case 1: // mm
                case 2: // mil
                case 3: // micron
                default:
                    m_fPkgStartPixelFromBottom = fValue / m_fMMToUnitValue;
                    break;
            }
        }
        public void SetPkgStartPixelFromLeft(float fValue, int intFromValueType)
        {
            switch (intFromValueType)
            {
                //Note* fValue should not be converted to pixel unless the m_fMMToPixelXValue == m_fMMToPixelYValue
                //case -1: // Pixel X
                //    m_fPkgStartPixelFromEdge = fValue / m_fMMToPixelXValue;
                //    break;
                //case -2: // Pixel Y
                //    m_fPkgStartPixelFromEdge = fValue / m_fMMToPixelYValue;
                //    break;
                case 1: // mm
                case 2: // mil
                case 3: // micron
                default:
                    m_fPkgStartPixelFromLeft = fValue / m_fMMToUnitValue;
                    break;
            }
        }
        /// <summary>
        /// 
        /// </summary>
        /// <param name="intValueType">-1=pixel X, -2=pixel Y, 0=Pixel(not available), 1=mm, 2=mil, 3=um</param>
        /// <returns></returns>
        public float GetScratchLengthLimit(int intValueType)
        {
            switch (intValueType)
            {
                case -1: // Pixel X
                    return m_fScratchLength * m_fMMToPixelXValue;
                case -2: // Pixel Y
                    return m_fScratchLength * m_fMMToPixelYValue;
                case 1: // mm
                case 2: // mil
                case 3: // micron
                    return m_fScratchLength * m_fMMToUnitValue;
                default:
                    return 0;
            }
        }

        public float GetLengthLimit(int intValueType)
        {
            switch (intValueType)
            {
                case -1: // Pixel X
                    return m_fScratchLength * m_fMMToPixelXValue;
                case -2: // Pixel Y
                    return m_fScratchLength * m_fMMToPixelYValue;
                case 1: // mm
                case 2: // mil
                case 3: // micron
                    return m_fScratchLength * m_fMMToUnitValue;
                default:
                    return 0;
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="intValueType">-1=pixel X, -2=pixel Y, 0=Pixel(not available), 1=mm, 2=mil, 3=um</param>
        /// <returns></returns>
        public float GetScratchAreaLimit(int intValueType)
        {
            switch (intValueType)
            {
                case -1: // Pixel X
                    return m_fScratchArea * m_fMMtoPixelAreaValue;
                case -2: // Pixel Y
                    return m_fScratchArea * m_fMMtoPixelAreaValue;
                case 1: // mm
                case 2: // mil
                case 3: // micron
                    return m_fScratchArea * m_fMMToUnitValueArea;
                default:
                    return 0;
            }
        }
        public float GetChipAreaLimit(int intValueType)
        {
            switch (intValueType)
            {
                case -1: // Pixel X
                    return m_fChipArea * m_fMMtoPixelAreaValue;
                case -2: // Pixel Y
                    return m_fChipArea * m_fMMtoPixelAreaValue;
                case 1: // mm
                case 2: // mil
                case 3: // micron
                    return m_fChipArea * m_fMMToUnitValueArea;
                default:
                    return 0;
            }
        }
        public float GetMoldFlashAreaLimit(int intValueType)
        {
            switch (intValueType)
            {
                case -1: // Pixel X
                    return m_fMoldFlashArea * m_fMMtoPixelAreaValue;
                case -2: // Pixel Y
                    return m_fMoldFlashArea * m_fMMtoPixelAreaValue;
                case 1: // mm
                case 2: // mil
                case 3: // micron
                    return m_fMoldFlashArea * m_fMMToUnitValueArea;
                default:
                    return 0;
            }
        }
        public float GetMoldFlashTotalAreaLimit(int intValueType)
        {
            switch (intValueType)
            {
                case 0: // Pixel
                    return m_fMoldFlashTotalArea * m_fMMtoPixelAreaValue;
                case 1: // mm
                case 2: // mil
                case 3: // micron
                    return m_fMoldFlashTotalArea * m_fMMToUnitValueArea;
                default:
                    return 0;
            }
        }

        public float GetMoldFlashLengthLimit(int intValueType)
        {
            switch (intValueType)
            {
                case -1: // Pixel X
                    return m_fMoldFlashLength * m_fMMToPixelXValue;
                case -2: // Pixel Y
                    return m_fMoldFlashLength * m_fMMToPixelYValue;
                case 1: // mm
                case 2: // mil
                case 3: // micron
                    return m_fMoldFlashLength * m_fMMToUnitValue;
                default:
                    return 0;
            }
        }

        public float GetMoldFlashWidthLimit(int intValueType)
        {
            switch (intValueType)
            {
                case -1: // Pixel X
                    return m_fMoldFlashWidth * m_fMMToPixelXValue;
                case -2: // Pixel Y
                    return m_fMoldFlashWidth * m_fMMToPixelYValue;
                case 1: // mm
                case 2: // mil
                case 3: // micron
                    return m_fMoldFlashWidth * m_fMMToUnitValue;
                default:
                    return 0;
            }
        }
        public float GetVoidLengthLimit(int intValueType)
        {
            switch (intValueType)
            {
                case -1: // Pixel X
                    return m_fVoidLength * m_fMMToPixelXValue;
                case -2: // Pixel Y
                    return m_fVoidLength * m_fMMToPixelYValue;
                case 1: // mm
                case 2: // mil
                case 3: // micron
                    return m_fVoidLength * m_fMMToUnitValue;
                default:
                    return 0;
            }
        }
        public float GetVoidAreaLimit(int intValueType)
        {
            switch (intValueType)
            {
                case -1: // Pixel X
                    return m_fVoidArea * m_fMMtoPixelAreaValue;
                case -2: // Pixel Y
                    return m_fVoidArea * m_fMMtoPixelAreaValue;
                case 1: // mm
                case 2: // mil
                case 3: // micron
                    return m_fVoidArea * m_fMMToUnitValueArea;
                default:
                    return 0;
            }
        }
        public float GetCrackLengthLimit(int intValueType)
        {
            switch (intValueType)
            {
                case -1: // Pixel X
                    return m_fCrackLength * m_fMMToPixelXValue;
                case -2: // Pixel Y
                    return m_fCrackLength * m_fMMToPixelYValue;
                case 1: // mm
                case 2: // mil
                case 3: // micron
                    return m_fCrackLength * m_fMMToUnitValue;
                default:
                    return 0;
            }
        }

        public float GetForeignMaterialAreaLimit(int intValueType)
        {
            switch (intValueType)
            {
                case -1: // Pixel X
                    return m_fForeignMaterialArea * m_fMMtoPixelAreaValue;
                case -2: // Pixel Y
                    return m_fForeignMaterialArea * m_fMMtoPixelAreaValue;
                case 1: // mm
                case 2: // mil
                case 3: // micron
                    return m_fForeignMaterialArea * m_fMMToUnitValueArea;
                default:
                    return 0;
            }
        }

        public float GetCrackAreaLimit(int intValueType)
        {
            switch (intValueType)
            {
                case -1: // Pixel X
                    return m_fCrackArea * m_fMMtoPixelAreaValue;
                case -2: // Pixel Y
                    return m_fCrackArea * m_fMMtoPixelAreaValue;
                case 1: // mm
                case 2: // mil
                case 3: // micron
                    return m_fCrackArea * m_fMMToUnitValueArea;
                default:
                    return 0;
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="intValueType">-1=pixel X, -2=pixel Y, 0=Pixel(not available), 1=mm, 2=mil, 3=um</param>
        /// <returns></returns>
        public float GetPadBrokenLengthLimit(int intValueType)
        {
            switch (intValueType)
            {
                case -1: // Pixel X
                    return m_fPadBrokenLength * m_fMMToPixelXValue;
                case -2: // Pixel Y
                    return m_fPadBrokenLength * m_fMMToPixelYValue;
                case 1: // mm
                case 2: // mil
                case 3: // micron
                    return m_fPadBrokenLength * m_fMMToUnitValue;
                default:
                    return 0;
            }
        }

        /// <summary>
        /// Get broken pad min area settings
        /// </summary>
        /// <param name="intValueType">0=Pixel, 1=mm, 2=mil, 3=um</param>
        /// <returns></returns>
        public float GetPadBrokenAreaLimit(int intValueType)
        {
            switch (intValueType)
            {
                case 0: // Pixel
                    return m_fPadBrokenArea * m_fMMtoPixelAreaValue;
                case 1: // mm
                case 2: // mil
                case 3: // micron
                    return m_fPadBrokenArea * m_fMMToUnitValueArea;
                default:
                    return 0;
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="intValueType">-1=pixel X, -2=pixel Y, 0=Pixel(not available), 1=mm, 2=mil, 3=um</param>
        /// <returns></returns>
        public float GetExtraPadLengthLimit(int intValueType)
        {
            switch (intValueType)
            {
                case -1: // Pixel X
                    return m_fExtraPadSetLength * m_fMMToPixelXValue;
                case -2: // Pixel Y
                    return m_fExtraPadSetLength * m_fMMToPixelYValue;
                case 1: // mm
                case 2: // mil
                case 3: // micron
                    return m_fExtraPadSetLength * m_fMMToUnitValue;
                default:
                    return 0;
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="intValueType">-1=pixel X, -2=pixel Y, 0=Pixel(not available), 1=mm, 2=mil, 3=um</param>
        /// <returns></returns>
        public float GetExcessPadLengthLimit(int intValueType)
        {
            switch (intValueType)
            {
                case -1: // Pixel X
                    return m_fExcessPadSetLength * m_fMMToPixelXValue;
                case -2: // Pixel Y
                    return m_fExcessPadSetLength * m_fMMToPixelYValue;
                case 1: // mm
                case 2: // mil
                case 3: // micron
                    return m_fExcessPadSetLength * m_fMMToUnitValue;
                default:
                    return 0;
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="intValueType">0=Pixel, 1=mm, 2=mil, 3=um</param>
        /// <returns></returns>
        public float GetPosToleranceX(int intValueType)
        {
            switch (intValueType)
            {
                case 0: // Pixel
                    return m_fPosToleranceX * m_fMMToPixelXValue;
                case 1: // mm
                case 2: // mil
                case 3: // micron
                    return m_fPosToleranceX * m_fMMToUnitValue;
                default:
                    return 0;
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="intValueType">0=Pixel, 1=mm, 2=mil, 3=um</param>
        /// <returns></returns>
        public float GetPosToleranceY(int intValueType)
        {
            switch (intValueType)
            {
                case 0: // Pixel
                    return m_fPosToleranceY * m_fMMToPixelYValue;
                case 1: // mm
                case 2: // mil
                case 3: // micron
                    return m_fPosToleranceY * m_fMMToUnitValue;
                default:
                    return 0;
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="fValue"></param>
        /// <param name="intFromValueType">0=Pixel(not available), 1=mm, 2=mil, 3=um</param>
        public void SetPosToleranceX(float fValue, int intFromValueType)
        {
            switch (intFromValueType)
            {
                case 0: // Pixel
                    m_fPosToleranceX = fValue / m_fMMToPixelXValue;
                    break;
                case 1: // mm
                case 2: // mil
                case 3: // micron
                default:
                    m_fPosToleranceX = fValue / m_fMMToUnitValue;
                    break;
            }
        }
        /// <summary>
        /// 
        /// </summary>
        /// <param name="fValue"></param>
        /// <param name="intFromValueType">0=Pixel(not available), 1=mm, 2=mil, 3=um</param>
        public void SetPosToleranceY(float fValue, int intFromValueType)
        {
            switch (intFromValueType)
            {
                case 0: // Pixel
                    m_fPosToleranceY = fValue / m_fMMToPixelYValue;
                    break;
                case 1: // mm
                case 2: // mil
                case 3: // micron
                default:
                    m_fPosToleranceY = fValue / m_fMMToUnitValue;
                    break;
            }
        }
        /// <summary>
        /// 
        /// </summary>
        /// <param name="fValue"></param>
        /// <param name="intFromValueType">0=Pixel(not available), 1=mm, 2=mil, 3=um</param>
        public void SetScratchLengthLimit(float fValue, int intFromValueType)
        {
            switch (intFromValueType)
            {
                //Note* fValue should not be converted to pixel unless the m_fMMToPixelXValue == m_fMMToPixelYValue
                //case 0: // Pixel X
                //    m_fScratchLength = fValue / m_fMMToPixelXValue;
                //    break;
                //case 1: // Pixel Y
                //    m_fScratchLength = fValue / m_fMMToPixelYValue;
                //    break;
                case 1: // mm
                case 2: // mil
                case 3: // micron
                default:
                    m_fScratchLength = fValue / m_fMMToUnitValue;
                    break;
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="fValue"></param>
        /// <param name="intFromValueType">0=Pixel(not available), 1=mm, 2=mil, 3=um</param>
        public void SetScratchAreaLimit(float fValue, int intFromValueType)
        {
            switch (intFromValueType)
            {
                //Note* fValue should not be converted to pixel unless the m_fMMToPixelXValue == m_fMMToPixelYValue
                //case 0: // Pixel X
                //    m_fScratchLength = fValue / m_fMMToPixelXValue;
                //    break;
                //case 1: // Pixel Y
                //    m_fScratchLength = fValue / m_fMMToPixelYValue;
                //    break;
                case 1: // mm
                case 2: // mil
                case 3: // micron
                default:
                    m_fScratchArea = fValue / m_fMMToUnitValueArea;
                    break;
            }
        }

        public void SetChipAreaLimit(float fValue, int intFromValueType)
        {
            switch (intFromValueType)
            {
                //Note* fValue should not be converted to pixel unless the m_fMMToPixelXValue == m_fMMToPixelYValue
                //case 0: // Pixel X
                //    m_fScratchLength = fValue / m_fMMToPixelXValue;
                //    break;
                //case 1: // Pixel Y
                //    m_fScratchLength = fValue / m_fMMToPixelYValue;
                //    break;
                case 1: // mm
                case 2: // mil
                case 3: // micron
                default:
                    m_fChipArea = fValue / m_fMMToUnitValueArea;
                    break;
            }
        }
        public void SetMoldFlashAreaLimit(float fValue, int intFromValueType)
        {
            switch (intFromValueType)
            {
                //Note* fValue should not be converted to pixel unless the m_fMMToPixelXValue == m_fMMToPixelYValue
                //case 0: // Pixel X
                //    m_fScratchLength = fValue / m_fMMToPixelXValue;
                //    break;
                //case 1: // Pixel Y
                //    m_fScratchLength = fValue / m_fMMToPixelYValue;
                //    break;
                case 1: // mm
                case 2: // mil
                case 3: // micron
                default:
                    m_fMoldFlashArea = fValue / m_fMMToUnitValueArea;
                    break;
            }
        }
        public void SetMoldFlashTotalAreaLimit(float fValue, int intFromValueType)
        {
            switch (intFromValueType)
            {
                //Note* fValue should not be converted to pixel unless the m_fMMToPixelXValue == m_fMMToPixelYValue
                //case 0: // Pixel X
                //    m_fScratchLength = fValue / m_fMMToPixelXValue;
                //    break;
                //case 1: // Pixel Y
                //    m_fScratchLength = fValue / m_fMMToPixelYValue;
                //    break;
                case 1: // mm
                case 2: // mil
                case 3: // micron
                default:
                    m_fMoldFlashTotalArea = fValue / m_fMMToUnitValueArea;
                    break;
            }
        }
        public void SetMoldFlashLengthLimit(float fValue, int intFromValueType)
        {
            switch (intFromValueType)
            {
                //Note* fValue should not be converted to pixel unless the m_fMMToPixelXValue == m_fMMToPixelYValue
                //case 0: // Pixel X
                //    m_fScratchLength = fValue / m_fMMToPixelXValue;
                //    break;
                //case 1: // Pixel Y
                //    m_fScratchLength = fValue / m_fMMToPixelYValue;
                //    break;
                case 1: // mm
                case 2: // mil
                case 3: // micron
                default:
                    m_fMoldFlashLength = fValue / m_fMMToUnitValue;
                    break;
            }
        }

        public void SetMoldFlashWidthLimit(float fValue, int intFromValueType)
        {
            switch (intFromValueType)
            {
                //Note* fValue should not be converted to pixel unless the m_fMMToPixelXValue == m_fMMToPixelYValue
                //case 0: // Pixel X
                //    m_fScratchLength = fValue / m_fMMToPixelXValue;
                //    break;
                //case 1: // Pixel Y
                //    m_fScratchLength = fValue / m_fMMToPixelYValue;
                //    break;
                case 1: // mm
                case 2: // mil
                case 3: // micron
                default:
                    m_fMoldFlashWidth = fValue / m_fMMToUnitValue;
                    break;
            }
        }

        public void SetVoidLengthLimit(float fValue, int intFromValueType)
        {
            switch (intFromValueType)
            {
                //Note* fValue should not be converted to pixel unless the m_fMMToPixelXValue == m_fMMToPixelYValue
                //case 0: // Pixel X
                //    m_fScratchLength = fValue / m_fMMToPixelXValue;
                //    break;
                //case 1: // Pixel Y
                //    m_fScratchLength = fValue / m_fMMToPixelYValue;
                //    break;
                case 1: // mm
                case 2: // mil
                case 3: // micron
                default:
                    m_fVoidLength = fValue / m_fMMToUnitValue;
                    break;
            }
        }
        public void SetVoidAreaLimit(float fValue, int intFromValueType)
        {
            switch (intFromValueType)
            {
                //Note* fValue should not be converted to pixel unless the m_fMMToPixelXValue == m_fMMToPixelYValue
                //case 0: // Pixel X
                //    m_fScratchLength = fValue / m_fMMToPixelXValue;
                //    break;
                //case 1: // Pixel Y
                //    m_fScratchLength = fValue / m_fMMToPixelYValue;
                //    break;
                case 1: // mm
                case 2: // mil
                case 3: // micron
                default:
                    m_fVoidArea = fValue / m_fMMToUnitValueArea;
                    break;
            }
        }

        public void SetForeignMaterialAreaLimit(float fValue, int intFromValueType)
        {
            switch (intFromValueType)
            {
                //Note* fValue should not be converted to pixel unless the m_fMMToPixelXValue == m_fMMToPixelYValue
                //case 0: // Pixel X
                //    m_fScratchLength = fValue / m_fMMToPixelXValue;
                //    break;
                //case 1: // Pixel Y
                //    m_fScratchLength = fValue / m_fMMToPixelYValue;
                //    break;
                case 1: // mm
                case 2: // mil
                case 3: // micron
                default:
                    m_fForeignMaterialArea = fValue / m_fMMToUnitValueArea;
                    break;
            }
        }

        public void SetCrackLengthLimit(float fValue, int intFromValueType)
        {
            switch (intFromValueType)
            {
                //Note* fValue should not be converted to pixel unless the m_fMMToPixelXValue == m_fMMToPixelYValue
                //case 0: // Pixel X
                //    m_fScratchLength = fValue / m_fMMToPixelXValue;
                //    break;
                //case 1: // Pixel Y
                //    m_fScratchLength = fValue / m_fMMToPixelYValue;
                //    break;
                case 1: // mm
                case 2: // mil
                case 3: // micron
                default:
                    m_fCrackLength = fValue / m_fMMToUnitValue;
                    break;
            }
        }
        public void SetCrackAreaLimit(float fValue, int intFromValueType)
        {
            switch (intFromValueType)
            {
                //Note* fValue should not be converted to pixel unless the m_fMMToPixelXValue == m_fMMToPixelYValue
                //case 0: // Pixel X
                //    m_fScratchLength = fValue / m_fMMToPixelXValue;
                //    break;
                //case 1: // Pixel Y
                //    m_fScratchLength = fValue / m_fMMToPixelYValue;
                //    break;
                case 1: // mm
                case 2: // mil
                case 3: // micron
                default:
                    m_fCrackArea = fValue / m_fMMToUnitValueArea;
                    break;
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="fValue"></param>
        /// <param name="intFromValueType">0=Pixel(not available), 1=mm, 2=mil, 3=um</param>
        public void SetPadBrokenLengthLimit(float fValue, int intFromValueType)
        {
            switch (intFromValueType)
            {
                //Note* fValue should not be converted to pixel unless the m_fMMToPixelXValue == m_fMMToPixelYValue
                //case 0: // Pixel X
                //    m_fPadBrokenLength = fValue / m_fMMToPixelXValue;
                //    break;
                //case 1: // Pixel Y
                //    m_fPadBrokenLength = fValue / m_fMMToPixelYValue;
                //    break;
                case 1: // mm
                case 2: // mil
                case 3: // micron
                default:
                    m_fPadBrokenLength = fValue / m_fMMToUnitValue;
                    break;
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="fValue"></param>
        /// <param name="intFromValueType">0=Pixel, 1=mm, 2=mil, 3=um</param>
        public void SetPadBrokenAreaLimit(float fValue, int intFromValueType)
        {
            switch (intFromValueType)
            {
                case 0: // Pixel
                    m_fPadBrokenArea = fValue / m_fMMtoPixelAreaValue;
                    break;
                case 1: // mm
                case 2: // mil
                case 3: // micron
                default:
                    m_fPadBrokenArea = fValue / m_fMMToUnitValueArea;
                    break;
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="fValue"></param>
        /// <param name="intFromValueType">0=Pixel(not available), 1=mm, 2=mil, 3=um</param>
        public void SetExtraPadLengthLimit(float fValue, int intFromValueType)
        {
            switch (intFromValueType)
            {
                //Note* fValue should not be converted to pixel unless the m_fMMToPixelXValue == m_fMMToPixelYValue
                //case 0: // Pixel X
                //    m_fExtraPadSetLength = fValue / m_fMMToPixelXValue;
                //    break;
                //case 1: // Pixel Y
                //    m_fExtraPadSetLength = fValue / m_fMMToPixelYValue;
                //    break;
                case 1: // mm
                case 2: // mil
                case 3: // micron
                default:
                    m_fExtraPadSetLength = fValue / m_fMMToUnitValue;
                    break;
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="fValue"></param>
        /// <param name="intFromValueType">0=Pixel(not available), 1=mm, 2=mil, 3=um</param>
        public void SetExcessPadLengthLimit(float fValue, int intFromValueType)
        {
            switch (intFromValueType)
            {
                //Note* fValue should not be converted to pixel unless the m_fMMToPixelXValue == m_fMMToPixelYValue
                //case 0: // Pixel X
                //    m_fExcessPadSetLength = fValue / m_fMMToPixelXValue;
                //    break;
                //case 1: // Pixel Y
                //    m_fExcessPadSetLength = fValue / m_fMMToPixelYValue;
                //    break;
                case 1: // mm
                case 2: // mil
                case 3: // micron
                default:
                    m_fExcessPadSetLength = fValue / m_fMMToUnitValue;
                    break;
            }
        }

        /// <summary>
        /// Get min area settings
        /// </summary>
        /// <returns>min area in mm^2</returns>
        public float GetMinimumArea()
        {
            return ((float)m_fFilterMinArea * m_fAreaMMPerPixel * m_fAreaMMPerPixel);
        }

        /// <summary>
        /// Get pad range width
        /// </summary>
        /// <returns>pad range width in mm</returns>
        public float GetRealPadRangWidth()
        {
            return (m_fPadRangeEndX - m_fPadRangeStartX) * m_fAreaMMPerPixel;
        }

        /// <summary>
        /// Get pad range height
        /// </summary>
        /// <returns>pad range height in mm</returns>
        public float GetRealPadRangHeight()
        {
            return (m_fPadRangeEndY - m_fPadRangeStartY) * m_fAreaMMPerPixel;
        }

        /// <summary>
        /// Get pad smear length settings
        /// </summary>
        /// <return>smear length in mm</returns>
        public float GetSmearLength()
        {
            return ((float)m_fSmearLength * m_fAreaMMPerPixel);
        }

        /// <summary>
        /// Get blobs features count
        /// </summary>
        /// <returns></returns>
        public int GetBlobsFeaturesNumber()
        {
            return m_arrTemplateBlobPads.Count;
        }

        /// <summary>
        /// Get the pitch gap drawing point
        /// </summary>
        /// <param name="intStartLine1">start line 1</param>
        /// <param name="intEndLine1">end line 1</param>
        /// <param name="intStartLine2">start line 2</param>
        /// <param name="intEndLine2">end line 2</param>
        /// <returns>pitch gap drawing point</returns>
        public int GetDrawPoint(int intStartLine1, int intEndLine1, int intStartLine2, int intEndLine2)
        {
            int intStartPoint;
            int intEndPoint;

            if (intStartLine1 > intStartLine2)
                intStartPoint = intStartLine1;
            else
                intStartPoint = intStartLine2;

            if (intEndLine1 < intEndLine2)
                intEndPoint = intEndLine1;
            else
                intEndPoint = intEndLine2;

            return intStartPoint + (int)Math.Abs((intStartPoint - intEndPoint) / 2);
        }

        /// <summary>
        /// Get blobs features length mode
        /// </summary>
        /// <param name="intIndex">blob index</param>
        /// <returns>length mode, 1: Length = Height, 2: Length = Width</returns>
        public int GetSampleLengthMode(int intIndex)
        {
            if (intIndex >= m_arrTemplateBlobPads.Count)
                return 1;

            return ((BlobsFeatures)m_arrTemplateBlobPads[intIndex]).intLengthMode;
        }

        /// <summary>
        /// Check which sample object is selected
        /// </summary>
        /// <param name="intOrgX">mouse position X</param>
        /// <param name="intOrgY">mouse position Y</param>
        /// <returns>-1 = unable to match any object, other = selected blob index</returns>
        public int SelectOrientFailSampleObject(int intOrgX, int intOrgY)
        {
            int intMatchNo = -1;

            if (m_arrTemplateBlobPads != null)
            {
                for (int i = 0; i < m_arrTemplateBlobPads.Count; i++)
                {
                    if ((intOrgX >= ((BlobsFeatures)m_arrTemplateBlobPads[i]).fStartX) && (intOrgX <= ((BlobsFeatures)m_arrTemplateBlobPads[i]).fEndX) &&
                        (intOrgY >= ((BlobsFeatures)m_arrTemplateBlobPads[i]).fStartY) && (intOrgY <= ((BlobsFeatures)m_arrTemplateBlobPads[i]).fEndY))
                        intMatchNo = i;
                }
            }

            return intMatchNo;
        }

        /// <summary>
        /// Check which sample object is selected
        /// </summary>
        /// <param name="intOrgX">mouse position X</param>
        /// <param name="intOrgY">mouse position Y</param>
        /// <returns>-1 = unable to match any object, other = selected blob index</returns>
        public int SelectSampleObject(int intOrgX, int intOrgY)
        {
            int intMatchNo = -1;

            if (m_arrSampleBlobPads != null)
            {
                for (int i = 0; i < m_arrSampleBlobPads.Length; i++)
                {
                    if ((intOrgX >= m_arrSampleBlobPads[i].fStartX) && (intOrgX <= m_arrSampleBlobPads[i].fEndX) &&
                        (intOrgY >= m_arrSampleBlobPads[i].fStartY) && (intOrgY <= m_arrSampleBlobPads[i].fEndY))
                        intMatchNo = i;
                }
            }

            return intMatchNo;
        }

        /// <summary>
        /// Check which pad defect object is selected
        /// </summary>
        /// <param name="intOrgX">mouse position X</param>
        /// <param name="intOrgY">mouse position Y</param>
        /// <returns>-1 = unable to match any object, other = selected pkg defect index</returns>
        public int SelectPadDefectObject(int intOrgX, int intOrgY)
        {
            int intMatchNo = -1;

            if (m_arrExtraBlobs != null)
            {
                for (int i = 0; i < m_arrExtraBlobs.Count; i++)
                {
                    if ((intOrgX >= m_arrExtraBlobs[i].fStartX) && (intOrgX <= m_arrExtraBlobs[i].fEndX) &&
                        (intOrgY >= m_arrExtraBlobs[i].fStartY) && (intOrgY <= m_arrExtraBlobs[i].fEndY))
                        intMatchNo = i;
                }
            }

            return intMatchNo;
        }

        /// <summary>
        /// Check which pad defect object is selected
        /// </summary>
        /// <param name="intOrgX">mouse position X</param>
        /// <param name="intOrgY">mouse position Y</param>
        /// <returns>-1 = unable to match any object, other = selected pkg defect index</returns>
        public int SelectBrokenPadDefectObject(int intOrgX, int intOrgY)
        {
            int intMatchNo = -1;

            if (m_arrPadDefectList != null)
            {
                for (int i = 0; i < m_arrPadDefectList.Count; i++)
                {
                    if ((intOrgX >= m_arrPadDefectList[i].ref_fStartX && intOrgX <= m_arrPadDefectList[i].ref_fEndX &&
                        (intOrgY >= m_arrPadDefectList[i].ref_fStartY && intOrgY <= (m_arrPadDefectList[i].ref_fEndY))))
                        intMatchNo = i;
                }
            }

            return intMatchNo;
        }

        /// <summary>
        /// Check which pkg defect object is selected
        /// </summary>
        /// <param name="intOrgX">mouse position X</param>
        /// <param name="intOrgY">mouse position Y</param>
        /// <returns>-1 = unable to match any object, other = selected pkg defect index</returns>
        public int SelectPkgDefectObject(int intOrgX, int intOrgY)
        {
            int intMatchNo = -1;

            if (m_arrPkgDefectList != null)
            {
                for (int i = 0; i < m_arrPkgDefectList.Count; i++)
                {
                    if ((intOrgX >= m_arrPkgDefectList[i].ref_fStartX && intOrgX <= m_arrPkgDefectList[i].ref_fEndX &&
                        (intOrgY >= m_arrPkgDefectList[i].ref_fStartY && intOrgY <= (m_arrPkgDefectList[i].ref_fEndY))))
                        intMatchNo = i;
                }
            }

            return intMatchNo;
        }
        public int SelectColorDefectObject(int intOrgX, int intOrgY)
        {
            int intMatchNo = -1;

            if (m_arrColorDefectList != null)
            {
                for (int i = 0; i < m_arrColorDefectList.Count; i++)
                {
                    if ((intOrgX >= m_arrColorDefectList[i].ref_fStartX && intOrgX <= m_arrColorDefectList[i].ref_fEndX &&
                        (intOrgY >= m_arrColorDefectList[i].ref_fStartY && intOrgY <= (m_arrColorDefectList[i].ref_fEndY))))
                        intMatchNo = i;
                }
            }

            return intMatchNo;
        }
        /// <summary>
        /// Get threshold value of particular ROI using specific threshold mode
        /// </summary>
        /// <param name="objROI">ROI</param>
        /// <param name="intThresholdMode">threshold mode, 0 = absolute, 1 = isodata, 3 = max entropy, 4 = min residue, 5 = relative</param>
        /// <returns>threshold value</returns>
        public int GetAutoThresholdValue(ROI objROI, int intThresholdMode)
        {
            EBW8 objBW8;
            if (intThresholdMode == 0)
                objBW8 = EasyImage.AutoThreshold(objROI.ref_ROI, EThresholdMode.Absolute);
            else if (intThresholdMode == 1)
                objBW8 = EasyImage.AutoThreshold(objROI.ref_ROI, EThresholdMode.Isodata);
            else if (intThresholdMode == 2)
                objBW8 = EasyImage.AutoThreshold(objROI.ref_ROI, EThresholdMode.MaxEntropy);
            else if (intThresholdMode == 3)
                objBW8 = EasyImage.AutoThreshold(objROI.ref_ROI, EThresholdMode.MinResidue);
            else
                objBW8 = EasyImage.AutoThreshold(objROI.ref_ROI, EThresholdMode.Relative);

            return objBW8.Value;
        }

        /// <summary>
        /// Get total selected object
        /// </summary>
        /// <returns>selected object count</returns>
        public int GetSelectedObjectNumber()
        {
            int intObjectCount = 0;
            for (int i = 0; i < m_arrTemplateBlobPads.Count; i++)
            {
                if (((BlobsFeatures)m_arrTemplateBlobPads[i]).blnSelected)
                    intObjectCount++;
            }
            return intObjectCount;
        }

        /// <summary>
        /// Get total pitch gap
        /// </summary>
        /// <returns>total pitch gap</returns>
        public int GetTotalPitchGap()
        {
            return m_arrPitchGap.Count;
        }

        public int GetGroupNo(int intPadIndex)
        {
            if (intPadIndex >= m_arrTemplateBlobPads.Count)
                return 0;

            return ((BlobsFeatures)m_arrTemplateBlobPads[intPadIndex]).intGroupID;
        }

        /// <summary>
        /// Get hit pad no by match with each blobs features
        /// </summary>
        /// <param name="intX">mouse position X</param>
        /// <param name="intY">mouse position Y</param>
        /// <returns>hit pad no</returns>
        public int HitPadNumber(int intX, int intY, ref int startX, ref int startY, int intRoiOrgX, int intRoiOrgY,
          ref int width, ref int height, ref int LineCount,
          ref float fFeretWidth, ref float FeretHeight, ref int FeretStartX, ref int FeretStartY, ref float FeretAngle,
          ref int MaxX, ref int MaxY, ref int MinX, ref int MinY, ref int intLengthMode, ref float fAmgle)
        {
            int intSelectedPadNo = -1;
            float fMinArea = float.MaxValue;
            for (int i = 0; i < m_arrTemplateBlobPads.Count; i++)
            {
                BlobsFeatures m_stcBlobPad = (BlobsFeatures)m_arrTemplateBlobPads[i];

                if ((intX >= m_stcBlobPad.intStartX) &&
                    (intX <= m_stcBlobPad.intEndX) &&
                    (intY >= m_stcBlobPad.intStartY) &&
                    (intY <= m_stcBlobPad.intEndY))
                {
                    if (m_stcBlobPad.fArea < fMinArea)
                    {

                        System.Drawing.Point p1 = new System.Drawing.Point(intRoiOrgX + (int)Math.Round(m_stcBlobPad.fLimitCenterX - m_stcBlobPad.fWidth / 2), intRoiOrgY + (int)Math.Round(m_stcBlobPad.fLimitCenterY - m_stcBlobPad.fHeight / 2));
                        System.Drawing.Point p2 = new System.Drawing.Point(intRoiOrgX + (int)Math.Round(m_stcBlobPad.fLimitCenterX + m_stcBlobPad.fWidth / 2), intRoiOrgY + (int)Math.Round(m_stcBlobPad.fLimitCenterY - m_stcBlobPad.fHeight / 2));
                        System.Drawing.Point p3 = new System.Drawing.Point(intRoiOrgX + (int)Math.Round(m_stcBlobPad.fLimitCenterX + m_stcBlobPad.fWidth / 2), intRoiOrgY + (int)Math.Round(m_stcBlobPad.fLimitCenterY + m_stcBlobPad.fHeight / 2));
                        System.Drawing.Point p4 = new System.Drawing.Point(intRoiOrgX + (int)Math.Round(m_stcBlobPad.fLimitCenterX - m_stcBlobPad.fWidth / 2), intRoiOrgY + (int)Math.Round(m_stcBlobPad.fLimitCenterY + m_stcBlobPad.fHeight / 2));

                        p1 = new System.Drawing.Point(intRoiOrgX + (int)Math.Round(m_stcBlobPad.fFeretCenterX - m_stcBlobPad.fFeretWidth / 2), intRoiOrgY + (int)Math.Round(m_stcBlobPad.fFeretCenterY - m_stcBlobPad.fFeretHeight / 2));
                        p2 = new System.Drawing.Point(intRoiOrgX + (int)Math.Round(m_stcBlobPad.fFeretCenterX + m_stcBlobPad.fFeretWidth / 2), intRoiOrgY + (int)Math.Round(m_stcBlobPad.fFeretCenterY - m_stcBlobPad.fFeretHeight / 2));
                        p3 = new System.Drawing.Point(intRoiOrgX + (int)Math.Round(m_stcBlobPad.fFeretCenterX + m_stcBlobPad.fFeretWidth / 2), intRoiOrgY + (int)Math.Round(m_stcBlobPad.fFeretCenterY + m_stcBlobPad.fFeretHeight / 2));
                        p4 = new System.Drawing.Point(intRoiOrgX + (int)Math.Round(m_stcBlobPad.fFeretCenterX - m_stcBlobPad.fFeretWidth / 2), intRoiOrgY + (int)Math.Round(m_stcBlobPad.fFeretCenterY + m_stcBlobPad.fFeretHeight / 2));


                        float newX1 = 0, newY1 = 0;  // new point 1 = p1
                        float newX2 = 0, newY2 = 0; // new point 2 = p4
                        float newX3 = 0, newY3 = 0; // new point 3  = p2
                        float newX4 = 0, newY4 = 0; // new point 4 = p3


                        float Angle = m_stcBlobPad.fFeretAngle;


                        Math2.NewXYAfterRotate1(intRoiOrgX + m_stcBlobPad.fFeretCenterX, intRoiOrgY + m_stcBlobPad.fFeretCenterY, (float)p1.X, (float)p1.Y, Angle, ref newX1, ref newY1);
                        Math2.NewXYAfterRotate2(intRoiOrgX + m_stcBlobPad.fFeretCenterX, intRoiOrgY + m_stcBlobPad.fFeretCenterY, (float)p4.X, (float)p4.Y, Angle, ref newX4, ref newY4);
                        Math2.NewXYAfterRotate3(intRoiOrgX + m_stcBlobPad.fFeretCenterX, intRoiOrgY + m_stcBlobPad.fFeretCenterY, (float)p2.X, (float)p2.Y, Angle, ref newX2, ref newY2);
                        Math2.NewXYAfterRotate4(intRoiOrgX + m_stcBlobPad.fFeretCenterX, intRoiOrgY + m_stcBlobPad.fFeretCenterY, (float)p3.X, (float)p3.Y, Angle, ref newX3, ref newY3);
                        p1.X = (int)newX1;
                        p1.Y = (int)newY1;
                        p2.X = (int)newX2;
                        p2.Y = (int)newY2;
                        p3.X = (int)newX3;
                        p3.Y = (int)newY3;
                        p4.X = (int)newX4;
                        p4.Y = (int)newY4;


                        FeretStartX = p1.X;
                        FeretStartY = p1.Y;
                        ////
                        System.Drawing.Point pStart = new System.Drawing.Point(intRoiOrgX + (int)Math.Round(m_stcBlobPad.fLimitCenterX - m_stcBlobPad.fWidth / 2), intRoiOrgY + (int)Math.Round(m_stcBlobPad.fLimitCenterY - m_stcBlobPad.fHeight / 2));
                        System.Drawing.Point pEnd = new System.Drawing.Point(intRoiOrgX + (int)Math.Round(m_stcBlobPad.fLimitCenterX + m_stcBlobPad.fWidth / 2), intRoiOrgY + (int)Math.Round(m_stcBlobPad.fLimitCenterY + m_stcBlobPad.fHeight / 2));
                        startX = pStart.X;//m_stcBlobPad.intStartX;
                        startY = pStart.Y;//m_stcBlobPad.intStartY;
                        width = (int)(pEnd.X - pStart.X);//Math.Round(m_stcBlobPad.fWidth) ;
                        height = (int)(pEnd.Y - pStart.Y);//Math.Round(m_stcBlobPad.fHeight);
                        intSelectedPadNo = i;
                        intLengthMode = m_stcBlobPad.intLengthMode;
                        fMinArea = m_stcBlobPad.fArea;
                        LineCount = m_stcBlobPad.intLineCount;
                        fFeretWidth = m_stcBlobPad.fFeretWidth;
                        FeretHeight = m_stcBlobPad.fFeretHeight;
                        FeretAngle = Angle;
                        fAmgle = m_stcBlobPad.fAngle;

                        if (p1.X > p2.X && p1.X > p3.X && p1.X > p4.X)
                            MaxX = p1.X;
                        else if (p2.X > p1.X && p2.X > p3.X && p2.X > p4.X)
                            MaxX = p2.X;
                        else if (p3.X > p1.X && p3.X > p2.X && p3.X > p4.X)
                            MaxX = p3.X;
                        else
                            MaxX = p4.X;

                        if (p1.Y > p2.Y && p1.Y > p3.Y && p1.Y > p4.Y)
                            MaxY = p1.Y;
                        else if (p2.Y > p1.Y && p2.Y > p3.Y && p2.Y > p4.Y)
                            MaxY = p2.Y;
                        else if (p3.Y > p1.Y && p3.Y > p2.Y && p3.Y > p4.Y)
                            MaxY = p3.Y;
                        else
                            MaxY = p4.Y;

                        if (p1.X < p2.X && p1.X < p3.X && p1.X < p4.X)
                            MinX = p1.X;
                        else if (p2.X < p1.X && p2.X < p3.X && p2.X < p4.X)
                            MinX = p2.X;
                        else if (p3.X < p1.X && p3.X < p2.X && p3.X < p4.X)
                            MinX = p3.X;
                        else
                            MinX = p4.X;

                        if (p1.Y < p2.Y && p1.Y < p3.Y && p1.Y < p4.Y)
                            MinY = p1.Y;
                        else if (p2.Y < p1.Y && p2.Y < p3.Y && p2.Y < p4.Y)
                            MinY = p2.Y;
                        else if (p3.Y < p1.Y && p3.Y < p2.Y && p3.Y < p4.Y)
                            MinY = p3.Y;
                        else
                            MinY = p4.Y;

                        MaxX = Math.Max(MaxX, pEnd.X);
                        MaxY = Math.Max(MaxY, pEnd.Y);
                        MinX = Math.Min(MinX, pStart.X);
                        MinY = Math.Min(MinY, pStart.Y);
                    }
                }
            }

            return intSelectedPadNo;
        }

        /// <summary>
        /// Get all data store in blobs features 
        /// </summary>
        /// <returns>blobs features data in string</returns>
        public string GetBlobsFeaturesAllData()
        {
            string strBlobsFeatures = "";

            for (int i = 0; i < m_arrTemplateBlobPads.Count; i++)
            {
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobPads[i]).intNoID.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobPads[i]).intGroupID.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobPads[i]).fArea.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobPads[i]).intLengthMode.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobPads[i]).intContourX.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobPads[i]).intContourY.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobPads[i]).intStartX.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobPads[i]).intStartY.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobPads[i]).intEndX.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobPads[i]).intEndY.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobPads[i]).fStartX.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobPads[i]).fStartY.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobPads[i]).fEndX.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobPads[i]).fEndY.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobPads[i]).intDirection.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobPads[i]).intSide.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobPads[i]).intSmearSide.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobPads[i]).fCenterX.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobPads[i]).fCenterY.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobPads[i]).fLimitCenterX.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobPads[i]).fLimitCenterY.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobPads[i]).fWidth.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobPads[i]).fHeight.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobPads[i]).fWidthPercentStart1.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobPads[i]).fHeightPercentStart1.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobPads[i]).fWidthPercentEnd1.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobPads[i]).fHeightPercentEnd1.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobPads[i]).fWidthPercentStart2.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobPads[i]).fHeightPercentStart2.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobPads[i]).fWidthPercentEnd2.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobPads[i]).fHeightPercentEnd2.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobPads[i]).fWidthPercentStart3.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobPads[i]).fHeightPercentStart3.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobPads[i]).fWidthPercentEnd3.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobPads[i]).fHeightPercentEnd3.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobPads[i]).fWidthPercentStart4.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobPads[i]).fHeightPercentStart4.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobPads[i]).fWidthPercentEnd4.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobPads[i]).fHeightPercentEnd4.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobPads[i]).fWidthPercentStart5.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobPads[i]).fHeightPercentStart5.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobPads[i]).fWidthPercentEnd5.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobPads[i]).fHeightPercentEnd5.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobPads[i]).fWidthPercentStart6.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobPads[i]).fHeightPercentStart6.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobPads[i]).fWidthPercentEnd6.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobPads[i]).fHeightPercentEnd6.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobPads[i]).fWidthPercentStart7.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobPads[i]).fHeightPercentStart7.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobPads[i]).fWidthPercentEnd7.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobPads[i]).fHeightPercentEnd7.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobPads[i]).fWidthPercentStart8.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobPads[i]).fHeightPercentStart8.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobPads[i]).fWidthPercentEnd8.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobPads[i]).fHeightPercentEnd8.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobPads[i]).fWidthPercentStart9.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobPads[i]).fHeightPercentStart9.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobPads[i]).fWidthPercentEnd9.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobPads[i]).fHeightPercentEnd9.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobPads[i]).fWidthPercentStart10.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobPads[i]).fHeightPercentStart10.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobPads[i]).fWidthPercentEnd10.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobPads[i]).fHeightPercentEnd10.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobPads[i]).fWidthPercentStart11.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobPads[i]).fHeightPercentStart11.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobPads[i]).fWidthPercentEnd11.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobPads[i]).fHeightPercentEnd11.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobPads[i]).fWidthPercentStart12.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobPads[i]).fHeightPercentStart12.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobPads[i]).fWidthPercentEnd12.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobPads[i]).fHeightPercentEnd12.ToString() + "#";

                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobPads[i]).fInwardPercentStart1.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobPads[i]).fInwardPercentEnd1.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobPads[i]).fInwardPercentStart2.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobPads[i]).fInwardPercentEnd2.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobPads[i]).fInwardPercentStart3.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobPads[i]).fInwardPercentEnd3.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobPads[i]).fInwardPercentStart4.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobPads[i]).fInwardPercentEnd4.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobPads[i]).fInwardPercentStart5.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobPads[i]).fInwardPercentEnd5.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobPads[i]).fInwardPercentStart6.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobPads[i]).fInwardPercentEnd6.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobPads[i]).fInwardPercentStart7.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobPads[i]).fInwardPercentEnd7.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobPads[i]).fInwardPercentStart8.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobPads[i]).fInwardPercentEnd8.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobPads[i]).fInwardPercentStart9.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobPads[i]).fInwardPercentEnd9.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobPads[i]).fInwardPercentStart10.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobPads[i]).fInwardPercentEnd10.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobPads[i]).fInwardPercentStart11.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobPads[i]).fInwardPercentEnd11.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobPads[i]).fInwardPercentStart12.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobPads[i]).fInwardPercentEnd12.ToString() + "#";

                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobPads[i]).intMeasureMethod1.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobPads[i]).intMeasureMethod2.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobPads[i]).intMeasureMethod3.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobPads[i]).intMeasureMethod4.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobPads[i]).intMeasureMethod5.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobPads[i]).intMeasureMethod6.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobPads[i]).intMeasureMethod7.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobPads[i]).intMeasureMethod8.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobPads[i]).intMeasureMethod9.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobPads[i]).intMeasureMethod10.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobPads[i]).intMeasureMethod11.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobPads[i]).intMeasureMethod12.ToString() + "#";

                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobPads[i]).fAngle.ToString() + "#";

                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobPads[i]).intLineCount.ToString() + "#";

                SetMaxExtraLineCount(((BlobsFeatures)m_arrTemplateBlobPads[i]).intLineCount);

                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobPads[i]).fFeretWidth.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobPads[i]).fFeretHeight.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobPads[i]).fFeretCenterX.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobPads[i]).fFeretCenterY.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobPads[i]).fFeretAngle.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobPads[i]).intFeretLengthMode.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobPads[i]).blnFeretActivated.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobPads[i]).P1X.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobPads[i]).P1Y.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobPads[i]).P2X.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobPads[i]).P2Y.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobPads[i]).P3X.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobPads[i]).P3Y.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobPads[i]).P4X.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobPads[i]).P4Y.ToString() + "#";

                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobPads[i]).blnSelected.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobPads[i]).blnEnable.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobPads[i]).fLeftDistance.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobPads[i]).fRightDistance.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobPads[i]).fTopDistance.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobPads[i]).fBottomDistance.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobPads[i]).fXDistance.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobPads[i]).fYDistance.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobPads[i]).fTemplateROICenterX.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobPads[i]).fTemplateROICenterY.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobPads[i]).fTemplateROITopLeftCornerX.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobPads[i]).fTemplateROITopLeftCornerY.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobPads[i]).fXDistance_Pattern.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobPads[i]).fYDistance_Pattern.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobPads[i]).fTemplateROICenterX_Pattern.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobPads[i]).fTemplateROICenterY_Pattern.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobPads[i]).fTemplateROITopLeftCornerX_Pattern.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobPads[i]).fTemplateROITopLeftCornerY_Pattern.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobPads[i]).fPitch.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobPads[i]).fGap.ToString() + "#";

                strBlobsFeatures += (((BlobsFeatures)m_arrTemplateBlobPads[i]).fOffSet).ToString("F4") + "#";
                strBlobsFeatures += (((BlobsFeatures)m_arrTemplateBlobPads[i]).fMinArea).ToString("F6") + "#";
                strBlobsFeatures += (((BlobsFeatures)m_arrTemplateBlobPads[i]).fMaxArea).ToString("F6") + "#";
                strBlobsFeatures += (((BlobsFeatures)m_arrTemplateBlobPads[i]).fMinWidth).ToString("F4") + "#";
                strBlobsFeatures += (((BlobsFeatures)m_arrTemplateBlobPads[i]).fMaxWidth).ToString("F4") + "#";
                strBlobsFeatures += (((BlobsFeatures)m_arrTemplateBlobPads[i]).fMinLength).ToString("F4") + "#";
                strBlobsFeatures += (((BlobsFeatures)m_arrTemplateBlobPads[i]).fMaxLength).ToString("F4") + "#";
                strBlobsFeatures += (((BlobsFeatures)m_arrTemplateBlobPads[i]).fMinPitch).ToString("F4") + "#";
                strBlobsFeatures += (((BlobsFeatures)m_arrTemplateBlobPads[i]).fMaxPitch).ToString("F4") + "#";
                strBlobsFeatures += (((BlobsFeatures)m_arrTemplateBlobPads[i]).fMinGap).ToString("F4") + "#";
                strBlobsFeatures += (((BlobsFeatures)m_arrTemplateBlobPads[i]).fMaxGap).ToString("F4") + "#";
                strBlobsFeatures += (((BlobsFeatures)m_arrTemplateBlobPads[i]).fMaxBroken).ToString("F6") + "#";
                strBlobsFeatures += (((BlobsFeatures)m_arrTemplateBlobPads[i]).fMaxBrokenLength).ToString("F4") + "#";
                strBlobsFeatures += (((BlobsFeatures)m_arrTemplateBlobPads[i]).fMaxExcess).ToString("F6") + "#";
                strBlobsFeatures += (((BlobsFeatures)m_arrTemplateBlobPads[i]).fMaxSmearLength).ToString("F4") + "#";

                strBlobsFeatures += (((BlobsFeatures)m_arrTemplateBlobPads[i]).fEdgeLimitTop).ToString("F4") + "#";
                strBlobsFeatures += (((BlobsFeatures)m_arrTemplateBlobPads[i]).fEdgeLimitRight).ToString("F4") + "#";
                strBlobsFeatures += (((BlobsFeatures)m_arrTemplateBlobPads[i]).fEdgeLimitBottom).ToString("F4") + "#";
                strBlobsFeatures += (((BlobsFeatures)m_arrTemplateBlobPads[i]).fEdgeLimitLeft).ToString("F4") + "#";

                strBlobsFeatures += (((BlobsFeatures)m_arrTemplateBlobPads[i]).fMaxStandOffTop).ToString("F4") + "#";
                strBlobsFeatures += (((BlobsFeatures)m_arrTemplateBlobPads[i]).fMaxStandOffBottom).ToString("F4") + "#";
                strBlobsFeatures += (((BlobsFeatures)m_arrTemplateBlobPads[i]).fMaxStandOffLeft).ToString("F4") + "#";
                strBlobsFeatures += (((BlobsFeatures)m_arrTemplateBlobPads[i]).fMaxStandOffRight).ToString("F4") + "#";
                
                strBlobsFeatures += (((BlobsFeatures)m_arrTemplateBlobPads[i]).fOffsetOffSet).ToString("F4") + "#";
                strBlobsFeatures += (((BlobsFeatures)m_arrTemplateBlobPads[i]).fWidthOffset).ToString("F4") + "#";
                strBlobsFeatures += (((BlobsFeatures)m_arrTemplateBlobPads[i]).fHeightOffset).ToString("F4") + "#";
                strBlobsFeatures += (((BlobsFeatures)m_arrTemplateBlobPads[i]).fPitchOffset).ToString("F4") + "#";
                strBlobsFeatures += (((BlobsFeatures)m_arrTemplateBlobPads[i]).fGapOffset).ToString("F4") + "#";

                strBlobsFeatures += (((BlobsFeatures)m_arrTemplateBlobPads[i]).fEdgeDistanceTopOffset).ToString("F4") + "#";
                strBlobsFeatures += (((BlobsFeatures)m_arrTemplateBlobPads[i]).fEdgeDistanceRightOffset).ToString("F4") + "#";
                strBlobsFeatures += (((BlobsFeatures)m_arrTemplateBlobPads[i]).fEdgeDistanceBottomOffset).ToString("F4") + "#";
                strBlobsFeatures += (((BlobsFeatures)m_arrTemplateBlobPads[i]).fEdgeDistanceLeftOffset).ToString("F4") + "#";
                strBlobsFeatures += (((BlobsFeatures)m_arrTemplateBlobPads[i]).fEdgeLimitTopOffset).ToString("F4") + "#";
                strBlobsFeatures += (((BlobsFeatures)m_arrTemplateBlobPads[i]).fEdgeLimitRightOffset).ToString("F4") + "#";
                strBlobsFeatures += (((BlobsFeatures)m_arrTemplateBlobPads[i]).fEdgeLimitBottomOffset).ToString("F4") + "#";
                strBlobsFeatures += (((BlobsFeatures)m_arrTemplateBlobPads[i]).fEdgeLimitLeftOffset).ToString("F4") + "#";
                strBlobsFeatures += (((BlobsFeatures)m_arrTemplateBlobPads[i]).fStandOffTopOffset).ToString("F4") + "#";
                strBlobsFeatures += (((BlobsFeatures)m_arrTemplateBlobPads[i]).fStandOffBottomOffset).ToString("F4") + "#";
                strBlobsFeatures += (((BlobsFeatures)m_arrTemplateBlobPads[i]).fStandOffLeftOffset).ToString("F4") + "#";
                strBlobsFeatures += (((BlobsFeatures)m_arrTemplateBlobPads[i]).fStandOffRightOffset).ToString("F4") + "#";

                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobPads[i]).fMinLine3.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobPads[i]).fMaxLine3.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobPads[i]).fMinLine4.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobPads[i]).fMaxLine4.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobPads[i]).fMinLine5.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobPads[i]).fMaxLine5.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobPads[i]).fMinLine6.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobPads[i]).fMaxLine6.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobPads[i]).fMinLine7.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobPads[i]).fMaxLine7.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobPads[i]).fMinLine8.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobPads[i]).fMaxLine8.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobPads[i]).fMinLine9.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobPads[i]).fMaxLine9.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobPads[i]).fMinLine10.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobPads[i]).fMaxLine10.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobPads[i]).fMinLine11.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobPads[i]).fMaxLine11.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobPads[i]).fMinLine12.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobPads[i]).fMaxLine12.ToString() + "#";

                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobPads[i]).fPadInspectionAreaFromTop.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobPads[i]).fPadInspectionAreaFromRight.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobPads[i]).fPadInspectionAreaFromBottom.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobPads[i]).fPadInspectionAreaFromLeft.ToString() + "#";

                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobPads[i]).intReferTopBottom.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobPads[i]).blnCheckTop.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobPads[i]).blnCheckBottom.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobPads[i]).intReferLeftRight.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobPads[i]).blnCheckLeft.ToString() + "#";
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobPads[i]).blnCheckRight.ToString() + "#";
            }
            return strBlobsFeatures;
        }

        /// <summary>
        /// Get all inspection data store in blobs features 
        /// </summary>
        /// <param name="intTemplateIndex">template index</param>
        /// <returns>blobs features inspection data in string</returns>
        public string GetBlobFeaturesInspectRealData(int intTemplateIndex)
        {
            string strBlobsFeatures = "";
            float fData;

            fData = ((BlobsFeatures)m_arrTemplateBlobPads[intTemplateIndex]).fOffSet * m_fMMToUnitValue;
            strBlobsFeatures += fData.ToString("F" + m_intDecimal) + "#";
            fData = ((BlobsFeatures)m_arrTemplateBlobPads[intTemplateIndex]).fMinArea * m_fMMToUnitValueArea;
            strBlobsFeatures += fData.ToString("F" + m_intDecimal2) + "#";
            fData = ((BlobsFeatures)m_arrTemplateBlobPads[intTemplateIndex]).fMaxArea * m_fMMToUnitValueArea;
            strBlobsFeatures += fData.ToString("F" + m_intDecimal2) + "#";

            if (((BlobsFeatures)m_arrTemplateBlobPads[intTemplateIndex]).intLengthMode == 2)
            {
                fData = ((BlobsFeatures)m_arrTemplateBlobPads[intTemplateIndex]).fMinLength * m_fMMToUnitValue;
                strBlobsFeatures += fData.ToString("F" + m_intDecimal) + "#";
                fData = ((BlobsFeatures)m_arrTemplateBlobPads[intTemplateIndex]).fMaxLength * m_fMMToUnitValue;
                strBlobsFeatures += fData.ToString("F" + m_intDecimal) + "#";
                fData = ((BlobsFeatures)m_arrTemplateBlobPads[intTemplateIndex]).fMinWidth * m_fMMToUnitValue;
                strBlobsFeatures += fData.ToString("F" + m_intDecimal) + "#";
                fData = ((BlobsFeatures)m_arrTemplateBlobPads[intTemplateIndex]).fMaxWidth * m_fMMToUnitValue;
                strBlobsFeatures += fData.ToString("F" + m_intDecimal) + "#";
            }
            else
            {
                fData = ((BlobsFeatures)m_arrTemplateBlobPads[intTemplateIndex]).fMinWidth * m_fMMToUnitValue;
                strBlobsFeatures += fData.ToString("F" + m_intDecimal) + "#";
                fData = ((BlobsFeatures)m_arrTemplateBlobPads[intTemplateIndex]).fMaxWidth * m_fMMToUnitValue;
                strBlobsFeatures += fData.ToString("F" + m_intDecimal) + "#";
                fData = ((BlobsFeatures)m_arrTemplateBlobPads[intTemplateIndex]).fMinLength * m_fMMToUnitValue;
                strBlobsFeatures += fData.ToString("F" + m_intDecimal) + "#";
                fData = ((BlobsFeatures)m_arrTemplateBlobPads[intTemplateIndex]).fMaxLength * m_fMMToUnitValue;
                strBlobsFeatures += fData.ToString("F" + m_intDecimal) + "#";
            }

            float fMinP, fMaxP, fMinG, fMaxG;
            fMinP = fMaxP = fMinG = fMaxG = 0.0f;

            if (GetPitchGapMinMax(intTemplateIndex, ref fMinP, ref fMaxP, ref fMinG, ref fMaxG))
            {
                fData = fMinP * m_fMMToUnitValue;
                strBlobsFeatures += fData.ToString("F" + m_intDecimal) + "#";

                fData = fMaxP * m_fMMToUnitValue;
                strBlobsFeatures += fData.ToString("F" + m_intDecimal) + "#";

                fData = fMinG * m_fMMToUnitValue;
                strBlobsFeatures += fData.ToString("F" + m_intDecimal) + "#";

                fData = fMaxG * m_fMMToUnitValue;
                strBlobsFeatures += fData.ToString("F" + m_intDecimal) + "#";
            }
            else
            {
                for (int j = 0; j < 4; j++)
                {
                    fData = -1;
                    strBlobsFeatures += fData.ToString("F" + m_intDecimal) + "#";
                }
            }

            //fData = ((BlobsFeatures)m_arrTemplateBlobPads[intTemplateIndex]).fMaxBroken * m_fMMToUnitValueArea;
            //strBlobsFeatures += fData.ToString("F" + m_intDecimal2) + "#";

            return strBlobsFeatures;
        }

        /// <summary>
        /// Get all inspection data store in blobs features 
        /// </summary>
        /// <returns>blobs features inspection data in string</returns>
        public string GetBlobsFeaturesInspectRealData()
        {
            string strBlobsFeatures = "";
            float fData;
            for (int i = 0; i < m_arrTemplateBlobPads.Count; i++)
            {
                fData = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fOffSet * m_fMMToUnitValue;
                strBlobsFeatures += fData.ToString("F" + m_intDecimal) + "#";
                fData = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fMinArea * m_fMMToUnitValueArea;
                strBlobsFeatures += fData.ToString("F" + m_intDecimal2) + "#";
                fData = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fMaxArea * m_fMMToUnitValueArea;
                strBlobsFeatures += fData.ToString("F" + m_intDecimal2) + "#";

                if (((BlobsFeatures)m_arrTemplateBlobPads[i]).intLengthMode == 2)
                {
                    fData = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fMinLength * m_fMMToUnitValue;
                    strBlobsFeatures += fData.ToString("F" + m_intDecimal) + "#";
                    fData = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fMaxLength * m_fMMToUnitValue;
                    strBlobsFeatures += fData.ToString("F" + m_intDecimal) + "#";
                    fData = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fMinWidth * m_fMMToUnitValue;
                    strBlobsFeatures += fData.ToString("F" + m_intDecimal) + "#";
                    fData = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fMaxWidth * m_fMMToUnitValue;
                    strBlobsFeatures += fData.ToString("F" + m_intDecimal) + "#";
                }
                else
                {
                    fData = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fMinWidth * m_fMMToUnitValue;
                    strBlobsFeatures += fData.ToString("F" + m_intDecimal) + "#";
                    fData = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fMaxWidth * m_fMMToUnitValue;
                    strBlobsFeatures += fData.ToString("F" + m_intDecimal) + "#";
                    fData = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fMinLength * m_fMMToUnitValue;
                    strBlobsFeatures += fData.ToString("F" + m_intDecimal) + "#";
                    fData = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fMaxLength * m_fMMToUnitValue;
                    strBlobsFeatures += fData.ToString("F" + m_intDecimal) + "#";
                }

                float fMinP, fMaxP, fMinG, fMaxG;
                fMinP = fMaxP = fMinG = fMaxG = 0.0f;

                if (GetPitchGapMinMax(i, ref fMinP, ref fMaxP, ref fMinG, ref fMaxG))
                {
                    fData = fMinP * m_fMMToUnitValue;
                    strBlobsFeatures += fData.ToString("F" + m_intDecimal) + "#";

                    fData = fMaxP * m_fMMToUnitValue;
                    strBlobsFeatures += fData.ToString("F" + m_intDecimal) + "#";

                    fData = fMinG * m_fMMToUnitValue;
                    strBlobsFeatures += fData.ToString("F" + m_intDecimal) + "#";

                    fData = fMaxG * m_fMMToUnitValue;
                    strBlobsFeatures += fData.ToString("F" + m_intDecimal) + "#";
                }
                else
                {
                    for (int j = 0; j < 4; j++)
                    {
                        fData = -1;
                        strBlobsFeatures += fData.ToString("F" + m_intDecimal) + "#";
                    }
                }

                fData = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fMaxBroken * m_fMMToUnitValueArea;
                strBlobsFeatures += fData.ToString("F" + m_intDecimal2) + "#";

                fData = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fMaxBrokenLength * m_fMMToUnitValue;
                strBlobsFeatures += fData.ToString("F" + m_intDecimal) + "#";

                fData = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fMaxExcess * m_fMMToUnitValueArea;
                strBlobsFeatures += fData.ToString("F" + m_intDecimal2) + "#";

                fData = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fMaxSmearLength * m_fMMToUnitValue;
                strBlobsFeatures += fData.ToString("F" + m_intDecimal) + "#";

                //Edge Limit
                fData = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fEdgeLimitTop * m_fMMToUnitValue;
                strBlobsFeatures += fData.ToString("F" + m_intDecimal) + "#";
                fData = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fEdgeLimitRight * m_fMMToUnitValue;
                strBlobsFeatures += fData.ToString("F" + m_intDecimal) + "#";
                fData = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fEdgeLimitBottom * m_fMMToUnitValue;
                strBlobsFeatures += fData.ToString("F" + m_intDecimal) + "#";
                fData = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fEdgeLimitLeft * m_fMMToUnitValue;
                strBlobsFeatures += fData.ToString("F" + m_intDecimal) + "#";

                //Max Stand Off
                fData = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fMaxStandOffTop * m_fMMToUnitValue;
                strBlobsFeatures += fData.ToString("F" + m_intDecimal) + "#";
                fData = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fMaxStandOffBottom * m_fMMToUnitValue;
                strBlobsFeatures += fData.ToString("F" + m_intDecimal) + "#";
                fData = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fMaxStandOffLeft * m_fMMToUnitValue;
                strBlobsFeatures += fData.ToString("F" + m_intDecimal) + "#";
                fData = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fMaxStandOffRight * m_fMMToUnitValue;
                strBlobsFeatures += fData.ToString("F" + m_intDecimal) + "#";
                
                fData = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fOffsetOffSet * m_fMMToUnitValue;
                strBlobsFeatures += fData.ToString("F" + m_intDecimal) + "#";
                fData = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fWidthOffset * m_fMMToUnitValue;
                strBlobsFeatures += fData.ToString("F" + m_intDecimal) + "#";
                fData = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fHeightOffset * m_fMMToUnitValue;
                strBlobsFeatures += fData.ToString("F" + m_intDecimal) + "#";
                fData = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fPitchOffset * m_fMMToUnitValue;
                strBlobsFeatures += fData.ToString("F" + m_intDecimal) + "#";
                fData = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fGapOffset * m_fMMToUnitValue;
                strBlobsFeatures += fData.ToString("F" + m_intDecimal) + "#";

                fData = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fEdgeDistanceTopOffset * m_fMMToUnitValue;
                strBlobsFeatures += fData.ToString("F" + m_intDecimal) + "#";
                fData = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fEdgeDistanceRightOffset * m_fMMToUnitValue;
                strBlobsFeatures += fData.ToString("F" + m_intDecimal) + "#";
                fData = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fEdgeDistanceBottomOffset * m_fMMToUnitValue;
                strBlobsFeatures += fData.ToString("F" + m_intDecimal) + "#";
                fData = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fEdgeDistanceLeftOffset * m_fMMToUnitValue;
                strBlobsFeatures += fData.ToString("F" + m_intDecimal) + "#";
                fData = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fEdgeLimitTopOffset * m_fMMToUnitValue;
                strBlobsFeatures += fData.ToString("F" + m_intDecimal) + "#";
                fData = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fEdgeLimitRightOffset * m_fMMToUnitValue;
                strBlobsFeatures += fData.ToString("F" + m_intDecimal) + "#";
                fData = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fEdgeLimitBottomOffset * m_fMMToUnitValue;
                strBlobsFeatures += fData.ToString("F" + m_intDecimal) + "#";
                fData = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fEdgeLimitLeftOffset * m_fMMToUnitValue;
                strBlobsFeatures += fData.ToString("F" + m_intDecimal) + "#";
                fData = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fStandOffTopOffset * m_fMMToUnitValue;
                strBlobsFeatures += fData.ToString("F" + m_intDecimal) + "#";
                fData = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fStandOffBottomOffset * m_fMMToUnitValue;
                strBlobsFeatures += fData.ToString("F" + m_intDecimal) + "#";
                fData = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fStandOffLeftOffset * m_fMMToUnitValue;
                strBlobsFeatures += fData.ToString("F" + m_intDecimal) + "#";
                fData = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fStandOffRightOffset * m_fMMToUnitValue;
                strBlobsFeatures += fData.ToString("F" + m_intDecimal) + "#";

                fData = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fMinLine3 * m_fMMToUnitValueArea;
                strBlobsFeatures += fData.ToString("F" + m_intDecimal) + "#";
                fData = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fMaxLine3 * m_fMMToUnitValueArea;
                strBlobsFeatures += fData.ToString("F" + m_intDecimal) + "#";
                fData = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fMinLine4 * m_fMMToUnitValueArea;
                strBlobsFeatures += fData.ToString("F" + m_intDecimal) + "#";
                fData = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fMaxLine4 * m_fMMToUnitValueArea;
                strBlobsFeatures += fData.ToString("F" + m_intDecimal) + "#";
                fData = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fMinLine5 * m_fMMToUnitValueArea;
                strBlobsFeatures += fData.ToString("F" + m_intDecimal) + "#";
                fData = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fMaxLine5 * m_fMMToUnitValueArea;
                strBlobsFeatures += fData.ToString("F" + m_intDecimal) + "#";
                fData = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fMinLine6 * m_fMMToUnitValueArea;
                strBlobsFeatures += fData.ToString("F" + m_intDecimal) + "#";
                fData = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fMaxLine6 * m_fMMToUnitValueArea;
                strBlobsFeatures += fData.ToString("F" + m_intDecimal) + "#";
                fData = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fMinLine7 * m_fMMToUnitValueArea;
                strBlobsFeatures += fData.ToString("F" + m_intDecimal) + "#";
                fData = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fMaxLine7 * m_fMMToUnitValueArea;
                strBlobsFeatures += fData.ToString("F" + m_intDecimal) + "#";
                fData = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fMinLine8 * m_fMMToUnitValueArea;
                strBlobsFeatures += fData.ToString("F" + m_intDecimal) + "#";
                fData = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fMaxLine8 * m_fMMToUnitValueArea;
                strBlobsFeatures += fData.ToString("F" + m_intDecimal) + "#";
                fData = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fMinLine9 * m_fMMToUnitValueArea;
                strBlobsFeatures += fData.ToString("F" + m_intDecimal) + "#";
                fData = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fMaxLine9 * m_fMMToUnitValueArea;
                strBlobsFeatures += fData.ToString("F" + m_intDecimal) + "#";
                fData = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fMinLine10 * m_fMMToUnitValueArea;
                strBlobsFeatures += fData.ToString("F" + m_intDecimal) + "#";
                fData = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fMaxLine10 * m_fMMToUnitValueArea;
                strBlobsFeatures += fData.ToString("F" + m_intDecimal) + "#";
                fData = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fMinLine11 * m_fMMToUnitValueArea;
                strBlobsFeatures += fData.ToString("F" + m_intDecimal) + "#";
                fData = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fMaxLine11 * m_fMMToUnitValueArea;
                strBlobsFeatures += fData.ToString("F" + m_intDecimal) + "#";
                fData = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fMinLine12 * m_fMMToUnitValueArea;
                strBlobsFeatures += fData.ToString("F" + m_intDecimal) + "#";
                fData = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fMaxLine12 * m_fMMToUnitValueArea;
                strBlobsFeatures += fData.ToString("F" + m_intDecimal) + "#";
            }
            return strBlobsFeatures;
        }
        public List<List<string>> GetBlobsFeaturesStandOff()
        {
            List<List<string>> arrBlobsFeaturesData = new List<List<string>>();
            for (int i = 0; i < m_arrTemplateBlobPads.Count; i++)
            {
                arrBlobsFeaturesData.Add(new List<string>());
                BlobsFeatures m_stcBlobPad = (BlobsFeatures)m_arrTemplateBlobPads[i];

                arrBlobsFeaturesData[i].Add("Pad");
                arrBlobsFeaturesData[i].Add((i).ToString());
                arrBlobsFeaturesData[i].Add((m_stcBlobPad.intReferTopBottom ).ToString());
                arrBlobsFeaturesData[i].Add((m_stcBlobPad.blnCheckTop ).ToString());
                arrBlobsFeaturesData[i].Add((m_stcBlobPad.blnCheckBottom).ToString());
                arrBlobsFeaturesData[i].Add((m_stcBlobPad.intReferLeftRight).ToString());
                arrBlobsFeaturesData[i].Add((m_stcBlobPad.blnCheckLeft).ToString());
                arrBlobsFeaturesData[i].Add((m_stcBlobPad.blnCheckRight).ToString());
            }

            return arrBlobsFeaturesData;
        }
        public List<List<string>> GetPadInspectionAreaValue()
        {
            List<List<string>> arrBlobsFeaturesData = new List<List<string>>();
            for (int i = 0; i < m_arrTemplateBlobPads.Count; i++)
            {
                arrBlobsFeaturesData.Add(new List<string>());
                BlobsFeatures m_stcBlobPad = (BlobsFeatures)m_arrTemplateBlobPads[i];

                arrBlobsFeaturesData[i].Add("Pad");

                arrBlobsFeaturesData[i].Add((i).ToString());

                arrBlobsFeaturesData[i].Add((m_stcBlobPad.fPadInspectionAreaFromTop * m_fMMToUnitValue).ToString("F" + m_intDecimal));

                arrBlobsFeaturesData[i].Add((m_stcBlobPad.fPadInspectionAreaFromRight * m_fMMToUnitValue).ToString("F" + m_intDecimal));

                arrBlobsFeaturesData[i].Add((m_stcBlobPad.fPadInspectionAreaFromBottom * m_fMMToUnitValue).ToString("F" + m_intDecimal));

                arrBlobsFeaturesData[i].Add((m_stcBlobPad.fPadInspectionAreaFromLeft * m_fMMToUnitValue).ToString("F" + m_intDecimal));

            }
            return arrBlobsFeaturesData;
        }
        public List<List<string>> GetPadOffsetSettingValue()
        {
            List<List<string>> arrBlobsFeaturesData = new List<List<string>>();
            for (int i = 0; i < m_arrTemplateBlobPads.Count; i++)
            {
                arrBlobsFeaturesData.Add(new List<string>());
                BlobsFeatures m_stcBlobPad = (BlobsFeatures)m_arrTemplateBlobPads[i];

                arrBlobsFeaturesData[i].Add("Pad");

                arrBlobsFeaturesData[i].Add((i).ToString());

                arrBlobsFeaturesData[i].Add((m_stcBlobPad.fOffsetOffSet * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                
                arrBlobsFeaturesData[i].Add((m_stcBlobPad.fWidthOffset * m_fMMToUnitValue).ToString("F" + m_intDecimal));

                arrBlobsFeaturesData[i].Add((m_stcBlobPad.fHeightOffset * m_fMMToUnitValue).ToString("F" + m_intDecimal));

                arrBlobsFeaturesData[i].Add((m_stcBlobPad.fPitchOffset * m_fMMToUnitValue).ToString("F" + m_intDecimal));

                arrBlobsFeaturesData[i].Add((m_stcBlobPad.fGapOffset * m_fMMToUnitValue).ToString("F" + m_intDecimal));

                arrBlobsFeaturesData[i].Add((m_stcBlobPad.fEdgeDistanceTopOffset * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                arrBlobsFeaturesData[i].Add((m_stcBlobPad.fEdgeDistanceRightOffset * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                arrBlobsFeaturesData[i].Add((m_stcBlobPad.fEdgeDistanceBottomOffset * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                arrBlobsFeaturesData[i].Add((m_stcBlobPad.fEdgeDistanceLeftOffset * m_fMMToUnitValue).ToString("F" + m_intDecimal));

                arrBlobsFeaturesData[i].Add((m_stcBlobPad.fEdgeLimitTopOffset * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                arrBlobsFeaturesData[i].Add((m_stcBlobPad.fEdgeLimitRightOffset * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                arrBlobsFeaturesData[i].Add((m_stcBlobPad.fEdgeLimitBottomOffset * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                arrBlobsFeaturesData[i].Add((m_stcBlobPad.fEdgeLimitLeftOffset * m_fMMToUnitValue).ToString("F" + m_intDecimal));

                arrBlobsFeaturesData[i].Add((m_stcBlobPad.fStandOffTopOffset * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                arrBlobsFeaturesData[i].Add((m_stcBlobPad.fStandOffBottomOffset * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                arrBlobsFeaturesData[i].Add((m_stcBlobPad.fStandOffLeftOffset * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                arrBlobsFeaturesData[i].Add((m_stcBlobPad.fStandOffRightOffset * m_fMMToUnitValue).ToString("F" + m_intDecimal));

            }
            return arrBlobsFeaturesData;
        }
        public List<List<string>> GetBlobsFeaturesGroupNo()
        {
            List<List<string>> arrBlobsFeaturesData = new List<List<string>>();
            for (int i = 0; i < m_arrTemplateBlobPads.Count; i++)
            {
                arrBlobsFeaturesData.Add(new List<string>());
                BlobsFeatures m_stcBlobPad = (BlobsFeatures)m_arrTemplateBlobPads[i];

                arrBlobsFeaturesData[i].Add(" (G" + m_stcBlobPad.intGroupID + ") " + "Pad " + (i + 1));
            }

            return arrBlobsFeaturesData;
        }
        public int GetBlobsFeaturesGroupNo(int intIndex)
        {
            if (m_arrTemplateBlobPads.Count > intIndex)
                return ((BlobsFeatures)m_arrTemplateBlobPads[intIndex]).intGroupID;

            return -1;
        }
        public int GetBlobsFeaturesPadID(int intIndex)
        {
            if (m_arrTemplateBlobPads.Count > intIndex)
                return ((BlobsFeatures)m_arrTemplateBlobPads[intIndex]).intNoID;

            return -1;
        }
        public List<List<string>> GetBlobsFeaturesInspectRealData2()
        {
            List<List<string>> arrBlobsFeaturesData = new List<List<string>>();
            for (int i = 0; i < m_arrTemplateBlobPads.Count; i++)
            {
                arrBlobsFeaturesData.Add(new List<string>());
                BlobsFeatures m_stcBlobPad = (BlobsFeatures)m_arrTemplateBlobPads[i];

                arrBlobsFeaturesData[i].Add("Pad");
                arrBlobsFeaturesData[i].Add((i).ToString());
                arrBlobsFeaturesData[i].Add((m_stcBlobPad.fOffSet * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                arrBlobsFeaturesData[i].Add((m_stcBlobPad.fMinArea * m_fMMToUnitValueArea).ToString("F" + m_intDecimal2));
                arrBlobsFeaturesData[i].Add((m_stcBlobPad.fMaxArea * m_fMMToUnitValueArea).ToString("F" + m_intDecimal2));
                // 2019 10 30 - CCENG: m_arrTemplateBlobPads fMinWidth, fMaxWidth, fMinHeigt, fMaxLength are not affacted by lengthmode.
                //if (((BlobsFeatures)m_arrTemplateBlobPads[i]).intLengthMode == 2)
                //{
                //    arrBlobsFeaturesData[i].Add((m_stcBlobPad.fMinLength * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                //    arrBlobsFeaturesData[i].Add((m_stcBlobPad.fMaxLength * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                //    arrBlobsFeaturesData[i].Add((m_stcBlobPad.fMinWidth * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                //    arrBlobsFeaturesData[i].Add((m_stcBlobPad.fMaxWidth * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                //}
                //else
                //{
                arrBlobsFeaturesData[i].Add((m_stcBlobPad.fMinWidth * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                arrBlobsFeaturesData[i].Add((m_stcBlobPad.fMaxWidth * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                arrBlobsFeaturesData[i].Add((m_stcBlobPad.fMinLength * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                arrBlobsFeaturesData[i].Add((m_stcBlobPad.fMaxLength * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                //}

                float fMinP, fMaxP, fMinG, fMaxG;
                fMinP = fMaxP = fMinG = fMaxG = 0.0f;

                if (GetPitchGapMinMax(i, ref fMinP, ref fMaxP, ref fMinG, ref fMaxG))
                {
                    arrBlobsFeaturesData[i].Add((fMinP * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                    arrBlobsFeaturesData[i].Add((fMaxP * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                    arrBlobsFeaturesData[i].Add((fMinG * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                    arrBlobsFeaturesData[i].Add((fMaxG * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                }
                else
                {
                    for (int j = 0; j < 4; j++)
                    {
                        arrBlobsFeaturesData[i].Add((-1).ToString("F" + m_intDecimal));
                    }
                }

                arrBlobsFeaturesData[i].Add((m_stcBlobPad.fMaxBroken * m_fMMToUnitValueArea).ToString("F" + m_intDecimal2));
                arrBlobsFeaturesData[i].Add((m_stcBlobPad.fMaxBrokenLength * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                arrBlobsFeaturesData[i].Add((m_stcBlobPad.fMaxExcess * m_fMMToUnitValueArea).ToString("F" + m_intDecimal2));
                arrBlobsFeaturesData[i].Add((m_stcBlobPad.fMaxSmearLength * m_fMMToUnitValue).ToString("F" + m_intDecimal));

                //Edge Limit
                arrBlobsFeaturesData[i].Add((m_stcBlobPad.fEdgeLimitTop * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                arrBlobsFeaturesData[i].Add((m_stcBlobPad.fEdgeLimitRight * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                arrBlobsFeaturesData[i].Add((m_stcBlobPad.fEdgeLimitBottom * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                arrBlobsFeaturesData[i].Add((m_stcBlobPad.fEdgeLimitLeft * m_fMMToUnitValue).ToString("F" + m_intDecimal));

                //MaxStandOff
                arrBlobsFeaturesData[i].Add((m_stcBlobPad.fMaxStandOffTop * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                arrBlobsFeaturesData[i].Add((m_stcBlobPad.fMaxStandOffBottom * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                arrBlobsFeaturesData[i].Add((m_stcBlobPad.fMaxStandOffLeft * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                arrBlobsFeaturesData[i].Add((m_stcBlobPad.fMaxStandOffRight * m_fMMToUnitValue).ToString("F" + m_intDecimal));
              
                arrBlobsFeaturesData[i].Add((m_stcBlobPad.fMinLine3 * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                arrBlobsFeaturesData[i].Add((m_stcBlobPad.fMaxLine3 * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                arrBlobsFeaturesData[i].Add((m_stcBlobPad.fMinLine4 * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                arrBlobsFeaturesData[i].Add((m_stcBlobPad.fMaxLine4 * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                arrBlobsFeaturesData[i].Add((m_stcBlobPad.fMinLine5 * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                arrBlobsFeaturesData[i].Add((m_stcBlobPad.fMaxLine5 * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                arrBlobsFeaturesData[i].Add((m_stcBlobPad.fMinLine6 * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                arrBlobsFeaturesData[i].Add((m_stcBlobPad.fMaxLine6 * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                arrBlobsFeaturesData[i].Add((m_stcBlobPad.fMinLine7 * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                arrBlobsFeaturesData[i].Add((m_stcBlobPad.fMaxLine7 * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                arrBlobsFeaturesData[i].Add((m_stcBlobPad.fMinLine8 * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                arrBlobsFeaturesData[i].Add((m_stcBlobPad.fMaxLine8 * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                arrBlobsFeaturesData[i].Add((m_stcBlobPad.fMinLine9 * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                arrBlobsFeaturesData[i].Add((m_stcBlobPad.fMaxLine9 * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                arrBlobsFeaturesData[i].Add((m_stcBlobPad.fMinLine10 * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                arrBlobsFeaturesData[i].Add((m_stcBlobPad.fMaxLine10 * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                arrBlobsFeaturesData[i].Add((m_stcBlobPad.fMinLine11 * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                arrBlobsFeaturesData[i].Add((m_stcBlobPad.fMaxLine11 * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                arrBlobsFeaturesData[i].Add((m_stcBlobPad.fMinLine12 * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                arrBlobsFeaturesData[i].Add((m_stcBlobPad.fMaxLine12 * m_fMMToUnitValue).ToString("F" + m_intDecimal));

                //arrBlobsFeaturesData[i].Add((m_stcBlobPad.fOffsetOffSet * m_fMMToUnitValue).ToString("F" + m_intDecimal)); 
                //arrBlobsFeaturesData[i].Add((m_stcBlobPad.fWidthOffset * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                //arrBlobsFeaturesData[i].Add((m_stcBlobPad.fHeightOffset * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                //arrBlobsFeaturesData[i].Add((m_stcBlobPad.fPitchOffset * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                //arrBlobsFeaturesData[i].Add((m_stcBlobPad.fGapOffset * m_fMMToUnitValue).ToString("F" + m_intDecimal));


            }

            return arrBlobsFeaturesData;
        }
        
        public List<List<string>> GetBlobsFeaturesData_PadAndGroup()
        {
            float fMinP, fMaxP, fMinG, fMaxG;
            List<List<string>> arrBlobsFeaturesData = new List<List<string>>();
            int intRowIndex = -1;
            for (int i = 0; i < m_arrGroupTemplateBlobPads.Count; i++)
            {
                arrBlobsFeaturesData.Add(new List<string>());
                intRowIndex++;
                BlobsFeatures m_stcBlobPad = (BlobsFeatures)m_arrGroupTemplateBlobPads[i];

                arrBlobsFeaturesData[intRowIndex].Add("Group");
                arrBlobsFeaturesData[intRowIndex].Add(i.ToString());
                arrBlobsFeaturesData[intRowIndex].Add((m_stcBlobPad.fOffSet * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                arrBlobsFeaturesData[intRowIndex].Add((m_stcBlobPad.fMinArea * m_fMMToUnitValueArea).ToString("F" + m_intDecimal2));
                arrBlobsFeaturesData[intRowIndex].Add((m_stcBlobPad.fMaxArea * m_fMMToUnitValueArea).ToString("F" + m_intDecimal2));
                //if (m_stcBlobPad.intLengthMode == 2)
                //{
                //    arrBlobsFeaturesData[intRowIndex].Add((m_stcBlobPad.fMinLength * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                //    arrBlobsFeaturesData[intRowIndex].Add((m_stcBlobPad.fMaxLength * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                //    arrBlobsFeaturesData[intRowIndex].Add((m_stcBlobPad.fMinWidth * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                //    arrBlobsFeaturesData[intRowIndex].Add((m_stcBlobPad.fMaxWidth * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                //}
                //else
                {
                    arrBlobsFeaturesData[intRowIndex].Add((m_stcBlobPad.fMinWidth * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                    arrBlobsFeaturesData[intRowIndex].Add((m_stcBlobPad.fMaxWidth * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                    arrBlobsFeaturesData[intRowIndex].Add((m_stcBlobPad.fMinLength * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                    arrBlobsFeaturesData[intRowIndex].Add((m_stcBlobPad.fMaxLength * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                }

                fMinP = fMaxP = fMinG = fMaxG = 0.0f;


                arrBlobsFeaturesData[intRowIndex].Add((m_stcBlobPad.fMinPitch * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                arrBlobsFeaturesData[intRowIndex].Add((m_stcBlobPad.fMaxPitch * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                arrBlobsFeaturesData[intRowIndex].Add((m_stcBlobPad.fMinGap * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                arrBlobsFeaturesData[intRowIndex].Add((m_stcBlobPad.fMaxGap * m_fMMToUnitValue).ToString("F" + m_intDecimal));

                arrBlobsFeaturesData[intRowIndex].Add((m_stcBlobPad.fMaxBroken * m_fMMToUnitValueArea).ToString("F" + m_intDecimal2));
                arrBlobsFeaturesData[intRowIndex].Add((m_stcBlobPad.fMaxBrokenLength * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                arrBlobsFeaturesData[intRowIndex].Add((m_stcBlobPad.fMaxExcess * m_fMMToUnitValueArea).ToString("F" + m_intDecimal2));
                arrBlobsFeaturesData[intRowIndex].Add((m_stcBlobPad.fMaxSmearLength * m_fMMToUnitValue).ToString("F" + m_intDecimal));

                //Edge Limit
                arrBlobsFeaturesData[intRowIndex].Add((m_stcBlobPad.fEdgeLimitTop * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                arrBlobsFeaturesData[intRowIndex].Add((m_stcBlobPad.fEdgeLimitRight * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                arrBlobsFeaturesData[intRowIndex].Add((m_stcBlobPad.fEdgeLimitBottom * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                arrBlobsFeaturesData[intRowIndex].Add((m_stcBlobPad.fEdgeLimitLeft * m_fMMToUnitValue).ToString("F" + m_intDecimal));

                //MaxStandOff
                arrBlobsFeaturesData[intRowIndex].Add((m_stcBlobPad.fMaxStandOffTop * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                arrBlobsFeaturesData[intRowIndex].Add((m_stcBlobPad.fMaxStandOffBottom * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                arrBlobsFeaturesData[intRowIndex].Add((m_stcBlobPad.fMaxStandOffLeft * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                arrBlobsFeaturesData[intRowIndex].Add((m_stcBlobPad.fMaxStandOffRight * m_fMMToUnitValue).ToString("F" + m_intDecimal));

                arrBlobsFeaturesData[intRowIndex].Add((m_stcBlobPad.fMinLine3 * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                arrBlobsFeaturesData[intRowIndex].Add((m_stcBlobPad.fMaxLine3 * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                arrBlobsFeaturesData[intRowIndex].Add((m_stcBlobPad.fMinLine4 * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                arrBlobsFeaturesData[intRowIndex].Add((m_stcBlobPad.fMaxLine4 * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                arrBlobsFeaturesData[intRowIndex].Add((m_stcBlobPad.fMinLine5 * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                arrBlobsFeaturesData[intRowIndex].Add((m_stcBlobPad.fMaxLine5 * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                arrBlobsFeaturesData[intRowIndex].Add((m_stcBlobPad.fMinLine6 * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                arrBlobsFeaturesData[intRowIndex].Add((m_stcBlobPad.fMaxLine6 * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                arrBlobsFeaturesData[intRowIndex].Add((m_stcBlobPad.fMinLine7 * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                arrBlobsFeaturesData[intRowIndex].Add((m_stcBlobPad.fMaxLine7 * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                arrBlobsFeaturesData[intRowIndex].Add((m_stcBlobPad.fMinLine8 * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                arrBlobsFeaturesData[intRowIndex].Add((m_stcBlobPad.fMaxLine8 * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                arrBlobsFeaturesData[intRowIndex].Add((m_stcBlobPad.fMinLine9 * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                arrBlobsFeaturesData[intRowIndex].Add((m_stcBlobPad.fMaxLine9 * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                arrBlobsFeaturesData[intRowIndex].Add((m_stcBlobPad.fMinLine10 * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                arrBlobsFeaturesData[intRowIndex].Add((m_stcBlobPad.fMaxLine10 * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                arrBlobsFeaturesData[intRowIndex].Add((m_stcBlobPad.fMinLine11 * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                arrBlobsFeaturesData[intRowIndex].Add((m_stcBlobPad.fMaxLine11 * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                arrBlobsFeaturesData[intRowIndex].Add((m_stcBlobPad.fMinLine12 * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                arrBlobsFeaturesData[intRowIndex].Add((m_stcBlobPad.fMaxLine12 * m_fMMToUnitValue).ToString("F" + m_intDecimal));

                //arrBlobsFeaturesData[intRowIndex].Add((m_stcBlobPad.fOffsetOffSet * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                //arrBlobsFeaturesData[intRowIndex].Add((m_stcBlobPad.fWidthOffset * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                //arrBlobsFeaturesData[intRowIndex].Add((m_stcBlobPad.fHeightOffset * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                //arrBlobsFeaturesData[intRowIndex].Add((m_stcBlobPad.fPitchOffset * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                //arrBlobsFeaturesData[intRowIndex].Add((m_stcBlobPad.fGapOffset * m_fMMToUnitValue).ToString("F" + m_intDecimal));


                // ----------------------------------------------------------------------------

                for (int p = 0; p < m_arrTemplateBlobPads.Count; p++)
                {
                    m_stcBlobPad = (BlobsFeatures)m_arrTemplateBlobPads[p];

                    if (m_stcBlobPad.intGroupID == i)
                    {
                        arrBlobsFeaturesData.Add(new List<string>());
                        intRowIndex++;

                        arrBlobsFeaturesData[intRowIndex].Add("Pad");
                        arrBlobsFeaturesData[intRowIndex].Add(p.ToString());
                        arrBlobsFeaturesData[intRowIndex].Add((m_stcBlobPad.fOffSet * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                        arrBlobsFeaturesData[intRowIndex].Add((m_stcBlobPad.fMinArea * m_fMMToUnitValueArea).ToString("F" + m_intDecimal2));
                        arrBlobsFeaturesData[intRowIndex].Add((m_stcBlobPad.fMaxArea * m_fMMToUnitValueArea).ToString("F" + m_intDecimal2));
                        //if (m_stcBlobPad.intLengthMode == 2)
                        //{
                        //    arrBlobsFeaturesData[intRowIndex].Add((m_stcBlobPad.fMinLength * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                        //    arrBlobsFeaturesData[intRowIndex].Add((m_stcBlobPad.fMaxLength * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                        //    arrBlobsFeaturesData[intRowIndex].Add((m_stcBlobPad.fMinWidth * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                        //    arrBlobsFeaturesData[intRowIndex].Add((m_stcBlobPad.fMaxWidth * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                        //}
                        //else
                        {
                            arrBlobsFeaturesData[intRowIndex].Add((m_stcBlobPad.fMinWidth * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                            arrBlobsFeaturesData[intRowIndex].Add((m_stcBlobPad.fMaxWidth * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                            arrBlobsFeaturesData[intRowIndex].Add((m_stcBlobPad.fMinLength * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                            arrBlobsFeaturesData[intRowIndex].Add((m_stcBlobPad.fMaxLength * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                        }

                        fMinP = fMaxP = fMinG = fMaxG = 0.0f;

                        if (GetPitchGapMinMax(i, ref fMinP, ref fMaxP, ref fMinG, ref fMaxG))
                        {
                            arrBlobsFeaturesData[intRowIndex].Add((fMinP * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                            arrBlobsFeaturesData[intRowIndex].Add((fMaxP * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                            arrBlobsFeaturesData[intRowIndex].Add((fMinG * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                            arrBlobsFeaturesData[intRowIndex].Add((fMaxG * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                        }
                        else
                        {
                            for (int j = 0; j < 4; j++)
                            {
                                arrBlobsFeaturesData[intRowIndex].Add((-1).ToString("F" + m_intDecimal));
                            }
                        }

                        arrBlobsFeaturesData[intRowIndex].Add((m_stcBlobPad.fMaxBroken * m_fMMToUnitValueArea).ToString("F" + m_intDecimal2));
                        arrBlobsFeaturesData[intRowIndex].Add((m_stcBlobPad.fMaxBrokenLength * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                        arrBlobsFeaturesData[intRowIndex].Add((m_stcBlobPad.fMaxExcess * m_fMMToUnitValueArea).ToString("F" + m_intDecimal2));
                        arrBlobsFeaturesData[intRowIndex].Add((m_stcBlobPad.fMaxSmearLength * m_fMMToUnitValue).ToString("F" + m_intDecimal));

                        arrBlobsFeaturesData[intRowIndex].Add((m_stcBlobPad.fEdgeLimitTop * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                        arrBlobsFeaturesData[intRowIndex].Add((m_stcBlobPad.fEdgeLimitRight * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                        arrBlobsFeaturesData[intRowIndex].Add((m_stcBlobPad.fEdgeLimitBottom * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                        arrBlobsFeaturesData[intRowIndex].Add((m_stcBlobPad.fEdgeLimitLeft * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                        
                        arrBlobsFeaturesData[intRowIndex].Add((m_stcBlobPad.fMaxStandOffTop * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                        arrBlobsFeaturesData[intRowIndex].Add((m_stcBlobPad.fMaxStandOffBottom * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                        arrBlobsFeaturesData[intRowIndex].Add((m_stcBlobPad.fMaxStandOffLeft * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                        arrBlobsFeaturesData[intRowIndex].Add((m_stcBlobPad.fMaxStandOffRight * m_fMMToUnitValue).ToString("F" + m_intDecimal));

                        arrBlobsFeaturesData[intRowIndex].Add((m_stcBlobPad.fMinLine3 * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                        arrBlobsFeaturesData[intRowIndex].Add((m_stcBlobPad.fMaxLine3 * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                        arrBlobsFeaturesData[intRowIndex].Add((m_stcBlobPad.fMinLine4 * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                        arrBlobsFeaturesData[intRowIndex].Add((m_stcBlobPad.fMaxLine4 * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                        arrBlobsFeaturesData[intRowIndex].Add((m_stcBlobPad.fMinLine5 * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                        arrBlobsFeaturesData[intRowIndex].Add((m_stcBlobPad.fMaxLine5 * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                        arrBlobsFeaturesData[intRowIndex].Add((m_stcBlobPad.fMinLine6 * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                        arrBlobsFeaturesData[intRowIndex].Add((m_stcBlobPad.fMaxLine6 * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                        arrBlobsFeaturesData[intRowIndex].Add((m_stcBlobPad.fMinLine7 * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                        arrBlobsFeaturesData[intRowIndex].Add((m_stcBlobPad.fMaxLine7 * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                        arrBlobsFeaturesData[intRowIndex].Add((m_stcBlobPad.fMinLine8 * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                        arrBlobsFeaturesData[intRowIndex].Add((m_stcBlobPad.fMaxLine8 * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                        arrBlobsFeaturesData[intRowIndex].Add((m_stcBlobPad.fMinLine9 * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                        arrBlobsFeaturesData[intRowIndex].Add((m_stcBlobPad.fMaxLine9 * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                        arrBlobsFeaturesData[intRowIndex].Add((m_stcBlobPad.fMinLine10 * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                        arrBlobsFeaturesData[intRowIndex].Add((m_stcBlobPad.fMaxLine10 * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                        arrBlobsFeaturesData[intRowIndex].Add((m_stcBlobPad.fMinLine11 * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                        arrBlobsFeaturesData[intRowIndex].Add((m_stcBlobPad.fMaxLine11 * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                        arrBlobsFeaturesData[intRowIndex].Add((m_stcBlobPad.fMinLine12 * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                        arrBlobsFeaturesData[intRowIndex].Add((m_stcBlobPad.fMaxLine12 * m_fMMToUnitValue).ToString("F" + m_intDecimal));

                        //arrBlobsFeaturesData[intRowIndex].Add((m_stcBlobPad.fOffsetOffSet * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                        //arrBlobsFeaturesData[intRowIndex].Add((m_stcBlobPad.fWidthOffset * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                        //arrBlobsFeaturesData[intRowIndex].Add((m_stcBlobPad.fHeightOffset * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                        //arrBlobsFeaturesData[intRowIndex].Add((m_stcBlobPad.fPitchOffset * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                        //arrBlobsFeaturesData[intRowIndex].Add((m_stcBlobPad.fGapOffset * m_fMMToUnitValue).ToString("F" + m_intDecimal));


                    }
                }
                // ============================================================================
            }

            return arrBlobsFeaturesData;
        }
        public List<List<string>> GetBlobsFeaturesEdgeLimitData_PadAndGroup()
        {
            float fMinP, fMaxP, fMinG, fMaxG;
            List<List<string>> arrBlobsFeaturesData = new List<List<string>>();
            int intRowIndex = -1;
            for (int i = 0; i < m_arrGroupTemplateBlobPads.Count; i++)
            {
                arrBlobsFeaturesData.Add(new List<string>());
                intRowIndex++;
                BlobsFeatures m_stcBlobPad = (BlobsFeatures)m_arrGroupTemplateBlobPads[i];

                arrBlobsFeaturesData[intRowIndex].Add("Group");
                arrBlobsFeaturesData[intRowIndex].Add(i.ToString());
                arrBlobsFeaturesData[intRowIndex].Add((m_stcBlobPad.fOffSet * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                arrBlobsFeaturesData[intRowIndex].Add((m_stcBlobPad.fMinArea * m_fMMToUnitValueArea).ToString("F" + m_intDecimal2));
                arrBlobsFeaturesData[intRowIndex].Add((m_stcBlobPad.fMaxArea * m_fMMToUnitValueArea).ToString("F" + m_intDecimal2));
                //if (m_stcBlobPad.intLengthMode == 2)
                //{
                //    arrBlobsFeaturesData[intRowIndex].Add((m_stcBlobPad.fMinLength * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                //    arrBlobsFeaturesData[intRowIndex].Add((m_stcBlobPad.fMaxLength * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                //    arrBlobsFeaturesData[intRowIndex].Add((m_stcBlobPad.fMinWidth * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                //    arrBlobsFeaturesData[intRowIndex].Add((m_stcBlobPad.fMaxWidth * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                //}
                //else
                {
                    arrBlobsFeaturesData[intRowIndex].Add((m_stcBlobPad.fMinWidth * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                    arrBlobsFeaturesData[intRowIndex].Add((m_stcBlobPad.fMaxWidth * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                    arrBlobsFeaturesData[intRowIndex].Add((m_stcBlobPad.fMinLength * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                    arrBlobsFeaturesData[intRowIndex].Add((m_stcBlobPad.fMaxLength * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                }

                fMinP = fMaxP = fMinG = fMaxG = 0.0f;


                arrBlobsFeaturesData[intRowIndex].Add((m_stcBlobPad.fMinPitch * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                arrBlobsFeaturesData[intRowIndex].Add((m_stcBlobPad.fMaxPitch * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                arrBlobsFeaturesData[intRowIndex].Add((m_stcBlobPad.fMinGap * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                arrBlobsFeaturesData[intRowIndex].Add((m_stcBlobPad.fMaxGap * m_fMMToUnitValue).ToString("F" + m_intDecimal));

                arrBlobsFeaturesData[intRowIndex].Add((m_stcBlobPad.fMaxBroken * m_fMMToUnitValueArea).ToString("F" + m_intDecimal2));
                arrBlobsFeaturesData[intRowIndex].Add((m_stcBlobPad.fMaxBrokenLength * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                arrBlobsFeaturesData[intRowIndex].Add((m_stcBlobPad.fMaxExcess * m_fMMToUnitValueArea).ToString("F" + m_intDecimal2));
                arrBlobsFeaturesData[intRowIndex].Add((m_stcBlobPad.fMaxSmearLength * m_fMMToUnitValue).ToString("F" + m_intDecimal));


                arrBlobsFeaturesData[intRowIndex].Add((m_stcBlobPad.fMinLine3 * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                arrBlobsFeaturesData[intRowIndex].Add((m_stcBlobPad.fMaxLine3 * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                arrBlobsFeaturesData[intRowIndex].Add((m_stcBlobPad.fMinLine4 * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                arrBlobsFeaturesData[intRowIndex].Add((m_stcBlobPad.fMaxLine4 * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                arrBlobsFeaturesData[intRowIndex].Add((m_stcBlobPad.fMinLine5 * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                arrBlobsFeaturesData[intRowIndex].Add((m_stcBlobPad.fMaxLine5 * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                arrBlobsFeaturesData[intRowIndex].Add((m_stcBlobPad.fMinLine6 * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                arrBlobsFeaturesData[intRowIndex].Add((m_stcBlobPad.fMaxLine6 * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                arrBlobsFeaturesData[intRowIndex].Add((m_stcBlobPad.fMinLine7 * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                arrBlobsFeaturesData[intRowIndex].Add((m_stcBlobPad.fMaxLine7 * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                arrBlobsFeaturesData[intRowIndex].Add((m_stcBlobPad.fMinLine8 * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                arrBlobsFeaturesData[intRowIndex].Add((m_stcBlobPad.fMaxLine8 * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                arrBlobsFeaturesData[intRowIndex].Add((m_stcBlobPad.fMinLine9 * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                arrBlobsFeaturesData[intRowIndex].Add((m_stcBlobPad.fMaxLine9 * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                arrBlobsFeaturesData[intRowIndex].Add((m_stcBlobPad.fMinLine10 * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                arrBlobsFeaturesData[intRowIndex].Add((m_stcBlobPad.fMaxLine10 * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                arrBlobsFeaturesData[intRowIndex].Add((m_stcBlobPad.fMinLine11 * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                arrBlobsFeaturesData[intRowIndex].Add((m_stcBlobPad.fMaxLine11 * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                arrBlobsFeaturesData[intRowIndex].Add((m_stcBlobPad.fMinLine12 * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                arrBlobsFeaturesData[intRowIndex].Add((m_stcBlobPad.fMaxLine12 * m_fMMToUnitValue).ToString("F" + m_intDecimal));

                arrBlobsFeaturesData[intRowIndex].Add((m_stcBlobPad.fOffsetOffSet * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                arrBlobsFeaturesData[intRowIndex].Add((m_stcBlobPad.fWidthOffset * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                arrBlobsFeaturesData[intRowIndex].Add((m_stcBlobPad.fHeightOffset * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                arrBlobsFeaturesData[intRowIndex].Add((m_stcBlobPad.fPitchOffset * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                arrBlobsFeaturesData[intRowIndex].Add((m_stcBlobPad.fGapOffset * m_fMMToUnitValue).ToString("F" + m_intDecimal));

                arrBlobsFeaturesData[intRowIndex].Add((m_stcBlobPad.fEdgeDistanceTopOffset * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                arrBlobsFeaturesData[intRowIndex].Add((m_stcBlobPad.fEdgeDistanceRightOffset * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                arrBlobsFeaturesData[intRowIndex].Add((m_stcBlobPad.fEdgeDistanceBottomOffset * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                arrBlobsFeaturesData[intRowIndex].Add((m_stcBlobPad.fEdgeDistanceLeftOffset * m_fMMToUnitValue).ToString("F" + m_intDecimal));

                arrBlobsFeaturesData[intRowIndex].Add((m_stcBlobPad.fEdgeLimitTopOffset * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                arrBlobsFeaturesData[intRowIndex].Add((m_stcBlobPad.fEdgeLimitRightOffset * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                arrBlobsFeaturesData[intRowIndex].Add((m_stcBlobPad.fEdgeLimitBottomOffset * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                arrBlobsFeaturesData[intRowIndex].Add((m_stcBlobPad.fEdgeLimitLeftOffset * m_fMMToUnitValue).ToString("F" + m_intDecimal));

                arrBlobsFeaturesData[intRowIndex].Add((m_stcBlobPad.fStandOffTopOffset * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                arrBlobsFeaturesData[intRowIndex].Add((m_stcBlobPad.fStandOffBottomOffset * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                arrBlobsFeaturesData[intRowIndex].Add((m_stcBlobPad.fStandOffLeftOffset * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                arrBlobsFeaturesData[intRowIndex].Add((m_stcBlobPad.fStandOffLeftOffset * m_fMMToUnitValue).ToString("F" + m_intDecimal));

                // ----------------------------------------------------------------------------

                for (int p = 0; p < m_arrTemplateBlobPads.Count; p++)
                {
                    m_stcBlobPad = (BlobsFeatures)m_arrTemplateBlobPads[p];

                    if (m_stcBlobPad.intGroupID == i)
                    {
                        arrBlobsFeaturesData.Add(new List<string>());
                        intRowIndex++;

                        arrBlobsFeaturesData[intRowIndex].Add("Pad");
                        arrBlobsFeaturesData[intRowIndex].Add(p.ToString());
                        arrBlobsFeaturesData[intRowIndex].Add((m_stcBlobPad.fOffSet * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                        arrBlobsFeaturesData[intRowIndex].Add((m_stcBlobPad.fMinArea * m_fMMToUnitValueArea).ToString("F" + m_intDecimal2));
                        arrBlobsFeaturesData[intRowIndex].Add((m_stcBlobPad.fMaxArea * m_fMMToUnitValueArea).ToString("F" + m_intDecimal2));
                        if (m_stcBlobPad.intLengthMode == 2)
                        {
                            arrBlobsFeaturesData[intRowIndex].Add((m_stcBlobPad.fMinLength * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                            arrBlobsFeaturesData[intRowIndex].Add((m_stcBlobPad.fMaxLength * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                            arrBlobsFeaturesData[intRowIndex].Add((m_stcBlobPad.fMinWidth * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                            arrBlobsFeaturesData[intRowIndex].Add((m_stcBlobPad.fMaxWidth * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                        }
                        else
                        {
                            arrBlobsFeaturesData[intRowIndex].Add((m_stcBlobPad.fMinWidth * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                            arrBlobsFeaturesData[intRowIndex].Add((m_stcBlobPad.fMaxWidth * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                            arrBlobsFeaturesData[intRowIndex].Add((m_stcBlobPad.fMinLength * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                            arrBlobsFeaturesData[intRowIndex].Add((m_stcBlobPad.fMaxLength * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                        }

                        fMinP = fMaxP = fMinG = fMaxG = 0.0f;

                        if (GetPitchGapMinMax(i, ref fMinP, ref fMaxP, ref fMinG, ref fMaxG))
                        {
                            arrBlobsFeaturesData[intRowIndex].Add((fMinP * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                            arrBlobsFeaturesData[intRowIndex].Add((fMaxP * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                            arrBlobsFeaturesData[intRowIndex].Add((fMinG * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                            arrBlobsFeaturesData[intRowIndex].Add((fMaxG * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                        }
                        else
                        {
                            for (int j = 0; j < 4; j++)
                            {
                                arrBlobsFeaturesData[intRowIndex].Add((-1).ToString("F" + m_intDecimal));
                            }
                        }

                        arrBlobsFeaturesData[intRowIndex].Add((m_stcBlobPad.fMaxBroken * m_fMMToUnitValueArea).ToString("F" + m_intDecimal2));
                        arrBlobsFeaturesData[intRowIndex].Add((m_stcBlobPad.fMaxBrokenLength * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                        arrBlobsFeaturesData[intRowIndex].Add((m_stcBlobPad.fMaxExcess * m_fMMToUnitValueArea).ToString("F" + m_intDecimal2));
                        arrBlobsFeaturesData[intRowIndex].Add((m_stcBlobPad.fMaxSmearLength * m_fMMToUnitValue).ToString("F" + m_intDecimal));


                        arrBlobsFeaturesData[intRowIndex].Add((m_stcBlobPad.fMinLine3 * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                        arrBlobsFeaturesData[intRowIndex].Add((m_stcBlobPad.fMaxLine3 * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                        arrBlobsFeaturesData[intRowIndex].Add((m_stcBlobPad.fMinLine4 * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                        arrBlobsFeaturesData[intRowIndex].Add((m_stcBlobPad.fMaxLine4 * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                        arrBlobsFeaturesData[intRowIndex].Add((m_stcBlobPad.fMinLine5 * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                        arrBlobsFeaturesData[intRowIndex].Add((m_stcBlobPad.fMaxLine5 * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                        arrBlobsFeaturesData[intRowIndex].Add((m_stcBlobPad.fMinLine6 * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                        arrBlobsFeaturesData[intRowIndex].Add((m_stcBlobPad.fMaxLine6 * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                        arrBlobsFeaturesData[intRowIndex].Add((m_stcBlobPad.fMinLine7 * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                        arrBlobsFeaturesData[intRowIndex].Add((m_stcBlobPad.fMaxLine7 * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                        arrBlobsFeaturesData[intRowIndex].Add((m_stcBlobPad.fMinLine8 * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                        arrBlobsFeaturesData[intRowIndex].Add((m_stcBlobPad.fMaxLine8 * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                        arrBlobsFeaturesData[intRowIndex].Add((m_stcBlobPad.fMinLine9 * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                        arrBlobsFeaturesData[intRowIndex].Add((m_stcBlobPad.fMaxLine9 * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                        arrBlobsFeaturesData[intRowIndex].Add((m_stcBlobPad.fMinLine10 * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                        arrBlobsFeaturesData[intRowIndex].Add((m_stcBlobPad.fMaxLine10 * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                        arrBlobsFeaturesData[intRowIndex].Add((m_stcBlobPad.fMinLine11 * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                        arrBlobsFeaturesData[intRowIndex].Add((m_stcBlobPad.fMaxLine11 * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                        arrBlobsFeaturesData[intRowIndex].Add((m_stcBlobPad.fMinLine12 * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                        arrBlobsFeaturesData[intRowIndex].Add((m_stcBlobPad.fMaxLine12 * m_fMMToUnitValue).ToString("F" + m_intDecimal));

                        arrBlobsFeaturesData[intRowIndex].Add((m_stcBlobPad.fOffsetOffSet * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                        arrBlobsFeaturesData[intRowIndex].Add((m_stcBlobPad.fWidthOffset * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                        arrBlobsFeaturesData[intRowIndex].Add((m_stcBlobPad.fHeightOffset * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                        arrBlobsFeaturesData[intRowIndex].Add((m_stcBlobPad.fPitchOffset * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                        arrBlobsFeaturesData[intRowIndex].Add((m_stcBlobPad.fGapOffset * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                        
                        arrBlobsFeaturesData[intRowIndex].Add((m_stcBlobPad.fEdgeDistanceTopOffset * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                        arrBlobsFeaturesData[intRowIndex].Add((m_stcBlobPad.fEdgeDistanceRightOffset * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                        arrBlobsFeaturesData[intRowIndex].Add((m_stcBlobPad.fEdgeDistanceBottomOffset * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                        arrBlobsFeaturesData[intRowIndex].Add((m_stcBlobPad.fEdgeDistanceLeftOffset * m_fMMToUnitValue).ToString("F" + m_intDecimal));

                        arrBlobsFeaturesData[intRowIndex].Add((m_stcBlobPad.fEdgeLimitTopOffset * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                        arrBlobsFeaturesData[intRowIndex].Add((m_stcBlobPad.fEdgeLimitRightOffset * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                        arrBlobsFeaturesData[intRowIndex].Add((m_stcBlobPad.fEdgeLimitBottomOffset * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                        arrBlobsFeaturesData[intRowIndex].Add((m_stcBlobPad.fEdgeLimitLeftOffset * m_fMMToUnitValue).ToString("F" + m_intDecimal));

                        arrBlobsFeaturesData[intRowIndex].Add((m_stcBlobPad.fStandOffTopOffset * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                        arrBlobsFeaturesData[intRowIndex].Add((m_stcBlobPad.fStandOffBottomOffset * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                        arrBlobsFeaturesData[intRowIndex].Add((m_stcBlobPad.fStandOffLeftOffset * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                        arrBlobsFeaturesData[intRowIndex].Add((m_stcBlobPad.fStandOffRightOffset * m_fMMToUnitValue).ToString("F" + m_intDecimal));

                    }
                }
                // ============================================================================
            }

            return arrBlobsFeaturesData;
        }
        public List<List<string>> GetGroupBlobsFeaturesInspectRealData()
        {
            List<List<string>> arrBlobsFeaturesData = new List<List<string>>();
            for (int i = 0; i < m_arrGroupTemplateBlobPads.Count; i++)
            {
                arrBlobsFeaturesData.Add(new List<string>());
                BlobsFeatures m_stcBlobPad = (BlobsFeatures)m_arrGroupTemplateBlobPads[i];

                arrBlobsFeaturesData[i].Add((m_stcBlobPad.fOffSet * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                arrBlobsFeaturesData[i].Add((m_stcBlobPad.fMinArea * m_fMMToUnitValueArea).ToString("F" + m_intDecimal2));
                arrBlobsFeaturesData[i].Add((m_stcBlobPad.fMaxArea * m_fMMToUnitValueArea).ToString("F" + m_intDecimal2));
                if (((BlobsFeatures)m_arrTemplateBlobPads[i]).intLengthMode == 2)
                {
                    arrBlobsFeaturesData[i].Add((m_stcBlobPad.fMinLength * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                    arrBlobsFeaturesData[i].Add((m_stcBlobPad.fMaxLength * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                    arrBlobsFeaturesData[i].Add((m_stcBlobPad.fMinWidth * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                    arrBlobsFeaturesData[i].Add((m_stcBlobPad.fMaxWidth * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                }
                else
                {
                    arrBlobsFeaturesData[i].Add((m_stcBlobPad.fMinWidth * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                    arrBlobsFeaturesData[i].Add((m_stcBlobPad.fMaxWidth * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                    arrBlobsFeaturesData[i].Add((m_stcBlobPad.fMinLength * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                    arrBlobsFeaturesData[i].Add((m_stcBlobPad.fMaxLength * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                }

                float fMinP, fMaxP, fMinG, fMaxG;
                fMinP = fMaxP = fMinG = fMaxG = 0.0f;

                if (GetPitchGapMinMax(i, ref fMinP, ref fMaxP, ref fMinG, ref fMaxG))
                {
                    arrBlobsFeaturesData[i].Add((fMinP * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                    arrBlobsFeaturesData[i].Add((fMaxP * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                    arrBlobsFeaturesData[i].Add((fMinG * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                    arrBlobsFeaturesData[i].Add((fMaxG * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                }
                else
                {
                    for (int j = 0; j < 4; j++)
                    {
                        arrBlobsFeaturesData[i].Add((-1).ToString("F" + m_intDecimal));
                    }
                }

                arrBlobsFeaturesData[i].Add((m_stcBlobPad.fMaxBroken * m_fMMToUnitValueArea).ToString("F" + m_intDecimal2));
                arrBlobsFeaturesData[i].Add((m_stcBlobPad.fMaxBrokenLength * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                arrBlobsFeaturesData[i].Add((m_stcBlobPad.fMaxExcess * m_fMMToUnitValueArea).ToString("F" + m_intDecimal2));
                arrBlobsFeaturesData[i].Add((m_stcBlobPad.fMaxSmearLength * m_fMMToUnitValue).ToString("F" + m_intDecimal));

                arrBlobsFeaturesData[i].Add((m_stcBlobPad.fEdgeLimitTop * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                arrBlobsFeaturesData[i].Add((m_stcBlobPad.fEdgeLimitRight * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                arrBlobsFeaturesData[i].Add((m_stcBlobPad.fEdgeLimitBottom * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                arrBlobsFeaturesData[i].Add((m_stcBlobPad.fEdgeLimitLeft * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                
                arrBlobsFeaturesData[i].Add((m_stcBlobPad.fMaxStandOffTop * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                arrBlobsFeaturesData[i].Add((m_stcBlobPad.fMaxStandOffBottom * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                arrBlobsFeaturesData[i].Add((m_stcBlobPad.fMaxStandOffLeft * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                arrBlobsFeaturesData[i].Add((m_stcBlobPad.fMaxStandOffRight * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                
                arrBlobsFeaturesData[i].Add((m_stcBlobPad.fOffsetOffSet * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                arrBlobsFeaturesData[i].Add((m_stcBlobPad.fWidthOffset * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                arrBlobsFeaturesData[i].Add((m_stcBlobPad.fHeightOffset * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                arrBlobsFeaturesData[i].Add((m_stcBlobPad.fPitchOffset * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                arrBlobsFeaturesData[i].Add((m_stcBlobPad.fGapOffset * m_fMMToUnitValue).ToString("F" + m_intDecimal));

                arrBlobsFeaturesData[i].Add((m_stcBlobPad.fEdgeDistanceTopOffset * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                arrBlobsFeaturesData[i].Add((m_stcBlobPad.fEdgeDistanceRightOffset * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                arrBlobsFeaturesData[i].Add((m_stcBlobPad.fEdgeDistanceBottomOffset * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                arrBlobsFeaturesData[i].Add((m_stcBlobPad.fEdgeDistanceLeftOffset * m_fMMToUnitValue).ToString("F" + m_intDecimal));

                arrBlobsFeaturesData[i].Add((m_stcBlobPad.fEdgeLimitTopOffset * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                arrBlobsFeaturesData[i].Add((m_stcBlobPad.fEdgeLimitRightOffset * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                arrBlobsFeaturesData[i].Add((m_stcBlobPad.fEdgeLimitBottomOffset * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                arrBlobsFeaturesData[i].Add((m_stcBlobPad.fEdgeLimitLeftOffset * m_fMMToUnitValue).ToString("F" + m_intDecimal));

                arrBlobsFeaturesData[i].Add((m_stcBlobPad.fStandOffTopOffset * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                arrBlobsFeaturesData[i].Add((m_stcBlobPad.fStandOffBottomOffset * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                arrBlobsFeaturesData[i].Add((m_stcBlobPad.fStandOffLeftOffset * m_fMMToUnitValue).ToString("F" + m_intDecimal));
                arrBlobsFeaturesData[i].Add((m_stcBlobPad.fStandOffRightOffset * m_fMMToUnitValue).ToString("F" + m_intDecimal));
            }

            return arrBlobsFeaturesData;
        }

        /// <summary>
        /// Get all blobs features result
        /// </summary>
        /// <param name="intTemplateIndex">template index</param>
        /// <returns>blobs features result in string</returns>
        public string GetBlobFeaturesResult(int intMatchTemplateIndex)
        {
            string strBlobFeatures = "";
            float fData;
            int i = intMatchTemplateIndex;

            if (m_arrSampleBlobPads == null || i >= m_arrSampleBlobPads.Length)
                return "---#---#---#---#---#---#---#---#---#---#---#---#---#---#---#---#---#---#---#---#---#---#---#---#---#---#---#---#---#"; ;

            if (m_arrSampleBlobPads == null)
                return "---#---#---#---#---#---#---#---#---#---#---#---#---#---#---#---#---#---#---#---#---#---#---#---#---#---#---#---#---#";

            strBlobFeatures += "Set Value#";

            if (m_arrSampleBlobPads[i].fOffSetMM == -999)
                strBlobFeatures += "---#";
            else
            {
                fData = m_arrSampleBlobPads[i].fOffSetMM * m_fMMToUnitValue;
                strBlobFeatures += fData.ToString("F" + m_intDecimal) + "#";
            }

            if (m_arrSampleBlobPads[i].fAreaMM == -999)
                strBlobFeatures += "---#";
            else
            {
                fData = m_arrSampleBlobPads[i].fAreaMM * m_fMMToUnitValueArea;
                strBlobFeatures += fData.ToString("F" + m_intDecimal2) + "#";
            }

            if (((BlobsFeatures)m_arrTemplateBlobPads[i]).blnFeretActivated)
            {
                if (m_arrSampleBlobPads[i].fWidthMM == -999)
                    strBlobFeatures += "---#";
                else
                {
                    fData = m_arrSampleBlobPads[i].fWidthMM * m_fMMToUnitValue;
                    strBlobFeatures += fData.ToString("F" + m_intDecimal) + "#";
                }

                if (m_arrSampleBlobPads[i].fHeightMM == -999)
                    strBlobFeatures += "---#";
                else
                {
                    fData = m_arrSampleBlobPads[i].fHeightMM * m_fMMToUnitValue;
                    strBlobFeatures += fData.ToString("F" + m_intDecimal) + "#";
                }
            }
            else
            {
                if (((BlobsFeatures)m_arrTemplateBlobPads[i]).intLengthMode == 1)
                {
                    if (m_arrSampleBlobPads[i].fWidthMM == -999)
                        strBlobFeatures += "---#";
                    else
                    {
                        fData = m_arrSampleBlobPads[i].fWidthMM * m_fMMToUnitValue;
                        strBlobFeatures += fData.ToString("F" + m_intDecimal) + "#";
                    }

                    if (m_arrSampleBlobPads[i].fHeightMM == -999)
                        strBlobFeatures += "---#";
                    else
                    {
                        fData = m_arrSampleBlobPads[i].fHeightMM * m_fMMToUnitValue;
                        strBlobFeatures += fData.ToString("F" + m_intDecimal) + "#";
                    }
                }
                else
                {
                    if (m_arrSampleBlobPads[i].fHeightMM == -999)
                        strBlobFeatures += "---#";
                    else
                    {
                        fData = m_arrSampleBlobPads[i].fHeightMM * m_fMMToUnitValue;
                        strBlobFeatures += fData.ToString("F" + m_intDecimal) + "#";
                    }

                    if (m_arrSampleBlobPads[i].fWidthMM == -999)
                        strBlobFeatures += "---#";
                    else
                    {
                        fData = m_arrSampleBlobPads[i].fWidthMM * m_fMMToUnitValue;
                        strBlobFeatures += fData.ToString("F" + m_intDecimal) + "#";
                    }
                }
            }

            float fPitch = 0, fGap = 0;
            if (GetPitchGapResult(i, ref fPitch, ref fGap))
            {
                strBlobFeatures += (fPitch * m_fMMToUnitValue).ToString("F" + m_intDecimal) + "#";
                strBlobFeatures += (fGap * m_fMMToUnitValue).ToString("F" + m_intDecimal) + "#";
            }
            else
            {
                strBlobFeatures += "---#";
                strBlobFeatures += "---#";
            }

            if (m_arrSamplePadBroken[i].fAreaMM == -999)
                strBlobFeatures += "---#";
            else
            {
                fData = m_arrSamplePadBroken[i].fAreaMM * m_fMMToUnitValue;
                strBlobFeatures += fData.ToString("F" + m_intDecimal) + "#";
            }

            if (m_arrSamplePadBroken[i].fWidthMM == -999)
                strBlobFeatures += "---#";
            else
            {
                fData = Math.Max(m_arrSamplePadBroken[i].fWidthMM, m_arrSamplePadBroken[i].fHeightMM) * m_fMMToUnitValue;
                strBlobFeatures += fData.ToString("F" + m_intDecimal) + "#";
            }

            if (m_arrSamplePadExcess[i].fAreaMM == -999)
                strBlobFeatures += "---#";
            else
            {
                fData = m_arrSamplePadExcess[i].fAreaMM * m_fMMToUnitValue;
                strBlobFeatures += fData.ToString("F" + m_intDecimal) + "#";
            }

            if (m_arrSamplePadSmear[i].fSmearLength == -999)
                strBlobFeatures += "---#";
            else
            {
                if (m_arrSamplePadSmear[i].fSmearLength < 0)
                {
                    fData = 0;
                }
                else
                {
                    fData = m_arrSamplePadSmear[i].fSmearLength * m_fMMToUnitValue;
                }
                strBlobFeatures += fData.ToString("F" + m_intDecimal) + "#";
            }

            if (m_arrSamplePadEdge[i].fEdgeTop == -999)
                strBlobFeatures += "---#";
            else
            {
                //if (m_arrSamplePadEdge[i].fEdgeTop < 0)
                //{
                //    fData = 0;
                //}
                //else
                //{
                fData = m_arrSamplePadEdge[i].fEdgeTop * m_fMMToUnitValue;
                //}
                strBlobFeatures += fData.ToString("F" + m_intDecimal) + "#";
            }

            if (m_arrSamplePadEdge[i].fEdgeRight == -999)
                strBlobFeatures += "---#";
            else
            {
                //if (m_arrSamplePadEdge[i].fEdgeRight < 0)
                //{
                //    fData = 0;
                //}
                //else
                //{
                fData = m_arrSamplePadEdge[i].fEdgeRight * m_fMMToUnitValue;
                //}
                strBlobFeatures += fData.ToString("F" + m_intDecimal) + "#";
            }

            if (m_arrSamplePadEdge[i].fEdgeBottom == -999)
                strBlobFeatures += "---#";
            else
            {
                //if (m_arrSamplePadEdge[i].fEdgeBottom < 0)
                //{
                //    fData = 0;
                //}
                //else
                //{
                fData = m_arrSamplePadEdge[i].fEdgeBottom * m_fMMToUnitValue;
                //}
                strBlobFeatures += fData.ToString("F" + m_intDecimal) + "#";
            }

            if (m_arrSamplePadEdge[i].fEdgeLeft == -999)
                strBlobFeatures += "---#";
            else
            {
                //if (m_arrSamplePadEdge[i].fEdgeLeft < 0)
                //{
                //    fData = 0;
                //}
                //else
                //{
                fData = m_arrSamplePadEdge[i].fEdgeLeft * m_fMMToUnitValue;
                //}
                strBlobFeatures += fData.ToString("F" + m_intDecimal) + "#";
            }

            if (m_arrSamplePadStandOff[i].fStandOffTop == -999)
                strBlobFeatures += "---#";
            else
            {
                fData = m_arrSamplePadStandOff[i].fStandOffTop * m_fMMToUnitValue;
                strBlobFeatures += fData.ToString("F" + m_intDecimal) + "#";
            }

            if (m_arrSamplePadStandOff[i].fStandOffBottom == -999)
                strBlobFeatures += "---#";
            else
            {
                fData = m_arrSamplePadStandOff[i].fStandOffBottom * m_fMMToUnitValue;
                strBlobFeatures += fData.ToString("F" + m_intDecimal) + "#";
            }

            if (m_arrSamplePadStandOff[i].fStandOffLeft == -999)
                strBlobFeatures += "---#";
            else
            {
                fData = m_arrSamplePadStandOff[i].fStandOffLeft * m_fMMToUnitValue;
                strBlobFeatures += fData.ToString("F" + m_intDecimal) + "#";
            }

            if (m_arrSamplePadStandOff[i].fStandOffRight == -999)
                strBlobFeatures += "---#";
            else
            {
                fData = m_arrSamplePadStandOff[i].fStandOffRight * m_fMMToUnitValue;
                strBlobFeatures += fData.ToString("F" + m_intDecimal) + "#";
            }

            if (m_arrSampleBlobPads[i].fLine3MM == -999)
                strBlobFeatures += "---#";
            else
            {
                fData = m_arrSampleBlobPads[i].fLine3MM * m_fMMToUnitValue;
                strBlobFeatures += fData.ToString("F" + m_intDecimal) + "#";
            }

            if (m_arrSampleBlobPads[i].fLine4MM == -999)
                strBlobFeatures += "---#";
            else
            {
                fData = m_arrSampleBlobPads[i].fLine4MM * m_fMMToUnitValue;
                strBlobFeatures += fData.ToString("F" + m_intDecimal) + "#";
            }

            if (m_arrSampleBlobPads[i].fLine5MM == -999)
                strBlobFeatures += "---#";
            else
            {
                fData = m_arrSampleBlobPads[i].fLine5MM * m_fMMToUnitValue;
                strBlobFeatures += fData.ToString("F" + m_intDecimal) + "#";
            }

            if (m_arrSampleBlobPads[i].fLine6MM == -999)
                strBlobFeatures += "---#";
            else
            {
                fData = m_arrSampleBlobPads[i].fLine6MM * m_fMMToUnitValue;
                strBlobFeatures += fData.ToString("F" + m_intDecimal) + "#";
            }

            if (m_arrSampleBlobPads[i].fLine7MM == -999)
                strBlobFeatures += "---#";
            else
            {
                fData = m_arrSampleBlobPads[i].fLine7MM * m_fMMToUnitValue;
                strBlobFeatures += fData.ToString("F" + m_intDecimal) + "#";
            }

            if (m_arrSampleBlobPads[i].fLine8MM == -999)
                strBlobFeatures += "---#";
            else
            {
                fData = m_arrSampleBlobPads[i].fLine8MM * m_fMMToUnitValue;
                strBlobFeatures += fData.ToString("F" + m_intDecimal) + "#";
            }

            if (m_arrSampleBlobPads[i].fLine9MM == -999)
                strBlobFeatures += "---#";
            else
            {
                fData = m_arrSampleBlobPads[i].fLine9MM * m_fMMToUnitValue;
                strBlobFeatures += fData.ToString("F" + m_intDecimal) + "#";
            }

            if (m_arrSampleBlobPads[i].fLine10MM == -999)
                strBlobFeatures += "---#";
            else
            {
                fData = m_arrSampleBlobPads[i].fLine10MM * m_fMMToUnitValue;
                strBlobFeatures += fData.ToString("F" + m_intDecimal) + "#";
            }

            if (m_arrSampleBlobPads[i].fLine11MM == -999)
                strBlobFeatures += "---#";
            else
            {
                fData = m_arrSampleBlobPads[i].fLine11MM * m_fMMToUnitValue;
                strBlobFeatures += fData.ToString("F" + m_intDecimal) + "#";
            }

            if (m_arrSampleBlobPads[i].fLine12MM == -999)
                strBlobFeatures += "---#";
            else
            {
                fData = m_arrSampleBlobPads[i].fLine12MM * m_fMMToUnitValue;
                strBlobFeatures += fData.ToString("F" + m_intDecimal) + "#";
            }

            return strBlobFeatures;

        }
        public long GetSampleBlobFailMask(int i)
        {
            if (m_arrSampleBlobPads == null || i >= m_arrSampleBlobPads.Length || !((BlobsFeatures)m_arrTemplateBlobPads[i]).blnEnable || !m_blnPadInspected)
                return 0;

            return m_arrSampleBlobPads[i].intFailMask;
        }
        public List<string> GetBlobFeaturesResult_WithPassFailIndicator(int intMatchTemplateIndex)
        {
            List<string> arrResultList = new List<string>();

            long intResultTableFailMask = 0;
            float fData, fMaxData, fMinData;
            int i = intMatchTemplateIndex;

            if (m_arrSampleBlobPads == null || i >= m_arrSampleBlobPads.Length || !((BlobsFeatures)m_arrTemplateBlobPads[i]).blnEnable || !m_blnPadInspected)
            {
                arrResultList.Add("---");
                arrResultList.Add("---");
                arrResultList.Add("---");
                arrResultList.Add("---");
                arrResultList.Add("---");
                arrResultList.Add("---");
                arrResultList.Add("---");
                arrResultList.Add("---");
                arrResultList.Add("---");
                arrResultList.Add("---");
                arrResultList.Add("---");
                arrResultList.Add("---");
                arrResultList.Add("---");
                arrResultList.Add("---");
                arrResultList.Add("---");
                arrResultList.Add("---");
                arrResultList.Add("---");
                arrResultList.Add("---");
                arrResultList.Add("---");
                arrResultList.Add("---");
                arrResultList.Add("---");
                arrResultList.Add("---");
                arrResultList.Add("---");
                arrResultList.Add("---");
                arrResultList.Add("---");
                arrResultList.Add("---");
                arrResultList.Add("---");
                arrResultList.Add("---");
                arrResultList.Add("---");
                arrResultList.Add("---");
                arrResultList.Add("---");
                arrResultList.Add("---");
                arrResultList.Add("---");
                arrResultList.Add("---");
                arrResultList.Add("---");
                arrResultList.Add(intResultTableFailMask.ToString());
                return arrResultList;
            }

            if (m_arrSampleBlobPads[i].fOffSetMM == -999 || (m_intFailOptionMask & 0x100) == 0)
                arrResultList.Add("---");
            else
            {
                fData = m_arrSampleBlobPads[i].fOffSetMM * m_fMMToUnitValue;
                arrResultList.Add(fData.ToString("F" + m_intDecimal));
                if (m_blnWantUseGroupToleranceSetting)
                {
                    int intGroupNo = ((BlobsFeatures)m_arrTemplateBlobPads[i]).intGroupID;
                    fMaxData = ((BlobsFeatures)m_arrGroupTemplateBlobPads[intGroupNo]).fOffSet * m_fMMToUnitValue;
                }
                else
                {
                    fMaxData = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fOffSet * m_fMMToUnitValue;
                }

                if (m_blnWantUseBorderLimitAsOffset)    // 2020 03 24 - CCENG: Border limit As Offset Feature
                {
                    if (fData < fMaxData)
                        intResultTableFailMask |= 0x01;
                }
                else
                {
                    if (fData > fMaxData)
                        intResultTableFailMask |= 0x01;
                }
            }

            if (m_arrSampleBlobPads[i].fAreaMM == -999 || (m_intFailOptionMask & 0x20) == 0)
                arrResultList.Add("---");
            else
            {
                fData = m_arrSampleBlobPads[i].fAreaMM * m_fMMToUnitValueArea;
                arrResultList.Add(fData.ToString("F" + m_intDecimal2));
                if (m_blnWantUseGroupToleranceSetting)
                {
                    int intGroupNo = ((BlobsFeatures)m_arrTemplateBlobPads[i]).intGroupID;
                    fMinData = ((BlobsFeatures)m_arrGroupTemplateBlobPads[intGroupNo]).fMinArea * m_fMMToUnitValueArea;
                    fMaxData = ((BlobsFeatures)m_arrGroupTemplateBlobPads[intGroupNo]).fMaxArea * m_fMMToUnitValueArea;
                }
                else
                {
                    fMinData = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fMinArea * m_fMMToUnitValueArea;
                    fMaxData = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fMaxArea * m_fMMToUnitValueArea;
                }
                if (fData < fMinData || fData > fMaxData)
                {
                    intResultTableFailMask |= 0x02;
                }
            }
            if (((BlobsFeatures)m_arrTemplateBlobPads[i]).blnFeretActivated)
            {
                if (m_arrSampleBlobPads[i].fWidthMM == -999 || (m_intFailOptionMask & 0xC0) == 0)
                    arrResultList.Add("---");
                else
                {
                    fData = m_arrSampleBlobPads[i].fWidthMM * m_fMMToUnitValue;
                    arrResultList.Add(fData.ToString("F" + m_intDecimal));
                    if (m_blnWantUseGroupToleranceSetting)
                    {
                        int intGroupNo = ((BlobsFeatures)m_arrTemplateBlobPads[i]).intGroupID;
                        fMinData = ((BlobsFeatures)m_arrGroupTemplateBlobPads[intGroupNo]).fMinWidth * m_fMMToUnitValue;
                        fMaxData = ((BlobsFeatures)m_arrGroupTemplateBlobPads[intGroupNo]).fMaxWidth * m_fMMToUnitValue;
                    }
                    else
                    {
                        fMinData = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fMinWidth * m_fMMToUnitValue;
                        fMaxData = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fMaxWidth * m_fMMToUnitValue;
                    }
                    if (fData < fMinData || fData > fMaxData)
                    {
                        intResultTableFailMask |= 0x04;
                    }
                }

                if (m_arrSampleBlobPads[i].fHeightMM == -999 || (m_intFailOptionMask & 0xC0) == 0)
                    arrResultList.Add("---");
                else
                {
                    fData = m_arrSampleBlobPads[i].fHeightMM * m_fMMToUnitValue;
                    arrResultList.Add(fData.ToString("F" + m_intDecimal));
                    if (m_blnWantUseGroupToleranceSetting)
                    {
                        int intGroupNo = ((BlobsFeatures)m_arrTemplateBlobPads[i]).intGroupID;
                        fMinData = ((BlobsFeatures)m_arrGroupTemplateBlobPads[intGroupNo]).fMinLength * m_fMMToUnitValue;
                        fMaxData = ((BlobsFeatures)m_arrGroupTemplateBlobPads[intGroupNo]).fMaxLength * m_fMMToUnitValue;
                    }
                    else
                    {
                        fMinData = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fMinLength * m_fMMToUnitValue;
                        fMaxData = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fMaxLength * m_fMMToUnitValue;
                    }


                    //fMinData = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fMinLength * m_fMMToUnitValue;
                    //fMaxData = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fMaxLength * m_fMMToUnitValue;
                    if (fData < fMinData || fData > fMaxData)
                    {
                        intResultTableFailMask |= 0x08;
                    }
                }
            }
            else
            {
                if (((BlobsFeatures)m_arrTemplateBlobPads[i]).intLengthMode == 1)
                {
                    if (m_arrSampleBlobPads[i].fWidthMM == -999 || (m_intFailOptionMask & 0xC0) == 0)
                        arrResultList.Add("---");
                    else
                    {
                        fData = m_arrSampleBlobPads[i].fWidthMM * m_fMMToUnitValue;
                        arrResultList.Add(fData.ToString("F" + m_intDecimal));
                        if (m_blnWantUseGroupToleranceSetting)
                        {
                            int intGroupNo = ((BlobsFeatures)m_arrTemplateBlobPads[i]).intGroupID;
                            fMinData = ((BlobsFeatures)m_arrGroupTemplateBlobPads[intGroupNo]).fMinWidth * m_fMMToUnitValue;
                            fMaxData = ((BlobsFeatures)m_arrGroupTemplateBlobPads[intGroupNo]).fMaxWidth * m_fMMToUnitValue;
                        }
                        else
                        {
                            fMinData = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fMinWidth * m_fMMToUnitValue;
                            fMaxData = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fMaxWidth * m_fMMToUnitValue;
                        }
                        if (fData < fMinData || fData > fMaxData)
                        {
                            intResultTableFailMask |= 0x04;
                        }
                    }

                    if (m_arrSampleBlobPads[i].fHeightMM == -999 || (m_intFailOptionMask & 0xC0) == 0)
                        arrResultList.Add("---");
                    else
                    {
                        fData = m_arrSampleBlobPads[i].fHeightMM * m_fMMToUnitValue;
                        arrResultList.Add(fData.ToString("F" + m_intDecimal));
                        if (m_blnWantUseGroupToleranceSetting)
                        {
                            int intGroupNo = ((BlobsFeatures)m_arrTemplateBlobPads[i]).intGroupID;
                            fMinData = ((BlobsFeatures)m_arrGroupTemplateBlobPads[intGroupNo]).fMinLength * m_fMMToUnitValue;
                            fMaxData = ((BlobsFeatures)m_arrGroupTemplateBlobPads[intGroupNo]).fMaxLength * m_fMMToUnitValue;
                        }
                        else
                        {
                            fMinData = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fMinLength * m_fMMToUnitValue;
                            fMaxData = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fMaxLength * m_fMMToUnitValue;
                        }


                        //fMinData = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fMinLength * m_fMMToUnitValue;
                        //fMaxData = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fMaxLength * m_fMMToUnitValue;
                        if (fData < fMinData || fData > fMaxData)
                        {
                            intResultTableFailMask |= 0x08;
                        }
                    }
                }
                else
                {
                    if (m_arrSampleBlobPads[i].fHeightMM == -999 || (m_intFailOptionMask & 0xC0) == 0)
                        arrResultList.Add("---");
                    else
                    {
                        fData = m_arrSampleBlobPads[i].fHeightMM * m_fMMToUnitValue;
                        arrResultList.Add(fData.ToString("F" + m_intDecimal));
                        if (m_blnWantUseGroupToleranceSetting)
                        {
                            int intGroupNo = ((BlobsFeatures)m_arrTemplateBlobPads[i]).intGroupID;
                            fMinData = ((BlobsFeatures)m_arrGroupTemplateBlobPads[intGroupNo]).fMinWidth * m_fMMToUnitValue;
                            fMaxData = ((BlobsFeatures)m_arrGroupTemplateBlobPads[intGroupNo]).fMaxWidth * m_fMMToUnitValue;
                        }
                        else
                        {
                            // 2019 10 29 - CCENG: Min Max Width is used to compare Width Result Data. It wont turn to length comparison for any lenth mode
                            //fMinData = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fMinLength * m_fMMToUnitValue;
                            //fMaxData = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fMaxLength * m_fMMToUnitValue;
                            fMinData = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fMinWidth * m_fMMToUnitValue;
                            fMaxData = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fMaxWidth * m_fMMToUnitValue;
                        }

                        if (fData < fMinData || fData > fMaxData)
                        {
                            intResultTableFailMask |= 0x04;
                        }
                    }

                    if (m_arrSampleBlobPads[i].fWidthMM == -999 || (m_intFailOptionMask & 0xC0) == 0)
                        arrResultList.Add("---");
                    else
                    {
                        fData = m_arrSampleBlobPads[i].fWidthMM * m_fMMToUnitValue;
                        arrResultList.Add(fData.ToString("F" + m_intDecimal));
                        if (m_blnWantUseGroupToleranceSetting)
                        {
                            int intGroupNo = ((BlobsFeatures)m_arrTemplateBlobPads[i]).intGroupID;
                            fMinData = ((BlobsFeatures)m_arrGroupTemplateBlobPads[intGroupNo]).fMinLength * m_fMMToUnitValue;
                            fMaxData = ((BlobsFeatures)m_arrGroupTemplateBlobPads[intGroupNo]).fMaxLength * m_fMMToUnitValue;
                        }
                        else
                        {
                            // 2019 10 29 - CCENG: Min Max Height is used to compare Length Result Data. It wont turn to width comparison for any lenth mode
                            //fMinData = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fMinWidth * m_fMMToUnitValue;
                            //fMaxData = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fMaxWidth * m_fMMToUnitValue;
                            fMinData = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fMinLength * m_fMMToUnitValue;
                            fMaxData = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fMaxLength * m_fMMToUnitValue;
                        }

                        if (fData < fMinData || fData > fMaxData)
                        {
                            intResultTableFailMask |= 0x08;
                        }
                    }
                }
            }

            float fPitch = 0, fGap = 0;
            float fMinP = 0, fMaxP = 0, fMinG = 0, fMaxG = 0;
            if ((m_intFailOptionMask & 0x600) > 0 && GetPitchGapResult(i, ref fPitch, ref fGap))
            {
                if (m_blnWantUseGroupToleranceSetting)
                {
                    fData = fPitch * m_fMMToUnitValue;
                    arrResultList.Add(fData.ToString("F" + m_intDecimal));
                    int intGroupNo = ((BlobsFeatures)m_arrTemplateBlobPads[i]).intGroupID;
                    fMinData = ((BlobsFeatures)m_arrGroupTemplateBlobPads[intGroupNo]).fMinPitch * m_fMMToUnitValue;
                    fMaxData = ((BlobsFeatures)m_arrGroupTemplateBlobPads[intGroupNo]).fMaxPitch * m_fMMToUnitValue;
                    if (fData < fMinData || fData > fMaxData)
                    {
                        intResultTableFailMask |= 0x10;
                    }

                    fData = fGap * m_fMMToUnitValue;
                    arrResultList.Add(fData.ToString("F" + m_intDecimal));
                    intGroupNo = ((BlobsFeatures)m_arrTemplateBlobPads[i]).intGroupID;
                    fMinData = ((BlobsFeatures)m_arrGroupTemplateBlobPads[intGroupNo]).fMinGap * m_fMMToUnitValue;
                    fMaxData = ((BlobsFeatures)m_arrGroupTemplateBlobPads[intGroupNo]).fMaxGap * m_fMMToUnitValue;
                    if (fData < fMinData || fData > fMaxData)
                    {
                        intResultTableFailMask |= 0x20;
                    }
                }
                else
                {
                    if (GetPitchGapMinMax(i, ref fMinP, ref fMaxP, ref fMinG, ref fMaxG))
                    {
                        fData = fPitch * m_fMMToUnitValue;
                        arrResultList.Add(fData.ToString("F" + m_intDecimal));
                        fMinData = fMinP * m_fMMToUnitValue;
                        fMaxData = fMaxP * m_fMMToUnitValue;
                        if (fData < fMinData || fData > fMaxData)
                        {
                            intResultTableFailMask |= 0x10;
                        }

                        fData = fGap * m_fMMToUnitValue;
                        arrResultList.Add(fData.ToString("F" + m_intDecimal));
                        fMinData = fMinG * m_fMMToUnitValue;
                        fMaxData = fMaxG * m_fMMToUnitValue;
                        if (fData < fMinData || fData > fMaxData)
                        {
                            intResultTableFailMask |= 0x20;
                        }
                    }
                    else
                    {
                        arrResultList.Add("---");
                        arrResultList.Add("---");
                    }
                }
            }
            else
            {
                arrResultList.Add("---");
                arrResultList.Add("---");
            }

            // -------- Broken Area-------------------------
            if (m_blnBrokenPadInspected)
            {
                fData = m_arrSamplePadBroken[i].fAreaMM * m_fMMToUnitValueArea;
                arrResultList.Add(fData.ToString("F" + m_intDecimal2));
                if (m_blnWantUseGroupToleranceSetting)
                {
                    int intGroupNo = ((BlobsFeatures)m_arrTemplateBlobPads[i]).intGroupID;
                    fMaxData = ((BlobsFeatures)m_arrGroupTemplateBlobPads[intGroupNo]).fMaxBroken * m_fMMToUnitValueArea;
                }
                else
                {
                    fMaxData = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fMaxBroken * m_fMMToUnitValueArea;
                }
                if (fData > fMaxData)
                {
                    intResultTableFailMask |= 0x40;
                }
            }
            else
                arrResultList.Add("---");

            if (m_blnBrokenPadInspected)
            {
                // -------- Broken Length-------------------------
                fData = Math.Max(m_arrSamplePadBroken[i].fWidthMM, m_arrSamplePadBroken[i].fHeightMM) * m_fMMToUnitValue;
                arrResultList.Add(fData.ToString("F" + m_intDecimal));
                if (m_blnWantUseGroupToleranceSetting)
                {
                    int intGroupNo = ((BlobsFeatures)m_arrTemplateBlobPads[i]).intGroupID;
                    fMaxData = ((BlobsFeatures)m_arrGroupTemplateBlobPads[intGroupNo]).fMaxBrokenLength * m_fMMToUnitValue;
                }
                else
                {
                    fMaxData = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fMaxBrokenLength * m_fMMToUnitValue;
                }
                if (fData > fMaxData)
                {
                    intResultTableFailMask |= 0x80;
                }
            }
            else
                arrResultList.Add("---");

            if (m_blnExcessPadInspected)
            {
                // -------- Excess -------------------------
                fData = m_arrSamplePadExcess[i].fAreaMM * m_fMMToUnitValueArea;
                arrResultList.Add(fData.ToString("F" + m_intDecimal2));
                if (m_blnWantUseGroupToleranceSetting)
                {
                    int intGroupNo = ((BlobsFeatures)m_arrTemplateBlobPads[i]).intGroupID;
                    fMaxData = ((BlobsFeatures)m_arrGroupTemplateBlobPads[intGroupNo]).fMaxExcess * m_fMMToUnitValueArea;
                }
                else
                {
                    fMaxData = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fMaxExcess * m_fMMToUnitValueArea;
                }
                if (fData > fMaxData)
                {
                    intResultTableFailMask |= 0x100;
                }
            }
            else
                arrResultList.Add("---");

            // -------- Smear Length-------------------------
            if (m_arrSamplePadSmear[i].fSmearLength < 0)
            {
                fData = 0;
            }
            else
            {
                fData = m_arrSamplePadSmear[i].fSmearLength * m_fMMToUnitValue;
            }
            arrResultList.Add(fData.ToString("F" + m_intDecimal));
            if (m_blnWantUseGroupToleranceSetting)
            {
                int intGroupNo = ((BlobsFeatures)m_arrTemplateBlobPads[i]).intGroupID;
                fMaxData = ((BlobsFeatures)m_arrGroupTemplateBlobPads[intGroupNo]).fMaxSmearLength * m_fMMToUnitValue;
            }
            else
            {
                fMaxData = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fMaxSmearLength * m_fMMToUnitValue;
            }
            if (fData > fMaxData)
            {
                intResultTableFailMask |= 0x2000;
            }

            // -------- Edge Top-------------------------
            //if (m_arrSamplePadEdge[i].fEdgeTop < 0)
            //{
            //    fData = 0;
            //}
            //else
            //{
            fData = m_arrSamplePadEdge[i].fEdgeTop * m_fMMToUnitValue;
            //}
            arrResultList.Add(fData.ToString("F" + m_intDecimal));
            if (m_blnWantUseGroupToleranceSetting)
            {
                int intGroupNo = ((BlobsFeatures)m_arrTemplateBlobPads[i]).intGroupID;
                fMaxData = ((BlobsFeatures)m_arrGroupTemplateBlobPads[intGroupNo]).fEdgeLimitTop * m_fMMToUnitValue;
            }
            else
            {
                fMaxData = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fEdgeLimitTop * m_fMMToUnitValue;
            }
            if (fData < fMaxData)
            {
                intResultTableFailMask |= 0x200000;
            }

            // -------- Edge Right-------------------------
            //if (m_arrSamplePadEdge[i].fEdgeRight < 0)
            //{
            //    fData = 0;
            //}
            //else
            //{
            fData = m_arrSamplePadEdge[i].fEdgeRight * m_fMMToUnitValue;
            //}
            arrResultList.Add(fData.ToString("F" + m_intDecimal));
            if (m_blnWantUseGroupToleranceSetting)
            {
                int intGroupNo = ((BlobsFeatures)m_arrTemplateBlobPads[i]).intGroupID;
                fMaxData = ((BlobsFeatures)m_arrGroupTemplateBlobPads[intGroupNo]).fEdgeLimitRight * m_fMMToUnitValue;
            }
            else
            {
                fMaxData = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fEdgeLimitRight * m_fMMToUnitValue;
            }
            if (fData < fMaxData)
            {
                intResultTableFailMask |= 0x400000;
            }

            // -------- Edge Bottom-------------------------
            //if (m_arrSamplePadEdge[i].fEdgeBottom < 0)
            //{
            //    fData = 0;
            //}
            //else
            //{
            fData = m_arrSamplePadEdge[i].fEdgeBottom * m_fMMToUnitValue;
            //}
            arrResultList.Add(fData.ToString("F" + m_intDecimal));
            if (m_blnWantUseGroupToleranceSetting)
            {
                int intGroupNo = ((BlobsFeatures)m_arrTemplateBlobPads[i]).intGroupID;
                fMaxData = ((BlobsFeatures)m_arrGroupTemplateBlobPads[intGroupNo]).fEdgeLimitBottom * m_fMMToUnitValue;
            }
            else
            {
                fMaxData = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fEdgeLimitBottom * m_fMMToUnitValue;
            }
            if (fData < fMaxData)
            {
                intResultTableFailMask |= 0x800000;
            }

            // -------- Edge Left-------------------------
            //if (m_arrSamplePadEdge[i].fEdgeLeft < 0)
            //{
            //    fData = 0;
            //}
            //else
            //{
            fData = m_arrSamplePadEdge[i].fEdgeLeft * m_fMMToUnitValue;
            //}
            arrResultList.Add(fData.ToString("F" + m_intDecimal));
            if (m_blnWantUseGroupToleranceSetting)
            {
                int intGroupNo = ((BlobsFeatures)m_arrTemplateBlobPads[i]).intGroupID;
                fMaxData = ((BlobsFeatures)m_arrGroupTemplateBlobPads[intGroupNo]).fEdgeLimitLeft * m_fMMToUnitValue;
            }
            else
            {
                fMaxData = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fEdgeLimitLeft * m_fMMToUnitValue;
            }
            if (fData < fMaxData)
            {
                intResultTableFailMask |= 0x1000000;
            }

            // -------- Stand Off Top-------------------------
            int intReferTopBottom = 0;
            if (((BlobsFeatures)m_arrTemplateBlobPads[i]).blnCheckTop)
            {
                fData = m_arrSamplePadStandOff[i].fStandOffTop * m_fMMToUnitValue;
                arrResultList.Add(fData.ToString("F" + m_intDecimal));
                if (m_blnWantUseGroupToleranceSetting)
                {
                    int intGroupNo = ((BlobsFeatures)m_arrTemplateBlobPads[i]).intGroupID;
                    fMaxData = ((BlobsFeatures)m_arrGroupTemplateBlobPads[intGroupNo]).fMaxStandOffTop * m_fMMToUnitValue;
                    intReferTopBottom = ((BlobsFeatures)m_arrGroupTemplateBlobPads[intGroupNo]).intReferTopBottom;
                }
                else
                {
                    fMaxData = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fMaxStandOffTop * m_fMMToUnitValue;
                    intReferTopBottom = ((BlobsFeatures)m_arrTemplateBlobPads[i]).intReferTopBottom;
                }
                if (intReferTopBottom == 0)
                {
                    if (fData < fMaxData)
                    {
                        intResultTableFailMask |= 0x2000000;
                    }
                }
                else
                {
                    if (fData > fMaxData)
                    {
                        intResultTableFailMask |= 0x2000000;
                    }
                }
            }
            else
            {
                arrResultList.Add("---");
            }

            // -------- Stand Off Bottom-------------------------
            if (((BlobsFeatures)m_arrTemplateBlobPads[i]).blnCheckBottom)
            {
                fData = m_arrSamplePadStandOff[i].fStandOffBottom * m_fMMToUnitValue;
                arrResultList.Add(fData.ToString("F" + m_intDecimal));
                if (m_blnWantUseGroupToleranceSetting)
                {
                    int intGroupNo = ((BlobsFeatures)m_arrTemplateBlobPads[i]).intGroupID;
                    fMaxData = ((BlobsFeatures)m_arrGroupTemplateBlobPads[intGroupNo]).fMaxStandOffBottom * m_fMMToUnitValue;
                    intReferTopBottom = ((BlobsFeatures)m_arrGroupTemplateBlobPads[intGroupNo]).intReferTopBottom;
                }
                else
                {
                    fMaxData = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fMaxStandOffBottom * m_fMMToUnitValue;
                    intReferTopBottom = ((BlobsFeatures)m_arrTemplateBlobPads[i]).intReferTopBottom;
                }
                if (intReferTopBottom == 0)
                {
                    if (fData > fMaxData)
                    {
                        intResultTableFailMask |= 0x4000000;
                    }
                }
                else
                {
                    if (fData < fMaxData)
                    {
                        intResultTableFailMask |= 0x4000000;
                    }
                }
            }
            else
            {
                arrResultList.Add("---");
            }

            // -------- Stand Off Left-------------------------
            int intReferLeftRight = 0;
            if (((BlobsFeatures)m_arrTemplateBlobPads[i]).blnCheckLeft)
            {
                fData = m_arrSamplePadStandOff[i].fStandOffLeft * m_fMMToUnitValue;
                arrResultList.Add(fData.ToString("F" + m_intDecimal));
                if (m_blnWantUseGroupToleranceSetting)
                {
                    int intGroupNo = ((BlobsFeatures)m_arrTemplateBlobPads[i]).intGroupID;
                    fMaxData = ((BlobsFeatures)m_arrGroupTemplateBlobPads[intGroupNo]).fMaxStandOffLeft * m_fMMToUnitValue;
                    intReferLeftRight = ((BlobsFeatures)m_arrGroupTemplateBlobPads[intGroupNo]).intReferLeftRight;
                }
                else
                {
                    fMaxData = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fMaxStandOffLeft * m_fMMToUnitValue;
                    intReferLeftRight = ((BlobsFeatures)m_arrTemplateBlobPads[i]).intReferLeftRight;
                }
                if (intReferLeftRight == 0)
                {
                    if (fData < fMaxData)
                    {
                        intResultTableFailMask |= 0x8000000;
                    }
                }
                else
                {
                    if (fData > fMaxData)
                    {
                        intResultTableFailMask |= 0x8000000;
                    }
                }
            }
            else
            {
                arrResultList.Add("---");
            }

            // -------- Stand Off Right-------------------------
            if (((BlobsFeatures)m_arrTemplateBlobPads[i]).blnCheckRight)
            {
                fData = m_arrSamplePadStandOff[i].fStandOffRight * m_fMMToUnitValue;
                arrResultList.Add(fData.ToString("F" + m_intDecimal));
                if (m_blnWantUseGroupToleranceSetting)
                {
                    int intGroupNo = ((BlobsFeatures)m_arrTemplateBlobPads[i]).intGroupID;
                    fMaxData = ((BlobsFeatures)m_arrGroupTemplateBlobPads[intGroupNo]).fMaxStandOffRight * m_fMMToUnitValue;
                    intReferLeftRight = ((BlobsFeatures)m_arrGroupTemplateBlobPads[intGroupNo]).intReferLeftRight;
                }
                else
                {
                    fMaxData = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fMaxStandOffRight * m_fMMToUnitValue;
                    intReferLeftRight = ((BlobsFeatures)m_arrTemplateBlobPads[i]).intReferLeftRight;
                }
                if (intReferLeftRight == 0)
                {
                    if (fData > fMaxData)
                    {
                        intResultTableFailMask |= 0x10000000;
                    }
                }
                else
                {
                    if (fData < fMaxData)
                    {
                        intResultTableFailMask |= 0x10000000;
                    }
                }
            }
            else
            {
                arrResultList.Add("---");
            }

            // -------- Edge Distance Top-------------------------
            if (m_intResultPadNoEdgeDistance_Top < 0 || m_intResultPadNoEdgeDistance_Top != i)
                arrResultList.Add("---");
            else
            {
                fData = m_fResultPadEdgeDistance_Top * m_fMMToUnitValue;
                arrResultList.Add(fData.ToString("F" + m_intDecimal));

                fMinData = m_fEdgeDistanceMin_Top * m_fMMToUnitValue;
                fMaxData = m_fEdgeDistanceMax_Top * m_fMMToUnitValue;

                if (fData < fMinData || fData > fMaxData)
                {
                    intResultTableFailMask |= 0x40000000;
                }
            }

            // -------- Edge Distance Right-------------------------
            if (m_intResultPadNoEdgeDistance_Right < 0 || m_intResultPadNoEdgeDistance_Right != i)
                arrResultList.Add("---");
            else
            {
                fData = m_fResultPadEdgeDistance_Right * m_fMMToUnitValue;
                arrResultList.Add(fData.ToString("F" + m_intDecimal));

                fMinData = m_fEdgeDistanceMin_Right * m_fMMToUnitValue;
                fMaxData = m_fEdgeDistanceMax_Right * m_fMMToUnitValue;

                if (fData < fMinData || fData > fMaxData)
                {
                    intResultTableFailMask |= 0x80000000;
                }
            }

            // -------- Edge Distance Bottom-------------------------
            if (m_intResultPadNoEdgeDistance_Bottom < 0 || m_intResultPadNoEdgeDistance_Bottom != i)
                arrResultList.Add("---");
            else
            {
                fData = m_fResultPadEdgeDistance_Bottom * m_fMMToUnitValue;
                arrResultList.Add(fData.ToString("F" + m_intDecimal));

                fMinData = m_fEdgeDistanceMin_Bottom * m_fMMToUnitValue;
                fMaxData = m_fEdgeDistanceMax_Bottom * m_fMMToUnitValue;

                if (fData < fMinData || fData > fMaxData)
                {
                    intResultTableFailMask |= 0x100000000;
                }
            }

            // -------- Edge Distance Left-------------------------
            if (m_intResultPadNoEdgeDistance_Left < 0 || m_intResultPadNoEdgeDistance_Left != i)
                arrResultList.Add("---");
            else
            {
                fData = m_fResultPadEdgeDistance_Left * m_fMMToUnitValue;
                arrResultList.Add(fData.ToString("F" + m_intDecimal));

                fMinData = m_fEdgeDistanceMin_Left * m_fMMToUnitValue;
                fMaxData = m_fEdgeDistanceMax_Left * m_fMMToUnitValue;

                if (fData < fMinData || fData > fMaxData)
                {
                    intResultTableFailMask |= 0x200000000;
                }
            }

            // Line 3 Length
            if (m_arrSampleBlobPads[i].fLine3MM == -999 || (m_intFailOptionMask & 0xC0) == 0)
            {
                if ((m_arrSampleBlobPads[i].intFailMask & 0x10000) > 0)
                {
                    intResultTableFailMask |= 0x10000;
                }

                arrResultList.Add("---");
            }
            else
            {
                fData = m_arrSampleBlobPads[i].fLine3MM * m_fMMToUnitValue;
                arrResultList.Add(fData.ToString("F" + m_intDecimal));
                if (m_blnWantUseGroupToleranceSetting)
                {
                    int intGroupNo = ((BlobsFeatures)m_arrTemplateBlobPads[i]).intGroupID;
                    fMinData = ((BlobsFeatures)m_arrGroupTemplateBlobPads[intGroupNo]).fMinLine3 * m_fMMToUnitValue;
                    fMaxData = ((BlobsFeatures)m_arrGroupTemplateBlobPads[intGroupNo]).fMaxLine3 * m_fMMToUnitValue;
                }
                else
                {
                    fMinData = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fMinLine3 * m_fMMToUnitValue;
                    fMaxData = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fMaxLine3 * m_fMMToUnitValue;
                }
                if (fData < fMinData || fData > fMaxData)
                {
                    intResultTableFailMask |= 0x10000;
                }
            }

            // Line 4 Length
            if (m_arrSampleBlobPads[i].fLine4MM == -999 || (m_intFailOptionMask & 0xC0) == 0)
            {
                if ((m_arrSampleBlobPads[i].intFailMask & 0x20000) > 0)
                {
                    intResultTableFailMask |= 0x20000;
                }

                arrResultList.Add("---");
            }
            else
            {
                fData = m_arrSampleBlobPads[i].fLine4MM * m_fMMToUnitValue;
                arrResultList.Add(fData.ToString("F" + m_intDecimal));
                if (m_blnWantUseGroupToleranceSetting)
                {
                    int intGroupNo = ((BlobsFeatures)m_arrTemplateBlobPads[i]).intGroupID;
                    fMinData = ((BlobsFeatures)m_arrGroupTemplateBlobPads[intGroupNo]).fMinLine4 * m_fMMToUnitValue;
                    fMaxData = ((BlobsFeatures)m_arrGroupTemplateBlobPads[intGroupNo]).fMaxLine4 * m_fMMToUnitValue;
                }
                else
                {
                    fMinData = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fMinLine4 * m_fMMToUnitValue;
                    fMaxData = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fMaxLine4 * m_fMMToUnitValue;
                }
                if (fData < fMinData || fData > fMaxData)
                {
                    intResultTableFailMask |= 0x20000;
                }
            }

            // Line 5 Length
            if (m_arrSampleBlobPads[i].fLine5MM == -999 || (m_intFailOptionMask & 0xC0) == 0)
            {
                if ((m_arrSampleBlobPads[i].intFailMask & 0x40000) > 0)
                {
                    intResultTableFailMask |= 0x40000;
                }

                arrResultList.Add("---");
            }
            else
            {
                fData = m_arrSampleBlobPads[i].fLine5MM * m_fMMToUnitValue;
                arrResultList.Add(fData.ToString("F" + m_intDecimal));
                if (m_blnWantUseGroupToleranceSetting)
                {
                    int intGroupNo = ((BlobsFeatures)m_arrTemplateBlobPads[i]).intGroupID;
                    fMinData = ((BlobsFeatures)m_arrGroupTemplateBlobPads[intGroupNo]).fMinLine5 * m_fMMToUnitValue;
                    fMaxData = ((BlobsFeatures)m_arrGroupTemplateBlobPads[intGroupNo]).fMaxLine5 * m_fMMToUnitValue;
                }
                else
                {
                    fMinData = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fMinLine5 * m_fMMToUnitValue;
                    fMaxData = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fMaxLine5 * m_fMMToUnitValue;
                }
                if (fData < fMinData || fData > fMaxData)
                {
                    intResultTableFailMask |= 0x40000;
                }
            }

            // Line 6 Length
            if (m_arrSampleBlobPads[i].fLine6MM == -999 || (m_intFailOptionMask & 0xC0) == 0)
            {
                if ((m_arrSampleBlobPads[i].intFailMask & 0x80000) > 0)
                {
                    intResultTableFailMask |= 0x80000;
                }

                arrResultList.Add("---");
            }
            else
            {
                fData = m_arrSampleBlobPads[i].fLine6MM * m_fMMToUnitValue;
                arrResultList.Add(fData.ToString("F" + m_intDecimal));
                if (m_blnWantUseGroupToleranceSetting)
                {
                    int intGroupNo = ((BlobsFeatures)m_arrTemplateBlobPads[i]).intGroupID;
                    fMinData = ((BlobsFeatures)m_arrGroupTemplateBlobPads[intGroupNo]).fMinLine6 * m_fMMToUnitValue;
                    fMaxData = ((BlobsFeatures)m_arrGroupTemplateBlobPads[intGroupNo]).fMaxLine6 * m_fMMToUnitValue;
                }
                else
                {
                    fMinData = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fMinLine6 * m_fMMToUnitValue;
                    fMaxData = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fMaxLine6 * m_fMMToUnitValue;
                }
                if (fData < fMinData || fData > fMaxData)
                {
                    intResultTableFailMask |= 0x80000;
                }
            }

            // Line 7 Length
            if (m_arrSampleBlobPads[i].fLine7MM == -999 || (m_intFailOptionMask & 0xC0) == 0)
            {
                if ((m_arrSampleBlobPads[i].intFailMask & 0x100000) > 0)
                {
                    intResultTableFailMask |= 0x100000;
                }

                arrResultList.Add("---");
            }
            else
            {
                fData = m_arrSampleBlobPads[i].fLine7MM * m_fMMToUnitValue;
                arrResultList.Add(fData.ToString("F" + m_intDecimal));
                if (m_blnWantUseGroupToleranceSetting)
                {
                    int intGroupNo = ((BlobsFeatures)m_arrTemplateBlobPads[i]).intGroupID;
                    fMinData = ((BlobsFeatures)m_arrGroupTemplateBlobPads[intGroupNo]).fMinLine7 * m_fMMToUnitValue;
                    fMaxData = ((BlobsFeatures)m_arrGroupTemplateBlobPads[intGroupNo]).fMaxLine7 * m_fMMToUnitValue;
                }
                else
                {
                    fMinData = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fMinLine7 * m_fMMToUnitValue;
                    fMaxData = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fMaxLine7 * m_fMMToUnitValue;
                }
                if (fData < fMinData || fData > fMaxData)
                {
                    intResultTableFailMask |= 0x100000;
                }
            }
            
            // Line 8 Length
            if (m_arrSampleBlobPads[i].fLine8MM == -999 || (m_intFailOptionMask & 0xC0) == 0)
            {
                if ((m_arrSampleBlobPads[i].intFailMask & 0x800000000) > 0)
                {
                    intResultTableFailMask |= 0x1000000000;
                }

                arrResultList.Add("---");
            }
            else
            {
                fData = m_arrSampleBlobPads[i].fLine8MM * m_fMMToUnitValue;
                arrResultList.Add(fData.ToString("F" + m_intDecimal));
                if (m_blnWantUseGroupToleranceSetting)
                {
                    int intGroupNo = ((BlobsFeatures)m_arrTemplateBlobPads[i]).intGroupID;
                    fMinData = ((BlobsFeatures)m_arrGroupTemplateBlobPads[intGroupNo]).fMinLine8 * m_fMMToUnitValue;
                    fMaxData = ((BlobsFeatures)m_arrGroupTemplateBlobPads[intGroupNo]).fMaxLine8 * m_fMMToUnitValue;
                }
                else
                {
                    fMinData = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fMinLine8 * m_fMMToUnitValue;
                    fMaxData = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fMaxLine8 * m_fMMToUnitValue;
                }
                if (fData < fMinData || fData > fMaxData)
                {
                    intResultTableFailMask |= 0x1000000000;
                }
            }

            // Line 9 Length
            if (m_arrSampleBlobPads[i].fLine9MM == -999 || (m_intFailOptionMask & 0xC0) == 0)
            {
                if ((m_arrSampleBlobPads[i].intFailMask & 0x1000000000) > 0)
                {
                    intResultTableFailMask |= 0x2000000000;
                }

                arrResultList.Add("---");
            }
            else
            {
                fData = m_arrSampleBlobPads[i].fLine9MM * m_fMMToUnitValue;
                arrResultList.Add(fData.ToString("F" + m_intDecimal));
                if (m_blnWantUseGroupToleranceSetting)
                {
                    int intGroupNo = ((BlobsFeatures)m_arrTemplateBlobPads[i]).intGroupID;
                    fMinData = ((BlobsFeatures)m_arrGroupTemplateBlobPads[intGroupNo]).fMinLine9 * m_fMMToUnitValue;
                    fMaxData = ((BlobsFeatures)m_arrGroupTemplateBlobPads[intGroupNo]).fMaxLine9 * m_fMMToUnitValue;
                }
                else
                {
                    fMinData = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fMinLine9 * m_fMMToUnitValue;
                    fMaxData = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fMaxLine9 * m_fMMToUnitValue;
                }
                if (fData < fMinData || fData > fMaxData)
                {
                    intResultTableFailMask |= 0x2000000000;
                }
            }

            // Line 10 Length
            if (m_arrSampleBlobPads[i].fLine10MM == -999 || (m_intFailOptionMask & 0xC0) == 0)
            {
                if ((m_arrSampleBlobPads[i].intFailMask & 0x2000000000) > 0)
                {
                    intResultTableFailMask |= 0x4000000000;
                }

                arrResultList.Add("---");
            }
            else
            {
                fData = m_arrSampleBlobPads[i].fLine10MM * m_fMMToUnitValue;
                arrResultList.Add(fData.ToString("F" + m_intDecimal));
                if (m_blnWantUseGroupToleranceSetting)
                {
                    int intGroupNo = ((BlobsFeatures)m_arrTemplateBlobPads[i]).intGroupID;
                    fMinData = ((BlobsFeatures)m_arrGroupTemplateBlobPads[intGroupNo]).fMinLine10 * m_fMMToUnitValue;
                    fMaxData = ((BlobsFeatures)m_arrGroupTemplateBlobPads[intGroupNo]).fMaxLine10 * m_fMMToUnitValue;
                }
                else
                {
                    fMinData = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fMinLine10 * m_fMMToUnitValue;
                    fMaxData = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fMaxLine10 * m_fMMToUnitValue;
                }
                if (fData < fMinData || fData > fMaxData)
                {
                    intResultTableFailMask |= 0x4000000000;
                }
            }

            // Line 11 Length
            if (m_arrSampleBlobPads[i].fLine11MM == -999 || (m_intFailOptionMask & 0xC0) == 0)
            {
                if ((m_arrSampleBlobPads[i].intFailMask & 0x4000000000) > 0)
                {
                    intResultTableFailMask |= 0x8000000000;
                }

                arrResultList.Add("---");
            }
            else
            {
                fData = m_arrSampleBlobPads[i].fLine11MM * m_fMMToUnitValue;
                arrResultList.Add(fData.ToString("F" + m_intDecimal));
                if (m_blnWantUseGroupToleranceSetting)
                {
                    int intGroupNo = ((BlobsFeatures)m_arrTemplateBlobPads[i]).intGroupID;
                    fMinData = ((BlobsFeatures)m_arrGroupTemplateBlobPads[intGroupNo]).fMinLine11 * m_fMMToUnitValue;
                    fMaxData = ((BlobsFeatures)m_arrGroupTemplateBlobPads[intGroupNo]).fMaxLine11 * m_fMMToUnitValue;
                }
                else
                {
                    fMinData = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fMinLine11 * m_fMMToUnitValue;
                    fMaxData = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fMaxLine11 * m_fMMToUnitValue;
                }
                if (fData < fMinData || fData > fMaxData)
                {
                    intResultTableFailMask |= 0x8000000000;
                }
            }

            // Line 12 Length
            if (m_arrSampleBlobPads[i].fLine12MM == -999 || (m_intFailOptionMask & 0xC0) == 0)
            {
                if ((m_arrSampleBlobPads[i].intFailMask & 0x8000000000) > 0)
                {
                    intResultTableFailMask |= 0x10000000000;
                }

                arrResultList.Add("---");
            }
            else
            {
                fData = m_arrSampleBlobPads[i].fLine12MM * m_fMMToUnitValue;
                arrResultList.Add(fData.ToString("F" + m_intDecimal));
                if (m_blnWantUseGroupToleranceSetting)
                {
                    int intGroupNo = ((BlobsFeatures)m_arrTemplateBlobPads[i]).intGroupID;
                    fMinData = ((BlobsFeatures)m_arrGroupTemplateBlobPads[intGroupNo]).fMinLine12 * m_fMMToUnitValue;
                    fMaxData = ((BlobsFeatures)m_arrGroupTemplateBlobPads[intGroupNo]).fMaxLine12 * m_fMMToUnitValue;
                }
                else
                {
                    fMinData = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fMinLine12 * m_fMMToUnitValue;
                    fMaxData = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fMaxLine12 * m_fMMToUnitValue;
                }
                if (fData < fMinData || fData > fMaxData)
                {
                    intResultTableFailMask |= 0x10000000000;
                }
            }

            // -------- Span X -------------------------
            if (m_fResultPadSpanX == -999)
                arrResultList.Add("---");
            else
            {
                fData = m_fResultPadSpanX * m_fMMToUnitValue;
                arrResultList.Add(fData.ToString("F" + m_intDecimal));

                fMinData = m_fMinSpanX * m_fMMToUnitValue;
                fMaxData = m_fMaxSpanX * m_fMMToUnitValue;

                if (fData < fMinData || fData > fMaxData)
                {
                    intResultTableFailMask |= 0x400000000;
                }
            }

            // -------- Span Y -------------------------
            if (m_fResultPadSpanY == -999)
                arrResultList.Add("---");
            else
            {
                fData = m_fResultPadSpanY * m_fMMToUnitValue;
                arrResultList.Add(fData.ToString("F" + m_intDecimal));

                fMinData = m_fMinSpanY * m_fMMToUnitValue;
                fMaxData = m_fMaxSpanY * m_fMMToUnitValue;

                if (fData < fMinData || fData > fMaxData)
                {
                    intResultTableFailMask |= 0x800000000;
                }
            }

            //Missing Mark
            if ((m_arrSampleBlobPads[i].intFailMask & 0x04) > 0)
            {
                intResultTableFailMask |= 0x20000000;
            }

            arrResultList.Add(intResultTableFailMask.ToString());

            return arrResultList;

        }

        public List<string> GetResult_WithPassFailIndicator(int intMatchTemplateIndex)
        {
            List<string> arrResultList = new List<string>();

            int intResultTableFailMask = 0;
            float fData, fMaxData, fMinData;
            int i = intMatchTemplateIndex;

            if (m_arrSampleBlobPads == null || i >= m_arrSampleBlobPads.Length || !((BlobsFeatures)m_arrTemplateBlobPads[i]).blnEnable)
            {
                arrResultList.Add("---");
                arrResultList.Add("---");
                arrResultList.Add("---");
                arrResultList.Add("---");
                arrResultList.Add("---");
                arrResultList.Add("---");
                arrResultList.Add("---");
                arrResultList.Add("---");
                arrResultList.Add("---");
                arrResultList.Add("---");
                arrResultList.Add("---");
                arrResultList.Add(intResultTableFailMask.ToString());
                return arrResultList;
            }

            if (m_arrSampleBlobPads[i].fOffSetMM == -999)
                arrResultList.Add("---");
            else
            {
                fData = m_arrSampleBlobPads[i].fOffSetMM * m_fMMToUnitValue;
                arrResultList.Add(fData.ToString("F" + m_intDecimal));
                if (m_blnWantUseGroupToleranceSetting)
                {
                    int intGroupNo = ((BlobsFeatures)m_arrTemplateBlobPads[i]).intGroupID;
                    fMaxData = ((BlobsFeatures)m_arrGroupTemplateBlobPads[intGroupNo]).fOffSet * m_fMMToUnitValue;
                }
                else
                {
                    fMaxData = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fOffSet * m_fMMToUnitValue;
                }
                if (fData > fMaxData)
                    intResultTableFailMask |= 0x01;
            }

            if (m_arrSampleBlobPads[i].fAreaMM == -999)
                arrResultList.Add("---");
            else
            {
                fData = m_arrSampleBlobPads[i].fAreaMM * m_fMMToUnitValueArea;
                arrResultList.Add(fData.ToString("F" + m_intDecimal2));
                if (m_blnWantUseGroupToleranceSetting)
                {
                    int intGroupNo = ((BlobsFeatures)m_arrTemplateBlobPads[i]).intGroupID;
                    fMinData = ((BlobsFeatures)m_arrGroupTemplateBlobPads[intGroupNo]).fMinArea * m_fMMToUnitValueArea;
                    fMaxData = ((BlobsFeatures)m_arrGroupTemplateBlobPads[intGroupNo]).fMaxArea * m_fMMToUnitValueArea;
                }
                else
                {
                    fMinData = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fMinArea * m_fMMToUnitValueArea;
                    fMaxData = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fMaxArea * m_fMMToUnitValueArea;
                }
                if (fData < fMinData || fData > fMaxData)
                {
                    intResultTableFailMask |= 0x02;
                }
            }

            if (((BlobsFeatures)m_arrTemplateBlobPads[i]).intLengthMode == 1)
            {
                if (m_arrSampleBlobPads[i].fWidthMM == -999)
                    arrResultList.Add("---");
                else
                {
                    fData = m_arrSampleBlobPads[i].fWidthMM * m_fMMToUnitValue;
                    arrResultList.Add(fData.ToString("F" + m_intDecimal));
                    if (m_blnWantUseGroupToleranceSetting)
                    {
                        int intGroupNo = ((BlobsFeatures)m_arrTemplateBlobPads[i]).intGroupID;
                        fMinData = ((BlobsFeatures)m_arrGroupTemplateBlobPads[intGroupNo]).fMinWidth * m_fMMToUnitValue;
                        fMaxData = ((BlobsFeatures)m_arrGroupTemplateBlobPads[intGroupNo]).fMaxWidth * m_fMMToUnitValue;
                    }
                    else
                    {
                        fMinData = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fMinWidth * m_fMMToUnitValue;
                        fMaxData = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fMaxWidth * m_fMMToUnitValue;
                    }
                    if (fData < fMinData || fData > fMaxData)
                    {
                        intResultTableFailMask |= 0x04;
                    }
                }

                if (m_arrSampleBlobPads[i].fHeightMM == -999)
                    arrResultList.Add("---");
                else
                {
                    fData = m_arrSampleBlobPads[i].fHeightMM * m_fMMToUnitValue;
                    arrResultList.Add(fData.ToString("F" + m_intDecimal));
                    if (m_blnWantUseGroupToleranceSetting)
                    {
                        int intGroupNo = ((BlobsFeatures)m_arrTemplateBlobPads[i]).intGroupID;
                        fMinData = ((BlobsFeatures)m_arrGroupTemplateBlobPads[intGroupNo]).fMinLength * m_fMMToUnitValue;
                        fMaxData = ((BlobsFeatures)m_arrGroupTemplateBlobPads[intGroupNo]).fMaxLength * m_fMMToUnitValue;
                    }
                    else
                    {
                        fMinData = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fMinLength * m_fMMToUnitValue;
                        fMaxData = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fMaxLength * m_fMMToUnitValue;
                    }


                    fMinData = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fMinLength * m_fMMToUnitValue;
                    fMaxData = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fMaxLength * m_fMMToUnitValue;
                    if (fData < fMinData || fData > fMaxData)
                    {
                        intResultTableFailMask |= 0x08;
                    }
                }
            }
            else
            {
                if (m_arrSampleBlobPads[i].fHeightMM == -999)
                    arrResultList.Add("---");
                else
                {
                    fData = m_arrSampleBlobPads[i].fHeightMM * m_fMMToUnitValue;
                    arrResultList.Add(fData.ToString("F" + m_intDecimal));
                    if (m_blnWantUseGroupToleranceSetting)
                    {
                        int intGroupNo = ((BlobsFeatures)m_arrTemplateBlobPads[i]).intGroupID;
                        fMinData = ((BlobsFeatures)m_arrGroupTemplateBlobPads[intGroupNo]).fMinWidth * m_fMMToUnitValue;
                        fMaxData = ((BlobsFeatures)m_arrGroupTemplateBlobPads[intGroupNo]).fMaxWidth * m_fMMToUnitValue;
                    }
                    else
                    {
                        // 2019 10 30 - CCENG: m_arrTemplateBlobPads fMinWidth, fMaxWidth, fMinHeigt, fMaxLength are not affacted by lengthmode.
                        //fMinData = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fMinLength * m_fMMToUnitValue;
                        //fMaxData = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fMaxLength * m_fMMToUnitValue;
                        fMinData = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fMinWidth * m_fMMToUnitValue;
                        fMaxData = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fMaxWidth * m_fMMToUnitValue;
                    }

                    if (fData < fMinData || fData > fMaxData)
                    {
                        intResultTableFailMask |= 0x04;
                    }
                }

                if (m_arrSampleBlobPads[i].fWidthMM == -999)
                    arrResultList.Add("---");
                else
                {
                    fData = m_arrSampleBlobPads[i].fWidthMM * m_fMMToUnitValue;
                    arrResultList.Add(fData.ToString("F" + m_intDecimal));
                    if (m_blnWantUseGroupToleranceSetting)
                    {
                        int intGroupNo = ((BlobsFeatures)m_arrTemplateBlobPads[i]).intGroupID;
                        fMinData = ((BlobsFeatures)m_arrGroupTemplateBlobPads[intGroupNo]).fMinLength * m_fMMToUnitValue;
                        fMaxData = ((BlobsFeatures)m_arrGroupTemplateBlobPads[intGroupNo]).fMaxLength * m_fMMToUnitValue;
                    }
                    else
                    {
                        // 2019 10 30 - CCENG: m_arrTemplateBlobPads fMinWidth, fMaxWidth, fMinHeigt, fMaxLength are not affacted by lengthmode.
                        //fMinData = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fMinWidth * m_fMMToUnitValue;
                        //fMaxData = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fMaxWidth * m_fMMToUnitValue;
                        fMinData = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fMinLength * m_fMMToUnitValue;
                        fMaxData = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fMaxLength * m_fMMToUnitValue;
                    }

                    if (fData < fMinData || fData > fMaxData)
                    {
                        intResultTableFailMask |= 0x08;
                    }
                }
            }

            float fPitch = 0, fGap = 0;
            float fMinP = 0, fMaxP = 0, fMinG = 0, fMaxG = 0;
            if (GetPitchGapResult(i, ref fPitch, ref fGap))
            {
                if (m_blnWantUseGroupToleranceSetting)
                {
                    fData = fPitch * m_fMMToUnitValue;
                    arrResultList.Add(fData.ToString("F" + m_intDecimal));
                    int intGroupNo = ((BlobsFeatures)m_arrTemplateBlobPads[i]).intGroupID;
                    fMinData = ((BlobsFeatures)m_arrGroupTemplateBlobPads[intGroupNo]).fMinPitch * m_fMMToUnitValue;
                    fMaxData = ((BlobsFeatures)m_arrGroupTemplateBlobPads[intGroupNo]).fMaxPitch * m_fMMToUnitValue;
                    if (fData < fMinData || fData > fMaxData)
                    {
                        intResultTableFailMask |= 0x10;
                    }

                    fData = fGap * m_fMMToUnitValue;
                    arrResultList.Add(fData.ToString("F" + m_intDecimal));
                    intGroupNo = ((BlobsFeatures)m_arrTemplateBlobPads[i]).intGroupID;
                    fMinData = ((BlobsFeatures)m_arrGroupTemplateBlobPads[intGroupNo]).fMinGap * m_fMMToUnitValue;
                    fMaxData = ((BlobsFeatures)m_arrGroupTemplateBlobPads[intGroupNo]).fMaxGap * m_fMMToUnitValue;
                    if (fData < fMinData || fData > fMaxData)
                    {
                        intResultTableFailMask |= 0x20;
                    }
                }
                else
                {
                    if (GetPitchGapMinMax(i, ref fMinP, ref fMaxP, ref fMinG, ref fMaxG))
                    {
                        fData = fPitch * m_fMMToUnitValue;
                        arrResultList.Add(fData.ToString("F" + m_intDecimal));
                        fMinData = fMinP * m_fMMToUnitValue;
                        fMaxData = fMaxP * m_fMMToUnitValue;
                        if (fData < fMinData || fData > fMaxData)
                        {
                            intResultTableFailMask |= 0x10;
                        }

                        fData = fGap * m_fMMToUnitValue;
                        arrResultList.Add(fData.ToString("F" + m_intDecimal));
                        fMinData = fMinG * m_fMMToUnitValue;
                        fMaxData = fMaxG * m_fMMToUnitValue;
                        if (fData < fMinData || fData > fMaxData)
                        {
                            intResultTableFailMask |= 0x20;
                        }
                    }
                    else
                    {
                        arrResultList.Add("---");
                        arrResultList.Add("---");
                    }
                }
            }
            else
            {
                arrResultList.Add("---");
                arrResultList.Add("---");
            }

            // -------- Broken Area-------------------------
            fData = m_arrSamplePadBroken[i].fAreaMM * m_fMMToUnitValueArea;
            arrResultList.Add(fData.ToString("F" + m_intDecimal2));
            if (m_blnWantUseGroupToleranceSetting)
            {
                int intGroupNo = ((BlobsFeatures)m_arrTemplateBlobPads[i]).intGroupID;
                fMaxData = ((BlobsFeatures)m_arrGroupTemplateBlobPads[intGroupNo]).fMaxBroken * m_fMMToUnitValueArea;
            }
            else
            {
                fMaxData = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fMaxBroken * m_fMMToUnitValueArea;
            }
            if (fData > fMaxData)
            {
                intResultTableFailMask |= 0x40;
            }

            // -------- Broken Length-------------------------
            fData = Math.Max(m_arrSamplePadBroken[i].fWidthMM, m_arrSamplePadBroken[i].fHeightMM) * m_fMMToUnitValue;
            arrResultList.Add(fData.ToString("F" + m_intDecimal));
            if (m_blnWantUseGroupToleranceSetting)
            {
                int intGroupNo = ((BlobsFeatures)m_arrTemplateBlobPads[i]).intGroupID;
                fMaxData = ((BlobsFeatures)m_arrGroupTemplateBlobPads[intGroupNo]).fMaxBrokenLength * m_fMMToUnitValue;
            }
            else
            {
                fMaxData = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fMaxBrokenLength * m_fMMToUnitValue;
            }
            if (fData > fMaxData)
            {
                intResultTableFailMask |= 0x80;
            }

            // -------- Excess -------------------------
            fData = m_arrSamplePadExcess[i].fAreaMM * m_fMMToUnitValueArea;
            arrResultList.Add(fData.ToString("F" + m_intDecimal2));
            if (m_blnWantUseGroupToleranceSetting)
            {
                int intGroupNo = ((BlobsFeatures)m_arrTemplateBlobPads[i]).intGroupID;
                fMaxData = ((BlobsFeatures)m_arrGroupTemplateBlobPads[intGroupNo]).fMaxExcess * m_fMMToUnitValueArea;
            }
            else
            {
                fMaxData = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fMaxExcess * m_fMMToUnitValueArea;
            }
            if (fData > fMaxData)
            {
                intResultTableFailMask |= 0x100;
            }

            // -------- Smear Length-------------------------
            if (m_arrSamplePadSmear[i].fSmearLength < 0)
            {
                fData = 0;
            }
            else
            {
                fData = m_arrSamplePadSmear[i].fSmearLength * m_fMMToUnitValue;
            }
            arrResultList.Add(fData.ToString("F" + m_intDecimal));
            if (m_blnWantUseGroupToleranceSetting)
            {
                int intGroupNo = ((BlobsFeatures)m_arrTemplateBlobPads[i]).intGroupID;
                fMaxData = ((BlobsFeatures)m_arrGroupTemplateBlobPads[intGroupNo]).fMaxSmearLength * m_fMMToUnitValue;
            }
            else
            {
                fMaxData = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fMaxSmearLength * m_fMMToUnitValue;
            }
            if (fData > fMaxData)
            {
                intResultTableFailMask |= 0x2000;
            }
            arrResultList.Add(intResultTableFailMask.ToString());

            return arrResultList;

        }

        private bool GetPitchGapResult(int intIndex, ref float fPitch, ref float fGap)
        {
            int iFrom, iTo;
            iFrom = iTo = 0;

            for (int i = 0; i < GetTotalPitchGap(); i++)
            {
                GetPitchGapPadLink(i, ref iFrom, ref iTo);

                if ((intIndex + 1) == iFrom)
                {
                    fPitch = m_arrPitchGap[i].fPitchMM;
                    fGap = m_arrPitchGap[i].fGapMM;
                    return true;
                }
            }

            return false;
        }

        public string GetMicronBlobsFeaturesData()
        {
            string strBlobsFeatures = "";
            float fData;
            for (int i = 0; i < m_arrTemplateBlobPads.Count; i++)
            {
                strBlobsFeatures += ((BlobsFeatures)m_arrTemplateBlobPads[i]).intNoID + "#";
                fData = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fOffSet * m_fMMToUnitValue;
                strBlobsFeatures += fData.ToString("F" + m_intDecimal) + "#";
                fData = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fMinArea * m_fMMToUnitValueArea;
                strBlobsFeatures += fData.ToString("F" + m_intDecimal2) + "#";
                fData = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fMaxArea * m_fMMToUnitValueArea;
                strBlobsFeatures += fData.ToString("F" + m_intDecimal2) + "#";
                // 2019 10 30 - CCENG: m_arrTemplateBlobPads fMinWidth, fMaxWidth, fMinHeigt, fMaxLength are not affacted by lengthmode.
                //if (((BlobsFeatures)m_arrTemplateBlobPads[i]).intLengthMode == 1)
                //{
                fData = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fMinWidth * m_fMMToUnitValue;
                    strBlobsFeatures += fData.ToString("F" + m_intDecimal) + "#";
                    fData = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fMaxWidth * m_fMMToUnitValue;
                    strBlobsFeatures += fData.ToString("F" + m_intDecimal) + "#";
                    fData = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fMinLength * m_fMMToUnitValue;
                    strBlobsFeatures += fData.ToString("F" + m_intDecimal) + "#";
                    fData = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fMaxLength * m_fMMToUnitValue;
                    strBlobsFeatures += fData.ToString("F" + m_intDecimal) + "#";
                //}
                //else
                //{
                //    fData = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fMinLength * m_fMMToUnitValue;
                //    strBlobsFeatures += fData.ToString("F" + m_intDecimal) + "#";
                //    fData = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fMaxLength * m_fMMToUnitValue;
                //    strBlobsFeatures += fData.ToString("F" + m_intDecimal) + "#";
                //    fData = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fMinWidth * m_fMMToUnitValue;
                //    strBlobsFeatures += fData.ToString("F" + m_intDecimal) + "#";
                //    fData = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fMaxWidth * m_fMMToUnitValue;
                //    strBlobsFeatures += fData.ToString("F" + m_intDecimal) + "#";
                //}

                fData = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fMaxBroken * m_fMMToUnitValueArea;
                strBlobsFeatures += fData.ToString("F" + m_intDecimal2) + "#";

                fData = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fMaxBrokenLength * m_fMMToUnitValue;
                strBlobsFeatures += fData.ToString("F" + m_intDecimal) + "#";

            }
            return strBlobsFeatures;
        }

        public string GetMicronPitchGapData(int intPitchGapIndex)
        {
            string strPitchGapData = "";

            PitchGap stcPitchGap = m_arrPitchGap[intPitchGapIndex];

            strPitchGapData += stcPitchGap.intFromPadNo.ToString() + "#";
            strPitchGapData += stcPitchGap.intToPadNo.ToString() + "#";
            strPitchGapData += (stcPitchGap.fMinPitch).ToString() + "#";
            strPitchGapData += (stcPitchGap.fMaxPitch).ToString() + "#";
            strPitchGapData += (stcPitchGap.fMinGap).ToString() + "#";
            strPitchGapData += (stcPitchGap.fMaxGap).ToString() + "#";
            strPitchGapData += stcPitchGap.fGap.ToString() + "#";
            strPitchGapData += stcPitchGap.fPitch.ToString() + "#";
            strPitchGapData += stcPitchGap.intStartPointX.ToString() + "#";
            strPitchGapData += stcPitchGap.intStartPointY.ToString() + "#";
            strPitchGapData += stcPitchGap.intEndPointX.ToString() + "#";
            strPitchGapData += stcPitchGap.intEndPointY.ToString() + "#";
            strPitchGapData += stcPitchGap.intDirection.ToString() + "#";

            return strPitchGapData;
        }

        /// <summary>
        /// Get inspection fail result
        /// </summary>
        /// <param name="strPosition">ROI position (Center ROI, Top ROI, Bottom ROI, Left ROI, Right ROI)</param>
        /// <returns>inspection fail result in string</returns>
        public string GetPadFailTestDisplayResult(string strPosition)
        {   
            float fData;
            float fMin;
            float fMax;
            float fMeasure;
            string strFailMessage = "";
            List<int> arrJoint = new List<int>();
            List<int> arrBroken = new List<int>();
            List<int> arrExcess = new List<int>();
            List<int> arrSmear = new List<int>();
            List<int> arrEdgeTop = new List<int>();
            List<int> arrEdgeBottom = new List<int>();
            List<int> arrEdgeRight = new List<int>();
            List<int> arrEdgeLeft = new List<int>();
            List<int> arrStandOffTop = new List<int>();
            List<int> arrStandOffBottom = new List<int>();
            List<int> arrStandOffLeft = new List<int>();
            List<int> arrStandOffRight = new List<int>();
            BlobsFeatures stcBlobsFeatures;
            for (int i = 0; i < m_arrSampleBlobPads.Length; i++)
            {
                if (m_blnWantUseGroupToleranceSetting)
                {
                    int intGroupNo = ((BlobsFeatures)m_arrTemplateBlobPads[i]).intGroupID;
                    stcBlobsFeatures = (BlobsFeatures)m_arrGroupTemplateBlobPads[intGroupNo];
                }
                else
                {
                    stcBlobsFeatures = (BlobsFeatures)m_arrTemplateBlobPads[i];
                }

                if ((m_arrSampleBlobPads[i].intFailMask & 0x40) > 0)
                {
                    if (((BlobsFeatures)m_arrTemplateBlobPads[i]).intLengthMode == 1)
                        strFailMessage += strPosition + "Pad " + (i + 1) + ": Width Fail. ";
                    else
                        strFailMessage += strPosition + "Pad " + (i + 1) + ": Length Fail. ";

                    // CCENG: Lengthmode ok?
                    if (m_blnWantUseGroupToleranceSetting)
                    {
                        if (((BlobsFeatures)m_arrTemplateBlobPads[i]).intLengthMode == 1)
                        {
                            fMin = stcBlobsFeatures.fMinWidth * m_fMMToUnitValue;
                            fMax = stcBlobsFeatures.fMaxWidth * m_fMMToUnitValue;
                        }
                        else
                        {
                            fMin = stcBlobsFeatures.fMinLength * m_fMMToUnitValue;
                            fMax = stcBlobsFeatures.fMaxLength * m_fMMToUnitValue;
                        }
                    }
                    else
                    {
                        if (((BlobsFeatures)m_arrTemplateBlobPads[i]).intLengthMode == 1)
                        {
                            fMin = stcBlobsFeatures.fMinWidth * m_fMMToUnitValue;
                            fMax = stcBlobsFeatures.fMaxWidth * m_fMMToUnitValue;
                        }
                        else
                        {
                            fMin = stcBlobsFeatures.fMinLength * m_fMMToUnitValue;
                            fMax = stcBlobsFeatures.fMaxLength * m_fMMToUnitValue;
                        }
                    }
                    fMeasure = m_arrSampleBlobPads[i].fWidthMM * m_fMMToUnitValue;
                    strFailMessage += "Min: " + fMin.ToString("F" + m_intDecimal) + ", Max: " + fMax.ToString("F" + m_intDecimal) + ", Measure: " + fMeasure.ToString("F" + m_intDecimal);

                }

                if ((m_arrSampleBlobPads[i].intFailMask & 0x80) > 0)
                {
                    if (((BlobsFeatures)m_arrTemplateBlobPads[i]).intLengthMode == 1)
                        strFailMessage += strPosition + "Pad " + (i + 1) + ": Length Fail. ";
                    else
                        strFailMessage += strPosition + "Pad " + (i + 1) + ": Width Fail. ";

                    if (m_blnWantUseGroupToleranceSetting)
                    {
                        // CCENG: Lengthmode ok?
                        if (((BlobsFeatures)m_arrTemplateBlobPads[i]).intLengthMode == 1)
                        {
                            fMin = stcBlobsFeatures.fMinLength * m_fMMToUnitValue;
                            fMax = stcBlobsFeatures.fMaxLength * m_fMMToUnitValue;
                        }
                        else
                        {
                            fMin = stcBlobsFeatures.fMinWidth * m_fMMToUnitValue;
                            fMax = stcBlobsFeatures.fMaxWidth * m_fMMToUnitValue;
                        }
                    }
                    else
                    {
                        if (((BlobsFeatures)m_arrTemplateBlobPads[i]).intLengthMode == 1)
                        {
                            fMin = stcBlobsFeatures.fMinLength * m_fMMToUnitValue;
                            fMax = stcBlobsFeatures.fMaxLength * m_fMMToUnitValue;
                        }
                        else
                        {
                            fMin = stcBlobsFeatures.fMinWidth * m_fMMToUnitValue;
                            fMax = stcBlobsFeatures.fMaxWidth * m_fMMToUnitValue;
                        }
                    }

                    fMeasure = m_arrSampleBlobPads[i].fHeightMM * m_fMMToUnitValue;
                    strFailMessage += "Min: " + fMin.ToString("F" + m_intDecimal) + ", Max: " + fMax.ToString("F" + m_intDecimal) + ", Measure: " + fMeasure.ToString("F" + m_intDecimal);
                }

                if ((m_arrSampleBlobPads[i].intFailMask & 0x20) > 0)
                {
                    strFailMessage += strPosition + "Pad " + (i + 1) + ": Area Fail. ";
                    fMin = stcBlobsFeatures.fMinArea * m_fMMToUnitValueArea;
                    fMax = stcBlobsFeatures.fMaxArea * m_fMMToUnitValueArea;
                    fMeasure = m_arrSampleBlobPads[i].fAreaMM * m_fMMToUnitValueArea;
                    strFailMessage += "Min: " + fMin.ToString("F" + m_intDecimal) + ", Max: " + fMax.ToString("F" + m_intDecimal) + ", Measure: " + fMeasure.ToString("F" + m_intDecimal);
                }

                if ((m_arrSampleBlobPads[i].intFailMask & 0x100) > 0)
                {
                    strFailMessage += strPosition + "Pad " + (i + 1) + ": Pad Off Set. ";
                    fMax = stcBlobsFeatures.fOffSet * m_fMMToUnitValue;    // Can use either m_fMMToUnitValue or m_fMMToUnitValue
                    fMeasure = m_arrSampleBlobPads[i].fOffSetMM * m_fMMToUnitValue;
                    strFailMessage += "Set: " + fMax.ToString("F" + m_intDecimal) + ", Measure: " + fMeasure.ToString("F" + m_intDecimal);
                }

                if ((m_arrSampleBlobPads[i].intFailMask & 0x10000) > 0)
                {
                    if (m_arrSampleBlobPads[i].fLine3MM == -999)
                    {
                        strFailMessage += strPosition + "Pad " + (i + 1) + ": Dimension 1 Fail. " + "Cannot find pad edge.";
                    }
                    else
                    {
                        strFailMessage += strPosition + "Pad " + (i + 1) + ": Dimension 1 Fail. ";

                        if (m_blnWantUseGroupToleranceSetting)
                        {

                            fMin = stcBlobsFeatures.fMinLine3 * m_fMMToUnitValue;
                            fMax = stcBlobsFeatures.fMaxLine3 * m_fMMToUnitValue;

                        }
                        else
                        {
                            fMin = stcBlobsFeatures.fMinLine3 * m_fMMToUnitValue;
                            fMax = stcBlobsFeatures.fMaxLine3 * m_fMMToUnitValue;
                        }

                        fMeasure = m_arrSampleBlobPads[i].fLine3MM * m_fMMToUnitValue;
                        strFailMessage += "Min: " + fMin.ToString("F" + m_intDecimal) + ", Max: " + fMax.ToString("F" + m_intDecimal) + ", Measure: " + fMeasure.ToString("F" + m_intDecimal);
                    }
                }

                if ((m_arrSampleBlobPads[i].intFailMask & 0x20000) > 0)
                {
                    if (m_arrSampleBlobPads[i].fLine4MM == -999)
                    {
                        strFailMessage += strPosition + "Pad " + (i + 1) + ": Dimension 2 Fail. " + "Cannot find pad edge.";
                    }
                    else
                    {
                        strFailMessage += strPosition + "Pad " + (i + 1) + ": Dimension 2 Fail. ";

                        if (m_blnWantUseGroupToleranceSetting)
                        {

                            fMin = stcBlobsFeatures.fMinLine4 * m_fMMToUnitValue;
                            fMax = stcBlobsFeatures.fMaxLine4 * m_fMMToUnitValue;

                        }
                        else
                        {
                            fMin = stcBlobsFeatures.fMinLine4 * m_fMMToUnitValue;
                            fMax = stcBlobsFeatures.fMaxLine4 * m_fMMToUnitValue;
                        }

                        fMeasure = m_arrSampleBlobPads[i].fLine4MM * m_fMMToUnitValue;
                        strFailMessage += "Min: " + fMin.ToString("F" + m_intDecimal) + ", Max: " + fMax.ToString("F" + m_intDecimal) + ", Measure: " + fMeasure.ToString("F" + m_intDecimal);
                    }
                }

                if ((m_arrSampleBlobPads[i].intFailMask & 0x40000) > 0)
                {
                    if (m_arrSampleBlobPads[i].fLine5MM == -999)
                    {
                        strFailMessage += strPosition + "Pad " + (i + 1) + ": Dimension 3 Fail. " + "Cannot find pad edge.";
                    }
                    else
                    {
                        strFailMessage += strPosition + "Pad " + (i + 1) + ": Dimension 3 Fail. ";

                        if (m_blnWantUseGroupToleranceSetting)
                        {

                            fMin = stcBlobsFeatures.fMinLine5 * m_fMMToUnitValue;
                            fMax = stcBlobsFeatures.fMaxLine5 * m_fMMToUnitValue;

                        }
                        else
                        {
                            fMin = stcBlobsFeatures.fMinLine5 * m_fMMToUnitValue;
                            fMax = stcBlobsFeatures.fMaxLine5 * m_fMMToUnitValue;
                        }

                        fMeasure = m_arrSampleBlobPads[i].fLine5MM * m_fMMToUnitValue;
                        strFailMessage += "Min: " + fMin.ToString("F" + m_intDecimal) + ", Max: " + fMax.ToString("F" + m_intDecimal) + ", Measure: " + fMeasure.ToString("F" + m_intDecimal);
                    }
                }

                if ((m_arrSampleBlobPads[i].intFailMask & 0x80000) > 0)
                {
                    if (m_arrSampleBlobPads[i].fLine6MM == -999)
                    {
                        strFailMessage += strPosition + "Pad " + (i + 1) + ": Dimension 4 Fail. " + "Cannot find pad edge.";
                    }
                    else
                    {
                        strFailMessage += strPosition + "Pad " + (i + 1) + ": Dimension 4 Fail. ";

                        if (m_blnWantUseGroupToleranceSetting)
                        {

                            fMin = stcBlobsFeatures.fMinLine6 * m_fMMToUnitValue;
                            fMax = stcBlobsFeatures.fMaxLine6 * m_fMMToUnitValue;

                        }
                        else
                        {
                            fMin = stcBlobsFeatures.fMinLine6 * m_fMMToUnitValue;
                            fMax = stcBlobsFeatures.fMaxLine6 * m_fMMToUnitValue;
                        }

                        fMeasure = m_arrSampleBlobPads[i].fLine6MM * m_fMMToUnitValue;
                        strFailMessage += "Min: " + fMin.ToString("F" + m_intDecimal) + ", Max: " + fMax.ToString("F" + m_intDecimal) + ", Measure: " + fMeasure.ToString("F" + m_intDecimal);
                    }
                }

                if ((m_arrSampleBlobPads[i].intFailMask & 0x100000) > 0)
                {
                    if (m_arrSampleBlobPads[i].fLine7MM == -999)
                    {
                        strFailMessage += strPosition + "Pad " + (i + 1) + ": Dimension 5 Fail. " + "Cannot find pad edge.";
                    }
                    else
                    {
                        strFailMessage += strPosition + "Pad " + (i + 1) + ": Dimension 5 Fail. ";

                        if (m_blnWantUseGroupToleranceSetting)
                        {

                            fMin = stcBlobsFeatures.fMinLine7 * m_fMMToUnitValue;
                            fMax = stcBlobsFeatures.fMaxLine7 * m_fMMToUnitValue;

                        }
                        else
                        {
                            fMin = stcBlobsFeatures.fMinLine7 * m_fMMToUnitValue;
                            fMax = stcBlobsFeatures.fMaxLine7 * m_fMMToUnitValue;
                        }

                        fMeasure = m_arrSampleBlobPads[i].fLine7MM * m_fMMToUnitValue;
                        strFailMessage += "Min: " + fMin.ToString("F" + m_intDecimal) + ", Max: " + fMax.ToString("F" + m_intDecimal) + ", Measure: " + fMeasure.ToString("F" + m_intDecimal);
                    }
                }

                if ((m_arrSampleBlobPads[i].intFailMask & 0x800000000) > 0)
                {
                    if (m_arrSampleBlobPads[i].fLine8MM == -999)
                    {
                        strFailMessage += strPosition + "Pad " + (i + 1) + ": Dimension 6 Fail. " + "Cannot find pad edge.";
                    }
                    else
                    {
                        strFailMessage += strPosition + "Pad " + (i + 1) + ": Dimension 6 Fail. ";

                        if (m_blnWantUseGroupToleranceSetting)
                        {

                            fMin = stcBlobsFeatures.fMinLine8 * m_fMMToUnitValue;
                            fMax = stcBlobsFeatures.fMaxLine8 * m_fMMToUnitValue;

                        }
                        else
                        {
                            fMin = stcBlobsFeatures.fMinLine8 * m_fMMToUnitValue;
                            fMax = stcBlobsFeatures.fMaxLine8 * m_fMMToUnitValue;
                        }

                        fMeasure = m_arrSampleBlobPads[i].fLine8MM * m_fMMToUnitValue;
                        strFailMessage += "Min: " + fMin.ToString("F" + m_intDecimal) + ", Max: " + fMax.ToString("F" + m_intDecimal) + ", Measure: " + fMeasure.ToString("F" + m_intDecimal);
                    }
                }

                if ((m_arrSampleBlobPads[i].intFailMask & 0x1000000000) > 0)
                {
                    if (m_arrSampleBlobPads[i].fLine9MM == -999)
                    {
                        strFailMessage += strPosition + "Pad " + (i + 1) + ": Dimension 7 Fail. " + "Cannot find pad edge.";
                    }
                    else
                    {
                        strFailMessage += strPosition + "Pad " + (i + 1) + ": Dimension 7 Fail. ";

                        if (m_blnWantUseGroupToleranceSetting)
                        {

                            fMin = stcBlobsFeatures.fMinLine9 * m_fMMToUnitValue;
                            fMax = stcBlobsFeatures.fMaxLine9 * m_fMMToUnitValue;

                        }
                        else
                        {
                            fMin = stcBlobsFeatures.fMinLine9 * m_fMMToUnitValue;
                            fMax = stcBlobsFeatures.fMaxLine9 * m_fMMToUnitValue;
                        }

                        fMeasure = m_arrSampleBlobPads[i].fLine9MM * m_fMMToUnitValue;
                        strFailMessage += "Min: " + fMin.ToString("F" + m_intDecimal) + ", Max: " + fMax.ToString("F" + m_intDecimal) + ", Measure: " + fMeasure.ToString("F" + m_intDecimal);
                    }
                }

                if ((m_arrSampleBlobPads[i].intFailMask & 0x2000000000) > 0)
                {
                    if (m_arrSampleBlobPads[i].fLine10MM == -999)
                    {
                        strFailMessage += strPosition + "Pad " + (i + 1) + ": Dimension 8 Fail. " + "Cannot find pad edge.";
                    }
                    else
                    {
                        strFailMessage += strPosition + "Pad " + (i + 1) + ": Dimension 8 Fail. ";

                        if (m_blnWantUseGroupToleranceSetting)
                        {

                            fMin = stcBlobsFeatures.fMinLine10 * m_fMMToUnitValue;
                            fMax = stcBlobsFeatures.fMaxLine10 * m_fMMToUnitValue;

                        }
                        else
                        {
                            fMin = stcBlobsFeatures.fMinLine10 * m_fMMToUnitValue;
                            fMax = stcBlobsFeatures.fMaxLine10 * m_fMMToUnitValue;
                        }

                        fMeasure = m_arrSampleBlobPads[i].fLine10MM * m_fMMToUnitValue;
                        strFailMessage += "Min: " + fMin.ToString("F" + m_intDecimal) + ", Max: " + fMax.ToString("F" + m_intDecimal) + ", Measure: " + fMeasure.ToString("F" + m_intDecimal);
                    }
                }

                if ((m_arrSampleBlobPads[i].intFailMask & 0x4000000000) > 0)
                {
                    if (m_arrSampleBlobPads[i].fLine11MM == -999)
                    {
                        strFailMessage += strPosition + "Pad " + (i + 1) + ": Dimension 9 Fail. " + "Cannot find pad edge.";
                    }
                    else
                    {
                        strFailMessage += strPosition + "Pad " + (i + 1) + ": Dimension 9 Fail. ";

                        if (m_blnWantUseGroupToleranceSetting)
                        {

                            fMin = stcBlobsFeatures.fMinLine11 * m_fMMToUnitValue;
                            fMax = stcBlobsFeatures.fMaxLine11 * m_fMMToUnitValue;

                        }
                        else
                        {
                            fMin = stcBlobsFeatures.fMinLine11 * m_fMMToUnitValue;
                            fMax = stcBlobsFeatures.fMaxLine11 * m_fMMToUnitValue;
                        }

                        fMeasure = m_arrSampleBlobPads[i].fLine11MM * m_fMMToUnitValue;
                        strFailMessage += "Min: " + fMin.ToString("F" + m_intDecimal) + ", Max: " + fMax.ToString("F" + m_intDecimal) + ", Measure: " + fMeasure.ToString("F" + m_intDecimal);
                    }
                }

                if ((m_arrSampleBlobPads[i].intFailMask & 0x8000000000) > 0)
                {
                    if (m_arrSampleBlobPads[i].fLine12MM == -999)
                    {
                        strFailMessage += strPosition + "Pad " + (i + 1) + ": Dimension 10 Fail. " + "Cannot find pad edge.";
                    }
                    else
                    {
                        strFailMessage += strPosition + "Pad " + (i + 1) + ": Dimension 10 Fail. ";

                        if (m_blnWantUseGroupToleranceSetting)
                        {

                            fMin = stcBlobsFeatures.fMinLine12 * m_fMMToUnitValue;
                            fMax = stcBlobsFeatures.fMaxLine12 * m_fMMToUnitValue;

                        }
                        else
                        {
                            fMin = stcBlobsFeatures.fMinLine12 * m_fMMToUnitValue;
                            fMax = stcBlobsFeatures.fMaxLine12 * m_fMMToUnitValue;
                        }

                        fMeasure = m_arrSampleBlobPads[i].fLine12MM * m_fMMToUnitValue;
                        strFailMessage += "Min: " + fMin.ToString("F" + m_intDecimal) + ", Max: " + fMax.ToString("F" + m_intDecimal) + ", Measure: " + fMeasure.ToString("F" + m_intDecimal);
                    }
                }
            }

            for (int y = 0; y < m_arrPitchGap.Count; y++)
            {
                int intFrom = m_arrPitchGap[y].intFromPadNo + 1;
                int intTo = m_arrPitchGap[y].intToPadNo + 1;
                if ((m_arrPitchGap[y].intFailMask & 0x200) > 0)
                {
                    strFailMessage += strPosition + "Gap " + intFrom.ToString() + " to " + intTo.ToString() + " Fail. ";
                    if (m_blnWantUseGroupToleranceSetting)
                    {
                        int i = m_arrPitchGap[y].intFromPadNo;
                        int intGroupNo = ((BlobsFeatures)m_arrTemplateBlobPads[i]).intGroupID;
                        stcBlobsFeatures = (BlobsFeatures)m_arrGroupTemplateBlobPads[intGroupNo];

                        fMin = stcBlobsFeatures.fMinGap * m_fMMToUnitValue;
                        fMax = stcBlobsFeatures.fMaxGap * m_fMMToUnitValue;
                    }
                    else
                    {
                        fMin = m_arrPitchGap[y].fMinGap * m_fMMToUnitValue;
                        fMax = m_arrPitchGap[y].fMaxGap * m_fMMToUnitValue;
                    }
                    fMeasure = m_arrPitchGap[y].fGapMM * m_fMMToUnitValue;
                    //fMeasure = m_arrSampleBlobPads[intFrom - 1].fGapMM * m_fMMToUnitValue;
                    strFailMessage += "Min: " + fMin.ToString("F" + m_intDecimal) + ", Max: " + fMax.ToString("F" + m_intDecimal) + ", Measure: " + fMeasure.ToString("F" + m_intDecimal);
                }

                if ((m_arrPitchGap[y].intFailMask & 0x400) > 0)
                {
                    strFailMessage += strPosition + "Pitch " + intFrom.ToString() + " to " + intTo.ToString() + " Fail. ";

                    if (m_blnWantUseGroupToleranceSetting)
                    {
                        int i = m_arrPitchGap[y].intFromPadNo;
                        int intGroupNo = ((BlobsFeatures)m_arrTemplateBlobPads[i]).intGroupID;
                        stcBlobsFeatures = (BlobsFeatures)m_arrGroupTemplateBlobPads[intGroupNo];

                        fMin = stcBlobsFeatures.fMinPitch * m_fMMToUnitValue;
                        fMax = stcBlobsFeatures.fMaxPitch * m_fMMToUnitValue;
                    }
                    else
                    {
                        fMin = m_arrPitchGap[y].fMinPitch * m_fMMToUnitValue;
                        fMax = m_arrPitchGap[y].fMaxPitch * m_fMMToUnitValue;
                    }
                    fMeasure = m_arrPitchGap[y].fPitchMM * m_fMMToUnitValue;
                    //fMeasure = m_arrSampleBlobPads[intFrom - 1].fPitchMM * m_fMMToUnitValue;
                    strFailMessage += "Min: " + fMin.ToString("F" + m_intDecimal) + ", Max: " + fMax.ToString("F" + m_intDecimal) + ", Measure: " + fMeasure.ToString("F" + m_intDecimal);
                }
            }

            for (int i = 0; i < m_arrSampleBlobPads.Length; i++)
            {
                stcBlobsFeatures = (BlobsFeatures)m_arrTemplateBlobPads[i];

                if ((m_arrSampleBlobPads[i].intFailMask & 0x04) > 0)
                {
                    strFailMessage += strPosition + "Pad " + (i + 1) + ": Missing Pad";
                }

                //Joint Pad
                if ((m_arrSampleBlobPads[i].intFailMask & 0x02) > 0)
                {
                    arrJoint.Add(i);
                }

                //Broken Pad and Hole Pad
                if ((m_arrSampleBlobPads[i].intFailMask & 0x08) > 0 || (m_arrSampleBlobPads[i].intFailMask & 0x10) > 0)
                {
                    arrBroken.Add(i);
                }

                //Excess Pad
                if ((m_arrSampleBlobPads[i].intFailMask & 0x800) > 0)
                {
                    arrExcess.Add(i);
                }

                //Smear Pad
                if ((m_arrSampleBlobPads[i].intFailMask & 0x2000) > 0)
                {
                    arrSmear.Add(i);
                }

                // Pad Edge Top
                if ((m_arrSampleBlobPads[i].intFailMask & 0x200000) > 0)
                {
                    arrEdgeTop.Add(i);
                }

                // Pad Edge Right
                if ((m_arrSampleBlobPads[i].intFailMask & 0x400000) > 0)
                {
                    arrEdgeRight.Add(i);
                }

                // Pad Edge Bottom
                if ((m_arrSampleBlobPads[i].intFailMask & 0x800000) > 0)
                {
                    arrEdgeBottom.Add(i);
                }

                // Pad Edge Left
                if ((m_arrSampleBlobPads[i].intFailMask & 0x1000000) > 0)
                {
                    arrEdgeLeft.Add(i);
                }

                // Pad StandOff Top
                if ((m_arrSampleBlobPads[i].intFailMask & 0x2000000) > 0)
                {
                    arrStandOffTop.Add(i);
                }

                // Pad StandOff Bottom
                if ((m_arrSampleBlobPads[i].intFailMask & 0x4000000) > 0)
                {
                    arrStandOffBottom.Add(i);
                }

                // Pad StandOff Left
                if ((m_arrSampleBlobPads[i].intFailMask & 0x8000000) > 0)
                {
                    arrStandOffLeft.Add(i);
                }

                // Pad StandOff Right
                if ((m_arrSampleBlobPads[i].intFailMask & 0x10000000) > 0)
                {
                    arrStandOffRight.Add(i);
                }

            }

            if (arrJoint.Count > 0)
            {
                for (int i = 0; i < arrJoint.Count; i++)
                {
                    if (i == 0)
                        strFailMessage += strPosition + "Pad " + (arrJoint[i] + 1);
                    else
                        strFailMessage += (arrJoint[i] + 1);

                    if (i != arrJoint.Count - 1)
                        strFailMessage += ", ";
                    else
                    {
                        strFailMessage += ": Bridgging.";
                    }
                }
            }

            if (arrBroken.Count > 0)
            {
                for (int i = 0; i < arrBroken.Count; i++)
                {
                    strFailMessage += strPosition + "Pad " + (arrBroken[i] + 1);

                    if (m_blnFailBrokenArea)
                    {
                        strFailMessage += ": Broken Pad Area Fail.";

                        if (m_blnWantUseGroupToleranceSetting)
                        {
                            int intGroupNo = ((BlobsFeatures)m_arrTemplateBlobPads[arrBroken[i]]).intGroupID;
                            fData = ((BlobsFeatures)m_arrGroupTemplateBlobPads[intGroupNo]).fMaxBroken * m_fMMToUnitValueArea;
                        }
                        else
                        {
                            fData = ((BlobsFeatures)m_arrTemplateBlobPads[arrBroken[i]]).fMaxBroken * m_fMMToUnitValueArea;
                        }

                        strFailMessage += " Set Area: " + fData.ToString("F" + m_intDecimal2);
                        float fResultData = m_arrSamplePadBroken[arrBroken[i]].fAreaMM * m_fMMToUnitValueArea;
                        strFailMessage += ", Measure: " + fResultData.ToString("F" + m_intDecimal2);
                    }

                    if (m_blnFailBrokenLength)
                    {
                        strFailMessage += ": Broken Pad Length Fail.";

                        if (m_blnWantUseGroupToleranceSetting)
                        {
                            int intGroupNo = ((BlobsFeatures)m_arrTemplateBlobPads[arrBroken[i]]).intGroupID;
                            fData = ((BlobsFeatures)m_arrGroupTemplateBlobPads[intGroupNo]).fMaxBrokenLength * m_fMMToUnitValue;
                        }
                        else
                        {
                            fData = ((BlobsFeatures)m_arrTemplateBlobPads[arrBroken[i]]).fMaxBrokenLength * m_fMMToUnitValue;
                        }

                        strFailMessage += " Set Length: " + fData.ToString("F" + m_intDecimal);
                        float fResultData = Math.Max(m_arrSamplePadBroken[arrBroken[i]].fWidthMM, m_arrSamplePadBroken[arrBroken[i]].fHeightMM) * m_fMMToUnitValue;
                        strFailMessage += ", Measure: " + fResultData.ToString("F" + m_intDecimal);
                    }
                }
            }



            //if (arrBroken.Count > 0)
            //{
            //    for (int i = 0; i < arrBroken.Count; i++)
            //    {
            //        if (i == 0)
            //            strFailMessage += strPosition + "Pad " + (arrBroken[i] + 1);
            //        else
            //            strFailMessage += (arrBroken[i] + 1);

            //        if (i != arrBroken.Count - 1)
            //            strFailMessage += ", ";
            //        else
            //        {
            //            if (m_blnFailBrokenArea)
            //            {
            //                strFailMessage += ": *Broken Pad.";
            //                if (m_fResultBrokenMaxArea >= 0)
            //                {
            //                    if (m_blnWantUseGroupToleranceSetting)
            //                    {
            //                        int intGroupNo = ((BlobsFeatures)m_arrTemplateBlobPads[arrBroken[i]]).intGroupID;
            //                        fData = ((BlobsFeatures)m_arrGroupTemplateBlobPads[intGroupNo]).fMaxBroken * m_fMMToUnitValueArea;
            //                    }
            //                    else
            //                    {
            //                        fData = ((BlobsFeatures)m_arrTemplateBlobPads[arrBroken[i]]).fMaxBroken * m_fMMToUnitValueArea;
            //                    }

            //                    strFailMessage += " *Set Area: " + fData.ToString("F" + m_intDecimal2);
            //                    float fSmallestData = m_fResultBrokenMinArea * m_fMMToUnitValueArea;
            //                    float fBiggestData = m_fResultBrokenMaxArea * m_fMMToUnitValueArea;
            //                    strFailMessage += ". *Measure: " + fSmallestData.ToString("F" + m_intDecimal2) + " to " + fBiggestData.ToString("F" + m_intDecimal2);

            //                }
            //            }
            //            if (m_blnFailBrokenLength)
            //            {
            //                strFailMessage += ": *Broken Pad.";
            //                if (m_fResultBrokenMaxArea >= 0)
            //                {
            //                    if (m_blnWantUseGroupToleranceSetting)
            //                    {
            //                        int intGroupNo = ((BlobsFeatures)m_arrTemplateBlobPads[arrBroken[i]]).intGroupID;
            //                        fData = ((BlobsFeatures)m_arrGroupTemplateBlobPads[intGroupNo]).fMaxBrokenLength * m_fMMToUnitValue;
            //                    }
            //                    else
            //                    {
            //                        fData = ((BlobsFeatures)m_arrTemplateBlobPads[arrBroken[i]]).fMaxBrokenLength * m_fMMToUnitValue;
            //                    }


            //                    strFailMessage += " *Set Length: " + fData.ToString("F" + m_intDecimal);
            //                    float fSmallestData = m_fResultBrokenMinArea * m_fMMToUnitValue;
            //                    float fBiggestData = m_fResultBrokenMaxArea * m_fMMToUnitValue;
            //                    strFailMessage += ". *Measure: " + fSmallestData.ToString("F" + m_intDecimal) + " to " + fBiggestData.ToString("F" + m_intDecimal);
            //                }
            //            }
            //        }
            //    }
            //}

            if (arrExcess.Count > 0)
            {
                for (int i = 0; i < arrExcess.Count; i++)
                {
                    strFailMessage += strPosition + "Pad " + (arrExcess[i] + 1);

                    if (m_blnFailExcessArea)
                    {
                        strFailMessage += ": Excess Pad Fail.";

                        if (m_blnWantUseGroupToleranceSetting)
                        {
                            int intGroupNo = ((BlobsFeatures)m_arrTemplateBlobPads[arrExcess[i]]).intGroupID;
                            fData = ((BlobsFeatures)m_arrGroupTemplateBlobPads[intGroupNo]).fMaxExcess * m_fMMToUnitValueArea;
                        }
                        else
                        {
                            fData = ((BlobsFeatures)m_arrTemplateBlobPads[arrExcess[i]]).fMaxExcess * m_fMMToUnitValueArea;
                        }

                        strFailMessage += " Set Area: " + fData.ToString("F" + m_intDecimal2);
                        float fResultData = m_arrSamplePadExcess[arrExcess[i]].fAreaMM * m_fMMToUnitValueArea;
                        strFailMessage += ", Measure: " + fResultData.ToString("F" + m_intDecimal2);
                    }
                }
            }

            //if (arrExcess.Count > 0)
            //{
            //    for (int i = 0; i < arrExcess.Count; i++)
            //    {
            //        if (i == 0)
            //            strFailMessage += strPosition + "Pad " + (arrExcess[i] + 1);
            //        else
            //            strFailMessage += (arrExcess[i] + 1);

            //        if (i != arrExcess.Count - 1)
            //            strFailMessage += ", ";
            //        else
            //        {
            //            if (m_blnFailExcessArea)
            //            {
            //                strFailMessage += ": *Excess Pad Fail.";

            //                if (m_blnWantUseGroupToleranceSetting)
            //                {
            //                    int intGroupNo = ((BlobsFeatures)m_arrTemplateBlobPads[arrExcess[i]]).intGroupID;
            //                    fData = ((BlobsFeatures)m_arrGroupTemplateBlobPads[intGroupNo]).fMaxExcess * m_fMMToUnitValueArea;
            //                }
            //                else
            //                {
            //                    fData = ((BlobsFeatures)m_arrTemplateBlobPads[arrExcess[i]]).fMaxExcess * m_fMMToUnitValueArea;
            //                }

            //                strFailMessage += " *Set Area: " + fData.ToString("F" + m_intDecimal2);
            //                float fSmallestData = m_fResultExcessMinArea * m_fMMToUnitValueArea;
            //                float fBiggestData = m_fResultExcessMaxArea * m_fMMToUnitValueArea;
            //                strFailMessage += ". *Measure: " + fSmallestData.ToString("F" + m_intDecimal2) + " to " + fBiggestData.ToString("F" + m_intDecimal2);
            //            }
            //        }
            //    }
            //}

            if (arrSmear.Count > 0)
            {
                for (int i = 0; i < arrSmear.Count; i++)
                {

                    strFailMessage += strPosition + "Pad " + (arrSmear[i] + 1) + " Smear,";

                    if (m_blnWantUseGroupToleranceSetting)
                    {
                        int intGroupNo = ((BlobsFeatures)m_arrTemplateBlobPads[arrSmear[i]]).intGroupID;
                        fData = ((BlobsFeatures)m_arrGroupTemplateBlobPads[intGroupNo]).fMaxSmearLength * m_fMMToUnitValue;
                    }
                    else
                    {
                        fData = ((BlobsFeatures)m_arrTemplateBlobPads[arrSmear[i]]).fMaxSmearLength * m_fMMToUnitValue;
                    }

                    strFailMessage += " Set Length: " + fData.ToString("F" + m_intDecimal);
                    float fResultData;
                    if (m_arrSamplePadSmear[arrSmear[i]].fSmearLength < 0)
                    {
                        fResultData = 0;
                    }
                    else
                    {
                        fResultData = m_arrSamplePadSmear[arrSmear[i]].fSmearLength * m_fMMToUnitValue;
                    }
                    strFailMessage += ", Measure: " + fResultData.ToString("F" + m_intDecimal);
                }
            }

            if (arrEdgeTop.Count > 0)
            {
                for (int i = 0; i < arrEdgeTop.Count; i++)
                {

                    strFailMessage += strPosition + "Pad " + (arrEdgeTop[i] + 1) + " Edge Limit Top Fail,";

                    if (m_blnWantUseGroupToleranceSetting)
                    {
                        int intGroupNo = ((BlobsFeatures)m_arrTemplateBlobPads[arrEdgeTop[i]]).intGroupID;
                        fData = ((BlobsFeatures)m_arrGroupTemplateBlobPads[intGroupNo]).fEdgeLimitTop * m_fMMToUnitValue;
                    }
                    else
                    {
                        fData = ((BlobsFeatures)m_arrTemplateBlobPads[arrEdgeTop[i]]).fEdgeLimitTop * m_fMMToUnitValue;
                    }

                    strFailMessage += " Set Length: " + fData.ToString("F" + m_intDecimal);
                    float fResultData;
                    //if (m_arrSamplePadEdge[arrEdgeTop[i]].fEdgeTop < 0)
                    //{
                    //    fResultData = 0;
                    //}
                    //else
                    //{
                    fResultData = m_arrSamplePadEdge[arrEdgeTop[i]].fEdgeTop * m_fMMToUnitValue;
                    //}
                    strFailMessage += ", Measure: " + fResultData.ToString("F" + m_intDecimal);
                }
            }

            if (arrEdgeRight.Count > 0)
            {
                for (int i = 0; i < arrEdgeRight.Count; i++)
                {

                    strFailMessage += strPosition + "Pad " + (arrEdgeRight[i] + 1) + " Edge Limit Right Fail,";

                    if (m_blnWantUseGroupToleranceSetting)
                    {
                        int intGroupNo = ((BlobsFeatures)m_arrTemplateBlobPads[arrEdgeRight[i]]).intGroupID;
                        fData = ((BlobsFeatures)m_arrGroupTemplateBlobPads[intGroupNo]).fEdgeLimitRight * m_fMMToUnitValue;
                    }
                    else
                    {
                        fData = ((BlobsFeatures)m_arrTemplateBlobPads[arrEdgeRight[i]]).fEdgeLimitRight * m_fMMToUnitValue;
                    }

                    strFailMessage += " Set Length: " + fData.ToString("F" + m_intDecimal);
                    float fResultData;
                    if (m_arrSamplePadEdge[arrEdgeRight[i]].fEdgeRight < 0)
                    {
                        fResultData = 0;
                    }
                    else
                    {
                        fResultData = m_arrSamplePadEdge[arrEdgeRight[i]].fEdgeRight * m_fMMToUnitValue;
                    }
                    strFailMessage += ", Measure: " + fResultData.ToString("F" + m_intDecimal);
                }
            }

            if (arrEdgeBottom.Count > 0)
            {
                for (int i = 0; i < arrEdgeBottom.Count; i++)
                {

                    strFailMessage += strPosition + "Pad " + (arrEdgeBottom[i] + 1) + " Edge Limit Bottom Fail,";

                    if (m_blnWantUseGroupToleranceSetting)
                    {
                        int intGroupNo = ((BlobsFeatures)m_arrTemplateBlobPads[arrEdgeBottom[i]]).intGroupID;
                        fData = ((BlobsFeatures)m_arrGroupTemplateBlobPads[intGroupNo]).fEdgeLimitBottom * m_fMMToUnitValue;
                    }
                    else
                    {
                        fData = ((BlobsFeatures)m_arrTemplateBlobPads[arrEdgeBottom[i]]).fEdgeLimitBottom * m_fMMToUnitValue;
                    }

                    strFailMessage += " Set Length: " + fData.ToString("F" + m_intDecimal);
                    float fResultData;
                    //if (m_arrSamplePadEdge[arrEdgeBottom[i]].fEdgeBottom < 0)
                    //{
                    //    fResultData = 0;
                    //}
                    //else
                    //{
                    fResultData = m_arrSamplePadEdge[arrEdgeBottom[i]].fEdgeBottom * m_fMMToUnitValue;
                    //}
                    strFailMessage += ", Measure: " + fResultData.ToString("F" + m_intDecimal);
                }
            }

            if (arrEdgeLeft.Count > 0)
            {
                for (int i = 0; i < arrEdgeLeft.Count; i++)
                {

                    strFailMessage += strPosition + "Pad " + (arrEdgeLeft[i] + 1) + " Edge Limit Left Fail,";

                    if (m_blnWantUseGroupToleranceSetting)
                    {
                        int intGroupNo = ((BlobsFeatures)m_arrTemplateBlobPads[arrEdgeLeft[i]]).intGroupID;
                        fData = ((BlobsFeatures)m_arrGroupTemplateBlobPads[intGroupNo]).fEdgeLimitLeft * m_fMMToUnitValue;
                    }
                    else
                    {
                        fData = ((BlobsFeatures)m_arrTemplateBlobPads[arrEdgeLeft[i]]).fEdgeLimitLeft * m_fMMToUnitValue;
                    }

                    strFailMessage += " Set Length: " + fData.ToString("F" + m_intDecimal);
                    float fResultData;
                    //if (m_arrSamplePadEdge[arrEdgeLeft[i]].fEdgeLeft < 0)
                    //{
                    //    fResultData = 0;
                    //}
                    //else
                    //{
                    fResultData = m_arrSamplePadEdge[arrEdgeLeft[i]].fEdgeLeft * m_fMMToUnitValue;
                    //}
                    strFailMessage += ", Measure: " + fResultData.ToString("F" + m_intDecimal);
                }
            }

            if (arrStandOffTop.Count > 0)
            {
                for (int i = 0; i < arrStandOffTop.Count; i++)
                {

                    strFailMessage += strPosition + "Pad " + (arrStandOffTop[i] + 1) + " Stand Off Top Fail,";

                    if (m_blnWantUseGroupToleranceSetting)
                    {
                        int intGroupNo = ((BlobsFeatures)m_arrTemplateBlobPads[arrStandOffTop[i]]).intGroupID;
                        fData = ((BlobsFeatures)m_arrGroupTemplateBlobPads[intGroupNo]).fMaxStandOffTop * m_fMMToUnitValue;
                    }
                    else
                    {
                        fData = ((BlobsFeatures)m_arrTemplateBlobPads[arrStandOffTop[i]]).fMaxStandOffTop * m_fMMToUnitValue;
                    }

                    strFailMessage += " Set Length: " + fData.ToString("F" + m_intDecimal);
                    float fResultData;
                    fResultData = m_arrSamplePadStandOff[arrStandOffTop[i]].fStandOffTop * m_fMMToUnitValue;
                   
                    strFailMessage += ", Measure: " + fResultData.ToString("F" + m_intDecimal);
                }
            }

            if (arrStandOffBottom.Count > 0)
            {
                for (int i = 0; i < arrStandOffBottom.Count; i++)
                {

                    strFailMessage += strPosition + "Pad " + (arrStandOffBottom[i] + 1) + " Stand Off Bottom Fail,";

                    if (m_blnWantUseGroupToleranceSetting)
                    {
                        int intGroupNo = ((BlobsFeatures)m_arrTemplateBlobPads[arrStandOffBottom[i]]).intGroupID;
                        fData = ((BlobsFeatures)m_arrGroupTemplateBlobPads[intGroupNo]).fMaxStandOffBottom * m_fMMToUnitValue;
                    }
                    else
                    {
                        fData = ((BlobsFeatures)m_arrTemplateBlobPads[arrStandOffBottom[i]]).fMaxStandOffBottom * m_fMMToUnitValue;
                    }

                    strFailMessage += " Set Length: " + fData.ToString("F" + m_intDecimal);
                    float fResultData;
                    fResultData = m_arrSamplePadStandOff[arrStandOffBottom[i]].fStandOffBottom * m_fMMToUnitValue;

                    strFailMessage += ", Measure: " + fResultData.ToString("F" + m_intDecimal);
                }
            }

            if (arrStandOffLeft.Count > 0)
            {
                for (int i = 0; i < arrStandOffLeft.Count; i++)
                {

                    strFailMessage += strPosition + "Pad " + (arrStandOffLeft[i] + 1) + " Stand Off Left Fail,";

                    if (m_blnWantUseGroupToleranceSetting)
                    {
                        int intGroupNo = ((BlobsFeatures)m_arrTemplateBlobPads[arrStandOffLeft[i]]).intGroupID;
                        fData = ((BlobsFeatures)m_arrGroupTemplateBlobPads[intGroupNo]).fMaxStandOffLeft * m_fMMToUnitValue;
                    }
                    else
                    {
                        fData = ((BlobsFeatures)m_arrTemplateBlobPads[arrStandOffLeft[i]]).fMaxStandOffLeft * m_fMMToUnitValue;
                    }

                    strFailMessage += " Set Length: " + fData.ToString("F" + m_intDecimal);
                    float fResultData;
                    fResultData = m_arrSamplePadStandOff[arrStandOffLeft[i]].fStandOffLeft * m_fMMToUnitValue;

                    strFailMessage += ", Measure: " + fResultData.ToString("F" + m_intDecimal);
                }
            }

            if (arrStandOffRight.Count > 0)
            {
                for (int i = 0; i < arrStandOffRight.Count; i++)
                {

                    strFailMessage += strPosition + "Pad " + (arrStandOffRight[i] + 1) + " Stand Off Right Fail,";

                    if (m_blnWantUseGroupToleranceSetting)
                    {
                        int intGroupNo = ((BlobsFeatures)m_arrTemplateBlobPads[arrStandOffRight[i]]).intGroupID;
                        fData = ((BlobsFeatures)m_arrGroupTemplateBlobPads[intGroupNo]).fMaxStandOffRight * m_fMMToUnitValue;
                    }
                    else
                    {
                        fData = ((BlobsFeatures)m_arrTemplateBlobPads[arrStandOffRight[i]]).fMaxStandOffRight * m_fMMToUnitValue;
                    }

                    strFailMessage += " Set Length: " + fData.ToString("F" + m_intDecimal);
                    float fResultData;
                    fResultData = m_arrSamplePadStandOff[arrStandOffRight[i]].fStandOffRight * m_fMMToUnitValue;

                    strFailMessage += ", Measure: " + fResultData.ToString("F" + m_intDecimal);
                }
            }

            if (m_intResultPadNoEdgeDistance_Top >= 0 && ((m_intFailResultMask & 0x20000000) > 0))
            {
                strFailMessage += strPosition + "Pad " + (m_intResultPadNoEdgeDistance_Top + 1) + " Edge Distance Top Fail,";

                fMin = m_fEdgeDistanceMin_Top * m_fMMToUnitValue;

                fMax = m_fEdgeDistanceMax_Top * m_fMMToUnitValue;

                float fResultData = m_fResultPadEdgeDistance_Top * m_fMMToUnitValue;

                strFailMessage += "Min: " + fMin.ToString("F" + m_intDecimal) + ", Max: " + fMax.ToString("F" + m_intDecimal) + ", Measure: " + fResultData.ToString("F" + m_intDecimal);
            }

            if (m_intResultPadNoEdgeDistance_Right >= 0 && ((m_intFailResultMask & 0x40000000) > 0))
            {
                strFailMessage += strPosition + "Pad " + (m_intResultPadNoEdgeDistance_Right + 1) + " Edge Distance Right Fail,";

                fMin = m_fEdgeDistanceMin_Right * m_fMMToUnitValue;

                fMax = m_fEdgeDistanceMax_Right * m_fMMToUnitValue;

                float fResultData = m_fResultPadEdgeDistance_Right * m_fMMToUnitValue;

                strFailMessage += "Min: " + fMin.ToString("F" + m_intDecimal) + ", Max: " + fMax.ToString("F" + m_intDecimal) + ", Measure: " + fResultData.ToString("F" + m_intDecimal);
            }

            if (m_intResultPadNoEdgeDistance_Bottom >= 0 && ((m_intFailResultMask & 0x80000000) > 0))
            {
                strFailMessage += strPosition + "Pad " + (m_intResultPadNoEdgeDistance_Bottom + 1) + " Edge Distance Bottom Fail,";

                fMin = m_fEdgeDistanceMin_Bottom * m_fMMToUnitValue;

                fMax = m_fEdgeDistanceMax_Bottom * m_fMMToUnitValue;

                float fResultData = m_fResultPadEdgeDistance_Bottom * m_fMMToUnitValue;

                strFailMessage += "Min: " + fMin.ToString("F" + m_intDecimal) + ", Max: " + fMax.ToString("F" + m_intDecimal) + ", Measure: " + fResultData.ToString("F" + m_intDecimal);
            }

            if (m_intResultPadNoEdgeDistance_Left >= 0 && ((m_intFailResultMask & 0x100000000) > 0))
            {
                strFailMessage += strPosition + "Pad " + (m_intResultPadNoEdgeDistance_Left + 1) + " Edge Distance Left Fail,";

                fMin = m_fEdgeDistanceMin_Left * m_fMMToUnitValue;

                fMax = m_fEdgeDistanceMax_Left * m_fMMToUnitValue;

                float fResultData = m_fResultPadEdgeDistance_Left * m_fMMToUnitValue;

                strFailMessage += "Min: " + fMin.ToString("F" + m_intDecimal) + ", Max: " + fMax.ToString("F" + m_intDecimal) + ", Measure: " + fResultData.ToString("F" + m_intDecimal);
            }

            if (((m_intFailResultMask & 0x200000000) > 0))
            {
                strFailMessage += strPosition + "Pad Span X Fail,";

                fMin = m_fMinSpanX * m_fMMToUnitValue;

                fMax = m_fMaxSpanX * m_fMMToUnitValue;

                float fResultData = m_fResultPadSpanX * m_fMMToUnitValue;

                strFailMessage += "Min: " + fMin.ToString("F" + m_intDecimal) + ", Max: " + fMax.ToString("F" + m_intDecimal) + ", Measure: " + fResultData.ToString("F" + m_intDecimal);
            }

            if (((m_intFailResultMask & 0x400000000) > 0))
            {
                strFailMessage += strPosition + "Pad Span Y Fail,";

                fMin = m_fMinSpanY * m_fMMToUnitValue;

                fMax = m_fMaxSpanY * m_fMMToUnitValue;

                float fResultData = m_fResultPadSpanY * m_fMMToUnitValue;

                strFailMessage += "Min: " + fMin.ToString("F" + m_intDecimal) + ", Max: " + fMax.ToString("F" + m_intDecimal) + ", Measure: " + fResultData.ToString("F" + m_intDecimal);
            }

            if ((m_intFailResultMask & 0x01) > 0)
            {
                strFailMessage += strPosition + "Foreign Material/Contamination Fail.";

                if (m_blnFailForeignMaterialLength)
                {
                    fData = GetExtraPadLengthLimit(1);  // Until here
                    strFailMessage += " *Set Length: " + fData.ToString("F" + m_intDecimal) + "mm";
                    fData = m_fResultExtraPadMinArea * m_fMMToUnitValue;
                    strFailMessage += ". *Result: Min=" + fData.ToString("F" + m_intDecimal) + "mm";
                    fData = m_fResultExtraPadMaxArea * m_fMMToUnitValue;
                    strFailMessage += ", Max=" + fData.ToString("F" + m_intDecimal) + "mm";
                }
                if (m_blnFailForeignMaterialArea)
                {

                    if (m_fResultExtraPadMaxArea >= 0)
                    {
                        fData = GetExtraPadMinArea(1);  // Until here
                        strFailMessage += " *Set Area: " + fData.ToString("F" + m_intDecimal2) + "mm^2";
                        fData = m_fResultExtraPadMinArea * m_fMMToUnitValueArea;
                        strFailMessage += ". *Result: Min=" + fData.ToString("F" + m_intDecimal2) + "mm^2";
                        fData = m_fResultExtraPadMaxArea * m_fMMToUnitValueArea;
                        strFailMessage += ", Max=" + fData.ToString("F" + m_intDecimal2) + "mm^2";
                    }
                }
            }

            if ((m_intFailResultMask & 0x1000) > 0)
            {
                strFailMessage += strPosition + "Total Foreign Material/Contamination Fail.";

                if (m_fResultTotalExtraPadArea >= 0)
                {
                    fData = GetTotalExtraPadMinArea(1);  // Until here
                    strFailMessage += " *Set Total Area: " + fData.ToString("F" + m_intDecimal2) + "mm^2";
                    fData = m_fResultTotalExtraPadArea * m_fMMToUnitValueArea;
                    strFailMessage += ". *Result: Total Area=" + fData.ToString("F" + m_intDecimal2) + "mm^2";
                }
            }

            //Color Defect
            for (int i = 0; i < m_arrColorDefectList.Count; i++)
            {
                int intColorThresIndex = 0;
                if ((m_arrColorDefectList[i].ref_intFailMask & 0x01) > 0)
                {
                    intColorThresIndex = 0;
                }
                else if ((m_arrColorDefectList[i].ref_intFailMask & 0x02) > 0)
                {
                    intColorThresIndex = 1;
                }
                else if ((m_arrColorDefectList[i].ref_intFailMask & 0x04) > 0)
                {
                    intColorThresIndex = 2;
                }
                else if ((m_arrColorDefectList[i].ref_intFailMask & 0x08) > 0)
                {
                    intColorThresIndex = 3;
                }
                else if ((m_arrColorDefectList[i].ref_intFailMask & 0x10) > 0)
                {
                    intColorThresIndex = 4;
                }

                if ((m_arrColorDefectList[i].ref_intFailCriteria & 0x01) > 0)
                {
                    strFailMessage += "*Defect " + (i + 1) + ": Image " + m_arrColorDefectList[i].ref_intImageNo + " " + m_arrColorDefectList[i].ref_strName + " width fail. Set=" + GetColorDefectInspectionWidthLimit(1, intColorThresIndex) +
                        "mm, Result=" + (m_arrColorDefectList[i].ref_fWidthFailValue * m_fMMToUnitValue).ToString("F" + m_intDecimal) + "mm.";
                }

                if ((m_arrColorDefectList[i].ref_intFailCriteria & 0x02) > 0)
                {
                    strFailMessage += "*Defect " + (i + 1) + ": Image " + m_arrColorDefectList[i].ref_intImageNo + " " + m_arrColorDefectList[i].ref_strName + " length fail. Set=" + GetColorDefectInspectionLengthLimit(1, intColorThresIndex) +
                        "mm, Result=" + (m_arrColorDefectList[i].ref_fHeightFailValue * m_fMMToUnitValue).ToString("F" + m_intDecimal) + "mm.";
                }

                if ((m_arrColorDefectList[i].ref_intFailCriteria & 0x04) > 0)
                {
                    strFailMessage += "*Defect " + (i + 1) + ": Image " + m_arrColorDefectList[i].ref_intImageNo + " " + m_arrColorDefectList[i].ref_strName + " area fail. Set Min=" + GetColorDefectInspectionMinAreaLimit(1, intColorThresIndex) +
                       "mm^2, Max=" + GetColorDefectInspectionMaxAreaLimit(1, intColorThresIndex) + "mm^2, Result=" + (m_arrColorDefectList[i].ref_fAreaFailValue * m_fMMToUnitValueArea).ToString("F" + m_intDecimal2) + "mm^2.";
                }

                if ((m_arrColorDefectList[i].ref_intFailCriteria & 0x08) > 0)
                {
                    strFailMessage += "*Defect " + (i + 1) + ": Image " + m_arrColorDefectList[i].ref_intImageNo + " " + m_arrColorDefectList[i].ref_strName + " total area fail. Set=" + GetColorDefectInspectionTotalAreaLimit(1, intColorThresIndex) +
                        "mm^2, Result=" + (m_arrColorDefectList[i].ref_fAreaFailValue * m_fMMToUnitValueArea).ToString("F" + m_intDecimal2) + "mm^2.";
                }

                if ((m_arrColorDefectList[i].ref_intFailCriteria & 0x10) > 0)
                {
                    strFailMessage += "*Defect " + (i + 1) + ": Image " + m_arrColorDefectList[i].ref_intImageNo + " " + m_arrColorDefectList[i].ref_strName + " fail. Missing Good Type Color";
                }

            }

            return strFailMessage;
        }

        public string GetPadFailResultMask()
        {
            for (int i = 0; i < m_arrSampleBlobPads.Length; i++)
            {
                if ((m_arrSampleBlobPads[i].intFailMask & 0x40) > 0 || (m_arrSampleBlobPads[i].intFailMask & 0x80) > 0)
                {
                    return "FailDimension";
                }

                if ((m_arrSampleBlobPads[i].intFailMask & 0x20) > 0)
                {
                    return "FailArea";
                }

                if ((m_arrSampleBlobPads[i].intFailMask & 0x100) > 0)
                {
                    return "FailOffset";
                }

                if ((m_arrSampleBlobPads[i].intFailMask & 0x04) > 0)
                {
                    return "FailPadMissing";
                }

                //Joint Pad
                if ((m_arrSampleBlobPads[i].intFailMask & 0x02) > 0)
                {
                    return "FailPad";
                }

                //Broken Pad and Hole Pad
                if ((m_arrSampleBlobPads[i].intFailMask & 0x08) > 0 || (m_arrSampleBlobPads[i].intFailMask & 0x10) > 0)
                {
                    return "FailBroken";
                }

                //Excess Pad
                if ((m_arrSampleBlobPads[i].intFailMask & 0x800) > 0)
                {
                    return "FailExcess";
                }

                //Smear Pad
                if ((m_arrSampleBlobPads[i].intFailMask & 0x2000) > 0)
                {
                    return "FailSmear";
                }

                //Edge Limit
                if (((m_arrSampleBlobPads[i].intFailMask & 0x200000) > 0) ||
                    ((m_arrSampleBlobPads[i].intFailMask & 0x400000) > 0) ||
                    ((m_arrSampleBlobPads[i].intFailMask & 0x800000) > 0) ||
                    ((m_arrSampleBlobPads[i].intFailMask & 0x1000000) > 0))
                {
                    return "FailEdgeLimit";
                }

                //Stand Off
                if (((m_arrSampleBlobPads[i].intFailMask & 0x2000000) > 0) ||
                    ((m_arrSampleBlobPads[i].intFailMask & 0x4000000) > 0) ||
                    ((m_arrSampleBlobPads[i].intFailMask & 0x8000000) > 0) ||
                    ((m_arrSampleBlobPads[i].intFailMask & 0x10000000) > 0))
                {
                    return "FailStandOff";
                }

                //Edge Distance
                if (((m_arrSampleBlobPads[i].intFailMask & 0x20000000) > 0) ||
                    ((m_arrSampleBlobPads[i].intFailMask & 0x40000000) > 0) ||
                    ((m_arrSampleBlobPads[i].intFailMask & 0x80000000) > 0) ||
                    ((m_arrSampleBlobPads[i].intFailMask & 0x100000000) > 0))
                {
                    return "FailEdgeDistance";
                }

                //Span
                if (((m_arrSampleBlobPads[i].intFailMask & 0x200000000) > 0) ||
                    ((m_arrSampleBlobPads[i].intFailMask & 0x400000000) > 0))
                {
                    return "FailSpan";
                }

            }

            for (int y = 0; y < m_arrPitchGap.Count; y++)
            {
                if ((m_arrPitchGap[y].intFailMask & 0x200) > 0 || (m_arrPitchGap[y].intFailMask & 0x400) > 0)
                {
                    return "FailPitchGap";
                }
            }

            if ((m_intFailResultMask & 0x01) > 0 || (m_intFailResultMask & 0x1000) > 0)
            {
                return "FailContamination";
            }

            if (m_intFailColorResultMask > 0)
            {
                return "FailPadColorDefect";
            }

            return "FailPad";
        }

        public string GetPackageFailTestDisplayResult(string strPosition)
        {
            string strErrorMessage = "";
            bool blnTotalContaminationFail = false;
            for (int i = 0; i < m_arrPkgDefectList.Count; i++)
            {
                // Chip off
                if ((m_arrPkgDefectList[i].ref_intFailMask & 0x04) > 0)
                {
                    if (m_blnUseDetailDefectCriteria)
                        strErrorMessage += "*Defect " + (i + 1) + ": Image " + m_arrPkgDefectList[i].ref_intImageNo + " chipped off. Set=" + m_fChipArea +
                            "mm^2, Result=" + (m_arrPkgDefectList[i].ref_fFailValue * m_fMMToUnitValueArea).ToString("F" + m_intDecimal2) + "mm^2.";
                    else
                    {
                        if (m_arrPkgDefectList[i].ref_intImageNo == 1)
                            strErrorMessage += "*Defect " + (i + 1) + ": Image " + m_arrPkgDefectList[i].ref_intImageNo + " chipped off. Set=" + m_fBrightChippedOffArea +
                        "mm^2, Result=" + (m_arrPkgDefectList[i].ref_fFailValue * m_fMMToUnitValueArea).ToString("F" + m_intDecimal2) + "mm^2.";
                        else
                            strErrorMessage += "*Defect " + (i + 1) + ": Image " + m_arrPkgDefectList[i].ref_intImageNo + " chipped off. Set=" + m_fDarkChippedOffArea +
                   "mm^2, Result=" + (m_arrPkgDefectList[i].ref_fFailValue * m_fMMToUnitValueArea).ToString("F" + m_intDecimal2) + "mm^2.";
                    }
                }

                // Scratches
                if ((m_arrPkgDefectList[i].ref_intFailMask & 0x08) > 0)
                {
                    if ((m_arrPkgDefectList[i].ref_intFailCriteria & 0x01) > 0)
                    {
                        strErrorMessage += "*Defect " + (i + 1) + ": Image " + m_arrPkgDefectList[i].ref_intImageNo + " package scratch width. Set=" + GetScratchLengthLimit(1) +
                            "mm, Result=" + (m_arrPkgDefectList[i].ref_fWidthFailValue * m_fMMToUnitValue).ToString("F" + m_intDecimal) + "mm.";
                    }

                    if ((m_arrPkgDefectList[i].ref_intFailCriteria & 0x02) > 0)
                    {
                        strErrorMessage += "*Defect " + (i + 1) + ": Image " + m_arrPkgDefectList[i].ref_intImageNo + " package scratch height. Set=" + GetScratchLengthLimit(1) +
                            "mm, Result=" + (m_arrPkgDefectList[i].ref_fHeightFailValue * m_fMMToUnitValue).ToString("F" + m_intDecimal) + "mm.";
                    }

                    if ((m_arrPkgDefectList[i].ref_intFailCriteria & 0x04) > 0)
                    {
                        strErrorMessage += "*Defect " + (i + 1) + ": Image " + m_arrPkgDefectList[i].ref_intImageNo + " package scratch area. Set=" + GetScratchAreaLimit(1) +
                            "mm^2, Result=" + (m_arrPkgDefectList[i].ref_fAreaFailValue * m_fMMToUnitValueArea).ToString("F" + m_intDecimal2) + "mm^2.";
                    }
                }

                // Contamination
                if ((m_arrPkgDefectList[i].ref_intFailMask & 0x10) > 0)
                {
                    if ((m_arrPkgDefectList[i].ref_intFailCriteria & 0x01) > 0)
                    {
                        strErrorMessage += "*Defect " + (i + 1) + ": Image " + m_arrPkgDefectList[i].ref_intImageNo + " package contamination width. Set=" + GetExtraPadLengthLimit(1) +
                            "mm, Result=" + (m_arrPkgDefectList[i].ref_fWidthFailValue * m_fMMToUnitValue).ToString("F" + m_intDecimal) + "mm.";
                    }

                    if ((m_arrPkgDefectList[i].ref_intFailCriteria & 0x02) > 0)
                    {
                        strErrorMessage += "*Defect " + (i + 1) + ": Image " + m_arrPkgDefectList[i].ref_intImageNo + " package contamination height. Set=" + GetExtraPadLengthLimit(1) +
                            "mm, Result=" + (m_arrPkgDefectList[i].ref_fHeightFailValue * m_fMMToUnitValue).ToString("F" + m_intDecimal) + "mm.";
                    }

                    if ((m_arrPkgDefectList[i].ref_intFailCriteria & 0x04) > 0)
                    {
                        strErrorMessage += "*Defect " + (i + 1) + ": Image " + m_arrPkgDefectList[i].ref_intImageNo + " package contamination area. Set=" + GetExtraPadMinArea(1) +
                            "mm^2, Result=" + (m_arrPkgDefectList[i].ref_fAreaFailValue * m_fMMToUnitValueArea).ToString("F" + m_intDecimal2) + "mm^2.";
                    }
                }

                //Bright
                if ((m_arrPkgDefectList[i].ref_intFailMask & 0x10000) > 0)
                {
                    if ((m_arrPkgDefectList[i].ref_intFailCriteria & 0x01) > 0)
                    {
                        strErrorMessage += "*Defect " + (i + 1) + ": Image " + m_arrPkgDefectList[i].ref_intImageNo + " package bright width fail. Set=" + GetBrightWidthLimit(1) +
                            "mm, Result=" + (m_arrPkgDefectList[i].ref_fWidthFailValue * m_fMMToUnitValue).ToString("F" + m_intDecimal) + "mm.";
                    }

                    if ((m_arrPkgDefectList[i].ref_intFailCriteria & 0x02) > 0)
                    {
                        strErrorMessage += "*Defect " + (i + 1) + ": Image " + m_arrPkgDefectList[i].ref_intImageNo + " package bright length fail. Set=" + GetBrightLengthLimit(1) +
                            "mm, Result=" + (m_arrPkgDefectList[i].ref_fHeightFailValue * m_fMMToUnitValue).ToString("F" + m_intDecimal) + "mm.";
                    }

                    if ((m_arrPkgDefectList[i].ref_intFailCriteria & 0x04) > 0)
                    {
                        strErrorMessage += "*Defect " + (i + 1) + ": Image " + m_arrPkgDefectList[i].ref_intImageNo + " package bright area fail. Set=" + GetBrightAreaLimit(1) +
                            "mm^2, Result=" + (m_arrPkgDefectList[i].ref_fAreaFailValue * m_fMMToUnitValueArea).ToString("F" + m_intDecimal2) + "mm^2.";
                    }

                    if ((m_arrPkgDefectList[i].ref_intFailCriteria & 0x08) > 0)
                    {
                        strErrorMessage += "*Defect " + (i + 1) + ": Image " + m_arrPkgDefectList[i].ref_intImageNo + " package bright total area fail. Set=" + GetBrightTotalAreaLimit(1) +
                            "mm^2, Result=" + (m_arrPkgDefectList[i].ref_fAreaFailValue * m_fMMToUnitValueArea).ToString("F" + m_intDecimal2) + "mm^2.";
                    }

                }

                //Dark
                if ((m_arrPkgDefectList[i].ref_intFailMask & 0x20000) > 0)
                {
                    if ((m_arrPkgDefectList[i].ref_intFailCriteria & 0x01) > 0)
                    {
                        strErrorMessage += "*Defect " + (i + 1) + ": Image " + m_arrPkgDefectList[i].ref_intImageNo + " package dark width fail. Set=" + GetDarkWidthLimit(1) +
                            "mm, Result=" + (m_arrPkgDefectList[i].ref_fWidthFailValue * m_fMMToUnitValue).ToString("F" + m_intDecimal) + "mm.";
                    }

                    if ((m_arrPkgDefectList[i].ref_intFailCriteria & 0x02) > 0)
                    {
                        strErrorMessage += "*Defect " + (i + 1) + ": Image " + m_arrPkgDefectList[i].ref_intImageNo + " package dark length fail. Set=" + GetDarkLengthLimit(1) +
                            "mm, Result=" + (m_arrPkgDefectList[i].ref_fHeightFailValue * m_fMMToUnitValue).ToString("F" + m_intDecimal) + "mm.";
                    }

                    if ((m_arrPkgDefectList[i].ref_intFailCriteria & 0x04) > 0)
                    {
                        strErrorMessage += "*Defect " + (i + 1) + ": Image " + m_arrPkgDefectList[i].ref_intImageNo + " package dark area fail. Set=" + GetDarkAreaLimit(1) +
                            "mm^2, Result=" + (m_arrPkgDefectList[i].ref_fAreaFailValue * m_fMMToUnitValueArea).ToString("F" + m_intDecimal2) + "mm^2.";
                    }

                    if ((m_arrPkgDefectList[i].ref_intFailCriteria & 0x08) > 0)
                    {
                        strErrorMessage += "*Defect " + (i + 1) + ": Image " + m_arrPkgDefectList[i].ref_intImageNo + " package dark total area fail. Set=" + GetDarkTotalAreaLimit(1) +
                            "mm^2, Result=" + (m_arrPkgDefectList[i].ref_fAreaFailValue * m_fMMToUnitValueArea).ToString("F" + m_intDecimal2) + "mm^2.";
                    }

                }

                //Foreign Material
                if ((m_arrPkgDefectList[i].ref_intFailMask & 0x40000) > 0)
                {
                    if ((m_arrPkgDefectList[i].ref_intFailCriteria & 0x01) > 0)
                    {
                        strErrorMessage += "*Defect " + (i + 1) + ": Image " + m_arrPkgDefectList[i].ref_intImageNo + " package Foreign Material bright width fail. Set=" + GetBrightHorizontalForeignMaterialLimit(1) +
                            "mm, Result=" + (m_arrPkgDefectList[i].ref_fWidthFailValue * m_fMMToUnitValue).ToString("F" + m_intDecimal) + "mm.";
                    }

                    if ((m_arrPkgDefectList[i].ref_intFailCriteria & 0x02) > 0)
                    {
                        strErrorMessage += "*Defect " + (i + 1) + ": Image " + m_arrPkgDefectList[i].ref_intImageNo + " package Foreign Material bright length fail. Set=" + GetBrightVerticalForeignMaterialLimit(1) +
                            "mm, Result=" + (m_arrPkgDefectList[i].ref_fHeightFailValue * m_fMMToUnitValue).ToString("F" + m_intDecimal) + "mm.";
                    }

                    if ((m_arrPkgDefectList[i].ref_intFailCriteria & 0x04) > 0)
                    {
                        strErrorMessage += "*Defect " + (i + 1) + ": Image " + m_arrPkgDefectList[i].ref_intImageNo + " package Foreign Material bright area fail. Set=" + GetForeignMaterialAreaLimit(1) +
                            "mm^2, Result=" + (m_arrPkgDefectList[i].ref_fAreaFailValue * m_fMMToUnitValueArea).ToString("F" + m_intDecimal2) + "mm^2.";
                    }

                }

                // Total Contamination
                if ((m_arrPkgDefectList[i].ref_intFailMask & 0x40) > 0)
                {

                }

                // Mold Flash
                if (((m_intFailPkgOptionMask & 0x80) > 0) || ((m_intFailPkgOptionMask & 0x1000000) > 0))
                {
                    if ((m_arrPkgDefectList[i].ref_intFailCriteria & 0x01) > 0)
                    {
                        strErrorMessage += "*Defect " + (i + 1) + ": Image " + m_arrPkgDefectList[i].ref_intImageNo + " mold flash width. Set=" + GetMoldFlashWidthLimit(1) +
                                            "mm, Result=" + (m_arrPkgDefectList[i].ref_fWidthFailValue * m_fMMToUnitValue).ToString("F" + m_intDecimal) + "mm.";
                    }

                    if ((m_arrPkgDefectList[i].ref_intFailCriteria & 0x02) > 0)
                    {
                        strErrorMessage += "*Defect " + (i + 1) + ": Image " + m_arrPkgDefectList[i].ref_intImageNo + " mold flash length. Set=" + GetMoldFlashLengthLimit(1) +
                                            "mm, Result=" + (m_arrPkgDefectList[i].ref_fHeightFailValue * m_fMMToUnitValue).ToString("F" + m_intDecimal) + "mm.";
                    }

                    if ((m_arrPkgDefectList[i].ref_intFailCriteria & 0x04) > 0)
                    {
                        strErrorMessage += "*Defect " + (i + 1) + ": Image " + m_arrPkgDefectList[i].ref_intImageNo + " mold flash area Fail. Set=" + m_fMoldFlashArea +
                             "mm^2, Result=" + (m_arrPkgDefectList[i].ref_fAreaFailValue * m_fMMToUnitValueArea).ToString("F" + m_intDecimal2) + "mm^2.";
                    }

                    if ((m_arrPkgDefectList[i].ref_intFailCriteria & 0x08) > 0)
                    {
                        strErrorMessage += "*Defect " + (i + 1) + ": Image " + m_arrPkgDefectList[i].ref_intImageNo + " mold flash total area fail. Set=" + m_fMoldFlashTotalArea +
                            "mm^2, Result=" + (m_arrPkgDefectList[i].ref_fAreaFailValue * m_fMMToUnitValueArea).ToString("F" + m_intDecimal2) + "mm^2.";
                    }

                }

                // Void
                if ((m_arrPkgDefectList[i].ref_intFailMask & 0x100) > 0)
                {
                    if ((m_arrPkgDefectList[i].ref_intFailCriteria & 0x01) > 0)
                    {
                        strErrorMessage += "*Defect " + (i + 1) + ": Image " + m_arrPkgDefectList[i].ref_intImageNo + " package void width. Set=" + GetVoidLengthLimit(1) +
                            "mm, Result=" + (m_arrPkgDefectList[i].ref_fWidthFailValue * m_fMMToUnitValue).ToString("F" + m_intDecimal) + "mm.";
                    }

                    if ((m_arrPkgDefectList[i].ref_intFailCriteria & 0x02) > 0)
                    {
                        strErrorMessage += "*Defect " + (i + 1) + ": Image " + m_arrPkgDefectList[i].ref_intImageNo + " package void height. Set=" + GetVoidLengthLimit(1) +
                            "mm, Result=" + (m_arrPkgDefectList[i].ref_fHeightFailValue * m_fMMToUnitValue).ToString("F" + m_intDecimal) + "mm.";
                    }

                    if ((m_arrPkgDefectList[i].ref_intFailCriteria & 0x04) > 0)
                    {
                        strErrorMessage += "*Defect " + (i + 1) + ": Image " + m_arrPkgDefectList[i].ref_intImageNo + " package void area. Set=" + GetVoidAreaLimit(1) +
                            "mm^2, Result=" + (m_arrPkgDefectList[i].ref_fAreaFailValue * m_fMMToUnitValueArea).ToString("F" + m_intDecimal2) + "mm^2.";
                    }

                }

                // Crack
                if ((m_arrPkgDefectList[i].ref_intFailMask & 0x400) > 0)
                {
                    if (m_blnUseDetailDefectCriteria)
                    {
                        if ((m_arrPkgDefectList[i].ref_intFailCriteria & 0x01) > 0)
                        {
                            // 2019 05 16 - CCENG: Display "crack length" not crack width or height since the Setting display Crack Length also.
                            //strErrorMessage += "*Defect " + (i + 1) + ": Image " + m_arrPkgDefectList[i].ref_intImageNo + " package crack width. Set=" + GetCrackLengthLimit(1) +
                            //    "mm, Result=" + (m_arrPkgDefectList[i].ref_fWidthFailValue * m_fMMToUnitValue).ToString("F" + m_intDecimal) + "mm.";
                            strErrorMessage += "*Defect " + (i + 1) + ": Image " + m_arrPkgDefectList[i].ref_intImageNo + " package crack length. Set=" + GetCrackLengthLimit(1) +
                                "mm, Result=" + (m_arrPkgDefectList[i].ref_fWidthFailValue * m_fMMToUnitValue).ToString("F" + m_intDecimal) + "mm.";
                        }

                        if ((m_arrPkgDefectList[i].ref_intFailCriteria & 0x02) > 0)
                        {
                            // 2019 05 16 - CCENG: Display "crack length" not crack width or height since the Setting display Crack Length also.
                            //strErrorMessage += "*Defect " + (i + 1) + ": Image " + m_arrPkgDefectList[i].ref_intImageNo + " package crack height. Set=" + GetCrackLengthLimit(1) +
                            //    "mm, Result=" + (m_arrPkgDefectList[i].ref_fHeightFailValue * m_fMMToUnitValue).ToString("F" + m_intDecimal) + "mm.";
                            strErrorMessage += "*Defect " + (i + 1) + ": Image " + m_arrPkgDefectList[i].ref_intImageNo + " package crack length. Set=" + GetCrackLengthLimit(1) +
        "mm, Result=" + (m_arrPkgDefectList[i].ref_fHeightFailValue * m_fMMToUnitValue).ToString("F" + m_intDecimal) + "mm.";
                        }
                    }
                    else
                    {
                        if ((m_arrPkgDefectList[i].ref_intFailCriteria & 0x01) > 0)
                        {
                            // 2019 05 16 - CCENG: Display "crack length" not crack width or height since the Setting display Crack Length also.
                            //strErrorMessage += "*Defect " + (i + 1) + ": Image " + m_arrPkgDefectList[i].ref_intImageNo + " package crack width. Set=" + GetCrackLengthLimit(1) +
                            //    "mm, Result=" + (m_arrPkgDefectList[i].ref_fWidthFailValue * m_fMMToUnitValue).ToString("F" + m_intDecimal) + "mm.";
                            strErrorMessage += "*Defect " + (i + 1) + ": Image " + m_arrPkgDefectList[i].ref_intImageNo + " package crack width. Set=" + GetDarkHorizontalCrackLimit(1) +
                                "mm, Result=" + (m_arrPkgDefectList[i].ref_fWidthFailValue * m_fMMToUnitValue).ToString("F" + m_intDecimal) + "mm.";
                        }

                        if ((m_arrPkgDefectList[i].ref_intFailCriteria & 0x02) > 0)
                        {
                            // 2019 05 16 - CCENG: Display "crack length" not crack width or height since the Setting display Crack Length also.
                            //strErrorMessage += "*Defect " + (i + 1) + ": Image " + m_arrPkgDefectList[i].ref_intImageNo + " package crack height. Set=" + GetCrackLengthLimit(1) +
                            //    "mm, Result=" + (m_arrPkgDefectList[i].ref_fHeightFailValue * m_fMMToUnitValue).ToString("F" + m_intDecimal) + "mm.";
                            strErrorMessage += "*Defect " + (i + 1) + ": Image " + m_arrPkgDefectList[i].ref_intImageNo + " package crack length. Set=" + GetDarkVerticalCrackLimit(1) +
        "mm, Result=" + (m_arrPkgDefectList[i].ref_fHeightFailValue * m_fMMToUnitValue).ToString("F" + m_intDecimal) + "mm.";
                        }
                    }

                    if ((m_arrPkgDefectList[i].ref_intFailCriteria & 0x04) > 0)
                    {
                        strErrorMessage += "*Defect " + (i + 1) + ": Image " + m_arrPkgDefectList[i].ref_intImageNo + " package crack area. Set=" + GetCrackAreaLimit(1) +
                            "mm^2, Result=" + (m_arrPkgDefectList[i].ref_fAreaFailValue * m_fMMToUnitValueArea).ToString("F" + m_intDecimal2) + "mm^2.";
                    }
                }
            }

            // Total Area Contamination
            if (m_fResultTotalExtraPadArea > 0)
            {
                strErrorMessage += "*Image 1 package contamination total area. Set=" + GetTotalExtraPadMinArea(1) +
                    "mm^2, Result=" + (m_fResultTotalExtraPadArea * m_fMMToUnitValueArea).ToString("F" + m_intDecimal2) + "mm^2.";

            }

            //if (m_fResultBrightFieldTotalArea > 0)
            //{
            //    strErrorMessage += "*Image 1 package bright total area fail. Set=" + GetBrightTotalAreaLimit(1) +
            //        "mm^2, Result=" + (m_fResultBrightFieldTotalArea * m_fMMToUnitValueArea).ToString("F" + m_intDecimal2) + "mm^2.";

            //}

            //if (m_fResultDarkFieldTotalArea > 0)
            //{
            //    strErrorMessage += "*Image 1 package dark total area fail. Set=" + GetDarkTotalAreaLimit(1) +
            //        "mm^2, Result=" + (m_fResultDarkFieldTotalArea * m_fMMToUnitValueArea).ToString("F" + m_intDecimal2) + "mm^2.";

            //}

            if (strErrorMessage == "")
                strErrorMessage = m_strErrorMessage;
            return strErrorMessage;
        }

        /// <summary>
        /// Get pitch gap data
        /// </summary>
        /// <param name="intPitchGapIndex">pitch gap index</param>
        /// <returns>pitch gap data</returns>
        public string GetPitchGapData(int intPitchGapIndex)
        {
            string strPitchGapData = "";

            PitchGap stcPitchGap = m_arrPitchGap[intPitchGapIndex];

            strPitchGapData += stcPitchGap.intFromPadNo.ToString() + "#";
            strPitchGapData += stcPitchGap.intToPadNo.ToString() + "#";
            strPitchGapData += (stcPitchGap.fMinPitch * m_fMMToUnitValue).ToString("F" + m_intDecimal) + "#";
            strPitchGapData += (stcPitchGap.fMaxPitch * m_fMMToUnitValue).ToString("F" + m_intDecimal) + "#";
            strPitchGapData += (stcPitchGap.fMinGap * m_fMMToUnitValue).ToString("F" + m_intDecimal) + "#";
            strPitchGapData += (stcPitchGap.fMaxGap * m_fMMToUnitValue).ToString("F" + m_intDecimal) + "#";
            strPitchGapData += stcPitchGap.fGap.ToString() + "#";
            strPitchGapData += stcPitchGap.fPitch.ToString() + "#";
            strPitchGapData += stcPitchGap.intStartPointX.ToString() + "#";
            strPitchGapData += stcPitchGap.intStartPointY.ToString() + "#";
            strPitchGapData += stcPitchGap.intEndPointX.ToString() + "#";
            strPitchGapData += stcPitchGap.intEndPointY.ToString() + "#";
            strPitchGapData += stcPitchGap.intDirection.ToString() + "#";

            return strPitchGapData;
        }

        public int GetPitchGapToPadNo(int intFromPadNo)
        {
            string strPitchGapData = "";

            for (int i = 0; i < m_arrPitchGap.Count; i++)
            {
                PitchGap stcPitchGap = m_arrPitchGap[i];

                if (stcPitchGap.intFromPadNo == intFromPadNo)
                {
                    return stcPitchGap.intToPadNo;
                }
            }

            return -1;
        }

        /// <summary>
        /// Get template pads no
        /// </summary>
        /// <returns>template pads no</returns>
        public string GetTemplatePadsNo()
        {
            string strPadsNo = "";
            for (int i = 0; i < m_arrTemplateBlobPads.Count; i++)
            {
                strPadsNo += ((BlobsFeatures)m_arrTemplateBlobPads[i]).intNoID.ToString() + "#";
            }
            return strPadsNo;
        }



        /// <summary>
        /// Analyzing pad
        /// </summary>
        /// <param name="intPadPosition">pad position</param>
        public void AnalyingPad_ClosestSizeMethod(int intPadPosition)
        {
            // Reset blob pitch, gab and direction information
            for (int i = 0; i < m_arrTemplateBlobPads.Count; i++)
            {
                BlobsFeatures m_stcBlobPad = (BlobsFeatures)m_arrTemplateBlobPads[i];
                m_stcBlobPad.intDirection = -1;
                m_stcBlobPad.intGroupID = 0;
                m_stcBlobPad.fPitch = -1;
                m_stcBlobPad.fGap = -1;
                m_stcBlobPad.intNoID = 0;
                m_arrTemplateBlobPads.RemoveAt(i);
                m_arrTemplateBlobPads.Insert(i, m_stcBlobPad);
            }

            ClassifyObjectsToDirectionGroup(intPadPosition);
            SortObjectNumber(intPadPosition);
            RearrangeBlobs();

            //m_arrPitchGap.Clear();
        }

        public void AnalyingPad_DefaultToleranceMethod(int intPadPosition)
        {
            // Reset blob pitch, gab and direction information
            for (int i = 0; i < m_arrTemplateBlobPads.Count; i++)
            {
                BlobsFeatures m_stcBlobPad = (BlobsFeatures)m_arrTemplateBlobPads[i];
                m_stcBlobPad.intDirection = -1;
                m_stcBlobPad.intGroupID = 0;
                m_stcBlobPad.fPitch = -1;
                m_stcBlobPad.fGap = -1;
                m_stcBlobPad.intNoID = 0;
                m_arrTemplateBlobPads.RemoveAt(i);
                m_arrTemplateBlobPads.Insert(i, m_stcBlobPad);
            }

            ClassifyObjectsToDirectionGroup(intPadPosition);
            SortObjectNumber();
            RearrangeBlobs();

            //m_arrPitchGap.Clear();
        }
        public void BackupBlobsFeaturesForReset()
        {
            m_arrTemporaryBlobPads_ForReset = new ArrayList();
            for (int i = 0; i < m_arrTemplateBlobPads.Count; i++)
            {
                BlobsFeatures m_stcBlobPad = (BlobsFeatures)m_arrTemplateBlobPads[i];

                m_arrTemporaryBlobPads_ForReset.Add(m_stcBlobPad);
            }
        }
        /// <summary>
        /// Back up all data of blobs features into m_arrTemporaryBlobPads
        /// </summary>
        public void BackupBlobsFeatures()
        {
            BlobsFeatures stcTemporaryBlobPad;
            m_arrTemporaryBlobPads = new ArrayList();
            for (int i = 0; i < m_arrTemplateBlobPads.Count; i++)
            {
                stcTemporaryBlobPad = new BlobsFeatures();
                BlobsFeatures m_stcBlobPad = (BlobsFeatures)m_arrTemplateBlobPads[i];

                stcTemporaryBlobPad.fArea = m_stcBlobPad.fArea;
                stcTemporaryBlobPad.fCenterX = m_stcBlobPad.fCenterX;
                stcTemporaryBlobPad.fCenterY = m_stcBlobPad.fCenterY;
                stcTemporaryBlobPad.fLimitCenterX = m_stcBlobPad.fLimitCenterX;
                stcTemporaryBlobPad.fLimitCenterY = m_stcBlobPad.fLimitCenterY;
                stcTemporaryBlobPad.fWidth = m_stcBlobPad.fWidth;
                stcTemporaryBlobPad.fHeight = m_stcBlobPad.fHeight;


                stcTemporaryBlobPad.fWidthPercentStart1 = m_stcBlobPad.fWidthPercentStart1; // for pad dimension start point
                stcTemporaryBlobPad.fHeightPercentStart1 = m_stcBlobPad.fHeightPercentStart1;  // for pad dimension start point
                stcTemporaryBlobPad.fWidthPercentEnd1 = m_stcBlobPad.fWidthPercentEnd1; // for pad dimension end point 
                stcTemporaryBlobPad.fHeightPercentEnd1 = m_stcBlobPad.fHeightPercentEnd1;  // for pad dimension end point
                stcTemporaryBlobPad.fWidthPercentStart2 = m_stcBlobPad.fWidthPercentStart2; // for pad dimension start point
                stcTemporaryBlobPad.fHeightPercentStart2 = m_stcBlobPad.fHeightPercentStart2;  // for pad dimension start point
                stcTemporaryBlobPad.fWidthPercentEnd2 = m_stcBlobPad.fWidthPercentEnd2; // for pad dimension end point 
                stcTemporaryBlobPad.fHeightPercentEnd2 = m_stcBlobPad.fHeightPercentEnd2;  // for pad dimension end point
                stcTemporaryBlobPad.fWidthPercentStart3 = m_stcBlobPad.fWidthPercentStart3; // for pad dimension start point
                stcTemporaryBlobPad.fHeightPercentStart3 = m_stcBlobPad.fHeightPercentStart3;  // for pad dimension start point
                stcTemporaryBlobPad.fWidthPercentEnd3 = m_stcBlobPad.fWidthPercentEnd3; // for pad dimension end point 
                stcTemporaryBlobPad.fHeightPercentEnd3 = m_stcBlobPad.fHeightPercentEnd3;  // for pad dimension end point
                stcTemporaryBlobPad.fWidthPercentStart4 = m_stcBlobPad.fWidthPercentStart4; // for pad dimension start point
                stcTemporaryBlobPad.fHeightPercentStart4 = m_stcBlobPad.fHeightPercentStart4;  // for pad dimension start point
                stcTemporaryBlobPad.fWidthPercentEnd4 = m_stcBlobPad.fWidthPercentEnd4; // for pad dimension end point 
                stcTemporaryBlobPad.fHeightPercentEnd4 = m_stcBlobPad.fHeightPercentEnd4;  // for pad dimension end point
                stcTemporaryBlobPad.fWidthPercentStart5 = m_stcBlobPad.fWidthPercentStart5; // for pad dimension start point
                stcTemporaryBlobPad.fHeightPercentStart5 = m_stcBlobPad.fHeightPercentStart5;  // for pad dimension start point
                stcTemporaryBlobPad.fWidthPercentEnd5 = m_stcBlobPad.fWidthPercentEnd5; // for pad dimension end point 
                stcTemporaryBlobPad.fHeightPercentEnd5 = m_stcBlobPad.fHeightPercentEnd5;  // for pad dimension end point
                stcTemporaryBlobPad.fWidthPercentStart6 = m_stcBlobPad.fWidthPercentStart6; // for pad dimension start point
                stcTemporaryBlobPad.fHeightPercentStart6 = m_stcBlobPad.fHeightPercentStart6;  // for pad dimension start point
                stcTemporaryBlobPad.fWidthPercentEnd6 = m_stcBlobPad.fWidthPercentEnd6; // for pad dimension end point 
                stcTemporaryBlobPad.fHeightPercentEnd6 = m_stcBlobPad.fHeightPercentEnd6;  // for pad dimension end point
                stcTemporaryBlobPad.fWidthPercentStart7 = m_stcBlobPad.fWidthPercentStart7; // for pad dimension start point
                stcTemporaryBlobPad.fHeightPercentStart7 = m_stcBlobPad.fHeightPercentStart7;  // for pad dimension start point
                stcTemporaryBlobPad.fWidthPercentEnd7 = m_stcBlobPad.fWidthPercentEnd7; // for pad dimension end point 
                stcTemporaryBlobPad.fHeightPercentEnd7 = m_stcBlobPad.fHeightPercentEnd7; // for pad dimension end point 
                stcTemporaryBlobPad.fWidthPercentStart8 = m_stcBlobPad.fWidthPercentStart8; // for pad dimension start point
                stcTemporaryBlobPad.fHeightPercentStart8 = m_stcBlobPad.fHeightPercentStart8;  // for pad dimension start point
                stcTemporaryBlobPad.fWidthPercentEnd8 = m_stcBlobPad.fWidthPercentEnd8; // for pad dimension end point 
                stcTemporaryBlobPad.fHeightPercentEnd8 = m_stcBlobPad.fHeightPercentEnd8;  // for pad dimension end point
                stcTemporaryBlobPad.fWidthPercentStart9 = m_stcBlobPad.fWidthPercentStart9; // for pad dimension start point
                stcTemporaryBlobPad.fHeightPercentStart9 = m_stcBlobPad.fHeightPercentStart9;  // for pad dimension start point
                stcTemporaryBlobPad.fWidthPercentEnd9 = m_stcBlobPad.fWidthPercentEnd9; // for pad dimension end point 
                stcTemporaryBlobPad.fHeightPercentEnd9 = m_stcBlobPad.fHeightPercentEnd9;  // for pad dimension end point
                stcTemporaryBlobPad.fWidthPercentStart10 = m_stcBlobPad.fWidthPercentStart10; // for pad dimension start point
                stcTemporaryBlobPad.fHeightPercentStart10 = m_stcBlobPad.fHeightPercentStart10;  // for pad dimension start point
                stcTemporaryBlobPad.fWidthPercentEnd10 = m_stcBlobPad.fWidthPercentEnd10; // for pad dimension end point 
                stcTemporaryBlobPad.fHeightPercentEnd10 = m_stcBlobPad.fHeightPercentEnd10;  // for pad dimension end point
                stcTemporaryBlobPad.fWidthPercentStart11 = m_stcBlobPad.fWidthPercentStart11; // for pad dimension start point
                stcTemporaryBlobPad.fHeightPercentStart11 = m_stcBlobPad.fHeightPercentStart11;  // for pad dimension start point
                stcTemporaryBlobPad.fWidthPercentEnd11 = m_stcBlobPad.fWidthPercentEnd11; // for pad dimension end point 
                stcTemporaryBlobPad.fHeightPercentEnd11 = m_stcBlobPad.fHeightPercentEnd11;  // for pad dimension end point
                stcTemporaryBlobPad.fWidthPercentStart12 = m_stcBlobPad.fWidthPercentStart12; // for pad dimension start point
                stcTemporaryBlobPad.fHeightPercentStart12 = m_stcBlobPad.fHeightPercentStart12;  // for pad dimension start point
                stcTemporaryBlobPad.fWidthPercentEnd12 = m_stcBlobPad.fWidthPercentEnd12; // for pad dimension end point 
                stcTemporaryBlobPad.fHeightPercentEnd12 = m_stcBlobPad.fHeightPercentEnd12; // for pad dimension end point 

                stcTemporaryBlobPad.fInwardPercentStart1 = m_stcBlobPad.fInwardPercentStart1;
                stcTemporaryBlobPad.fInwardPercentEnd1 = m_stcBlobPad.fInwardPercentEnd1;
                stcTemporaryBlobPad.fInwardPercentStart2 = m_stcBlobPad.fInwardPercentStart2;
                stcTemporaryBlobPad.fInwardPercentEnd2 = m_stcBlobPad.fInwardPercentEnd2;
                stcTemporaryBlobPad.fInwardPercentStart3 = m_stcBlobPad.fInwardPercentStart3;
                stcTemporaryBlobPad.fInwardPercentEnd3 = m_stcBlobPad.fInwardPercentEnd3;
                stcTemporaryBlobPad.fInwardPercentStart4 = m_stcBlobPad.fInwardPercentStart4;
                stcTemporaryBlobPad.fInwardPercentEnd4 = m_stcBlobPad.fInwardPercentEnd4;
                stcTemporaryBlobPad.fInwardPercentStart5 = m_stcBlobPad.fInwardPercentStart5;
                stcTemporaryBlobPad.fInwardPercentEnd5 = m_stcBlobPad.fInwardPercentEnd5;
                stcTemporaryBlobPad.fInwardPercentStart6 = m_stcBlobPad.fInwardPercentStart6;
                stcTemporaryBlobPad.fInwardPercentEnd6 = m_stcBlobPad.fInwardPercentEnd6;
                stcTemporaryBlobPad.fInwardPercentStart7 = m_stcBlobPad.fInwardPercentStart7;
                stcTemporaryBlobPad.fInwardPercentEnd7 = m_stcBlobPad.fInwardPercentEnd7;
                stcTemporaryBlobPad.fInwardPercentStart8 = m_stcBlobPad.fInwardPercentStart8;
                stcTemporaryBlobPad.fInwardPercentEnd8 = m_stcBlobPad.fInwardPercentEnd8;
                stcTemporaryBlobPad.fInwardPercentStart9 = m_stcBlobPad.fInwardPercentStart9;
                stcTemporaryBlobPad.fInwardPercentEnd9 = m_stcBlobPad.fInwardPercentEnd9;
                stcTemporaryBlobPad.fInwardPercentStart10 = m_stcBlobPad.fInwardPercentStart10;
                stcTemporaryBlobPad.fInwardPercentEnd10 = m_stcBlobPad.fInwardPercentEnd10;
                stcTemporaryBlobPad.fInwardPercentStart11 = m_stcBlobPad.fInwardPercentStart11;
                stcTemporaryBlobPad.fInwardPercentEnd11 = m_stcBlobPad.fInwardPercentEnd11;
                stcTemporaryBlobPad.fInwardPercentStart12 = m_stcBlobPad.fInwardPercentStart12;
                stcTemporaryBlobPad.fInwardPercentEnd12 = m_stcBlobPad.fInwardPercentEnd12;

                stcTemporaryBlobPad.intMeasureMethod1 = m_stcBlobPad.intMeasureMethod1;
                stcTemporaryBlobPad.intMeasureMethod2 = m_stcBlobPad.intMeasureMethod2;
                stcTemporaryBlobPad.intMeasureMethod3 = m_stcBlobPad.intMeasureMethod3;
                stcTemporaryBlobPad.intMeasureMethod4 = m_stcBlobPad.intMeasureMethod4;
                stcTemporaryBlobPad.intMeasureMethod5 = m_stcBlobPad.intMeasureMethod5;
                stcTemporaryBlobPad.intMeasureMethod6 = m_stcBlobPad.intMeasureMethod6;
                stcTemporaryBlobPad.intMeasureMethod7 = m_stcBlobPad.intMeasureMethod7;
                stcTemporaryBlobPad.intMeasureMethod8 = m_stcBlobPad.intMeasureMethod8;
                stcTemporaryBlobPad.intMeasureMethod9 = m_stcBlobPad.intMeasureMethod9;
                stcTemporaryBlobPad.intMeasureMethod10 = m_stcBlobPad.intMeasureMethod10;
                stcTemporaryBlobPad.intMeasureMethod11 = m_stcBlobPad.intMeasureMethod11;
                stcTemporaryBlobPad.intMeasureMethod12 = m_stcBlobPad.intMeasureMethod12;

                stcTemporaryBlobPad.fAngle = m_stcBlobPad.fAngle;

                stcTemporaryBlobPad.intLineCount = m_stcBlobPad.intLineCount;

                stcTemporaryBlobPad.intLengthMode = m_stcBlobPad.intLengthMode;
                stcTemporaryBlobPad.intContourX = m_stcBlobPad.intContourX;
                stcTemporaryBlobPad.intContourY = m_stcBlobPad.intContourY;
                stcTemporaryBlobPad.intObjNo = m_stcBlobPad.intObjNo;
                stcTemporaryBlobPad.fStartX = m_stcBlobPad.fStartX;
                stcTemporaryBlobPad.fEndX = m_stcBlobPad.fEndX;
                stcTemporaryBlobPad.fStartY = m_stcBlobPad.fStartY;
                stcTemporaryBlobPad.fEndY = m_stcBlobPad.fEndY;
                stcTemporaryBlobPad.intStartX = m_stcBlobPad.intStartX;
                stcTemporaryBlobPad.intEndX = m_stcBlobPad.intEndX;
                stcTemporaryBlobPad.intStartY = m_stcBlobPad.intStartY;
                stcTemporaryBlobPad.intEndY = m_stcBlobPad.intEndY;
                stcTemporaryBlobPad.blnSelected = m_stcBlobPad.blnSelected;
                stcTemporaryBlobPad.blnEnable = m_stcBlobPad.blnEnable;
                stcTemporaryBlobPad.intDirection = m_stcBlobPad.intDirection;
                stcTemporaryBlobPad.intGroupID = m_stcBlobPad.intGroupID;
                stcTemporaryBlobPad.fPitch = m_stcBlobPad.fPitch;
                stcTemporaryBlobPad.fGap = m_stcBlobPad.fGap;
                stcTemporaryBlobPad.intNoID = m_stcBlobPad.intNoID;

                stcTemporaryBlobPad.fMinLine3 = m_stcBlobPad.fMinLine3;
                stcTemporaryBlobPad.fMaxLine3 = m_stcBlobPad.fMaxLine3;
                stcTemporaryBlobPad.fMinLine4 = m_stcBlobPad.fMinLine4;
                stcTemporaryBlobPad.fMaxLine4 = m_stcBlobPad.fMaxLine4;
                stcTemporaryBlobPad.fMinLine5 = m_stcBlobPad.fMinLine5;
                stcTemporaryBlobPad.fMaxLine5 = m_stcBlobPad.fMaxLine5;
                stcTemporaryBlobPad.fMinLine6 = m_stcBlobPad.fMinLine6;
                stcTemporaryBlobPad.fMaxLine6 = m_stcBlobPad.fMaxLine6;
                stcTemporaryBlobPad.fMinLine7 = m_stcBlobPad.fMinLine7;
                stcTemporaryBlobPad.fMaxLine7 = m_stcBlobPad.fMaxLine7;
                stcTemporaryBlobPad.fMinLine8 = m_stcBlobPad.fMinLine8;
                stcTemporaryBlobPad.fMaxLine8 = m_stcBlobPad.fMaxLine8;
                stcTemporaryBlobPad.fMinLine9 = m_stcBlobPad.fMinLine9;
                stcTemporaryBlobPad.fMaxLine9 = m_stcBlobPad.fMaxLine9;
                stcTemporaryBlobPad.fMinLine10 = m_stcBlobPad.fMinLine10;
                stcTemporaryBlobPad.fMaxLine10 = m_stcBlobPad.fMaxLine10;
                stcTemporaryBlobPad.fMinLine11 = m_stcBlobPad.fMinLine11;
                stcTemporaryBlobPad.fMaxLine11 = m_stcBlobPad.fMaxLine11;
                stcTemporaryBlobPad.fMinLine12 = m_stcBlobPad.fMinLine12;
                stcTemporaryBlobPad.fMaxLine12 = m_stcBlobPad.fMaxLine12;

                stcTemporaryBlobPad.fPadInspectionAreaFromTop = m_stcBlobPad.fPadInspectionAreaFromTop;
                stcTemporaryBlobPad.fPadInspectionAreaFromRight = m_stcBlobPad.fPadInspectionAreaFromRight;
                stcTemporaryBlobPad.fPadInspectionAreaFromBottom = m_stcBlobPad.fPadInspectionAreaFromBottom;
                stcTemporaryBlobPad.fPadInspectionAreaFromLeft = m_stcBlobPad.fPadInspectionAreaFromLeft;

                stcTemporaryBlobPad.intReferTopBottom = m_stcBlobPad.intReferTopBottom;
                stcTemporaryBlobPad.blnCheckTop = m_stcBlobPad.blnCheckTop;
                stcTemporaryBlobPad.blnCheckBottom = m_stcBlobPad.blnCheckBottom;
                stcTemporaryBlobPad.intReferLeftRight = m_stcBlobPad.intReferLeftRight;
                stcTemporaryBlobPad.blnCheckLeft = m_stcBlobPad.blnCheckLeft;
                stcTemporaryBlobPad.blnCheckRight = m_stcBlobPad.blnCheckRight;

                stcTemporaryBlobPad.fFeretWidth = m_stcBlobPad.fFeretWidth;
                stcTemporaryBlobPad.fFeretHeight = m_stcBlobPad.fFeretHeight;
                stcTemporaryBlobPad.fFeretCenterX = m_stcBlobPad.fFeretCenterX;
                stcTemporaryBlobPad.fFeretCenterY = m_stcBlobPad.fFeretCenterY;
                stcTemporaryBlobPad.fFeretAngle = m_stcBlobPad.fFeretAngle;
                stcTemporaryBlobPad.intFeretLengthMode = m_stcBlobPad.intFeretLengthMode;
                stcTemporaryBlobPad.blnFeretActivated = m_stcBlobPad.blnFeretActivated;
                stcTemporaryBlobPad.P1X = m_stcBlobPad.P1X;
                stcTemporaryBlobPad.P1Y = m_stcBlobPad.P1Y;
                stcTemporaryBlobPad.P2X = m_stcBlobPad.P2X;
                stcTemporaryBlobPad.P2Y = m_stcBlobPad.P2Y;
                stcTemporaryBlobPad.P3X = m_stcBlobPad.P3X;
                stcTemporaryBlobPad.P3Y = m_stcBlobPad.P3Y;
                stcTemporaryBlobPad.P4X = m_stcBlobPad.P4X;
                stcTemporaryBlobPad.P4Y = m_stcBlobPad.P4Y;


                m_arrTemporaryBlobPads.Add(stcTemporaryBlobPad);
            }
        }

        /// <summary>
        /// Backup all tolerance of blobs features into m_arrBackupTemplateBlobPads and all tolerance of pitch gap into m_arrTolePitchGap
        /// </summary>
        public void BackupPreviousTolerance()
        {
            m_arrBackupTemplateBlobPads.Clear();
            for (int i = 0; i < m_arrTemplateBlobPads.Count; i++)
            {
                BlobsFeatures m_stcBlobPad = (BlobsFeatures)m_arrTemplateBlobPads[i];

                m_stcBackupTemplateBlobPad.intDirection = m_stcBlobPad.intDirection;
                m_stcBackupTemplateBlobPad.intNoID = m_stcBlobPad.intNoID;
                m_stcBackupTemplateBlobPad.intGroupID = m_stcBlobPad.intGroupID;
                m_stcBackupTemplateBlobPad.fStartX = m_stcBlobPad.fStartX;
                m_stcBackupTemplateBlobPad.fStartY = m_stcBlobPad.fStartY;
                m_stcBackupTemplateBlobPad.fEndX = m_stcBlobPad.fEndX;
                m_stcBackupTemplateBlobPad.fEndY = m_stcBlobPad.fEndY;
                m_stcBackupTemplateBlobPad.fLimitCenterX = m_stcBlobPad.fLimitCenterX;
                m_stcBackupTemplateBlobPad.fLimitCenterY = m_stcBlobPad.fLimitCenterY;
                m_stcBackupTemplateBlobPad.fOffSet = m_stcBlobPad.fOffSet;
                m_stcBackupTemplateBlobPad.fMinArea = m_stcBlobPad.fMinArea;
                m_stcBackupTemplateBlobPad.fMaxArea = m_stcBlobPad.fMaxArea;
                m_stcBackupTemplateBlobPad.fMinWidth = m_stcBlobPad.fMinWidth;
                m_stcBackupTemplateBlobPad.fMaxWidth = m_stcBlobPad.fMaxWidth;
                m_stcBackupTemplateBlobPad.fMinLength = m_stcBlobPad.fMinLength;
                m_stcBackupTemplateBlobPad.fMaxLength = m_stcBlobPad.fMaxLength;
                m_stcBackupTemplateBlobPad.fMaxBroken = m_stcBlobPad.fMaxBroken;
                m_stcBackupTemplateBlobPad.fMaxBrokenLength = m_stcBlobPad.fMaxBrokenLength;
                m_stcBackupTemplateBlobPad.fMaxSmearLength = m_stcBlobPad.fMaxSmearLength;

                m_stcBackupTemplateBlobPad.fEdgeLimitTop = m_stcBlobPad.fEdgeLimitTop;
                m_stcBackupTemplateBlobPad.fEdgeLimitRight = m_stcBlobPad.fEdgeLimitRight;
                m_stcBackupTemplateBlobPad.fEdgeLimitBottom = m_stcBlobPad.fEdgeLimitBottom;
                m_stcBackupTemplateBlobPad.fEdgeLimitLeft = m_stcBlobPad.fEdgeLimitLeft;

                m_stcBackupTemplateBlobPad.fMaxStandOffTop = m_stcBlobPad.fMaxStandOffTop;
                m_stcBackupTemplateBlobPad.fMaxStandOffBottom = m_stcBlobPad.fMaxStandOffBottom;
                m_stcBackupTemplateBlobPad.fMaxStandOffLeft = m_stcBlobPad.fMaxStandOffLeft;
                m_stcBackupTemplateBlobPad.fMaxStandOffRight = m_stcBlobPad.fMaxStandOffRight;
                
                m_stcBackupTemplateBlobPad.fOffsetOffSet = m_stcBlobPad.fOffsetOffSet;
                m_stcBackupTemplateBlobPad.fWidthOffset = m_stcBlobPad.fWidthOffset;
                m_stcBackupTemplateBlobPad.fHeightOffset = m_stcBlobPad.fHeightOffset;
                m_stcBackupTemplateBlobPad.fPitchOffset = m_stcBlobPad.fPitchOffset;
                m_stcBackupTemplateBlobPad.fGapOffset = m_stcBlobPad.fGapOffset;

                m_stcBackupTemplateBlobPad.fEdgeDistanceTopOffset = m_stcBlobPad.fEdgeDistanceTopOffset;
                m_stcBackupTemplateBlobPad.fEdgeDistanceRightOffset = m_stcBlobPad.fEdgeDistanceRightOffset;
                m_stcBackupTemplateBlobPad.fEdgeDistanceBottomOffset = m_stcBlobPad.fEdgeDistanceBottomOffset;
                m_stcBackupTemplateBlobPad.fEdgeDistanceLeftOffset = m_stcBlobPad.fEdgeDistanceLeftOffset;

                m_stcBackupTemplateBlobPad.fEdgeLimitTopOffset = m_stcBlobPad.fEdgeLimitTopOffset;
                m_stcBackupTemplateBlobPad.fEdgeLimitRightOffset = m_stcBlobPad.fEdgeLimitRightOffset;
                m_stcBackupTemplateBlobPad.fEdgeLimitBottomOffset = m_stcBlobPad.fEdgeLimitBottomOffset;
                m_stcBackupTemplateBlobPad.fEdgeLimitLeftOffset = m_stcBlobPad.fEdgeLimitLeftOffset;

                m_stcBackupTemplateBlobPad.fStandOffTopOffset = m_stcBlobPad.fStandOffTopOffset;
                m_stcBackupTemplateBlobPad.fStandOffBottomOffset = m_stcBlobPad.fStandOffBottomOffset;
                m_stcBackupTemplateBlobPad.fStandOffLeftOffset = m_stcBlobPad.fStandOffLeftOffset;
                m_stcBackupTemplateBlobPad.fStandOffRightOffset = m_stcBlobPad.fStandOffRightOffset;
                
                m_stcBackupTemplateBlobPad.fMaxExcess = m_stcBlobPad.fMaxExcess;
                m_stcBackupTemplateBlobPad.intLengthMode = m_stcBlobPad.intLengthMode;
                m_stcBackupTemplateBlobPad.fLearnArea = m_stcBlobPad.fArea;
                m_stcBackupTemplateBlobPad.fLearnWidth = m_stcBlobPad.fWidth;
                m_stcBackupTemplateBlobPad.fLearnHeight = m_stcBlobPad.fHeight;
                m_stcBackupTemplateBlobPad.bEnable = m_stcBlobPad.blnEnable;

                m_stcBackupTemplateBlobPad.fPadInspectionAreaFromTop = m_stcBlobPad.fPadInspectionAreaFromTop;
                m_stcBackupTemplateBlobPad.fPadInspectionAreaFromRight = m_stcBlobPad.fPadInspectionAreaFromRight;
                m_stcBackupTemplateBlobPad.fPadInspectionAreaFromBottom = m_stcBlobPad.fPadInspectionAreaFromBottom;
                m_stcBackupTemplateBlobPad.fPadInspectionAreaFromLeft = m_stcBlobPad.fPadInspectionAreaFromLeft;

                m_arrBackupTemplateBlobPads.Add(m_stcBackupTemplateBlobPad);
            }

            m_arrTolePitchGap.Clear();
            for (int i = 0; i < m_arrPitchGap.Count; i++)
            {
                TolerancePitchGap stcTolePitchGap = new TolerancePitchGap();
                stcTolePitchGap.fMinPitch = m_arrPitchGap[i].fMinPitch;
                stcTolePitchGap.fMaxPitch = m_arrPitchGap[i].fMaxPitch;
                stcTolePitchGap.fMinGap = m_arrPitchGap[i].fMinGap;
                stcTolePitchGap.fMaxGap = m_arrPitchGap[i].fMaxGap;
                m_arrTolePitchGap.Add(stcTolePitchGap);

                //m_stcTolePitchGap.fMinPitch = m_arrPitchGap[i].fMinPitch;
                //m_stcTolePitchGap.fMaxPitch = m_arrPitchGap[i].fMaxPitch;
                //m_stcTolePitchGap.fMinGap = m_arrPitchGap[i].fMinGap;
                //m_stcTolePitchGap.fMaxGap = m_arrPitchGap[i].fMaxGap;
                //m_arrTolePitchGap.Add(m_stcTolePitchGap);
            }

            m_arrBackupPitchGap.Clear();
            //PitchGap stcPitchGap = new PitchGap();
            for (int i = 0; i < m_arrPitchGap.Count; i++)
            {
                PitchGap stcPitchGap = new PitchGap();
                stcPitchGap.intFromPadNo = m_arrPitchGap[i].intFromPadNo;
                stcPitchGap.intToPadNo = m_arrPitchGap[i].intToPadNo;
                stcPitchGap.intDirection = m_arrPitchGap[i].intDirection;
                stcPitchGap.fPitch = m_arrPitchGap[i].fPitch;
                stcPitchGap.fGap = m_arrPitchGap[i].fGap;
                stcPitchGap.fPitchMM = m_arrPitchGap[i].fPitchMM;
                stcPitchGap.fGapMM = m_arrPitchGap[i].fGapMM;
                stcPitchGap.fMinPitch = m_arrPitchGap[i].fMinPitch;
                stcPitchGap.fMaxPitch = m_arrPitchGap[i].fMaxPitch;
                stcPitchGap.fMinGap = m_arrPitchGap[i].fMinGap;
                stcPitchGap.fMaxGap = m_arrPitchGap[i].fMaxGap;
                stcPitchGap.intStartPointX = m_arrPitchGap[i].intStartPointX;
                stcPitchGap.intStartPointY = m_arrPitchGap[i].intStartPointY;
                stcPitchGap.intEndPointX = m_arrPitchGap[i].intEndPointX;
                stcPitchGap.intEndPointY = m_arrPitchGap[i].intEndPointY;
                stcPitchGap.intFailMask = m_arrPitchGap[i].intFailMask;

                m_arrBackupPitchGap.Add(stcPitchGap);
            }

            m_arrBackupGroupTemplateBlobPads.Clear();
            BlobsFeatures stcBlobsFeatures = new BlobsFeatures();
            for (int i = 0; i < m_arrGroupTemplateBlobPads.Count; i++)
            {
                stcBlobsFeatures = (BlobsFeatures)m_arrGroupTemplateBlobPads[i];

                m_arrBackupGroupTemplateBlobPads.Add(stcBlobsFeatures);
            }
        }

        /// <summary>
        /// Build pad range, pad distance and define side pad
        /// </summary>
        /// <param name="objROI"></param>
        public void BuildPadsParameter(ROI objROI, ROI objSearchROI)
        {
            BuildPadRange(objROI);
            BuildPadDistance(objROI);
            //BuildPadGapPitch();
            DefineSidePad(15);
            //DefineSmearSide(objSearchROI, objROI);
        }

        /// <summary>
        /// Build pitch gap
        /// </summary>
        public void BuildPitchGap()
        {
            RearrangeBlobs();
        }

        /// <summary>
        /// Build dilate objects
        /// </summary>
        /// <param name="objROI">ROI</param>
        public void BuildDilateObjects(ROI objROI, int intMinArea)
        {
            if (m_fPadImageGain != 1f)
            {
                ROI objROI2 = new ROI();
                objROI2.LoadROISetting(objROI.ref_ROITotalX, objROI.ref_ROITotalY, objROI.ref_ROIWidth, objROI.ref_ROIHeight);
                ImageDrawing objImage = new ImageDrawing(objROI.ref_ROI.TopParent.Width, objROI.ref_ROI.TopParent.Height);
                EasyImage.Copy(objROI.ref_ROI.TopParent, objImage.ref_objMainImage);
                objROI2.AttachImage(objImage);

                EasyImage.GainOffset(objROI2.ref_ROI, objROI2.ref_ROI, m_fPadImageGain);

                m_objDilateEBlobs.BuildObjects_Filter_GetElement(objROI2, !m_blnWhiteOnBlack, true, 0, m_intThresholdValue,
                intMinArea, m_intMaxArea, false, 0x1F);

                objROI2.Dispose();
                objImage.Dispose();
            }
            else
            {
                m_objDilateEBlobs.BuildObjects_Filter_GetElement(objROI, !m_blnWhiteOnBlack, true, 0, m_intThresholdValue,
                intMinArea, m_intMaxArea, false, 0x1F);
            }
        }

        public void BuildDilateObjects(ROI objROI, int intMinArea, int intThreshold)
        {
            if (m_fPadImageGain != 1f)
            {
                ROI objROI2 = new ROI();
                objROI2.LoadROISetting(objROI.ref_ROITotalX, objROI.ref_ROITotalY, objROI.ref_ROIWidth, objROI.ref_ROIHeight);
                ImageDrawing objImage = new ImageDrawing(objROI.ref_ROI.TopParent.Width, objROI.ref_ROI.TopParent.Height);
                EasyImage.Copy(objROI.ref_ROI.TopParent, objImage.ref_objMainImage);
                objROI2.AttachImage(objImage);

                EasyImage.GainOffset(objROI2.ref_ROI, objROI2.ref_ROI, m_fPadImageGain);

                m_objDilateEBlobs.BuildObjects_Filter_GetElement(objROI2, !m_blnWhiteOnBlack, true, 0, intThreshold,
                intMinArea, m_intMaxArea, false, 0x1F);

                objROI2.Dispose();
                objImage.Dispose();
            }
            else
            {
                m_objDilateEBlobs.BuildObjects_Filter_GetElement(objROI, !m_blnWhiteOnBlack, true, 0, intThreshold,
                intMinArea, m_intMaxArea, false, 0x1F);
            }
        }

        /// <summary>
        /// Build erode objects
        /// </summary>
        /// <param name="objROI">ROI</param>
        public void BuildErodeObjects(ROI objROI, int intMinArea)
        {
            if (m_fPadImageGain != 1f)
            {
                ROI objROI2 = new ROI();
                objROI2.LoadROISetting(objROI.ref_ROITotalX, objROI.ref_ROITotalY, objROI.ref_ROIWidth, objROI.ref_ROIHeight);
                ImageDrawing objImage = new ImageDrawing(objROI.ref_ROI.TopParent.Width, objROI.ref_ROI.TopParent.Height);
                EasyImage.Copy(objROI.ref_ROI.TopParent, objImage.ref_objMainImage);
                objROI2.AttachImage(objImage);

                EasyImage.GainOffset(objROI2.ref_ROI, objROI2.ref_ROI, m_fPadImageGain);

                m_objErodeEBlobs.BuildObjects_Filter_GetElement(objROI2, !m_blnWhiteOnBlack, true, 0, m_intThresholdValue,
                intMinArea, m_intMaxArea, false, 0x1F);

                objROI2.Dispose();
                objImage.Dispose();
            }
            else
            {
                m_objErodeEBlobs.BuildObjects_Filter_GetElement(objROI, !m_blnWhiteOnBlack, true, 0, m_intThresholdValue,
                 intMinArea, m_intMaxArea, false, 0x1F);
            }
        }

        /// <summary>
        /// Build pad left, right, top, bottom distance (distance between pad center point and pad range left, right, top, bottom edge)
        /// </summary>
        public void BuildPadDistance()
        {
            for (int i = 0; i < m_arrTemplateBlobPads.Count; i++)
            {
                BlobsFeatures m_stcBlobPad = (BlobsFeatures)m_arrTemplateBlobPads[i];

                m_stcBlobPad.fLeftDistance = m_stcBlobPad.fLimitCenterX - m_fPadRangeStartX;
                m_stcBlobPad.fRightDistance = m_fPadRangeEndX - m_stcBlobPad.fLimitCenterX;
                m_stcBlobPad.fTopDistance = m_stcBlobPad.fLimitCenterY - m_fPadRangeStartY;
                m_stcBlobPad.fBottomDistance = m_fPadRangeEndY - m_stcBlobPad.fLimitCenterY;

                // Get Pad Off Set value from unit center point
                m_stcBlobPad.fXDistance = m_stcBlobPad.fLimitCenterX - GetResultCenterPoint_RectGauge4L().X;
                m_stcBlobPad.fYDistance = m_stcBlobPad.fLimitCenterY - GetResultCenterPoint_RectGauge4L().Y;

                m_stcBlobPad.fTemplateROICenterX = GetResultCenterPoint_RectGauge4L().X;
                m_stcBlobPad.fTemplateROICenterY = GetResultCenterPoint_RectGauge4L().Y;

                m_stcBlobPad.fTemplateROITopLeftCornerX = GetResultTopLeftCornerPoint_RectGauge4L().X;
                m_stcBlobPad.fTemplateROITopLeftCornerY = GetResultTopLeftCornerPoint_RectGauge4L().Y;

                m_arrTemplateBlobPads.RemoveAt(i);
                m_arrTemplateBlobPads.Insert(i, m_stcBlobPad);
            }
        }

        public void BuildPadDistance(ROI objROI)
        {
            for (int i = 0; i < m_arrTemplateBlobPads.Count; i++)
            {
                BlobsFeatures m_stcBlobPad = (BlobsFeatures)m_arrTemplateBlobPads[i];

                m_stcBlobPad.fLeftDistance = m_stcBlobPad.fLimitCenterX - m_fPadRangeStartX;
                m_stcBlobPad.fRightDistance = m_fPadRangeEndX - m_stcBlobPad.fLimitCenterX;
                m_stcBlobPad.fTopDistance = m_stcBlobPad.fLimitCenterY - m_fPadRangeStartY;
                m_stcBlobPad.fBottomDistance = m_fPadRangeEndY - m_stcBlobPad.fLimitCenterY;

                // Get Pad Off Set value from unit center point
                //if (GetOverallWantGaugeMeasurePkgSize())
                {
                    m_stcBlobPad.fXDistance = objROI.ref_ROITotalX + m_stcBlobPad.fLimitCenterX - GetResultCenterPoint_RectGauge4L().X;
                    m_stcBlobPad.fYDistance = objROI.ref_ROITotalY + m_stcBlobPad.fLimitCenterY - GetResultCenterPoint_RectGauge4L().Y;

                    m_stcBlobPad.fTemplateROICenterX = GetResultCenterPoint_RectGauge4L().X - objROI.ref_ROITotalX;
                    m_stcBlobPad.fTemplateROICenterY = GetResultCenterPoint_RectGauge4L().Y - objROI.ref_ROITotalY;

                    m_stcBlobPad.fTemplateROITopLeftCornerX = GetResultTopLeftCornerPoint_RectGauge4L().X - objROI.ref_ROITotalX;
                    m_stcBlobPad.fTemplateROITopLeftCornerY = GetResultTopLeftCornerPoint_RectGauge4L().Y - objROI.ref_ROITotalY;
                    
                }
                //else
                {
                    m_stcBlobPad.fXDistance_Pattern = objROI.ref_ROITotalX + m_stcBlobPad.fLimitCenterX - objROI.ref_ROITotalCenterX;//(float)objROI.ref_ROIWidth / 2;
                    m_stcBlobPad.fYDistance_Pattern = objROI.ref_ROITotalY + m_stcBlobPad.fLimitCenterY - objROI.ref_ROITotalCenterY;//(float)objROI.ref_ROIHeight / 2;

                    m_stcBlobPad.fTemplateROICenterX_Pattern = objROI.ref_ROITotalCenterX - objROI.ref_ROITotalX;
                    m_stcBlobPad.fTemplateROICenterY_Pattern = objROI.ref_ROITotalCenterY - objROI.ref_ROITotalY;

                    switch (m_intPadROIDirection)
                    {
                        case 0:
                        case 1:
                            m_stcBlobPad.fTemplateROITopLeftCornerX_Pattern = (objROI.ref_ROITotalCenterX - (objROI.ref_ROIWidth / 2)) - objROI.ref_ROITotalX;
                            m_stcBlobPad.fTemplateROITopLeftCornerY_Pattern = (objROI.ref_ROITotalCenterX - (objROI.ref_ROIHeight / 2)) - objROI.ref_ROITotalY;
                            break;
                        case 2:
                            m_stcBlobPad.fTemplateROITopLeftCornerX_Pattern = (objROI.ref_ROITotalCenterX + (objROI.ref_ROIWidth / 2)) - objROI.ref_ROITotalX;
                            m_stcBlobPad.fTemplateROITopLeftCornerY_Pattern = (objROI.ref_ROITotalCenterX - (objROI.ref_ROIHeight / 2)) - objROI.ref_ROITotalY;
                            break;
                        case 3:
                            m_stcBlobPad.fTemplateROITopLeftCornerX_Pattern = (objROI.ref_ROITotalCenterX + (objROI.ref_ROIWidth / 2)) - objROI.ref_ROITotalX;
                            m_stcBlobPad.fTemplateROITopLeftCornerY_Pattern = (objROI.ref_ROITotalCenterX + (objROI.ref_ROIHeight / 2)) - objROI.ref_ROITotalY;
                            break;
                        case 4:
                            m_stcBlobPad.fTemplateROITopLeftCornerX_Pattern = (objROI.ref_ROITotalCenterX - (objROI.ref_ROIWidth / 2)) - objROI.ref_ROITotalX;
                            m_stcBlobPad.fTemplateROITopLeftCornerY_Pattern = (objROI.ref_ROITotalCenterX + (objROI.ref_ROIHeight / 2)) - objROI.ref_ROITotalY;
                            break;
                    }

                }
                m_arrTemplateBlobPads.RemoveAt(i);
                m_arrTemplateBlobPads.Insert(i, m_stcBlobPad);
            }
        }

        /// <summary>
        /// Build pad pitch gap
        /// </summary>
        public void BuildPadGapPitch()
        {
            int intCheckCount = m_arrTemplateBlobPads.Count - 1;
            BlobsFeatures stcFirstBlobsFeatures;
            BlobsFeatures stcSecondBlobsFeatures;
            int intDirection5Index = -1;

            m_arrPitchGap.Clear();
            for (int i = 0; i < intCheckCount; i++)
            {
                stcFirstBlobsFeatures = (BlobsFeatures)m_arrTemplateBlobPads[i];
                stcSecondBlobsFeatures = (BlobsFeatures)m_arrTemplateBlobPads[i + 1];

                if (stcFirstBlobsFeatures.intDirection == 0x05)
                    intDirection5Index = i;

                // Define Top Gap and Pitch
                if (((stcFirstBlobsFeatures.intDirection == 0x05) && (stcSecondBlobsFeatures.intDirection == 0x04)) ||
                    ((stcFirstBlobsFeatures.intDirection == 0x04) && (stcSecondBlobsFeatures.intDirection == 0x04)) ||
                    ((stcFirstBlobsFeatures.intDirection == 0x04) && (stcSecondBlobsFeatures.intDirection == 0x06)) ||
                    ((stcFirstBlobsFeatures.intDirection == 0x0D) && (stcSecondBlobsFeatures.intDirection == 0x0C)) ||
                    ((stcFirstBlobsFeatures.intDirection == 0x0C) && (stcSecondBlobsFeatures.intDirection == 0x0C)) ||
                    ((stcFirstBlobsFeatures.intDirection == 0x0C) && (stcSecondBlobsFeatures.intDirection == 0x0E)))
                {
                    if (stcSecondBlobsFeatures.fStartX > stcFirstBlobsFeatures.fEndX)
                    {
                        stcFirstBlobsFeatures.fGap = stcSecondBlobsFeatures.fStartX - stcFirstBlobsFeatures.fEndX;
                        stcFirstBlobsFeatures.fPitch = stcSecondBlobsFeatures.fLimitCenterX - stcFirstBlobsFeatures.fLimitCenterX;
                        //stcFirstBlobsFeatures.fPitch = stcSecondBlobsFeatures.fCenterX - stcFirstBlobsFeatures.fCenterX;
                    }
                }
                // Define Right Gap and Pitch
                else if (((stcFirstBlobsFeatures.intDirection == 0x06) && (stcSecondBlobsFeatures.intDirection == 0x02)) ||
                    ((stcFirstBlobsFeatures.intDirection == 0x02) && (stcSecondBlobsFeatures.intDirection == 0x02)) ||
                    ((stcFirstBlobsFeatures.intDirection == 0x02) && (stcSecondBlobsFeatures.intDirection == 0x0A)) ||
                    ((stcFirstBlobsFeatures.intDirection == 0x07) && (stcSecondBlobsFeatures.intDirection == 0x03)) ||
                    ((stcFirstBlobsFeatures.intDirection == 0x03) && (stcSecondBlobsFeatures.intDirection == 0x03)) ||
                    ((stcFirstBlobsFeatures.intDirection == 0x03) && (stcSecondBlobsFeatures.intDirection == 0x0B)))
                {
                    if (stcSecondBlobsFeatures.fStartY > stcFirstBlobsFeatures.fEndY)
                    {
                        stcFirstBlobsFeatures.fGap = stcSecondBlobsFeatures.fStartY - stcFirstBlobsFeatures.fEndY;
                        stcFirstBlobsFeatures.fPitch = stcSecondBlobsFeatures.fLimitCenterY - stcFirstBlobsFeatures.fLimitCenterY;
                    }
                }
                // Define Bottom Gap and Pitch
                else if (((stcFirstBlobsFeatures.intDirection == 0x0A) && (stcSecondBlobsFeatures.intDirection == 0x08)) ||
                    ((stcFirstBlobsFeatures.intDirection == 0x08) && (stcSecondBlobsFeatures.intDirection == 0x08)) ||
                    ((stcFirstBlobsFeatures.intDirection == 0x08) && (stcSecondBlobsFeatures.intDirection == 0x09)))
                {
                    if (stcFirstBlobsFeatures.fStartX > stcSecondBlobsFeatures.fEndX)
                    {
                        stcFirstBlobsFeatures.fGap = stcFirstBlobsFeatures.fStartX - stcSecondBlobsFeatures.fEndX;
                        stcFirstBlobsFeatures.fPitch = stcFirstBlobsFeatures.fLimitCenterX - stcSecondBlobsFeatures.fLimitCenterX;
                    }
                }
                // Define Left Gap and Pitch
                else if (((stcFirstBlobsFeatures.intDirection == 0x09) && (stcSecondBlobsFeatures.intDirection == 0x01)) ||
                    ((stcFirstBlobsFeatures.intDirection == 0x01) && (stcSecondBlobsFeatures.intDirection == 0x01)) ||
                    ((stcFirstBlobsFeatures.intDirection == 0x01) && (stcSecondBlobsFeatures.intDirection == 0x05)))
                {
                    if (stcFirstBlobsFeatures.fStartY > stcSecondBlobsFeatures.fEndY)
                    {
                        stcFirstBlobsFeatures.fGap = stcFirstBlobsFeatures.fStartY - stcSecondBlobsFeatures.fEndY;
                        stcFirstBlobsFeatures.fPitch = stcFirstBlobsFeatures.fLimitCenterY - stcSecondBlobsFeatures.fLimitCenterY;
                    }
                }
                else if ((stcFirstBlobsFeatures.intDirection == 0x01) && (stcSecondBlobsFeatures.intDirection != 0x01) &&
                   (intDirection5Index != -1))
                {
                    stcSecondBlobsFeatures = (BlobsFeatures)m_arrTemplateBlobPads[intDirection5Index];
                    if (stcFirstBlobsFeatures.fStartY > stcSecondBlobsFeatures.fEndY)
                    {
                        stcFirstBlobsFeatures.fGap = stcFirstBlobsFeatures.fStartY - stcSecondBlobsFeatures.fEndY;
                        stcFirstBlobsFeatures.fPitch = stcFirstBlobsFeatures.fLimitCenterY - stcSecondBlobsFeatures.fLimitCenterY;
                    }
                }
                m_arrTemplateBlobPads.RemoveAt(i);
                m_arrTemplateBlobPads.Insert(i, stcFirstBlobsFeatures);

            }
        }

        /// <summary>
        /// Build pad pitch gap link
        /// </summary>
        /// <param name="blnUpdateTolerance">true = use default pitch gap tolerance, false = use previous pitch gap tolerance</param>
        public void BuildPadPitchGapLink(bool blnUpdateTolerance)
        {
            int intCheckCount = m_arrTemplateBlobPads.Count - 1;
            BlobsFeatures stcFirstBlobsFeatures;
            BlobsFeatures stcSecondBlobsFeatures;
            int intDirection5Index = -1;

            bool blnFound;
            int intDrawPoint;
            //int intPitchCount = 0;
            m_arrPitchGap.Clear();
            for (int i = 0; i < intCheckCount; i++)
            {
                m_stcPitchGap = new PitchGap();
                m_stcPitchGap.intFromPadNo = i;
                m_stcPitchGap.intToPadNo = i + 1;
                blnFound = false;
                stcFirstBlobsFeatures = (BlobsFeatures)m_arrTemplateBlobPads[i];
                stcSecondBlobsFeatures = (BlobsFeatures)m_arrTemplateBlobPads[i + 1];
                //m_stcBackupTemplateBlobPad = (ToleranceBlobsFeatures)m_arrBackupTemplateBlobPads[i];

                //m_stcBlobPad.intDirection = m_stcBackupTemplateBlobPad.intDirection;

                if (stcFirstBlobsFeatures.intDirection == 0x05)
                    intDirection5Index = i;

                // Define Top Gap and Pitch
                if (((stcFirstBlobsFeatures.intDirection == 0x05) && (stcSecondBlobsFeatures.intDirection == 0x04)) ||
                    ((stcFirstBlobsFeatures.intDirection == 0x04) && (stcSecondBlobsFeatures.intDirection == 0x04)) ||
                    ((stcFirstBlobsFeatures.intDirection == 0x04) && (stcSecondBlobsFeatures.intDirection == 0x06)) ||
                    ((stcFirstBlobsFeatures.intDirection == 0x0D) && (stcSecondBlobsFeatures.intDirection == 0x0C)) ||
                    ((stcFirstBlobsFeatures.intDirection == 0x0C) && (stcSecondBlobsFeatures.intDirection == 0x0C)) ||
                    ((stcFirstBlobsFeatures.intDirection == 0x0C) && (stcSecondBlobsFeatures.intDirection == 0x0E)))
                {
                    if (stcSecondBlobsFeatures.fStartX > stcFirstBlobsFeatures.fEndX)
                    {
                        intDrawPoint = GetDrawPoint(stcFirstBlobsFeatures.intStartY, stcFirstBlobsFeatures.intEndY, stcSecondBlobsFeatures.intStartY, stcSecondBlobsFeatures.intEndY);
                        m_stcPitchGap.intStartPointX = stcSecondBlobsFeatures.intStartX;
                        m_stcPitchGap.intEndPointX = stcFirstBlobsFeatures.intEndX;
                        m_stcPitchGap.intStartPointY = intDrawPoint;
                        m_stcPitchGap.intEndPointY = intDrawPoint;
                        m_stcPitchGap.fGap = stcSecondBlobsFeatures.fStartX - stcFirstBlobsFeatures.fEndX;
                        m_stcPitchGap.fPitch = stcSecondBlobsFeatures.fLimitCenterX - stcFirstBlobsFeatures.fLimitCenterX;
                        m_stcPitchGap.intDirection = 90;
                        if (blnUpdateTolerance)
                            DefinePitchGapTolerance();
                        else
                            UpdatePreviousPitchToleranceToTemplate();
                        blnFound = true;
                    }
                }
                // Define Right Gap and Pitch
                else if (((stcFirstBlobsFeatures.intDirection == 0x06) && (stcSecondBlobsFeatures.intDirection == 0x02)) ||
                    ((stcFirstBlobsFeatures.intDirection == 0x02) && (stcSecondBlobsFeatures.intDirection == 0x02)) ||
                    ((stcFirstBlobsFeatures.intDirection == 0x02) && (stcSecondBlobsFeatures.intDirection == 0x0A)) ||
                    ((stcFirstBlobsFeatures.intDirection == 0x07) && (stcSecondBlobsFeatures.intDirection == 0x03)) ||
                    ((stcFirstBlobsFeatures.intDirection == 0x03) && (stcSecondBlobsFeatures.intDirection == 0x03)) ||
                    ((stcFirstBlobsFeatures.intDirection == 0x03) && (stcSecondBlobsFeatures.intDirection == 0x0B)))
                {
                    if (stcSecondBlobsFeatures.fStartY > stcFirstBlobsFeatures.fEndY)
                    {
                        intDrawPoint = GetDrawPoint(stcFirstBlobsFeatures.intStartX, stcFirstBlobsFeatures.intEndX, stcSecondBlobsFeatures.intStartX, stcSecondBlobsFeatures.intEndX);
                        m_stcPitchGap.intStartPointY = stcSecondBlobsFeatures.intStartY;
                        m_stcPitchGap.intEndPointY = stcFirstBlobsFeatures.intEndY;
                        m_stcPitchGap.intStartPointX = intDrawPoint;
                        m_stcPitchGap.intEndPointX = intDrawPoint;
                        m_stcPitchGap.fGap = stcSecondBlobsFeatures.fStartY - stcFirstBlobsFeatures.fEndY;
                        m_stcPitchGap.fPitch = stcSecondBlobsFeatures.fLimitCenterY - stcFirstBlobsFeatures.fLimitCenterY;
                        m_stcPitchGap.intDirection = 180;
                        if (blnUpdateTolerance)
                            DefinePitchGapTolerance();
                        else
                            UpdatePreviousPitchToleranceToTemplate();
                        blnFound = true;
                    }
                }
                // Define Bottom Gap and Pitch
                else if (((stcFirstBlobsFeatures.intDirection == 0x0A) && (stcSecondBlobsFeatures.intDirection == 0x08)) ||
                    ((stcFirstBlobsFeatures.intDirection == 0x08) && (stcSecondBlobsFeatures.intDirection == 0x08)) ||
                    ((stcFirstBlobsFeatures.intDirection == 0x08) && (stcSecondBlobsFeatures.intDirection == 0x09)))
                {
                    if (stcFirstBlobsFeatures.fStartX > stcSecondBlobsFeatures.fEndX)
                    {
                        intDrawPoint = GetDrawPoint(stcFirstBlobsFeatures.intStartY, stcFirstBlobsFeatures.intEndY, stcSecondBlobsFeatures.intStartY, stcSecondBlobsFeatures.intEndY);
                        m_stcPitchGap.intStartPointX = stcSecondBlobsFeatures.intEndX;
                        m_stcPitchGap.intEndPointX = stcFirstBlobsFeatures.intStartX;
                        m_stcPitchGap.intStartPointY = intDrawPoint;
                        m_stcPitchGap.intEndPointY = intDrawPoint;
                        m_stcPitchGap.fGap = stcFirstBlobsFeatures.fStartX - stcSecondBlobsFeatures.fEndX;
                        m_stcPitchGap.fPitch = stcFirstBlobsFeatures.fLimitCenterX - stcSecondBlobsFeatures.fLimitCenterX;
                        m_stcPitchGap.intDirection = 90;
                        if (blnUpdateTolerance)
                            DefinePitchGapTolerance();
                        else
                            UpdatePreviousPitchToleranceToTemplate();
                        blnFound = true;
                    }
                }
                // Define Left Gap and Pitch
                else if (((stcFirstBlobsFeatures.intDirection == 0x09) && (stcSecondBlobsFeatures.intDirection == 0x01)) ||
                    ((stcFirstBlobsFeatures.intDirection == 0x01) && (stcSecondBlobsFeatures.intDirection == 0x01)) ||
                    ((stcFirstBlobsFeatures.intDirection == 0x01) && (stcSecondBlobsFeatures.intDirection == 0x05)))
                {
                    if (stcFirstBlobsFeatures.fStartY > stcSecondBlobsFeatures.fEndY)
                    {
                        intDrawPoint = GetDrawPoint(stcFirstBlobsFeatures.intStartX, stcFirstBlobsFeatures.intEndX, stcSecondBlobsFeatures.intStartX, stcSecondBlobsFeatures.intEndX);
                        m_stcPitchGap.intStartPointY = stcSecondBlobsFeatures.intEndY;
                        m_stcPitchGap.intEndPointY = stcFirstBlobsFeatures.intStartY;
                        m_stcPitchGap.intStartPointX = intDrawPoint;
                        m_stcPitchGap.intEndPointX = intDrawPoint;
                        m_stcPitchGap.fGap = stcFirstBlobsFeatures.fStartY - stcSecondBlobsFeatures.fEndY;
                        m_stcPitchGap.fPitch = stcFirstBlobsFeatures.fLimitCenterY - stcSecondBlobsFeatures.fLimitCenterY;
                        m_stcPitchGap.intDirection = 0;
                        if (blnUpdateTolerance)
                            DefinePitchGapTolerance();
                        else
                            UpdatePreviousPitchToleranceToTemplate();
                        blnFound = true;
                    }
                }
                else if ((stcFirstBlobsFeatures.intDirection == 0x01) && (stcSecondBlobsFeatures.intDirection != 0x01) &&
                   (intDirection5Index != -1))
                {
                    stcSecondBlobsFeatures = (BlobsFeatures)m_arrTemplateBlobPads[intDirection5Index];
                    m_stcPitchGap.intToPadNo = intDirection5Index;
                    if (stcFirstBlobsFeatures.fStartY > stcSecondBlobsFeatures.fEndY)
                    {
                        intDrawPoint = GetDrawPoint(stcFirstBlobsFeatures.intStartX, stcFirstBlobsFeatures.intEndX, stcSecondBlobsFeatures.intStartX, stcSecondBlobsFeatures.intEndX);
                        m_stcPitchGap.intStartPointY = stcSecondBlobsFeatures.intEndY;
                        m_stcPitchGap.intEndPointY = stcFirstBlobsFeatures.intStartY;
                        m_stcPitchGap.intStartPointX = intDrawPoint;
                        m_stcPitchGap.intEndPointX = intDrawPoint;
                        m_stcPitchGap.fGap = stcFirstBlobsFeatures.fStartY - stcSecondBlobsFeatures.fEndY;
                        m_stcPitchGap.fPitch = stcFirstBlobsFeatures.fLimitCenterY - stcSecondBlobsFeatures.fLimitCenterY;
                        m_stcPitchGap.intDirection = 0;
                        if (blnUpdateTolerance)
                            DefinePitchGapTolerance();
                        else
                            UpdatePreviousPitchToleranceToTemplate();
                        blnFound = true;
                    }
                }

                if (blnFound)
                {
                    m_arrPitchGap.Add(m_stcPitchGap);
                }

            }
        }

        /// <summary>
        /// Build pad range - start X, start Y, end X, end Y
        /// </summary>
        /// <param name="objROI"></param>
        public void BuildPadRange(ROI objROI)
        {
            float fStartX, fStartY, fEndX, fEndY;
            fStartX = (float)objROI.ref_ROIWidth;
            fStartY = (float)objROI.ref_ROIHeight;
            fEndX = 0;// (float)objROI.ref_ROIPositionX;  //08-07-2019 ZJYEOH : Chenged to 0 as, because the objROI now is pad ROI, which do not atttach to search ROI, so its position does not start from search ROI
            fEndY = 0;// (float)objROI.ref_ROIPositionY;  //08-07-2019 ZJYEOH : Chenged to 0 as, because the objROI now is pad ROI, which do not atttach to search ROI, so its position does not start from search ROI

            for (int i = 0; i < m_arrTemplateBlobPads.Count; i++)
            {
                BlobsFeatures m_stcBlobPad = (BlobsFeatures)m_arrTemplateBlobPads[i];
                if (m_stcBlobPad.fStartX < fStartX)
                    fStartX = m_stcBlobPad.fStartX;

                if (m_stcBlobPad.fStartY < fStartY)
                    fStartY = m_stcBlobPad.fStartY;

                if (m_stcBlobPad.fEndX > fEndX)
                    fEndX = m_stcBlobPad.fEndX;

                if (m_stcBlobPad.fEndY > fEndY)
                    fEndY = m_stcBlobPad.fEndY;
            }

            m_fPadRangeStartX = fStartX;
            m_fPadRangeStartY = fStartY;
            m_fPadRangeEndX = fEndX;
            m_fPadRangeEndY = fEndY;
        }

        /// <summary>
        /// Clear m_arrTemplateBlobPads
        /// </summary>
        public void ClearTemplateBlobsFeatures()
        {
            m_arrTemplateBlobPads.Clear();
        }

        /// <summary>
        /// Clear m_arrTemporaryBlobPads
        /// </summary>
        public void ClearTempBlobsFeatures()
        {
            m_arrTemporaryBlobPads.Clear();
        }

        /// <summary>
        /// Clear m_arrPitchGap
        /// </summary>
        public void ClearTemplatePitchGap()
        {
            m_arrPitchGap.Clear();
        }

        /// <summary>
        /// Compare to find new selected blobs and replace new selected blobs data into m_arrTemplateBlobPads
        /// </summary>
        public void CompareSelectedBlobs()
        {
            float fCenterX, fCenterY, fStartX, fStartY, fEndX, fEndY;
            bool blnSelect;

            for (int i = 0; i < m_arrTemporaryBlobPads.Count; i++)
            {
                fCenterX = ((BlobsFeatures)m_arrTemporaryBlobPads[i]).fLimitCenterX;
                fCenterY = ((BlobsFeatures)m_arrTemporaryBlobPads[i]).fLimitCenterY;

                for (int j = 0; j < m_arrTemplateBlobPads.Count; j++)
                {
                    fStartX = ((BlobsFeatures)m_arrTemplateBlobPads[j]).fStartX;
                    fStartY = ((BlobsFeatures)m_arrTemplateBlobPads[j]).fStartY;

                    fEndX = ((BlobsFeatures)m_arrTemplateBlobPads[j]).fEndX;
                    fEndY = ((BlobsFeatures)m_arrTemplateBlobPads[j]).fEndY;

                    blnSelect = ((BlobsFeatures)m_arrTemplateBlobPads[j]).blnSelected;

                    if ((fCenterX >= fStartX && fCenterX <= fEndX) && (fCenterY >= fStartY && fCenterY <= fEndY) && blnSelect)
                    {
                        BlobsFeatures objBlobsFeatures = (BlobsFeatures)m_arrTemporaryBlobPads[i];
                        objBlobsFeatures.blnSelected = true;
                        m_arrTemporaryBlobPads.RemoveAt(i);
                        m_arrTemporaryBlobPads.Insert(i, objBlobsFeatures);
                    }
                }
            }

            m_arrTemplateBlobPads.Clear();

            for (int v = 0; v < m_arrTemporaryBlobPads.Count; v++)
            {
                BlobsFeatures stcBlobsFeatures = new BlobsFeatures();

                stcBlobsFeatures.fArea = ((BlobsFeatures)m_arrTemporaryBlobPads[v]).fArea;
                stcBlobsFeatures.fCenterX = ((BlobsFeatures)m_arrTemporaryBlobPads[v]).fCenterX;
                stcBlobsFeatures.fCenterY = ((BlobsFeatures)m_arrTemporaryBlobPads[v]).fCenterY;
                stcBlobsFeatures.fLimitCenterX = ((BlobsFeatures)m_arrTemporaryBlobPads[v]).fLimitCenterX;
                stcBlobsFeatures.fLimitCenterY = ((BlobsFeatures)m_arrTemporaryBlobPads[v]).fLimitCenterY;
                stcBlobsFeatures.fWidth = ((BlobsFeatures)m_arrTemporaryBlobPads[v]).fWidth;
                stcBlobsFeatures.fHeight = ((BlobsFeatures)m_arrTemporaryBlobPads[v]).fHeight;
                stcBlobsFeatures.intLengthMode = ((BlobsFeatures)m_arrTemporaryBlobPads[v]).intLengthMode;
                stcBlobsFeatures.intContourX = ((BlobsFeatures)m_arrTemporaryBlobPads[v]).intContourX;
                stcBlobsFeatures.intContourY = ((BlobsFeatures)m_arrTemporaryBlobPads[v]).intContourY;
                stcBlobsFeatures.intObjNo = ((BlobsFeatures)m_arrTemporaryBlobPads[v]).intObjNo;
                stcBlobsFeatures.fStartX = ((BlobsFeatures)m_arrTemporaryBlobPads[v]).fStartX;
                stcBlobsFeatures.fEndX = ((BlobsFeatures)m_arrTemporaryBlobPads[v]).fEndX;
                stcBlobsFeatures.fStartY = ((BlobsFeatures)m_arrTemporaryBlobPads[v]).fStartY;
                stcBlobsFeatures.fEndY = ((BlobsFeatures)m_arrTemporaryBlobPads[v]).fEndY;
                stcBlobsFeatures.intStartX = ((BlobsFeatures)m_arrTemporaryBlobPads[v]).intStartX;
                stcBlobsFeatures.intEndX = ((BlobsFeatures)m_arrTemporaryBlobPads[v]).intEndX;
                stcBlobsFeatures.intStartY = ((BlobsFeatures)m_arrTemporaryBlobPads[v]).intStartY;
                stcBlobsFeatures.intEndY = ((BlobsFeatures)m_arrTemporaryBlobPads[v]).intEndY;
                stcBlobsFeatures.blnSelected = ((BlobsFeatures)m_arrTemporaryBlobPads[v]).blnSelected;
                stcBlobsFeatures.blnEnable = ((BlobsFeatures)m_arrTemporaryBlobPads[v]).blnEnable;
                stcBlobsFeatures.intDirection = ((BlobsFeatures)m_arrTemporaryBlobPads[v]).intDirection;
                stcBlobsFeatures.intGroupID = ((BlobsFeatures)m_arrTemporaryBlobPads[v]).intGroupID;
                stcBlobsFeatures.fPitch = ((BlobsFeatures)m_arrTemporaryBlobPads[v]).fPitch;
                stcBlobsFeatures.fGap = ((BlobsFeatures)m_arrTemporaryBlobPads[v]).fGap;
                stcBlobsFeatures.intNoID = ((BlobsFeatures)m_arrTemporaryBlobPads[v]).intNoID;

                stcBlobsFeatures.fWidthPercentStart1 = ((BlobsFeatures)m_arrTemporaryBlobPads[v]).fWidthPercentStart1; // for pad dimension start point
                stcBlobsFeatures.fHeightPercentStart1 = ((BlobsFeatures)m_arrTemporaryBlobPads[v]).fHeightPercentStart1;  // for pad dimension start point
                stcBlobsFeatures.fWidthPercentEnd1 = ((BlobsFeatures)m_arrTemporaryBlobPads[v]).fWidthPercentEnd1; // for pad dimension end point 
                stcBlobsFeatures.fHeightPercentEnd1 = ((BlobsFeatures)m_arrTemporaryBlobPads[v]).fHeightPercentEnd1;  // for pad dimension end point
                stcBlobsFeatures.fWidthPercentStart2 = ((BlobsFeatures)m_arrTemporaryBlobPads[v]).fWidthPercentStart2; // for pad dimension start point
                stcBlobsFeatures.fHeightPercentStart2 = ((BlobsFeatures)m_arrTemporaryBlobPads[v]).fHeightPercentStart2;  // for pad dimension start point
                stcBlobsFeatures.fWidthPercentEnd2 = ((BlobsFeatures)m_arrTemporaryBlobPads[v]).fWidthPercentEnd2; // for pad dimension end point 
                stcBlobsFeatures.fHeightPercentEnd2 = ((BlobsFeatures)m_arrTemporaryBlobPads[v]).fHeightPercentEnd2;  // for pad dimension end point
                stcBlobsFeatures.fWidthPercentStart3 = ((BlobsFeatures)m_arrTemporaryBlobPads[v]).fWidthPercentStart3; // for pad dimension start point
                stcBlobsFeatures.fHeightPercentStart3 = ((BlobsFeatures)m_arrTemporaryBlobPads[v]).fHeightPercentStart3;  // for pad dimension start point
                stcBlobsFeatures.fWidthPercentEnd3 = ((BlobsFeatures)m_arrTemporaryBlobPads[v]).fWidthPercentEnd3; // for pad dimension end point 
                stcBlobsFeatures.fHeightPercentEnd3 = ((BlobsFeatures)m_arrTemporaryBlobPads[v]).fHeightPercentEnd3;  // for pad dimension end point
                stcBlobsFeatures.fWidthPercentStart4 = ((BlobsFeatures)m_arrTemporaryBlobPads[v]).fWidthPercentStart4; // for pad dimension start point
                stcBlobsFeatures.fHeightPercentStart4 = ((BlobsFeatures)m_arrTemporaryBlobPads[v]).fHeightPercentStart4;  // for pad dimension start point
                stcBlobsFeatures.fWidthPercentEnd4 = ((BlobsFeatures)m_arrTemporaryBlobPads[v]).fWidthPercentEnd4; // for pad dimension end point 
                stcBlobsFeatures.fHeightPercentEnd4 = ((BlobsFeatures)m_arrTemporaryBlobPads[v]).fHeightPercentEnd4;  // for pad dimension end point
                stcBlobsFeatures.fWidthPercentStart5 = ((BlobsFeatures)m_arrTemporaryBlobPads[v]).fWidthPercentStart5; // for pad dimension start point
                stcBlobsFeatures.fHeightPercentStart5 = ((BlobsFeatures)m_arrTemporaryBlobPads[v]).fHeightPercentStart5;  // for pad dimension start point
                stcBlobsFeatures.fWidthPercentEnd5 = ((BlobsFeatures)m_arrTemporaryBlobPads[v]).fWidthPercentEnd5; // for pad dimension end point 
                stcBlobsFeatures.fHeightPercentEnd5 = ((BlobsFeatures)m_arrTemporaryBlobPads[v]).fHeightPercentEnd5;  // for pad dimension end point
                stcBlobsFeatures.fWidthPercentStart6 = ((BlobsFeatures)m_arrTemporaryBlobPads[v]).fWidthPercentStart6; // for pad dimension start point
                stcBlobsFeatures.fHeightPercentStart6 = ((BlobsFeatures)m_arrTemporaryBlobPads[v]).fHeightPercentStart6;  // for pad dimension start point
                stcBlobsFeatures.fWidthPercentEnd6 = ((BlobsFeatures)m_arrTemporaryBlobPads[v]).fWidthPercentEnd6; // for pad dimension end point 
                stcBlobsFeatures.fHeightPercentEnd6 = ((BlobsFeatures)m_arrTemporaryBlobPads[v]).fHeightPercentEnd6;  // for pad dimension end point
                stcBlobsFeatures.fWidthPercentStart7 = ((BlobsFeatures)m_arrTemporaryBlobPads[v]).fWidthPercentStart7; // for pad dimension start point
                stcBlobsFeatures.fHeightPercentStart7 = ((BlobsFeatures)m_arrTemporaryBlobPads[v]).fHeightPercentStart7;  // for pad dimension start point
                stcBlobsFeatures.fWidthPercentEnd7 = ((BlobsFeatures)m_arrTemporaryBlobPads[v]).fWidthPercentEnd7; // for pad dimension end point 
                stcBlobsFeatures.fHeightPercentEnd7 = ((BlobsFeatures)m_arrTemporaryBlobPads[v]).fHeightPercentEnd7;  // for pad dimension end point
                stcBlobsFeatures.fWidthPercentStart8 = ((BlobsFeatures)m_arrTemporaryBlobPads[v]).fWidthPercentStart8; // for pad dimension start point
                stcBlobsFeatures.fHeightPercentStart8 = ((BlobsFeatures)m_arrTemporaryBlobPads[v]).fHeightPercentStart8;  // for pad dimension start point
                stcBlobsFeatures.fWidthPercentEnd8 = ((BlobsFeatures)m_arrTemporaryBlobPads[v]).fWidthPercentEnd8; // for pad dimension end point 
                stcBlobsFeatures.fHeightPercentEnd8 = ((BlobsFeatures)m_arrTemporaryBlobPads[v]).fHeightPercentEnd8;  // for pad dimension end point
                stcBlobsFeatures.fWidthPercentStart9 = ((BlobsFeatures)m_arrTemporaryBlobPads[v]).fWidthPercentStart9; // for pad dimension start point
                stcBlobsFeatures.fHeightPercentStart9 = ((BlobsFeatures)m_arrTemporaryBlobPads[v]).fHeightPercentStart9;  // for pad dimension start point
                stcBlobsFeatures.fWidthPercentEnd9 = ((BlobsFeatures)m_arrTemporaryBlobPads[v]).fWidthPercentEnd9; // for pad dimension end point 
                stcBlobsFeatures.fHeightPercentEnd9 = ((BlobsFeatures)m_arrTemporaryBlobPads[v]).fHeightPercentEnd9;  // for pad dimension end point
                stcBlobsFeatures.fWidthPercentStart10 = ((BlobsFeatures)m_arrTemporaryBlobPads[v]).fWidthPercentStart10; // for pad dimension start point
                stcBlobsFeatures.fHeightPercentStart10 = ((BlobsFeatures)m_arrTemporaryBlobPads[v]).fHeightPercentStart10;  // for pad dimension start point
                stcBlobsFeatures.fWidthPercentEnd10 = ((BlobsFeatures)m_arrTemporaryBlobPads[v]).fWidthPercentEnd10; // for pad dimension end point 
                stcBlobsFeatures.fHeightPercentEnd10 = ((BlobsFeatures)m_arrTemporaryBlobPads[v]).fHeightPercentEnd10;  // for pad dimension end point
                stcBlobsFeatures.fWidthPercentStart11 = ((BlobsFeatures)m_arrTemporaryBlobPads[v]).fWidthPercentStart11; // for pad dimension start point
                stcBlobsFeatures.fHeightPercentStart11 = ((BlobsFeatures)m_arrTemporaryBlobPads[v]).fHeightPercentStart11;  // for pad dimension start point
                stcBlobsFeatures.fWidthPercentEnd11 = ((BlobsFeatures)m_arrTemporaryBlobPads[v]).fWidthPercentEnd11; // for pad dimension end point 
                stcBlobsFeatures.fHeightPercentEnd11 = ((BlobsFeatures)m_arrTemporaryBlobPads[v]).fHeightPercentEnd11;  // for pad dimension end point
                stcBlobsFeatures.fWidthPercentStart12 = ((BlobsFeatures)m_arrTemporaryBlobPads[v]).fWidthPercentStart12; // for pad dimension start point
                stcBlobsFeatures.fHeightPercentStart12 = ((BlobsFeatures)m_arrTemporaryBlobPads[v]).fHeightPercentStart12;  // for pad dimension start point
                stcBlobsFeatures.fWidthPercentEnd12 = ((BlobsFeatures)m_arrTemporaryBlobPads[v]).fWidthPercentEnd12; // for pad dimension end point 
                stcBlobsFeatures.fHeightPercentEnd12 = ((BlobsFeatures)m_arrTemporaryBlobPads[v]).fHeightPercentEnd12;  // for pad dimension end point

                stcBlobsFeatures.fInwardPercentStart1 = ((BlobsFeatures)m_arrTemporaryBlobPads[v]).fInwardPercentStart1;
                stcBlobsFeatures.fInwardPercentEnd1 = ((BlobsFeatures)m_arrTemporaryBlobPads[v]).fInwardPercentEnd1;
                stcBlobsFeatures.fInwardPercentStart2 = ((BlobsFeatures)m_arrTemporaryBlobPads[v]).fInwardPercentStart2;
                stcBlobsFeatures.fInwardPercentEnd2 = ((BlobsFeatures)m_arrTemporaryBlobPads[v]).fInwardPercentEnd2;
                stcBlobsFeatures.fInwardPercentStart3 = ((BlobsFeatures)m_arrTemporaryBlobPads[v]).fInwardPercentStart3;
                stcBlobsFeatures.fInwardPercentEnd3 = ((BlobsFeatures)m_arrTemporaryBlobPads[v]).fInwardPercentEnd3;
                stcBlobsFeatures.fInwardPercentStart4 = ((BlobsFeatures)m_arrTemporaryBlobPads[v]).fInwardPercentStart4;
                stcBlobsFeatures.fInwardPercentEnd4 = ((BlobsFeatures)m_arrTemporaryBlobPads[v]).fInwardPercentEnd4;
                stcBlobsFeatures.fInwardPercentStart5 = ((BlobsFeatures)m_arrTemporaryBlobPads[v]).fInwardPercentStart5;
                stcBlobsFeatures.fInwardPercentEnd5 = ((BlobsFeatures)m_arrTemporaryBlobPads[v]).fInwardPercentEnd5;
                stcBlobsFeatures.fInwardPercentStart6 = ((BlobsFeatures)m_arrTemporaryBlobPads[v]).fInwardPercentStart6;
                stcBlobsFeatures.fInwardPercentEnd6 = ((BlobsFeatures)m_arrTemporaryBlobPads[v]).fInwardPercentEnd6;
                stcBlobsFeatures.fInwardPercentStart7 = ((BlobsFeatures)m_arrTemporaryBlobPads[v]).fInwardPercentStart7;
                stcBlobsFeatures.fInwardPercentEnd7 = ((BlobsFeatures)m_arrTemporaryBlobPads[v]).fInwardPercentEnd7;
                stcBlobsFeatures.fInwardPercentStart8 = ((BlobsFeatures)m_arrTemporaryBlobPads[v]).fInwardPercentStart8;
                stcBlobsFeatures.fInwardPercentEnd8 = ((BlobsFeatures)m_arrTemporaryBlobPads[v]).fInwardPercentEnd8;
                stcBlobsFeatures.fInwardPercentStart9 = ((BlobsFeatures)m_arrTemporaryBlobPads[v]).fInwardPercentStart9;
                stcBlobsFeatures.fInwardPercentEnd9 = ((BlobsFeatures)m_arrTemporaryBlobPads[v]).fInwardPercentEnd9;
                stcBlobsFeatures.fInwardPercentStart10 = ((BlobsFeatures)m_arrTemporaryBlobPads[v]).fInwardPercentStart10;
                stcBlobsFeatures.fInwardPercentEnd10 = ((BlobsFeatures)m_arrTemporaryBlobPads[v]).fInwardPercentEnd10;
                stcBlobsFeatures.fInwardPercentStart11 = ((BlobsFeatures)m_arrTemporaryBlobPads[v]).fInwardPercentStart11;
                stcBlobsFeatures.fInwardPercentEnd11 = ((BlobsFeatures)m_arrTemporaryBlobPads[v]).fInwardPercentEnd11;
                stcBlobsFeatures.fInwardPercentStart12 = ((BlobsFeatures)m_arrTemporaryBlobPads[v]).fInwardPercentStart12;
                stcBlobsFeatures.fInwardPercentEnd12 = ((BlobsFeatures)m_arrTemporaryBlobPads[v]).fInwardPercentEnd12;

                stcBlobsFeatures.intMeasureMethod1 = ((BlobsFeatures)m_arrTemporaryBlobPads[v]).intMeasureMethod1;
                stcBlobsFeatures.intMeasureMethod2 = ((BlobsFeatures)m_arrTemporaryBlobPads[v]).intMeasureMethod2;
                stcBlobsFeatures.intMeasureMethod3 = ((BlobsFeatures)m_arrTemporaryBlobPads[v]).intMeasureMethod3;
                stcBlobsFeatures.intMeasureMethod4 = ((BlobsFeatures)m_arrTemporaryBlobPads[v]).intMeasureMethod4;
                stcBlobsFeatures.intMeasureMethod5 = ((BlobsFeatures)m_arrTemporaryBlobPads[v]).intMeasureMethod5;
                stcBlobsFeatures.intMeasureMethod6 = ((BlobsFeatures)m_arrTemporaryBlobPads[v]).intMeasureMethod6;
                stcBlobsFeatures.intMeasureMethod7 = ((BlobsFeatures)m_arrTemporaryBlobPads[v]).intMeasureMethod7;
                stcBlobsFeatures.intMeasureMethod8 = ((BlobsFeatures)m_arrTemporaryBlobPads[v]).intMeasureMethod8;
                stcBlobsFeatures.intMeasureMethod9 = ((BlobsFeatures)m_arrTemporaryBlobPads[v]).intMeasureMethod9;
                stcBlobsFeatures.intMeasureMethod10 = ((BlobsFeatures)m_arrTemporaryBlobPads[v]).intMeasureMethod10;
                stcBlobsFeatures.intMeasureMethod11 = ((BlobsFeatures)m_arrTemporaryBlobPads[v]).intMeasureMethod11;
                stcBlobsFeatures.intMeasureMethod12 = ((BlobsFeatures)m_arrTemporaryBlobPads[v]).intMeasureMethod12;

                stcBlobsFeatures.fAngle = ((BlobsFeatures)m_arrTemporaryBlobPads[v]).fAngle;

                m_arrTemplateBlobPads.Add(stcBlobsFeatures);
            }
        }

        public void DrawPkgDefect(Graphics g, float fDrawingScaleX, float fDrawingScaleY, int intDefectSelectingNumber)
        {
            lock (m_objLockBlobs)
            {
                /*
                 * Why add value 1 to Center X/Y , and minus value 1 to size?
                 * DrawRectangle tool will draw rectangle with start x y line outer the object, and end X Y line inner the object.
                 * Adding value 1 to center X and y will make sure rectangle is drawed with start xy inner the object.
                 * Reduct 1 value to size will make sure the end XY keep inner the object.
                 */
                if (m_blnInspectLock)
                    return;

                Pen pen = new Pen(Color.Red, 1);
                Pen penLime = new Pen(Color.Lime, 1);

                for (int i = 0; i < m_arrPkgDefectList.Count; i++)
                {
                    if (m_blnInspectLock)
                        return;

                    if (intDefectSelectingNumber == i)
                        pen = new Pen(Color.Yellow, 1);
                    else
                    {
                        if (m_arrPkgDefectList[i].ref_intFailCriteria > 0 || m_arrPkgDefectList[i].ref_blnFailTotalArea)
                        {
                            pen = new Pen(Color.Red, 1);
                        }
                        else
                        {
                            pen = new Pen(Color.Lime, 1);
                        }
                    }

                    if (m_blnUseDetailDefectCriteria)
                    {
                        if (m_arrPkgDefectList[i].ref_strName.Contains("Crack"))
                        {
                            // Draw Crack Defect
                            //  Point 1 *-------------* Point 3
                            //          |             |
                            //          |             |
                            //          |             |
                            //  Point 2 *-------------* Point 4

                            //if (m_arrPkgDefectList[i].ref_intFailCriteria > 0)
                            {
                                float newX1 = 0, newY1 = 0;  // new point 1
                                float newX2 = 0, newY2 = 0; // new point 2
                                float newX3 = 0, newY3 = 0; // new point 3
                                float newX4 = 0, newY4 = 0; // new point 4


                                Math2.NewXYAfterRotate1(m_arrPkgDefectList[i].ref_fCenterX, m_arrPkgDefectList[i].ref_fCenterY, (m_arrPkgDefectList[i].ref_fCenterX - (m_arrPkgDefectList[i].ref_fWidth / 2)), (m_arrPkgDefectList[i].ref_fCenterY - (m_arrPkgDefectList[i].ref_fHeight / 2)), -m_arrPkgDefectList[i].ref_fAngle, ref newX1, ref newY1);
                                Math2.NewXYAfterRotate2(m_arrPkgDefectList[i].ref_fCenterX, m_arrPkgDefectList[i].ref_fCenterY, (m_arrPkgDefectList[i].ref_fCenterX - (m_arrPkgDefectList[i].ref_fWidth / 2)), (m_arrPkgDefectList[i].ref_fCenterY + (m_arrPkgDefectList[i].ref_fHeight / 2)), -m_arrPkgDefectList[i].ref_fAngle, ref newX2, ref newY2);
                                Math2.NewXYAfterRotate3(m_arrPkgDefectList[i].ref_fCenterX, m_arrPkgDefectList[i].ref_fCenterY, (m_arrPkgDefectList[i].ref_fCenterX + (m_arrPkgDefectList[i].ref_fWidth / 2)), (m_arrPkgDefectList[i].ref_fCenterY - (m_arrPkgDefectList[i].ref_fHeight / 2)), -m_arrPkgDefectList[i].ref_fAngle, ref newX3, ref newY3);
                                Math2.NewXYAfterRotate4(m_arrPkgDefectList[i].ref_fCenterX, m_arrPkgDefectList[i].ref_fCenterY, (m_arrPkgDefectList[i].ref_fCenterX + (m_arrPkgDefectList[i].ref_fWidth / 2)), (m_arrPkgDefectList[i].ref_fCenterY + (m_arrPkgDefectList[i].ref_fHeight / 2)), -m_arrPkgDefectList[i].ref_fAngle, ref newX4, ref newY4);

                                g.DrawLine(pen, newX1 * fDrawingScaleX, newY1 * fDrawingScaleY, (newX3) * fDrawingScaleX, (newY3) * fDrawingScaleY);
                                g.DrawLine(pen, newX2 * fDrawingScaleX, newY2 * fDrawingScaleY, (newX1) * fDrawingScaleX, (newY1) * fDrawingScaleY);
                                g.DrawLine(pen, newX2 * fDrawingScaleX, newY2 * fDrawingScaleY, (newX4) * fDrawingScaleX, (newY4) * fDrawingScaleY);
                                g.DrawLine(pen, newX4 * fDrawingScaleX, newY4 * fDrawingScaleY, (newX3) * fDrawingScaleX, (newY3) * fDrawingScaleY);

                                //g.DrawRectangle(new Pen(Color.Red), (newX) * fDrawingScaleX,
                                //                                    (newY) * fDrawingScaleY,
                                //                                    objDefect.ref_fDimX * fDrawingScaleX, objDefect.ref_fDimY * fDrawingScaleY);
                            }
                            //else
                            //{
                            //    float newX1 = 0, newY1 = 0;
                            //    float newX2 = 0, newY2 = 0;
                            //    float newX3 = 0, newY3 = 0;
                            //    float newX4 = 0, newY4 = 0;
                            //    Math2.NewXYAfterRotate1(m_arrPkgDefectList[i].ref_fCenterX, m_arrPkgDefectList[i].ref_fCenterY, (m_arrPkgDefectList[i].ref_fCenterX - (m_arrPkgDefectList[i].ref_fWidth / 2)), (m_arrPkgDefectList[i].ref_fCenterY - (m_arrPkgDefectList[i].ref_fHeight / 2)), m_arrPkgDefectList[i].ref_fAngle, ref newX1, ref newY1);
                            //    Math2.NewXYAfterRotate2(m_arrPkgDefectList[i].ref_fCenterX, m_arrPkgDefectList[i].ref_fCenterY, (m_arrPkgDefectList[i].ref_fCenterX - (m_arrPkgDefectList[i].ref_fWidth / 2)), (m_arrPkgDefectList[i].ref_fCenterY + (m_arrPkgDefectList[i].ref_fHeight / 2)), m_arrPkgDefectList[i].ref_fAngle, ref newX2, ref newY2);
                            //    Math2.NewXYAfterRotate3(m_arrPkgDefectList[i].ref_fCenterX, m_arrPkgDefectList[i].ref_fCenterY, (m_arrPkgDefectList[i].ref_fCenterX + (m_arrPkgDefectList[i].ref_fWidth / 2)), (m_arrPkgDefectList[i].ref_fCenterY - (m_arrPkgDefectList[i].ref_fHeight / 2)), m_arrPkgDefectList[i].ref_fAngle, ref newX3, ref newY3);
                            //    Math2.NewXYAfterRotate4(m_arrPkgDefectList[i].ref_fCenterX, m_arrPkgDefectList[i].ref_fCenterY, (m_arrPkgDefectList[i].ref_fCenterX + (m_arrPkgDefectList[i].ref_fWidth / 2)), (m_arrPkgDefectList[i].ref_fCenterY + (m_arrPkgDefectList[i].ref_fHeight / 2)), m_arrPkgDefectList[i].ref_fAngle, ref newX4, ref newY4);

                            //    g.DrawLine(pen, newX1 * fDrawingScaleX, newY1 * fDrawingScaleY, (newX3) * fDrawingScaleX, (newY3) * fDrawingScaleY);
                            //    g.DrawLine(pen, newX2 * fDrawingScaleX, newY2 * fDrawingScaleY, (newX1) * fDrawingScaleX, (newY1) * fDrawingScaleY);
                            //    g.DrawLine(pen, newX2 * fDrawingScaleX, newY2 * fDrawingScaleY, (newX4) * fDrawingScaleX, (newY4) * fDrawingScaleY);
                            //    g.DrawLine(pen, newX4 * fDrawingScaleX, newY4 * fDrawingScaleY, (newX3) * fDrawingScaleX, (newY3) * fDrawingScaleY);
                            //}
                        }
                        else
                        {
                            g.DrawRectangle(pen, (m_arrPkgDefectList[i].ref_fCenterX - m_arrPkgDefectList[i].ref_fWidth / 2) * fDrawingScaleX + 1f,
                                                    (m_arrPkgDefectList[i].ref_fCenterY - m_arrPkgDefectList[i].ref_fHeight / 2) * fDrawingScaleY + 1f,
                                                    Math.Max(1f, m_arrPkgDefectList[i].ref_fWidth * fDrawingScaleX - 1f),
                                                    Math.Max(1f, m_arrPkgDefectList[i].ref_fHeight * fDrawingScaleY - 1f));
                        }
                    }
                    else
                    {
                        float newX1 = 0, newY1 = 0;  // new point 1
                        float newX2 = 0, newY2 = 0; // new point 2
                        float newX3 = 0, newY3 = 0; // new point 3
                        float newX4 = 0, newY4 = 0; // new point 4


                        //Math2.NewXYAfterRotate1(m_arrPkgDefectList[i].ref_fCenterX, m_arrPkgDefectList[i].ref_fCenterY, (m_arrPkgDefectList[i].ref_fCenterX - (m_arrPkgDefectList[i].ref_fWidth / 2)), (m_arrPkgDefectList[i].ref_fCenterY - (m_arrPkgDefectList[i].ref_fHeight / 2)), -m_arrPkgDefectList[i].ref_fAngle, ref newX1, ref newY1);
                        //Math2.NewXYAfterRotate2(m_arrPkgDefectList[i].ref_fCenterX, m_arrPkgDefectList[i].ref_fCenterY, (m_arrPkgDefectList[i].ref_fCenterX - (m_arrPkgDefectList[i].ref_fWidth / 2)), (m_arrPkgDefectList[i].ref_fCenterY + (m_arrPkgDefectList[i].ref_fHeight / 2)), -m_arrPkgDefectList[i].ref_fAngle, ref newX2, ref newY2);
                        //Math2.NewXYAfterRotate3(m_arrPkgDefectList[i].ref_fCenterX, m_arrPkgDefectList[i].ref_fCenterY, (m_arrPkgDefectList[i].ref_fCenterX + (m_arrPkgDefectList[i].ref_fWidth / 2)), (m_arrPkgDefectList[i].ref_fCenterY - (m_arrPkgDefectList[i].ref_fHeight / 2)), -m_arrPkgDefectList[i].ref_fAngle, ref newX3, ref newY3);
                        //Math2.NewXYAfterRotate4(m_arrPkgDefectList[i].ref_fCenterX, m_arrPkgDefectList[i].ref_fCenterY, (m_arrPkgDefectList[i].ref_fCenterX + (m_arrPkgDefectList[i].ref_fWidth / 2)), (m_arrPkgDefectList[i].ref_fCenterY + (m_arrPkgDefectList[i].ref_fHeight / 2)), -m_arrPkgDefectList[i].ref_fAngle, ref newX4, ref newY4);

                        //if (m_arrPkgDefectList[i].ref_strName.Contains("Right Border") || m_arrPkgDefectList[i].ref_strName.Contains("Left Border"))
                        //{
                        //    Math2.RotateWithAngleAccordingToReferencePoint(m_arrPkgDefectList[i].ref_fCenterX, m_arrPkgDefectList[i].ref_fCenterY, (m_arrPkgDefectList[i].ref_fCenterX - (m_arrPkgDefectList[i].ref_fHeight / 2)), (m_arrPkgDefectList[i].ref_fCenterY - (m_arrPkgDefectList[i].ref_fWidth / 2)), m_arrPkgDefectList[i].ref_fAngle, ref newX1, ref newY1);
                        //    Math2.RotateWithAngleAccordingToReferencePoint(m_arrPkgDefectList[i].ref_fCenterX, m_arrPkgDefectList[i].ref_fCenterY, (m_arrPkgDefectList[i].ref_fCenterX - (m_arrPkgDefectList[i].ref_fHeight / 2)), (m_arrPkgDefectList[i].ref_fCenterY + (m_arrPkgDefectList[i].ref_fWidth / 2)), m_arrPkgDefectList[i].ref_fAngle, ref newX2, ref newY2);
                        //    Math2.RotateWithAngleAccordingToReferencePoint(m_arrPkgDefectList[i].ref_fCenterX, m_arrPkgDefectList[i].ref_fCenterY, (m_arrPkgDefectList[i].ref_fCenterX + (m_arrPkgDefectList[i].ref_fHeight / 2)), (m_arrPkgDefectList[i].ref_fCenterY - (m_arrPkgDefectList[i].ref_fWidth / 2)), m_arrPkgDefectList[i].ref_fAngle, ref newX3, ref newY3);
                        //    Math2.RotateWithAngleAccordingToReferencePoint(m_arrPkgDefectList[i].ref_fCenterX, m_arrPkgDefectList[i].ref_fCenterY, (m_arrPkgDefectList[i].ref_fCenterX + (m_arrPkgDefectList[i].ref_fHeight / 2)), (m_arrPkgDefectList[i].ref_fCenterY + (m_arrPkgDefectList[i].ref_fWidth / 2)), m_arrPkgDefectList[i].ref_fAngle, ref newX4, ref newY4);
                        //}
                        //else
                        {
                            Math2.RotateWithAngleAccordingToReferencePoint(m_arrPkgDefectList[i].ref_fCenterX, m_arrPkgDefectList[i].ref_fCenterY, (m_arrPkgDefectList[i].ref_fCenterX - (m_arrPkgDefectList[i].ref_fWidth / 2)), (m_arrPkgDefectList[i].ref_fCenterY - (m_arrPkgDefectList[i].ref_fHeight / 2)), m_arrPkgDefectList[i].ref_fAngle, ref newX1, ref newY1);
                            Math2.RotateWithAngleAccordingToReferencePoint(m_arrPkgDefectList[i].ref_fCenterX, m_arrPkgDefectList[i].ref_fCenterY, (m_arrPkgDefectList[i].ref_fCenterX - (m_arrPkgDefectList[i].ref_fWidth / 2)), (m_arrPkgDefectList[i].ref_fCenterY + (m_arrPkgDefectList[i].ref_fHeight / 2)), m_arrPkgDefectList[i].ref_fAngle, ref newX2, ref newY2);
                            Math2.RotateWithAngleAccordingToReferencePoint(m_arrPkgDefectList[i].ref_fCenterX, m_arrPkgDefectList[i].ref_fCenterY, (m_arrPkgDefectList[i].ref_fCenterX + (m_arrPkgDefectList[i].ref_fWidth / 2)), (m_arrPkgDefectList[i].ref_fCenterY - (m_arrPkgDefectList[i].ref_fHeight / 2)), m_arrPkgDefectList[i].ref_fAngle, ref newX3, ref newY3);
                            Math2.RotateWithAngleAccordingToReferencePoint(m_arrPkgDefectList[i].ref_fCenterX, m_arrPkgDefectList[i].ref_fCenterY, (m_arrPkgDefectList[i].ref_fCenterX + (m_arrPkgDefectList[i].ref_fWidth / 2)), (m_arrPkgDefectList[i].ref_fCenterY + (m_arrPkgDefectList[i].ref_fHeight / 2)), m_arrPkgDefectList[i].ref_fAngle, ref newX4, ref newY4);
                        }

                        g.DrawLine(pen, newX1 * fDrawingScaleX, newY1 * fDrawingScaleY, (newX3) * fDrawingScaleX, (newY3) * fDrawingScaleY);
                        g.DrawLine(pen, newX2 * fDrawingScaleX, newY2 * fDrawingScaleY, (newX1) * fDrawingScaleX, (newY1) * fDrawingScaleY);
                        g.DrawLine(pen, newX2 * fDrawingScaleX, newY2 * fDrawingScaleY, (newX4) * fDrawingScaleX, (newY4) * fDrawingScaleY);
                        g.DrawLine(pen, newX4 * fDrawingScaleX, newY4 * fDrawingScaleY, (newX3) * fDrawingScaleX, (newY3) * fDrawingScaleY);
                    }
                }
            }
        }

        /// <summary>
        /// Define sample pad contour
        /// </summary>
        /// <param name="objROI">ROI</param>
        public void DefineSamplePadContour(ROI objROI)
        {
            int intThresholdValue;
            if (m_intThresholdValue == -4)
                intThresholdValue = ROI.GetAutoThresholdValue(objROI, 3);
            else
                intThresholdValue = m_intThresholdValue;

            m_objSampleContour.ClearContour();


            for (int i = 0; i < m_arrTemplateBlobPads.Count; i++)
            {
                m_objSampleContour.BuildContour(objROI, ((BlobsFeatures)m_arrTemplateBlobPads[i]).intContourX,
                                                 ((BlobsFeatures)m_arrTemplateBlobPads[i]).intContourY,
                                                 intThresholdValue, m_objEBlobs.ref_intConnexity);
            }
        }

        /// <summary>
        /// Define template pad contour
        /// </summary>
        /// <param name="objROI">ROI</param>
        public void DefineTemplatePadContour(ROI objROI)
        {
            int intThresholdValue;
            if (m_intThresholdValue == -4)
                intThresholdValue = ROI.GetAutoThresholdValue(objROI, 3);
            else
                intThresholdValue = m_intThresholdValue;

            m_objTemplateContour.ClearContour();
            for (int i = 0; i < m_arrTemplateBlobPads.Count; i++)
            {
                m_objTemplateContour.BuildContour(objROI, ((BlobsFeatures)m_arrTemplateBlobPads[i]).intContourX,
                                                 ((BlobsFeatures)m_arrTemplateBlobPads[i]).intContourY,
                                                 intThresholdValue, m_objEBlobs.ref_intConnexity);
            }
        }

        /// <summary>
        /// Define pad side - top, right, bottom, left
        /// </summary>
        /// <param name="intSideTolerance"></param>
        public void DefineSidePad(int intSideTolerance)
        {
            for (int i = 0; i < m_arrTemplateBlobPads.Count; i++)
            {
                BlobsFeatures m_stcBlobPad = (BlobsFeatures)m_arrTemplateBlobPads[i];

                m_stcBlobPad.intSide = 0;

                //Left side
                if ((m_stcBlobPad.fStartX - m_fPadRangeStartX) <= intSideTolerance)
                {
                    m_stcBlobPad.intSide |= 0x01;
                }
                //Right side
                if ((m_fPadRangeEndX - m_stcBlobPad.fEndX) <= intSideTolerance)
                {
                    m_stcBlobPad.intSide |= 0x02;
                }
                //Top side
                if ((m_stcBlobPad.fStartY - m_fPadRangeStartY) <= intSideTolerance)
                {
                    m_stcBlobPad.intSide |= 0x04;
                }
                //Bottom side
                if ((m_fPadRangeEndY - m_stcBlobPad.fEndY) <= intSideTolerance)
                {
                    m_stcBlobPad.intSide |= 0x08;
                }

                m_arrTemplateBlobPads.RemoveAt(i);
                m_arrTemplateBlobPads.Insert(i, m_stcBlobPad);
            }
        }
        public void DefineSmearSide(ROI objSearchROI, ROI objROI)
        {
            for (int i = 0; i < m_arrTemplateBlobPads.Count; i++)
            {
                BlobsFeatures m_stcBlobPad = (BlobsFeatures)m_arrTemplateBlobPads[i];
                int intTolerance = 3;
                m_stcBlobPad.intSmearSide = 0;

                //Left side
                if ((m_stcBlobPad.fStartX - m_intPadROIStartPixelFromLeft - intTolerance) <= 0)
                {
                    m_stcBlobPad.intSmearSide |= 0x01;
                }
                //Right side
                if ((m_stcBlobPad.fEndX - m_intPadROIStartPixelFromRight + intTolerance) >= objROI.ref_ROIWidth - (m_intPadROIStartPixelFromLeft + m_intPadROIStartPixelFromRight))
                {
                    m_stcBlobPad.intSmearSide |= 0x02;
                }
                //Top side
                if ((m_stcBlobPad.fStartY - m_intPadROIStartPixelFromTop - intTolerance) <= 0)
                {
                    m_stcBlobPad.intSmearSide |= 0x04;
                }
                //Bottom side
                if ((m_stcBlobPad.fEndY - m_intPadROIStartPixelFromBottom + intTolerance) >= objROI.ref_ROIHeight - (m_intPadROIStartPixelFromTop + m_intPadROIStartPixelFromBottom))
                {
                    m_stcBlobPad.intSmearSide |= 0x08;
                }

                m_arrTemplateBlobPads.RemoveAt(i);
                m_arrTemplateBlobPads.Insert(i, m_stcBlobPad);
            }
        }
        /// <summary>
        /// Define template tolerance either use default tolerance or use previous tolerance
        /// </summary>
        /// <param name="blnUseDefault">true = use default tolerance, false = use previous tolerance</param>
        public void DefineTolerance(bool blnUseDefault)
        {
            if (blnUseDefault)
                DefinePadDefaultTolerance();
            else
                UpdatePreviousToleranceToTemplate();
        }

        public void DefineTolerance2()
        {
            UpdatePreviousToleranceToTemplate();
        }

        public void DefineGroupTolerance()
        {
            m_arrGroupTemplateBlobPads.Clear();

            for (int intGroupNo = 0; intGroupNo < m_arrTemplateBlobPads.Count; intGroupNo++)
            {

                int intGroupNoPrev = -1;
                int intMathPadNo = -1;
                for (int i = 0; i < m_arrTemplateBlobPads.Count; i++)
                {
                    BlobsFeatures m_stcBlobPad = (BlobsFeatures)m_arrTemplateBlobPads[i];

                    if (m_stcBlobPad.intGroupID == intGroupNo)
                    {
                        intMathPadNo = i;

                        if (i < m_arrBackupTemplateBlobPads.Count)
                        {
                            intGroupNoPrev = ((ToleranceBlobsFeatures)m_arrBackupTemplateBlobPads[i]).intGroupID;
                            break;
                        }
                    }
                }

                if (intGroupNoPrev >= 0)
                {
                    if (intGroupNoPrev < m_arrBackupGroupTemplateBlobPads.Count)
                    {
                        m_arrGroupTemplateBlobPads.Add(m_arrBackupGroupTemplateBlobPads[intGroupNoPrev]);
                    }
                    else
                    {
                        m_arrGroupTemplateBlobPads.Add(m_arrTemplateBlobPads[intMathPadNo]);
                    }
                }
                else if (intMathPadNo >= 0)
                {
                    m_arrGroupTemplateBlobPads.Add(m_arrTemplateBlobPads[intMathPadNo]);
                }
                else
                    break;
            }
        }

        public void DefinePadDefaultTolerance()
        {
            //for (int i = 0; i < m_arrTemplateBlobPads.Count; i++)
            //{
            //    m_stcBlobPad = (BlobsFeatures)m_arrTemplateBlobPads[i];
            //}

            for (int i = 0; i < m_arrTemplateBlobPads.Count; i++)
            {
                BlobsFeatures m_stcBlobPad = (BlobsFeatures)m_arrTemplateBlobPads[i];

                // Use Pixel to calculate default setting
                m_stcBlobPad.fOffSet = 0.030f;

                m_stcBlobPad.fMinWidth = Math.Max(0, m_stcBlobPad.fWidth / m_fMMToPixelXValue - 0.030f);
                m_stcBlobPad.fMaxWidth = m_stcBlobPad.fWidth / m_fMMToPixelXValue + 0.030f;

                m_stcBlobPad.fMinLength = Math.Max(0, m_stcBlobPad.fHeight / m_fMMToPixelYValue - 0.030f);
                m_stcBlobPad.fMaxLength = m_stcBlobPad.fHeight / m_fMMToPixelYValue + 0.030f;

                float fAreaTolerance = (m_stcBlobPad.fMaxWidth * m_stcBlobPad.fMaxLength -
                                        m_stcBlobPad.fMinWidth * m_stcBlobPad.fMinLength);
                m_stcBlobPad.fMinArea = Math.Max(0, m_stcBlobPad.fArea / m_fMMtoPixelAreaValue - fAreaTolerance);
                m_stcBlobPad.fMaxArea = m_stcBlobPad.fArea / m_fMMtoPixelAreaValue + fAreaTolerance;

                m_stcBlobPad.fMinGap = 0;
                m_stcBlobPad.fMaxGap = 1;

                m_stcBlobPad.fMinPitch = 0;
                m_stcBlobPad.fMaxPitch = 1;

                m_stcBlobPad.fMaxBroken = m_stcBlobPad.fArea / m_fMMtoPixelAreaValue * 0.2f;

                m_stcBlobPad.fMaxBrokenLength = m_stcBlobPad.fWidth / m_fMMToPixelXValue / 5;

                m_arrTemplateBlobPads.RemoveAt(i);
                m_arrTemplateBlobPads.Insert(i, m_stcBlobPad);
            }
        }

        /// <summary>
        /// Remove certain pitch gap 
        /// </summary>
        /// <param name="intPitchGapIndex">pitch gap index</param>
        public void DeletePitchGap(int intPitchGapIndex)
        {
            if (intPitchGapIndex >= m_arrPitchGap.Count)
                return;

            m_arrPitchGap.RemoveAt(intPitchGapIndex);
        }

        /// <summary>
        /// Draw selected blob 
        /// </summary>
        /// <param name="g">destination image to be drawn</param>
        /// <param name="fScale">scale</param>
        /// <param name="intZoomImageEdgeX">translation factor for panning in the horizontal direction</param>
        /// <param name="intZoomImageEdgeY">translation factor for panning in the vertical direction</param>
        public void DrawObjects(Graphics g, float fDrawingScaleX, float fDrawingScaleY)
        {
            int intColorIndex = 0;
            for (int i = 0; i < m_arrTemplateBlobPads.Count; i++)
            {
                if (((BlobsFeatures)m_arrTemplateBlobPads[i]).blnSelected)
                    m_objEBlobs.DrawSelectedBlob(g, fDrawingScaleX, fDrawingScaleY, intColorIndex, i);

                intColorIndex++;
            }
        }

        /// <summary>
        /// Draw pitch gap link
        /// </summary>
        /// <param name="g">destination image to be drawn</param>
        /// <param name="intRoiOrgX">ROI origin X</param>
        /// <param name="intRoiOrgY">ROI origin Y</param>
        /// <param name="fScale">scale</param>
        /// <param name="intZoomImageEdgeX">translation factor for panning in the horizontal direction</param>
        /// <param name="intZoomImageEdgeY">translation factor for panning in the vertical direction</param>
        public void DrawPitchGapLink(Graphics g, float fDrawingScaleX, float fDrawingScaleY, int intRoiOrgX, int intRoiOrgY, Color objColor)
        {
            for (int i = 0; i < m_arrPitchGap.Count; i++)
            {
                g.DrawLine(new Pen(objColor), (int)Math.Round((intRoiOrgX + m_arrPitchGap[i].intStartPointX) * fDrawingScaleX, 0, MidpointRounding.AwayFromZero),
                                               (int)Math.Round((intRoiOrgY + m_arrPitchGap[i].intStartPointY) * fDrawingScaleY, 0, MidpointRounding.AwayFromZero),
                                               (int)Math.Round((intRoiOrgX + m_arrPitchGap[i].intEndPointX) * fDrawingScaleX, 0, MidpointRounding.AwayFromZero),
                                               (int)Math.Round((intRoiOrgY + m_arrPitchGap[i].intEndPointY) * fDrawingScaleY, 0, MidpointRounding.AwayFromZero));
            }
        }

        /// <summary>
        /// Draw sample pad range
        /// </summary>
        /// <param name="g">destination image to be drawn</param>
        /// <param name="intRoiOrgX">ROI origin X</param>
        /// <param name="intRoiOrgY">ROI origin Y</param>
        /// <param name="fScale">scale</param>
        /// <param name="intZoomImageEdgeX">translation factor for panning in the horizontal direction</param>
        /// <param name="intZoomImageEdgeY">translation factor for panning in the vertical direction</param>
        public void DrawSamplePadRange(Graphics g, float fDrawingScaleX, float fDrawingScaleY, int intRoiOrgX, int intRoiOrgY)
        {
            g.DrawLine(new Pen(Color.Green, 1),
                       ((float)intRoiOrgX + m_fSamplePadRangeStartX) * fDrawingScaleX,
                       ((float)intRoiOrgY + m_fSamplePadRangeStartY) * fDrawingScaleY,
                       ((float)intRoiOrgX + m_fSamplePadRangeEndX) * fDrawingScaleX,
                       ((float)intRoiOrgY + m_fSamplePadRangeStartY) * fDrawingScaleY);
            g.DrawLine(new Pen(Color.Green, 1),
                       ((float)intRoiOrgX + m_fSamplePadRangeEndX) * fDrawingScaleX,
                       ((float)intRoiOrgY + m_fSamplePadRangeStartY) * fDrawingScaleY,
                       ((float)intRoiOrgX + m_fSamplePadRangeEndX) * fDrawingScaleX,
                       ((float)intRoiOrgY + m_fSamplePadRangeEndY) * fDrawingScaleY);
            g.DrawLine(new Pen(Color.Green, 1),
                       ((float)intRoiOrgX + m_fSamplePadRangeEndX) * fDrawingScaleX,
                       ((float)intRoiOrgY + m_fSamplePadRangeEndY) * fDrawingScaleY,
                       ((float)intRoiOrgX + m_fSamplePadRangeStartX) * fDrawingScaleX,
                       ((float)intRoiOrgY + m_fSamplePadRangeEndY) * fDrawingScaleY);
            g.DrawLine(new Pen(Color.Green, 1),
                       ((float)intRoiOrgX + m_fSamplePadRangeStartX) * fDrawingScaleX,
                       ((float)intRoiOrgY + m_fSamplePadRangeEndY) * fDrawingScaleY,
                       ((float)intRoiOrgX + m_fSamplePadRangeStartX) * fDrawingScaleX,
                       ((float)intRoiOrgY + m_fSamplePadRangeStartY) * fDrawingScaleY);
        }
        public void DrawPadInspectionAreaSetting(Graphics g, float fDrawingScaleX, float fDrawingScaleY, int intRoiOrgX, int intRoiOrgY, bool blnDrawOriSize, Color objColor)
        {
            lock (m_objLockBlobs)
            {
                if (m_blnInspectLock)
                    return;
                Pen CyanPen = new Pen(objColor);
                Pen redPen = new Pen(Color.Red);
                Pen limePen = new Pen(Color.Lime);
                Pen YellowPen = new Pen(Color.Yellow);
                Pen BluePen = new Pen(Color.Blue);
                int intTestUnitWidth = m_ImgUnitTemplateImage.Width;
                int intTestUnitHeight = m_ImgUnitTemplateImage.Height;
                int intToleSize = m_intMPDilateHalfWidth; // intToleSize is use to wider the Pad ROI size.
                ROI objThresholdTemplateROI = new ROI();
                if ((m_ImgTUnitErodeThresImage.Width != m_ImgUnitTemplateImage.Width) || (m_ImgTUnitErodeThresImage.Height != m_ImgUnitTemplateImage.Height))
                    m_ImgTUnitErodeThresImage.SetSize(m_ImgUnitTemplateImage.Width, m_ImgUnitTemplateImage.Height);
                objThresholdTemplateROI.LoadROISetting((int)Math.Round((float)m_ImgTUnitErodeThresImage.Width / 2 - (float)intTestUnitWidth / 2, 0, MidpointRounding.AwayFromZero),
                                     (int)Math.Round((float)m_ImgTUnitErodeThresImage.Height / 2 - (float)intTestUnitHeight / 2, 0, MidpointRounding.AwayFromZero),
                                     intTestUnitWidth, intTestUnitHeight);
                m_ImgWhiteUnitTemplateImage2.SetSize(m_ImgWhiteUnitTemplateImage.Width, m_ImgWhiteUnitTemplateImage.Height);
                float fSampleCenterX = 0, fSampleCenterY = 0, fSampleWidth = 0, fSampleHeight = 0;
                float fTemplateCenterX = 0, fTemplateCenterY = 0, fTemplateWidth = 0, fTemplateHeight = 0;
                for (int i = 0; i < m_arrSampleBlobPads.Length; i++)
                {
                    if (m_blnInspectLock)
                        return;

                    if (i >= m_arrTemplateBlobPads.Count)
                        continue;

                    if (!((BlobsFeatures)m_arrTemplateBlobPads[i]).blnEnable)
                        continue;

                    if (!((BlobsFeatures)m_arrTemplateBlobPads[i]).blnFeretActivated)
                    {
                        fSampleCenterX = m_arrSampleBlobPads[i].fCenterX;
                        fSampleCenterY = m_arrSampleBlobPads[i].fCenterY;
                        fSampleWidth = m_arrSampleBlobPads[i].fWidth;
                        fSampleHeight = m_arrSampleBlobPads[i].fHeight;

                        fTemplateCenterX = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fLimitCenterX;
                        fTemplateCenterY = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fLimitCenterY;
                        fTemplateWidth = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fWidth;
                        fTemplateHeight = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fHeight;
                    }
                    else
                    {
                        fSampleCenterX = m_arrSampleBlobPads[i].fFeretCenterX;
                        fSampleCenterY = m_arrSampleBlobPads[i].fFeretCenterY;
                        fSampleWidth = m_arrSampleBlobPads[i].fFeretWidth;
                        fSampleHeight = m_arrSampleBlobPads[i].fFeretHeight;

                        fTemplateCenterX = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fFeretCenterX;
                        fTemplateCenterY = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fFeretCenterY;
                        fTemplateWidth = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fFeretWidth;
                        fTemplateHeight = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fFeretHeight;
                    }

                    // check the different size between sample and template blobs
                    int intDiffSizeWidth = (int)Math.Round((fSampleWidth - fTemplateWidth) / 2, 0, MidpointRounding.AwayFromZero);
                    int intDiffSizeHeight = (int)Math.Round((fSampleHeight - fTemplateHeight) / 2, 0, MidpointRounding.AwayFromZero);

                    // set the smaller Diff Value to 0 if one is positive value and another one is negative value
                    if ((intDiffSizeWidth > 0 && intDiffSizeHeight < 0) || (intDiffSizeHeight > 0 && intDiffSizeWidth < 0))
                    {
                        if (Math.Abs(intDiffSizeWidth) > Math.Abs(intDiffSizeHeight))
                            intDiffSizeHeight = 0;
                        else
                            intDiffSizeWidth = 0;
                    }

                    // Get biggest size of width and height based on DiffSize value
                    float fWidth, fHeight;
                    if ((intDiffSizeWidth > 0) || (intDiffSizeHeight > 0))
                    {
                        fWidth = fSampleWidth;
                        fHeight = fSampleHeight;
                    }
                    else
                    {
                        fWidth = fTemplateWidth;
                        fHeight = fTemplateHeight;
                    }


                    int intAdjustX = 0, intAdjustY = 0;
                    int intStartX = (int)Math.Round(fTemplateCenterX - fWidth / 2 - intToleSize, 0, MidpointRounding.AwayFromZero);
                    if (intStartX < 0)
                    {
                        intAdjustX = intStartX; // Keep the minus value
                        intStartX = 0;  // Set start value to 0 if smaller than 0.
                    }
                    int intStartY = (int)Math.Round(fTemplateCenterY - fHeight / 2 - intToleSize, 0, MidpointRounding.AwayFromZero);
                    if (intStartY < 0)
                    {
                        intAdjustY = intStartY; // Keep the minus value
                        intStartY = 0;          // Set start value to 0 if smaller than 0
                    }

                    //int intStartX2 = (int)Math.Round(m_arrSampleBlobPads[i].fGravityCenterX - fWidth / 2, 0, MidpointRounding.AwayFromZero);  // 2018 10 05 - CCENG: change from fGravityCenterX to fCenterX. The GravityCenterX is too much different compare to centerX especially when pad shape is not rectangle or square.
                    int intStartX2 = (int)Math.Round(fSampleCenterX - fWidth / 2, 0, MidpointRounding.AwayFromZero);
                    intStartX2 -= intToleSize;
                    if (intStartX2 < 0)
                    {
                        if (intStartX2 > intAdjustX)
                            intAdjustX = intStartX2;
                        intStartX2 = 0;
                    }
                    //int intStartY2 = (int)Math.Round(m_arrSampleBlobPads[i].fGravityCenterY - fHeight / 2, 0, MidpointRounding.AwayFromZero); // 2018 10 05 - CCENG: change from fGravityCenterY to fCenterY. The GravityCenterY is too much different compare to centerY especially when pad shape is not rectangle or square.
                    int intStartY2 = (int)Math.Round(fSampleCenterY - fHeight / 2, 0, MidpointRounding.AwayFromZero);
                    intStartY2 -= intToleSize;
                    if (intStartY2 < 0)
                    {
                        if (intStartY2 > intAdjustY)
                            intAdjustY = intStartY2;
                        intStartY2 = 0;
                    }

                    int intWidth = (int)Math.Round(fWidth, 0, MidpointRounding.AwayFromZero) + intToleSize * 2;
                    int intEndX = intStartX + intWidth + intAdjustX;
                    int intEndAdjustX = 0;
                    if (intEndX > objThresholdTemplateROI.ref_ROIWidth - 1)
                    {
                        intEndAdjustX = (intEndX - (objThresholdTemplateROI.ref_ROIWidth - 1));
                    }
                    int intHeight = (int)Math.Round(fHeight, 0, MidpointRounding.AwayFromZero) + intToleSize * 2;
                    int intEndY = intStartY + intHeight + intAdjustY;
                    int intEndAdjustY = 0;
                    if (intEndY > objThresholdTemplateROI.ref_ROIHeight - 1)
                    {
                        intEndAdjustY = (intEndY - (objThresholdTemplateROI.ref_ROIHeight - 1));
                    }

                    //intEndX = intStartX2 + intWidth + intToleSize * 2 + intAdjustX;
                    intEndX = intStartX2 + intWidth + intAdjustX;
                    if (intEndX > m_ImgWhiteUnitTemplateImage2.Width - 1)
                    {
                        if (intEndAdjustX < (intEndX - (m_ImgWhiteUnitTemplateImage2.Width - 1)))
                            intEndAdjustX = (intEndX - (m_ImgWhiteUnitTemplateImage2.Width - 1));
                    }
                    //intEndY = intStartY2 + intHeight + intToleSize * 2 + intAdjustY;
                    intEndY = intStartY2 + intHeight + intAdjustY;
                    if (intEndY > m_ImgWhiteUnitTemplateImage2.Height - 1)
                    {
                        if (intEndAdjustY < (intEndY - (m_ImgWhiteUnitTemplateImage2.Height - 1)))
                            intEndAdjustY = (intEndY - (m_ImgWhiteUnitTemplateImage2.Height - 1));
                    }

                    intWidth -= intEndAdjustX;
                    intHeight -= intEndAdjustY;

                    //Draw using sample
                    //System.Drawing.Point p1_Ori = new System.Drawing.Point(intRoiOrgX + (int)Math.Round(m_arrSampleBlobPads[i].fStartX), intRoiOrgY + (int)Math.Round(m_arrSampleBlobPads[i].fStartY));
                    //System.Drawing.Point p2_Ori = new System.Drawing.Point(intRoiOrgX + (int)Math.Round(m_arrSampleBlobPads[i].fEndX ), intRoiOrgY + (int)Math.Round(m_arrSampleBlobPads[i].fStartY));
                    //System.Drawing.Point p3_Ori = new System.Drawing.Point(intRoiOrgX + (int)Math.Round(m_arrSampleBlobPads[i].fStartX), intRoiOrgY + (int)Math.Round(m_arrSampleBlobPads[i].fEndY));
                    //System.Drawing.Point p4_Ori = new System.Drawing.Point(intRoiOrgX + (int)Math.Round(m_arrSampleBlobPads[i].fEndX), intRoiOrgY + (int)Math.Round(m_arrSampleBlobPads[i].fEndY));

                    //System.Drawing.Point p1 = new System.Drawing.Point(intRoiOrgX + (int)Math.Round(m_arrSampleBlobPads[i].fStartX + ((BlobsFeatures)m_arrTemplateBlobPads[i]).intPadInspectionAreaFromLeft), intRoiOrgY + (int)Math.Round(m_arrSampleBlobPads[i].fStartY + ((BlobsFeatures)m_arrTemplateBlobPads[i]).intPadInspectionAreaFromTop));
                    //System.Drawing.Point p2 = new System.Drawing.Point(intRoiOrgX + (int)Math.Round(m_arrSampleBlobPads[i].fEndX - ((BlobsFeatures)m_arrTemplateBlobPads[i]).intPadInspectionAreaFromRight), intRoiOrgY + (int)Math.Round(m_arrSampleBlobPads[i].fStartY + ((BlobsFeatures)m_arrTemplateBlobPads[i]).intPadInspectionAreaFromTop));
                    //System.Drawing.Point p3 = new System.Drawing.Point(intRoiOrgX + (int)Math.Round(m_arrSampleBlobPads[i].fStartX + ((BlobsFeatures)m_arrTemplateBlobPads[i]).intPadInspectionAreaFromLeft), intRoiOrgY + (int)Math.Round(m_arrSampleBlobPads[i].fEndY - ((BlobsFeatures)m_arrTemplateBlobPads[i]).intPadInspectionAreaFromBottom));
                    //System.Drawing.Point p4 = new System.Drawing.Point(intRoiOrgX + (int)Math.Round(m_arrSampleBlobPads[i].fEndX - ((BlobsFeatures)m_arrTemplateBlobPads[i]).intPadInspectionAreaFromRight), intRoiOrgY + (int)Math.Round(m_arrSampleBlobPads[i].fEndY - ((BlobsFeatures)m_arrTemplateBlobPads[i]).intPadInspectionAreaFromBottom));

                    //Draw using template
                    //float fStartX = m_arrSampleBlobPads[i].fCenterX - (((BlobsFeatures)m_arrTemplateBlobPads[i]).fWidth / 2);
                    //float fEndX = m_arrSampleBlobPads[i].fCenterX + (((BlobsFeatures)m_arrTemplateBlobPads[i]).fWidth / 2);
                    //float fStartY = m_arrSampleBlobPads[i].fCenterY - (((BlobsFeatures)m_arrTemplateBlobPads[i]).fHeight / 2);
                    //float fEndY = m_arrSampleBlobPads[i].fCenterY + (((BlobsFeatures)m_arrTemplateBlobPads[i]).fHeight / 2);

                    //System.Drawing.Point p1_Ori = new System.Drawing.Point(intRoiOrgX + (int)Math.Round(fStartX), intRoiOrgY + (int)Math.Round(fStartY));
                    //System.Drawing.Point p2_Ori = new System.Drawing.Point(intRoiOrgX + (int)Math.Round(fEndX), intRoiOrgY + (int)Math.Round(fStartY));
                    //System.Drawing.Point p3_Ori = new System.Drawing.Point(intRoiOrgX + (int)Math.Round(fStartX), intRoiOrgY + (int)Math.Round(fEndY));
                    //System.Drawing.Point p4_Ori = new System.Drawing.Point(intRoiOrgX + (int)Math.Round(fEndX), intRoiOrgY + (int)Math.Round(fEndY));

                    //System.Drawing.Point p1 = new System.Drawing.Point(intRoiOrgX + (int)Math.Round(fStartX + (int)(((BlobsFeatures)m_arrTemplateBlobPads[i]).fPadInspectionAreaFromLeft * m_fMMToPixelXValue)), intRoiOrgY + (int)Math.Round(fStartY + (int)(((BlobsFeatures)m_arrTemplateBlobPads[i]).fPadInspectionAreaFromTop * m_fMMToPixelYValue)));
                    //System.Drawing.Point p2 = new System.Drawing.Point(intRoiOrgX + (int)Math.Round(fEndX - (int)(((BlobsFeatures)m_arrTemplateBlobPads[i]).fPadInspectionAreaFromRight * m_fMMToPixelXValue)), intRoiOrgY + (int)Math.Round(fStartY + (int)(((BlobsFeatures)m_arrTemplateBlobPads[i]).fPadInspectionAreaFromTop * m_fMMToPixelYValue)));
                    //System.Drawing.Point p3 = new System.Drawing.Point(intRoiOrgX + (int)Math.Round(fStartX + (int)(((BlobsFeatures)m_arrTemplateBlobPads[i]).fPadInspectionAreaFromLeft * m_fMMToPixelXValue)), intRoiOrgY + (int)Math.Round(fEndY - (int)(((BlobsFeatures)m_arrTemplateBlobPads[i]).fPadInspectionAreaFromBottom * m_fMMToPixelYValue)));
                    //System.Drawing.Point p4 = new System.Drawing.Point(intRoiOrgX + (int)Math.Round(fEndX - (int)(((BlobsFeatures)m_arrTemplateBlobPads[i]).fPadInspectionAreaFromRight * m_fMMToPixelXValue)), intRoiOrgY + (int)Math.Round(fEndY - (int)(((BlobsFeatures)m_arrTemplateBlobPads[i]).fPadInspectionAreaFromBottom * m_fMMToPixelYValue)));
                    intEndX = intStartX2 + intWidth;
                    intEndY = intStartY2 + intHeight;
                    System.Drawing.Point p1_Ori = new System.Drawing.Point(intRoiOrgX + intStartX2, intRoiOrgY + intStartY2);
                    System.Drawing.Point p2_Ori = new System.Drawing.Point(intRoiOrgX + intEndX, intRoiOrgY + intStartY2);
                    System.Drawing.Point p3_Ori = new System.Drawing.Point(intRoiOrgX + intStartX2, intRoiOrgY + intEndY);
                    System.Drawing.Point p4_Ori = new System.Drawing.Point(intRoiOrgX + intEndX, intRoiOrgY + intEndY);

                    System.Drawing.Point p1 = new System.Drawing.Point(intRoiOrgX + intStartX2 + (int)(((BlobsFeatures)m_arrTemplateBlobPads[i]).fPadInspectionAreaFromLeft * m_fMMToPixelXValue), intRoiOrgY + intStartY2 + (int)(((BlobsFeatures)m_arrTemplateBlobPads[i]).fPadInspectionAreaFromTop * m_fMMToPixelYValue));
                    System.Drawing.Point p2 = new System.Drawing.Point(intRoiOrgX + intEndX - (int)(((BlobsFeatures)m_arrTemplateBlobPads[i]).fPadInspectionAreaFromRight * m_fMMToPixelXValue), intRoiOrgY + intStartY2 + (int)(((BlobsFeatures)m_arrTemplateBlobPads[i]).fPadInspectionAreaFromTop * m_fMMToPixelYValue));
                    System.Drawing.Point p3 = new System.Drawing.Point(intRoiOrgX + intStartX2 + (int)(((BlobsFeatures)m_arrTemplateBlobPads[i]).fPadInspectionAreaFromLeft * m_fMMToPixelXValue), intRoiOrgY + intEndY - (int)(((BlobsFeatures)m_arrTemplateBlobPads[i]).fPadInspectionAreaFromBottom * m_fMMToPixelYValue));
                    System.Drawing.Point p4 = new System.Drawing.Point(intRoiOrgX + intEndX - (int)(((BlobsFeatures)m_arrTemplateBlobPads[i]).fPadInspectionAreaFromRight * m_fMMToPixelXValue), intRoiOrgY + intEndY - (int)(((BlobsFeatures)m_arrTemplateBlobPads[i]).fPadInspectionAreaFromBottom * m_fMMToPixelYValue));

                    BlobsFeatures m_stcBlobPad = (BlobsFeatures)m_arrTemplateBlobPads[i];
                    if (m_stcBlobPad.blnFeretActivated)
                    {
                        float newX1_Ori = 0, newY1_Ori = 0;
                        float newX2_Ori = 0, newY2_Ori = 0;
                        float newX3_Ori = 0, newY3_Ori = 0;
                        float newX4_Ori = 0, newY4_Ori = 0;
                        Math2.RotateWithAngleAccordingToReferencePoint(intRoiOrgX + m_arrSampleBlobPads[i].fFeretCenterX, intRoiOrgY + m_arrSampleBlobPads[i].fFeretCenterY, (float)p1_Ori.X, (float)p1_Ori.Y, m_arrSampleBlobPads[i].fFeretAngle, ref newX1_Ori, ref newY1_Ori);
                        Math2.RotateWithAngleAccordingToReferencePoint(intRoiOrgX + m_arrSampleBlobPads[i].fFeretCenterX, intRoiOrgY + m_arrSampleBlobPads[i].fFeretCenterY, (float)p2_Ori.X, (float)p2_Ori.Y, m_arrSampleBlobPads[i].fFeretAngle, ref newX2_Ori, ref newY2_Ori);
                        Math2.RotateWithAngleAccordingToReferencePoint(intRoiOrgX + m_arrSampleBlobPads[i].fFeretCenterX, intRoiOrgY + m_arrSampleBlobPads[i].fFeretCenterY, (float)p3_Ori.X, (float)p3_Ori.Y, m_arrSampleBlobPads[i].fFeretAngle, ref newX3_Ori, ref newY3_Ori);
                        Math2.RotateWithAngleAccordingToReferencePoint(intRoiOrgX + m_arrSampleBlobPads[i].fFeretCenterX, intRoiOrgY + m_arrSampleBlobPads[i].fFeretCenterY, (float)p4_Ori.X, (float)p4_Ori.Y, m_arrSampleBlobPads[i].fFeretAngle, ref newX4_Ori, ref newY4_Ori);

                        p1_Ori.X = (int)newX1_Ori;
                        p1_Ori.Y = (int)newY1_Ori;
                        p2_Ori.X = (int)newX2_Ori;
                        p2_Ori.Y = (int)newY2_Ori;
                        p3_Ori.X = (int)newX3_Ori;
                        p3_Ori.Y = (int)newY3_Ori;
                        p4_Ori.X = (int)newX4_Ori;
                        p4_Ori.Y = (int)newY4_Ori;

                        float newX1 = 0, newY1 = 0;
                        float newX2 = 0, newY2 = 0;
                        float newX3 = 0, newY3 = 0;
                        float newX4 = 0, newY4 = 0;
                        Math2.RotateWithAngleAccordingToReferencePoint(intRoiOrgX + m_arrSampleBlobPads[i].fFeretCenterX, intRoiOrgY + m_arrSampleBlobPads[i].fFeretCenterY, (float)p1.X, (float)p1.Y, m_arrSampleBlobPads[i].fFeretAngle, ref newX1, ref newY1);
                        Math2.RotateWithAngleAccordingToReferencePoint(intRoiOrgX + m_arrSampleBlobPads[i].fFeretCenterX, intRoiOrgY + m_arrSampleBlobPads[i].fFeretCenterY, (float)p2.X, (float)p2.Y, m_arrSampleBlobPads[i].fFeretAngle, ref newX2, ref newY2);
                        Math2.RotateWithAngleAccordingToReferencePoint(intRoiOrgX + m_arrSampleBlobPads[i].fFeretCenterX, intRoiOrgY + m_arrSampleBlobPads[i].fFeretCenterY, (float)p3.X, (float)p3.Y, m_arrSampleBlobPads[i].fFeretAngle, ref newX3, ref newY3);
                        Math2.RotateWithAngleAccordingToReferencePoint(intRoiOrgX + m_arrSampleBlobPads[i].fFeretCenterX, intRoiOrgY + m_arrSampleBlobPads[i].fFeretCenterY, (float)p4.X, (float)p4.Y, m_arrSampleBlobPads[i].fFeretAngle, ref newX4, ref newY4);

                        p1.X = (int)newX1;
                        p1.Y = (int)newY1;
                        p2.X = (int)newX2;
                        p2.Y = (int)newY2;
                        p3.X = (int)newX3;
                        p3.Y = (int)newY3;
                        p4.X = (int)newX4;
                        p4.Y = (int)newY4;
                    }

                    if (fDrawingScaleX != 1f || fDrawingScaleY != 1f)
                    {
                        p1_Ori.X = (int)Math.Round((float)p1_Ori.X * fDrawingScaleX, 0, MidpointRounding.AwayFromZero);
                        p1_Ori.Y = (int)Math.Round((float)p1_Ori.Y * fDrawingScaleY, 0, MidpointRounding.AwayFromZero);
                        p2_Ori.X = (int)Math.Round((float)p2_Ori.X * fDrawingScaleX, 0, MidpointRounding.AwayFromZero);
                        p2_Ori.Y = (int)Math.Round((float)p2_Ori.Y * fDrawingScaleY, 0, MidpointRounding.AwayFromZero);
                        p3_Ori.X = (int)Math.Round((float)p3_Ori.X * fDrawingScaleX, 0, MidpointRounding.AwayFromZero);
                        p3_Ori.Y = (int)Math.Round((float)p3_Ori.Y * fDrawingScaleY, 0, MidpointRounding.AwayFromZero);
                        p4_Ori.X = (int)Math.Round((float)p4_Ori.X * fDrawingScaleX, 0, MidpointRounding.AwayFromZero);
                        p4_Ori.Y = (int)Math.Round((float)p4_Ori.Y * fDrawingScaleY, 0, MidpointRounding.AwayFromZero);

                        p1.X = (int)Math.Round((float)p1.X * fDrawingScaleX, 0, MidpointRounding.AwayFromZero);
                        p1.Y = (int)Math.Round((float)p1.Y * fDrawingScaleY, 0, MidpointRounding.AwayFromZero);
                        p2.X = (int)Math.Round((float)p2.X * fDrawingScaleX, 0, MidpointRounding.AwayFromZero);
                        p2.Y = (int)Math.Round((float)p2.Y * fDrawingScaleY, 0, MidpointRounding.AwayFromZero);
                        p3.X = (int)Math.Round((float)p3.X * fDrawingScaleX, 0, MidpointRounding.AwayFromZero);
                        p3.Y = (int)Math.Round((float)p3.Y * fDrawingScaleY, 0, MidpointRounding.AwayFromZero);
                        p4.X = (int)Math.Round((float)p4.X * fDrawingScaleX, 0, MidpointRounding.AwayFromZero);
                        p4.Y = (int)Math.Round((float)p4.Y * fDrawingScaleY, 0, MidpointRounding.AwayFromZero);

                    }

                    //if ((intPadSelectingNumber == -1) || (i != intPadSelectingNumber))
                    //{
                    //    g.DrawLine(limePen, p1, p2);
                    //    g.DrawLine(limePen, p2, p4);
                    //    g.DrawLine(limePen, p4, p3);
                    //    g.DrawLine(limePen, p3, p1);

                    //}
                    //else
                    {
                        if (blnDrawOriSize)
                        {
                            g.DrawLine(CyanPen, p1_Ori, p2_Ori);
                            g.DrawLine(CyanPen, p2_Ori, p4_Ori);
                            g.DrawLine(CyanPen, p4_Ori, p3_Ori);
                            g.DrawLine(CyanPen, p3_Ori, p1_Ori);
                        }

                        g.DrawLine(CyanPen, p1, p2);
                        g.DrawLine(CyanPen, p2, p4);
                        g.DrawLine(CyanPen, p4, p3);
                        g.DrawLine(CyanPen, p3, p1);

                    }

                    if (m_blnInspectLock)
                        return;

                    if (blnDrawOriSize)
                    {
                        g.DrawString((i + 1).ToString(), m_Font, new SolidBrush(Color.Red),
                        (float)(m_arrSampleBlobPads[i].fCenterX + intRoiOrgX - 8) * fDrawingScaleX,
                        (float)(m_arrSampleBlobPads[i].fCenterY + intRoiOrgY - 8) * fDrawingScaleY);
                    }
                }
                objThresholdTemplateROI.Dispose();
            }
        }

        /// <summary>
        /// Draw pad display result
        /// </summary>
        /// <param name="g">destination image to be drawn</param>
        /// <param name="intPadSelectingNumber">pad selecting no</param>
        /// <param name="intRoiOrgX">ROI origin X</param>
        /// <param name="intRoiOrgY">ROI origin Y</param>
        /// <param name="fScale"></param>
        /// <param name="intZoomImageEdgeX">translation factor for panning in the horizontal direction</param>
        /// <param name="intZoomImageEdgeY">translation factor for panning in the vertical direction</param>
        public void DrawPadDisplayResult(Graphics g, float fDrawingScaleX, float fDrawingScaleY, int intPadSelectingNumber, int intPadDefectSelectingNumber, int intRoiOrgX, int intRoiOrgY)
        {
            lock (m_objLockBlobs)
            {
                if (m_blnInspectLock)
                    return;

                Pen redPen = new Pen(Color.Red);
                Pen limePen = new Pen(Color.Lime);
                Pen YellowPen = new Pen(Color.Yellow);
                Pen BluePen = new Pen(Color.Blue);
                Pen PinkPen = new Pen(Color.Pink);
                Pen OrangePen = new Pen(Color.Orange);
                Pen CyanPen = new Pen(Color.Cyan);
                Pen MagentaPen = new Pen(Color.Magenta);
                Pen SilverPen = new Pen(Color.Silver);
                Pen WheatPen = new Pen(Color.Wheat);
                Pen BrownPen = new Pen(Color.DarkGoldenrod);
                Pen GreenPen = new Pen(Color.MediumSeaGreen);

                if (m_arrSampleBlobPads.Length != 0 && m_arrSampleBlobPads[0].fArea == 0)
                {
                    for (int i = 0; i < m_arrTemplateBlobPads.Count; i++)
                    {
                        if (m_blnInspectLock)
                            return;

                        BlobsFeatures m_stcBlobPad = (BlobsFeatures)m_arrTemplateBlobPads[i];
                        System.Drawing.Point p1 = new System.Drawing.Point(intRoiOrgX + m_stcBlobPad.intStartX, intRoiOrgY + m_stcBlobPad.intStartY);
                        System.Drawing.Point p2 = new System.Drawing.Point(intRoiOrgX + m_stcBlobPad.intEndX, intRoiOrgY + m_stcBlobPad.intStartY);
                        System.Drawing.Point p3 = new System.Drawing.Point(intRoiOrgX + m_stcBlobPad.intStartX, intRoiOrgY + m_stcBlobPad.intEndY);
                        System.Drawing.Point p4 = new System.Drawing.Point(intRoiOrgX + m_stcBlobPad.intEndX, intRoiOrgY + m_stcBlobPad.intEndY);

                        if (fDrawingScaleX != 1f || fDrawingScaleY != 1f)
                        {
                            p1.X = (int)Math.Round((float)p1.X * fDrawingScaleX, 0, MidpointRounding.AwayFromZero);
                            p1.Y = (int)Math.Round((float)p1.Y * fDrawingScaleY, 0, MidpointRounding.AwayFromZero);
                            p2.X = (int)Math.Round((float)p2.X * fDrawingScaleX, 0, MidpointRounding.AwayFromZero);
                            p2.Y = (int)Math.Round((float)p2.Y * fDrawingScaleY, 0, MidpointRounding.AwayFromZero);
                            p3.X = (int)Math.Round((float)p3.X * fDrawingScaleX, 0, MidpointRounding.AwayFromZero);
                            p3.Y = (int)Math.Round((float)p3.Y * fDrawingScaleY, 0, MidpointRounding.AwayFromZero);
                            p4.X = (int)Math.Round((float)p4.X * fDrawingScaleX, 0, MidpointRounding.AwayFromZero);
                            p4.Y = (int)Math.Round((float)p4.Y * fDrawingScaleY, 0, MidpointRounding.AwayFromZero);
                        }

                        g.DrawLine(redPen, p1, p2);
                        g.DrawLine(redPen, p2, p4);
                        g.DrawLine(redPen, p4, p3);
                        g.DrawLine(redPen, p3, p1);
                        g.DrawLine(redPen, p1, p4);
                        g.DrawString(m_stcBlobPad.intNoID.ToString(), m_Font, new SolidBrush(Color.Red),
                            (float)(m_stcBlobPad.fCenterX + intRoiOrgX - 8) * fDrawingScaleX,
                            (float)(m_stcBlobPad.fCenterY + intRoiOrgY - 8) * fDrawingScaleY);
                    }
                }
                else
                {
                    //Extra, Join Pad, Excess Pad
                    for (int i = 0; i < m_arrExtraBlobs.Count; i++)
                    {
                        if (m_blnInspectLock)
                            return;

                        if (i == intPadDefectSelectingNumber)
                        {
                            System.Drawing.Point p1 = new System.Drawing.Point(intRoiOrgX + (int)Math.Round(m_arrExtraBlobs[i].fStartX), intRoiOrgY + (int)Math.Round(m_arrExtraBlobs[i].fStartY));
                            System.Drawing.Point p2 = new System.Drawing.Point(intRoiOrgX + (int)Math.Round(m_arrExtraBlobs[i].fEndX), intRoiOrgY + (int)Math.Round(m_arrExtraBlobs[i].fStartY));
                            System.Drawing.Point p3 = new System.Drawing.Point(intRoiOrgX + (int)Math.Round(m_arrExtraBlobs[i].fStartX), intRoiOrgY + (int)Math.Round(m_arrExtraBlobs[i].fEndY));
                            System.Drawing.Point p4 = new System.Drawing.Point(intRoiOrgX + (int)Math.Round(m_arrExtraBlobs[i].fEndX), intRoiOrgY + (int)Math.Round(m_arrExtraBlobs[i].fEndY));

                            if (fDrawingScaleX != 1f || fDrawingScaleY != 1f)
                            {
                                p1.X = (int)Math.Round((float)p1.X * fDrawingScaleX, 0, MidpointRounding.AwayFromZero);
                                p1.Y = (int)Math.Round((float)p1.Y * fDrawingScaleY, 0, MidpointRounding.AwayFromZero);
                                p2.X = (int)Math.Round((float)p2.X * fDrawingScaleX, 0, MidpointRounding.AwayFromZero);
                                p2.Y = (int)Math.Round((float)p2.Y * fDrawingScaleY, 0, MidpointRounding.AwayFromZero);
                                p3.X = (int)Math.Round((float)p3.X * fDrawingScaleX, 0, MidpointRounding.AwayFromZero);
                                p3.Y = (int)Math.Round((float)p3.Y * fDrawingScaleY, 0, MidpointRounding.AwayFromZero);
                                p4.X = (int)Math.Round((float)p4.X * fDrawingScaleX, 0, MidpointRounding.AwayFromZero);
                                p4.Y = (int)Math.Round((float)p4.Y * fDrawingScaleY, 0, MidpointRounding.AwayFromZero);
                            }

                            g.DrawLine(new Pen(Color.Yellow), p1, p2);
                            g.DrawLine(new Pen(Color.Yellow), p2, p4);
                            g.DrawLine(new Pen(Color.Yellow), p4, p3);
                            g.DrawLine(new Pen(Color.Yellow), p3, p1);
                            continue;
                        }
                        else
                        {
                            if (m_blnInspectLock)
                                return;

                            System.Drawing.Point p1 = new System.Drawing.Point(intRoiOrgX + (int)Math.Round(m_arrExtraBlobs[i].fStartX), intRoiOrgY + (int)Math.Round(m_arrExtraBlobs[i].fStartY));
                            System.Drawing.Point p2 = new System.Drawing.Point(intRoiOrgX + (int)Math.Round(m_arrExtraBlobs[i].fEndX), intRoiOrgY + (int)Math.Round(m_arrExtraBlobs[i].fStartY));
                            System.Drawing.Point p3 = new System.Drawing.Point(intRoiOrgX + (int)Math.Round(m_arrExtraBlobs[i].fStartX), intRoiOrgY + (int)Math.Round(m_arrExtraBlobs[i].fEndY));
                            System.Drawing.Point p4 = new System.Drawing.Point(intRoiOrgX + (int)Math.Round(m_arrExtraBlobs[i].fEndX), intRoiOrgY + (int)Math.Round(m_arrExtraBlobs[i].fEndY));

                            if (fDrawingScaleX != 1f || fDrawingScaleY != 1f)
                            {
                                p1.X = (int)Math.Round((float)p1.X * fDrawingScaleX, 0, MidpointRounding.AwayFromZero);
                                p1.Y = (int)Math.Round((float)p1.Y * fDrawingScaleY, 0, MidpointRounding.AwayFromZero);
                                p2.X = (int)Math.Round((float)p2.X * fDrawingScaleX, 0, MidpointRounding.AwayFromZero);
                                p2.Y = (int)Math.Round((float)p2.Y * fDrawingScaleY, 0, MidpointRounding.AwayFromZero);
                                p3.X = (int)Math.Round((float)p3.X * fDrawingScaleX, 0, MidpointRounding.AwayFromZero);
                                p3.Y = (int)Math.Round((float)p3.Y * fDrawingScaleY, 0, MidpointRounding.AwayFromZero);
                                p4.X = (int)Math.Round((float)p4.X * fDrawingScaleX, 0, MidpointRounding.AwayFromZero);
                                p4.Y = (int)Math.Round((float)p4.Y * fDrawingScaleY, 0, MidpointRounding.AwayFromZero);
                            }

                            if (m_arrExtraBlobs[i].intFailMask == 0)
                            {
                                g.DrawLine(limePen, p1, p2);
                                g.DrawLine(limePen, p2, p4);
                                g.DrawLine(limePen, p4, p3);
                                g.DrawLine(limePen, p3, p1);
                                g.DrawLine(limePen, p1, p4);
                            }
                            else
                            {
                                g.DrawLine(redPen, p1, p2);
                                g.DrawLine(redPen, p2, p4);
                                g.DrawLine(redPen, p4, p3);
                                g.DrawLine(redPen, p3, p1);
                                g.DrawLine(redPen, p1, p4);
                            }
                        }
                    }

                    for (int i = 0; i < m_arrSampleBlobPads.Length; i++)
                    {
                        if (m_blnInspectLock)
                            return;

                        if (i >= m_arrTemplateBlobPads.Count)
                            continue;

                        if (!((BlobsFeatures)m_arrTemplateBlobPads[i]).blnEnable)
                            continue;
                        /*if (i == intPadSelectingNumber)
                        {
                            m_stcBlobPad = (BlobsFeatures)m_arrTemplateBlobPads[i];
                            System.Drawing.Point p1 = new System.Drawing.Point(intRoiOrgX + m_stcBlobPad.intStartX, intRoiOrgY + m_stcBlobPad.intStartY);
                            System.Drawing.Point p2 = new System.Drawing.Point(intRoiOrgX + m_stcBlobPad.intEndX, intRoiOrgY + m_stcBlobPad.intStartY);
                            System.Drawing.Point p3 = new System.Drawing.Point(intRoiOrgX + m_stcBlobPad.intStartX, intRoiOrgY + m_stcBlobPad.intEndY);
                            System.Drawing.Point p4 = new System.Drawing.Point(intRoiOrgX + m_stcBlobPad.intEndX, intRoiOrgY + m_stcBlobPad.intEndY);
                            g.DrawLine(new Pen(Color.Lime), p1, p2);
                            g.DrawLine(new Pen(Color.Lime), p2, p4);
                            g.DrawLine(new Pen(Color.Lime), p4, p3);
                            g.DrawLine(new Pen(Color.Lime), p3, p1);
                            g.DrawString(m_stcBlobPad.intNoID.ToString(), m_Font, new SolidBrush(Color.Red), (float)(m_stcBlobPad.fCenterX + intRoiOrgX - 8), (float)(m_stcBlobPad.fCenterY + intRoiOrgY - 8));
                            continue;
                        }*/

                        //Missing Pad
                        if (m_arrSampleBlobPads[i].intFailMask == 0x04)
                        {
                            BlobsFeatures m_stcBlobPad = (BlobsFeatures)m_arrTemplateBlobPads[i];
                            System.Drawing.Point p1 = new System.Drawing.Point(intRoiOrgX + m_stcBlobPad.intStartX, intRoiOrgY + m_stcBlobPad.intStartY);
                            System.Drawing.Point p2 = new System.Drawing.Point(intRoiOrgX + m_stcBlobPad.intEndX, intRoiOrgY + m_stcBlobPad.intStartY);
                            System.Drawing.Point p3 = new System.Drawing.Point(intRoiOrgX + m_stcBlobPad.intStartX, intRoiOrgY + m_stcBlobPad.intEndY);
                            System.Drawing.Point p4 = new System.Drawing.Point(intRoiOrgX + m_stcBlobPad.intEndX, intRoiOrgY + m_stcBlobPad.intEndY);
                            if (fDrawingScaleX != 1f || fDrawingScaleY != 1f)
                            {
                                p1.X = (int)Math.Round((float)p1.X * fDrawingScaleX, 0, MidpointRounding.AwayFromZero);
                                p1.Y = (int)Math.Round((float)p1.Y * fDrawingScaleY, 0, MidpointRounding.AwayFromZero);
                                p2.X = (int)Math.Round((float)p2.X * fDrawingScaleX, 0, MidpointRounding.AwayFromZero);
                                p2.Y = (int)Math.Round((float)p2.Y * fDrawingScaleY, 0, MidpointRounding.AwayFromZero);
                                p3.X = (int)Math.Round((float)p3.X * fDrawingScaleX, 0, MidpointRounding.AwayFromZero);
                                p3.Y = (int)Math.Round((float)p3.Y * fDrawingScaleY, 0, MidpointRounding.AwayFromZero);
                                p4.X = (int)Math.Round((float)p4.X * fDrawingScaleX, 0, MidpointRounding.AwayFromZero);
                                p4.Y = (int)Math.Round((float)p4.Y * fDrawingScaleY, 0, MidpointRounding.AwayFromZero);
                            }

                            g.DrawLine(redPen, p1, p2);
                            g.DrawLine(redPen, p2, p4);
                            g.DrawLine(redPen, p4, p3);
                            g.DrawLine(redPen, p3, p1);
                            g.DrawLine(redPen, p1, p4);
                            g.DrawString(m_stcBlobPad.intNoID.ToString(), m_Font, new SolidBrush(Color.Red),
                                (float)(m_stcBlobPad.fCenterX + intRoiOrgX - 8) * fDrawingScaleX,
                                (float)(m_stcBlobPad.fCenterY + intRoiOrgY - 8) * fDrawingScaleY);
                        }
                        //Valid Pad
                        else if (m_arrSampleBlobPads[i].intFailMask == 0)
                        {
                            System.Drawing.Point p1 = new System.Drawing.Point(intRoiOrgX + (int)Math.Round(m_arrSampleBlobPads[i].fStartX), intRoiOrgY + (int)Math.Round(m_arrSampleBlobPads[i].fStartY));
                            System.Drawing.Point p2 = new System.Drawing.Point(intRoiOrgX + (int)Math.Round(m_arrSampleBlobPads[i].fEndX), intRoiOrgY + (int)Math.Round(m_arrSampleBlobPads[i].fStartY));
                            System.Drawing.Point p3 = new System.Drawing.Point(intRoiOrgX + (int)Math.Round(m_arrSampleBlobPads[i].fStartX), intRoiOrgY + (int)Math.Round(m_arrSampleBlobPads[i].fEndY));
                            System.Drawing.Point p4 = new System.Drawing.Point(intRoiOrgX + (int)Math.Round(m_arrSampleBlobPads[i].fEndX), intRoiOrgY + (int)Math.Round(m_arrSampleBlobPads[i].fEndY));
                            //System.Drawing.Point p1 = new System.Drawing.Point(intRoiOrgX + (int)Math.Round(m_arrSampleBlobPads[i].fBlobCenterX - m_arrSampleBlobPads[i].fBlobWidth / 2), intRoiOrgY + (int)Math.Round(m_arrSampleBlobPads[i].fBlobCenterY - m_arrSampleBlobPads[i].fBlobHeight / 2));
                            //System.Drawing.Point p2 = new System.Drawing.Point(intRoiOrgX + (int)Math.Round(m_arrSampleBlobPads[i].fBlobCenterX + m_arrSampleBlobPads[i].fBlobWidth / 2), intRoiOrgY + (int)Math.Round(m_arrSampleBlobPads[i].fBlobCenterY - m_arrSampleBlobPads[i].fBlobHeight / 2));
                            //System.Drawing.Point p3 = new System.Drawing.Point(intRoiOrgX + (int)Math.Round(m_arrSampleBlobPads[i].fBlobCenterX - m_arrSampleBlobPads[i].fBlobWidth / 2), intRoiOrgY + (int)Math.Round(m_arrSampleBlobPads[i].fBlobCenterY + m_arrSampleBlobPads[i].fBlobHeight / 2));
                            //System.Drawing.Point p4 = new System.Drawing.Point(intRoiOrgX + (int)Math.Round(m_arrSampleBlobPads[i].fBlobCenterX + m_arrSampleBlobPads[i].fBlobWidth / 2), intRoiOrgY + (int)Math.Round(m_arrSampleBlobPads[i].fBlobCenterY + m_arrSampleBlobPads[i].fBlobHeight / 2));

                            System.Drawing.Point pStartLine1 = new System.Drawing.Point(intRoiOrgX + (int)Math.Round(m_arrSampleBlobPads[i].fStartXLine1), intRoiOrgY + (int)Math.Round(m_arrSampleBlobPads[i].fStartYLine1));
                            System.Drawing.Point pEndLine1 = new System.Drawing.Point(intRoiOrgX + (int)Math.Round(m_arrSampleBlobPads[i].fEndXLine1), intRoiOrgY + (int)Math.Round(m_arrSampleBlobPads[i].fEndYLine1));
                            System.Drawing.Point pStartLine2 = new System.Drawing.Point(intRoiOrgX + (int)Math.Round(m_arrSampleBlobPads[i].fStartXLine2), intRoiOrgY + (int)Math.Round(m_arrSampleBlobPads[i].fStartYLine2));
                            System.Drawing.Point pEndLine2 = new System.Drawing.Point(intRoiOrgX + (int)Math.Round(m_arrSampleBlobPads[i].fEndXLine2), intRoiOrgY + (int)Math.Round(m_arrSampleBlobPads[i].fEndYLine2));
                            System.Drawing.Point pStartLine3 = new System.Drawing.Point(intRoiOrgX + (int)Math.Round(m_arrSampleBlobPads[i].fStartXLine3), intRoiOrgY + (int)Math.Round(m_arrSampleBlobPads[i].fStartYLine3));
                            System.Drawing.Point pEndLine3 = new System.Drawing.Point(intRoiOrgX + (int)Math.Round(m_arrSampleBlobPads[i].fEndXLine3), intRoiOrgY + (int)Math.Round(m_arrSampleBlobPads[i].fEndYLine3));
                            System.Drawing.Point pStartLine4 = new System.Drawing.Point(intRoiOrgX + (int)Math.Round(m_arrSampleBlobPads[i].fStartXLine4), intRoiOrgY + (int)Math.Round(m_arrSampleBlobPads[i].fStartYLine4));
                            System.Drawing.Point pEndLine4 = new System.Drawing.Point(intRoiOrgX + (int)Math.Round(m_arrSampleBlobPads[i].fEndXLine4), intRoiOrgY + (int)Math.Round(m_arrSampleBlobPads[i].fEndYLine4));
                            System.Drawing.Point pStartLine5 = new System.Drawing.Point(intRoiOrgX + (int)Math.Round(m_arrSampleBlobPads[i].fStartXLine5), intRoiOrgY + (int)Math.Round(m_arrSampleBlobPads[i].fStartYLine5));
                            System.Drawing.Point pEndLine5 = new System.Drawing.Point(intRoiOrgX + (int)Math.Round(m_arrSampleBlobPads[i].fEndXLine5), intRoiOrgY + (int)Math.Round(m_arrSampleBlobPads[i].fEndYLine5));
                            System.Drawing.Point pStartLine6 = new System.Drawing.Point(intRoiOrgX + (int)Math.Round(m_arrSampleBlobPads[i].fStartXLine6), intRoiOrgY + (int)Math.Round(m_arrSampleBlobPads[i].fStartYLine6));
                            System.Drawing.Point pEndLine6 = new System.Drawing.Point(intRoiOrgX + (int)Math.Round(m_arrSampleBlobPads[i].fEndXLine6), intRoiOrgY + (int)Math.Round(m_arrSampleBlobPads[i].fEndYLine6));
                            System.Drawing.Point pStartLine7 = new System.Drawing.Point(intRoiOrgX + (int)Math.Round(m_arrSampleBlobPads[i].fStartXLine7), intRoiOrgY + (int)Math.Round(m_arrSampleBlobPads[i].fStartYLine7));
                            System.Drawing.Point pEndLine7 = new System.Drawing.Point(intRoiOrgX + (int)Math.Round(m_arrSampleBlobPads[i].fEndXLine7), intRoiOrgY + (int)Math.Round(m_arrSampleBlobPads[i].fEndYLine7));
                            System.Drawing.Point pStartLine8 = new System.Drawing.Point(intRoiOrgX + (int)Math.Round(m_arrSampleBlobPads[i].fStartXLine8), intRoiOrgY + (int)Math.Round(m_arrSampleBlobPads[i].fStartYLine8));
                            System.Drawing.Point pEndLine8 = new System.Drawing.Point(intRoiOrgX + (int)Math.Round(m_arrSampleBlobPads[i].fEndXLine8), intRoiOrgY + (int)Math.Round(m_arrSampleBlobPads[i].fEndYLine8));
                            System.Drawing.Point pStartLine9 = new System.Drawing.Point(intRoiOrgX + (int)Math.Round(m_arrSampleBlobPads[i].fStartXLine9), intRoiOrgY + (int)Math.Round(m_arrSampleBlobPads[i].fStartYLine9));
                            System.Drawing.Point pEndLine9 = new System.Drawing.Point(intRoiOrgX + (int)Math.Round(m_arrSampleBlobPads[i].fEndXLine9), intRoiOrgY + (int)Math.Round(m_arrSampleBlobPads[i].fEndYLine9));
                            System.Drawing.Point pStartLine10 = new System.Drawing.Point(intRoiOrgX + (int)Math.Round(m_arrSampleBlobPads[i].fStartXLine10), intRoiOrgY + (int)Math.Round(m_arrSampleBlobPads[i].fStartYLine10));
                            System.Drawing.Point pEndLine10 = new System.Drawing.Point(intRoiOrgX + (int)Math.Round(m_arrSampleBlobPads[i].fEndXLine10), intRoiOrgY + (int)Math.Round(m_arrSampleBlobPads[i].fEndYLine10));
                            System.Drawing.Point pStartLine11 = new System.Drawing.Point(intRoiOrgX + (int)Math.Round(m_arrSampleBlobPads[i].fStartXLine11), intRoiOrgY + (int)Math.Round(m_arrSampleBlobPads[i].fStartYLine11));
                            System.Drawing.Point pEndLine11 = new System.Drawing.Point(intRoiOrgX + (int)Math.Round(m_arrSampleBlobPads[i].fEndXLine11), intRoiOrgY + (int)Math.Round(m_arrSampleBlobPads[i].fEndYLine11));
                            System.Drawing.Point pStartLine12 = new System.Drawing.Point(intRoiOrgX + (int)Math.Round(m_arrSampleBlobPads[i].fStartXLine12), intRoiOrgY + (int)Math.Round(m_arrSampleBlobPads[i].fStartYLine12));
                            System.Drawing.Point pEndLine12 = new System.Drawing.Point(intRoiOrgX + (int)Math.Round(m_arrSampleBlobPads[i].fEndXLine12), intRoiOrgY + (int)Math.Round(m_arrSampleBlobPads[i].fEndYLine12));

                            BlobsFeatures m_stcBlobPad = (BlobsFeatures)m_arrTemplateBlobPads[i];
                            if (m_stcBlobPad.blnFeretActivated)
                            {
                                p1 = new System.Drawing.Point(intRoiOrgX + (int)Math.Round(m_arrSampleBlobPads[i].fFeretCenterX - m_arrSampleBlobPads[i].fFeretWidth / 2), intRoiOrgY + (int)Math.Round(m_arrSampleBlobPads[i].fFeretCenterY - m_arrSampleBlobPads[i].fFeretHeight / 2));
                                p2 = new System.Drawing.Point(intRoiOrgX + (int)Math.Round(m_arrSampleBlobPads[i].fFeretCenterX + m_arrSampleBlobPads[i].fFeretWidth / 2), intRoiOrgY + (int)Math.Round(m_arrSampleBlobPads[i].fFeretCenterY - m_arrSampleBlobPads[i].fFeretHeight / 2));
                                p3 = new System.Drawing.Point(intRoiOrgX + (int)Math.Round(m_arrSampleBlobPads[i].fFeretCenterX - m_arrSampleBlobPads[i].fFeretWidth / 2), intRoiOrgY + (int)Math.Round(m_arrSampleBlobPads[i].fFeretCenterY + m_arrSampleBlobPads[i].fFeretHeight / 2));
                                p4 = new System.Drawing.Point(intRoiOrgX + (int)Math.Round(m_arrSampleBlobPads[i].fFeretCenterX + m_arrSampleBlobPads[i].fFeretWidth / 2), intRoiOrgY + (int)Math.Round(m_arrSampleBlobPads[i].fFeretCenterY + m_arrSampleBlobPads[i].fFeretHeight / 2));

                                float newX1 = 0, newY1 = 0;
                                float newX2 = 0, newY2 = 0;
                                float newX3 = 0, newY3 = 0;
                                float newX4 = 0, newY4 = 0;
                                Math2.RotateWithAngleAccordingToReferencePoint(intRoiOrgX + m_arrSampleBlobPads[i].fFeretCenterX, intRoiOrgY + m_arrSampleBlobPads[i].fFeretCenterY, (float)p1.X, (float)p1.Y, m_arrSampleBlobPads[i].fFeretAngle, ref newX1, ref newY1);
                                Math2.RotateWithAngleAccordingToReferencePoint(intRoiOrgX + m_arrSampleBlobPads[i].fFeretCenterX, intRoiOrgY + m_arrSampleBlobPads[i].fFeretCenterY, (float)p2.X, (float)p2.Y, m_arrSampleBlobPads[i].fFeretAngle, ref newX2, ref newY2);
                                Math2.RotateWithAngleAccordingToReferencePoint(intRoiOrgX + m_arrSampleBlobPads[i].fFeretCenterX, intRoiOrgY + m_arrSampleBlobPads[i].fFeretCenterY, (float)p3.X, (float)p3.Y, m_arrSampleBlobPads[i].fFeretAngle, ref newX3, ref newY3);
                                Math2.RotateWithAngleAccordingToReferencePoint(intRoiOrgX + m_arrSampleBlobPads[i].fFeretCenterX, intRoiOrgY + m_arrSampleBlobPads[i].fFeretCenterY, (float)p4.X, (float)p4.Y, m_arrSampleBlobPads[i].fFeretAngle, ref newX4, ref newY4);

                                p1.X = (int)newX1;
                                p1.Y = (int)newY1;
                                p2.X = (int)newX2;
                                p2.Y = (int)newY2;
                                p3.X = (int)newX3;
                                p3.Y = (int)newY3;
                                p4.X = (int)newX4;
                                p4.Y = (int)newY4;
                            }

                            if (fDrawingScaleX != 1f || fDrawingScaleY != 1f)
                            {
                                p1.X = (int)Math.Round((float)p1.X * fDrawingScaleX, 0, MidpointRounding.AwayFromZero);
                                p1.Y = (int)Math.Round((float)p1.Y * fDrawingScaleY, 0, MidpointRounding.AwayFromZero);
                                p2.X = (int)Math.Round((float)p2.X * fDrawingScaleX, 0, MidpointRounding.AwayFromZero);
                                p2.Y = (int)Math.Round((float)p2.Y * fDrawingScaleY, 0, MidpointRounding.AwayFromZero);
                                p3.X = (int)Math.Round((float)p3.X * fDrawingScaleX, 0, MidpointRounding.AwayFromZero);
                                p3.Y = (int)Math.Round((float)p3.Y * fDrawingScaleY, 0, MidpointRounding.AwayFromZero);
                                p4.X = (int)Math.Round((float)p4.X * fDrawingScaleX, 0, MidpointRounding.AwayFromZero);
                                p4.Y = (int)Math.Round((float)p4.Y * fDrawingScaleY, 0, MidpointRounding.AwayFromZero);


                                pStartLine1.X = (int)Math.Round((float)pStartLine1.X * fDrawingScaleX, 0, MidpointRounding.AwayFromZero);
                                pStartLine1.Y = (int)Math.Round((float)pStartLine1.Y * fDrawingScaleY, 0, MidpointRounding.AwayFromZero);
                                pEndLine1.X = (int)Math.Round((float)pEndLine1.X * fDrawingScaleX, 0, MidpointRounding.AwayFromZero);
                                pEndLine1.Y = (int)Math.Round((float)pEndLine1.Y * fDrawingScaleY, 0, MidpointRounding.AwayFromZero);

                                pStartLine2.X = (int)Math.Round((float)pStartLine2.X * fDrawingScaleX, 0, MidpointRounding.AwayFromZero);
                                pStartLine2.Y = (int)Math.Round((float)pStartLine2.Y * fDrawingScaleY, 0, MidpointRounding.AwayFromZero);
                                pEndLine2.X = (int)Math.Round((float)pEndLine2.X * fDrawingScaleX, 0, MidpointRounding.AwayFromZero);
                                pEndLine2.Y = (int)Math.Round((float)pEndLine2.Y * fDrawingScaleY, 0, MidpointRounding.AwayFromZero);

                                pStartLine3.X = (int)Math.Round((float)pStartLine3.X * fDrawingScaleX, 0, MidpointRounding.AwayFromZero);
                                pStartLine3.Y = (int)Math.Round((float)pStartLine3.Y * fDrawingScaleY, 0, MidpointRounding.AwayFromZero);
                                pEndLine3.X = (int)Math.Round((float)pEndLine3.X * fDrawingScaleX, 0, MidpointRounding.AwayFromZero);
                                pEndLine3.Y = (int)Math.Round((float)pEndLine3.Y * fDrawingScaleY, 0, MidpointRounding.AwayFromZero);

                                pStartLine4.X = (int)Math.Round((float)pStartLine4.X * fDrawingScaleX, 0, MidpointRounding.AwayFromZero);
                                pStartLine4.Y = (int)Math.Round((float)pStartLine4.Y * fDrawingScaleY, 0, MidpointRounding.AwayFromZero);
                                pEndLine4.X = (int)Math.Round((float)pEndLine4.X * fDrawingScaleX, 0, MidpointRounding.AwayFromZero);
                                pEndLine4.Y = (int)Math.Round((float)pEndLine4.Y * fDrawingScaleY, 0, MidpointRounding.AwayFromZero);

                                pStartLine5.X = (int)Math.Round((float)pStartLine5.X * fDrawingScaleX, 0, MidpointRounding.AwayFromZero);
                                pStartLine5.Y = (int)Math.Round((float)pStartLine5.Y * fDrawingScaleY, 0, MidpointRounding.AwayFromZero);
                                pEndLine5.X = (int)Math.Round((float)pEndLine5.X * fDrawingScaleX, 0, MidpointRounding.AwayFromZero);
                                pEndLine5.Y = (int)Math.Round((float)pEndLine5.Y * fDrawingScaleY, 0, MidpointRounding.AwayFromZero);

                                pStartLine6.X = (int)Math.Round((float)pStartLine6.X * fDrawingScaleX, 0, MidpointRounding.AwayFromZero);
                                pStartLine6.Y = (int)Math.Round((float)pStartLine6.Y * fDrawingScaleY, 0, MidpointRounding.AwayFromZero);
                                pEndLine6.X = (int)Math.Round((float)pEndLine6.X * fDrawingScaleX, 0, MidpointRounding.AwayFromZero);
                                pEndLine6.Y = (int)Math.Round((float)pEndLine6.Y * fDrawingScaleY, 0, MidpointRounding.AwayFromZero);

                                pStartLine7.X = (int)Math.Round((float)pStartLine7.X * fDrawingScaleX, 0, MidpointRounding.AwayFromZero);
                                pStartLine7.Y = (int)Math.Round((float)pStartLine7.Y * fDrawingScaleY, 0, MidpointRounding.AwayFromZero);
                                pEndLine7.X = (int)Math.Round((float)pEndLine7.X * fDrawingScaleX, 0, MidpointRounding.AwayFromZero);
                                pEndLine7.Y = (int)Math.Round((float)pEndLine7.Y * fDrawingScaleY, 0, MidpointRounding.AwayFromZero);

                                pStartLine8.X = (int)Math.Round((float)pStartLine8.X * fDrawingScaleX, 0, MidpointRounding.AwayFromZero);
                                pStartLine8.Y = (int)Math.Round((float)pStartLine8.Y * fDrawingScaleY, 0, MidpointRounding.AwayFromZero);
                                pEndLine8.X = (int)Math.Round((float)pEndLine8.X * fDrawingScaleX, 0, MidpointRounding.AwayFromZero);
                                pEndLine8.Y = (int)Math.Round((float)pEndLine8.Y * fDrawingScaleY, 0, MidpointRounding.AwayFromZero);

                                pStartLine9.X = (int)Math.Round((float)pStartLine9.X * fDrawingScaleX, 0, MidpointRounding.AwayFromZero);
                                pStartLine9.Y = (int)Math.Round((float)pStartLine9.Y * fDrawingScaleY, 0, MidpointRounding.AwayFromZero);
                                pEndLine9.X = (int)Math.Round((float)pEndLine9.X * fDrawingScaleX, 0, MidpointRounding.AwayFromZero);
                                pEndLine9.Y = (int)Math.Round((float)pEndLine9.Y * fDrawingScaleY, 0, MidpointRounding.AwayFromZero);

                                pStartLine10.X = (int)Math.Round((float)pStartLine10.X * fDrawingScaleX, 0, MidpointRounding.AwayFromZero);
                                pStartLine10.Y = (int)Math.Round((float)pStartLine10.Y * fDrawingScaleY, 0, MidpointRounding.AwayFromZero);
                                pEndLine10.X = (int)Math.Round((float)pEndLine10.X * fDrawingScaleX, 0, MidpointRounding.AwayFromZero);
                                pEndLine10.Y = (int)Math.Round((float)pEndLine10.Y * fDrawingScaleY, 0, MidpointRounding.AwayFromZero);

                                pStartLine11.X = (int)Math.Round((float)pStartLine11.X * fDrawingScaleX, 0, MidpointRounding.AwayFromZero);
                                pStartLine11.Y = (int)Math.Round((float)pStartLine11.Y * fDrawingScaleY, 0, MidpointRounding.AwayFromZero);
                                pEndLine11.X = (int)Math.Round((float)pEndLine11.X * fDrawingScaleX, 0, MidpointRounding.AwayFromZero);
                                pEndLine11.Y = (int)Math.Round((float)pEndLine11.Y * fDrawingScaleY, 0, MidpointRounding.AwayFromZero);

                                pStartLine12.X = (int)Math.Round((float)pStartLine12.X * fDrawingScaleX, 0, MidpointRounding.AwayFromZero);
                                pStartLine12.Y = (int)Math.Round((float)pStartLine12.Y * fDrawingScaleY, 0, MidpointRounding.AwayFromZero);
                                pEndLine12.X = (int)Math.Round((float)pEndLine12.X * fDrawingScaleX, 0, MidpointRounding.AwayFromZero);
                                pEndLine12.Y = (int)Math.Round((float)pEndLine12.Y * fDrawingScaleY, 0, MidpointRounding.AwayFromZero);
                            }
                           
                            if ((intPadSelectingNumber == -1) || (i != intPadSelectingNumber))
                            {
                                g.DrawLine(limePen, p1, p2);
                                g.DrawLine(limePen, p2, p4);
                                g.DrawLine(limePen, p4, p3);
                                g.DrawLine(limePen, p3, p1);

                                //g.DrawLine(BluePen, pStartLine1, pEndLine1);
                                //g.DrawLine(BluePen, pStartLine2, pEndLine2);
                                //g.DrawLine(BluePen, pStartLine3, pEndLine3);
                                //g.DrawLine(BluePen, pStartLine4, pEndLine4);
                                //g.DrawLine(BluePen, pStartLine5, pEndLine5);
                                //g.DrawLine(BluePen, pStartLine6, pEndLine6);
                                //g.DrawLine(BluePen, pStartLine7, pEndLine7);
                                g.DrawLine(limePen, pStartLine1, pEndLine1);
                                g.DrawLine(BluePen, pStartLine2, pEndLine2);
                                g.DrawLine(redPen, pStartLine3, pEndLine3);
                                g.DrawLine(YellowPen, pStartLine4, pEndLine4);
                                g.DrawLine(PinkPen, pStartLine5, pEndLine5);
                                g.DrawLine(OrangePen, pStartLine6, pEndLine6);
                                g.DrawLine(CyanPen, pStartLine7, pEndLine7);
                                g.DrawLine(MagentaPen, pStartLine8, pEndLine8);
                                g.DrawLine(SilverPen, pStartLine9, pEndLine9);
                                g.DrawLine(WheatPen, pStartLine10, pEndLine10);
                                g.DrawLine(BrownPen, pStartLine11, pEndLine11);
                                g.DrawLine(GreenPen, pStartLine12, pEndLine12);
                            }
                            else
                            {
                                g.DrawLine(YellowPen, p1, p2);
                                g.DrawLine(YellowPen, p2, p4);
                                g.DrawLine(YellowPen, p4, p3);
                                g.DrawLine(YellowPen, p3, p1);

                                //g.DrawLine(BluePen, pStartLine1, pEndLine1);
                                //g.DrawLine(BluePen, pStartLine2, pEndLine2);
                                //g.DrawLine(BluePen, pStartLine3, pEndLine3);
                                //g.DrawLine(BluePen, pStartLine4, pEndLine4);
                                //g.DrawLine(BluePen, pStartLine5, pEndLine5);
                                //g.DrawLine(BluePen, pStartLine6, pEndLine6);
                                //g.DrawLine(BluePen, pStartLine7, pEndLine7);
                                g.DrawLine(limePen, pStartLine1, pEndLine1);
                                g.DrawLine(BluePen, pStartLine2, pEndLine2);
                                g.DrawLine(redPen, pStartLine3, pEndLine3);
                                g.DrawLine(YellowPen, pStartLine4, pEndLine4);
                                g.DrawLine(PinkPen, pStartLine5, pEndLine5);
                                g.DrawLine(OrangePen, pStartLine6, pEndLine6);
                                g.DrawLine(CyanPen, pStartLine7, pEndLine7);
                                g.DrawLine(MagentaPen, pStartLine8, pEndLine8);
                                g.DrawLine(SilverPen, pStartLine9, pEndLine9);
                                g.DrawLine(WheatPen, pStartLine10, pEndLine10);
                                g.DrawLine(BrownPen, pStartLine11, pEndLine11);
                                g.DrawLine(GreenPen, pStartLine12, pEndLine12);
                            }

                            if (m_blnInspectLock)
                                return;

                            g.DrawString((i + 1).ToString(), m_Font, new SolidBrush(Color.Red),
                                (float)(m_arrSampleBlobPads[i].fCenterX + intRoiOrgX - 8) * fDrawingScaleX,
                                (float)(m_arrSampleBlobPads[i].fCenterY + intRoiOrgY - 8) * fDrawingScaleY);
                        }
                        else
                        {
                            if (m_blnInspectLock)
                                return;

                            System.Drawing.Point p1 = new System.Drawing.Point(intRoiOrgX + (int)Math.Round(m_arrSampleBlobPads[i].fStartX), intRoiOrgY + (int)Math.Round(m_arrSampleBlobPads[i].fStartY));
                            System.Drawing.Point p2 = new System.Drawing.Point(intRoiOrgX + (int)Math.Round(m_arrSampleBlobPads[i].fEndX), intRoiOrgY + (int)Math.Round(m_arrSampleBlobPads[i].fStartY));
                            System.Drawing.Point p3 = new System.Drawing.Point(intRoiOrgX + (int)Math.Round(m_arrSampleBlobPads[i].fStartX), intRoiOrgY + (int)Math.Round(m_arrSampleBlobPads[i].fEndY));
                            System.Drawing.Point p4 = new System.Drawing.Point(intRoiOrgX + (int)Math.Round(m_arrSampleBlobPads[i].fEndX), intRoiOrgY + (int)Math.Round(m_arrSampleBlobPads[i].fEndY));
                            //System.Drawing.Point p1 = new System.Drawing.Point(intRoiOrgX + (int)Math.Round(m_arrSampleBlobPads[i].fBlobCenterX - m_arrSampleBlobPads[i].fBlobWidth / 2), intRoiOrgY + (int)Math.Round(m_arrSampleBlobPads[i].fBlobCenterY - m_arrSampleBlobPads[i].fBlobHeight / 2));
                            //System.Drawing.Point p2 = new System.Drawing.Point(intRoiOrgX + (int)Math.Round(m_arrSampleBlobPads[i].fBlobCenterX + m_arrSampleBlobPads[i].fBlobWidth / 2), intRoiOrgY + (int)Math.Round(m_arrSampleBlobPads[i].fBlobCenterY - m_arrSampleBlobPads[i].fBlobHeight / 2));
                            //System.Drawing.Point p3 = new System.Drawing.Point(intRoiOrgX + (int)Math.Round(m_arrSampleBlobPads[i].fBlobCenterX - m_arrSampleBlobPads[i].fBlobWidth / 2), intRoiOrgY + (int)Math.Round(m_arrSampleBlobPads[i].fBlobCenterY + m_arrSampleBlobPads[i].fBlobHeight / 2));
                            //System.Drawing.Point p4 = new System.Drawing.Point(intRoiOrgX + (int)Math.Round(m_arrSampleBlobPads[i].fBlobCenterX + m_arrSampleBlobPads[i].fBlobWidth / 2), intRoiOrgY + (int)Math.Round(m_arrSampleBlobPads[i].fBlobCenterY + m_arrSampleBlobPads[i].fBlobHeight / 2));

                            System.Drawing.Point pStartLine1 = new System.Drawing.Point(intRoiOrgX + (int)Math.Round(m_arrSampleBlobPads[i].fStartXLine1), intRoiOrgY + (int)Math.Round(m_arrSampleBlobPads[i].fStartYLine1));
                            System.Drawing.Point pEndLine1 = new System.Drawing.Point(intRoiOrgX + (int)Math.Round(m_arrSampleBlobPads[i].fEndXLine1), intRoiOrgY + (int)Math.Round(m_arrSampleBlobPads[i].fEndYLine1));
                            System.Drawing.Point pStartLine2 = new System.Drawing.Point(intRoiOrgX + (int)Math.Round(m_arrSampleBlobPads[i].fStartXLine2), intRoiOrgY + (int)Math.Round(m_arrSampleBlobPads[i].fStartYLine2));
                            System.Drawing.Point pEndLine2 = new System.Drawing.Point(intRoiOrgX + (int)Math.Round(m_arrSampleBlobPads[i].fEndXLine2), intRoiOrgY + (int)Math.Round(m_arrSampleBlobPads[i].fEndYLine2));
                            System.Drawing.Point pStartLine3 = new System.Drawing.Point(intRoiOrgX + (int)Math.Round(m_arrSampleBlobPads[i].fStartXLine3), intRoiOrgY + (int)Math.Round(m_arrSampleBlobPads[i].fStartYLine3));
                            System.Drawing.Point pEndLine3 = new System.Drawing.Point(intRoiOrgX + (int)Math.Round(m_arrSampleBlobPads[i].fEndXLine3), intRoiOrgY + (int)Math.Round(m_arrSampleBlobPads[i].fEndYLine3));
                            System.Drawing.Point pStartLine4 = new System.Drawing.Point(intRoiOrgX + (int)Math.Round(m_arrSampleBlobPads[i].fStartXLine4), intRoiOrgY + (int)Math.Round(m_arrSampleBlobPads[i].fStartYLine4));
                            System.Drawing.Point pEndLine4 = new System.Drawing.Point(intRoiOrgX + (int)Math.Round(m_arrSampleBlobPads[i].fEndXLine4), intRoiOrgY + (int)Math.Round(m_arrSampleBlobPads[i].fEndYLine4));
                            System.Drawing.Point pStartLine5 = new System.Drawing.Point(intRoiOrgX + (int)Math.Round(m_arrSampleBlobPads[i].fStartXLine5), intRoiOrgY + (int)Math.Round(m_arrSampleBlobPads[i].fStartYLine5));
                            System.Drawing.Point pEndLine5 = new System.Drawing.Point(intRoiOrgX + (int)Math.Round(m_arrSampleBlobPads[i].fEndXLine5), intRoiOrgY + (int)Math.Round(m_arrSampleBlobPads[i].fEndYLine5));
                            System.Drawing.Point pStartLine6 = new System.Drawing.Point(intRoiOrgX + (int)Math.Round(m_arrSampleBlobPads[i].fStartXLine6), intRoiOrgY + (int)Math.Round(m_arrSampleBlobPads[i].fStartYLine6));
                            System.Drawing.Point pEndLine6 = new System.Drawing.Point(intRoiOrgX + (int)Math.Round(m_arrSampleBlobPads[i].fEndXLine6), intRoiOrgY + (int)Math.Round(m_arrSampleBlobPads[i].fEndYLine6));
                            System.Drawing.Point pStartLine7 = new System.Drawing.Point(intRoiOrgX + (int)Math.Round(m_arrSampleBlobPads[i].fStartXLine7), intRoiOrgY + (int)Math.Round(m_arrSampleBlobPads[i].fStartYLine7));
                            System.Drawing.Point pEndLine7 = new System.Drawing.Point(intRoiOrgX + (int)Math.Round(m_arrSampleBlobPads[i].fEndXLine7), intRoiOrgY + (int)Math.Round(m_arrSampleBlobPads[i].fEndYLine7));
                            System.Drawing.Point pStartLine8 = new System.Drawing.Point(intRoiOrgX + (int)Math.Round(m_arrSampleBlobPads[i].fStartXLine8), intRoiOrgY + (int)Math.Round(m_arrSampleBlobPads[i].fStartYLine8));
                            System.Drawing.Point pEndLine8 = new System.Drawing.Point(intRoiOrgX + (int)Math.Round(m_arrSampleBlobPads[i].fEndXLine8), intRoiOrgY + (int)Math.Round(m_arrSampleBlobPads[i].fEndYLine8));
                            System.Drawing.Point pStartLine9 = new System.Drawing.Point(intRoiOrgX + (int)Math.Round(m_arrSampleBlobPads[i].fStartXLine9), intRoiOrgY + (int)Math.Round(m_arrSampleBlobPads[i].fStartYLine9));
                            System.Drawing.Point pEndLine9 = new System.Drawing.Point(intRoiOrgX + (int)Math.Round(m_arrSampleBlobPads[i].fEndXLine9), intRoiOrgY + (int)Math.Round(m_arrSampleBlobPads[i].fEndYLine9));
                            System.Drawing.Point pStartLine10 = new System.Drawing.Point(intRoiOrgX + (int)Math.Round(m_arrSampleBlobPads[i].fStartXLine10), intRoiOrgY + (int)Math.Round(m_arrSampleBlobPads[i].fStartYLine10));
                            System.Drawing.Point pEndLine10 = new System.Drawing.Point(intRoiOrgX + (int)Math.Round(m_arrSampleBlobPads[i].fEndXLine10), intRoiOrgY + (int)Math.Round(m_arrSampleBlobPads[i].fEndYLine10));
                            System.Drawing.Point pStartLine11 = new System.Drawing.Point(intRoiOrgX + (int)Math.Round(m_arrSampleBlobPads[i].fStartXLine11), intRoiOrgY + (int)Math.Round(m_arrSampleBlobPads[i].fStartYLine11));
                            System.Drawing.Point pEndLine11 = new System.Drawing.Point(intRoiOrgX + (int)Math.Round(m_arrSampleBlobPads[i].fEndXLine11), intRoiOrgY + (int)Math.Round(m_arrSampleBlobPads[i].fEndYLine11));
                            System.Drawing.Point pStartLine12 = new System.Drawing.Point(intRoiOrgX + (int)Math.Round(m_arrSampleBlobPads[i].fStartXLine12), intRoiOrgY + (int)Math.Round(m_arrSampleBlobPads[i].fStartYLine12));
                            System.Drawing.Point pEndLine12 = new System.Drawing.Point(intRoiOrgX + (int)Math.Round(m_arrSampleBlobPads[i].fEndXLine12), intRoiOrgY + (int)Math.Round(m_arrSampleBlobPads[i].fEndYLine12));

                            BlobsFeatures m_stcBlobPad = (BlobsFeatures)m_arrTemplateBlobPads[i];
                            if (m_stcBlobPad.blnFeretActivated)
                            {
                                p1 = new System.Drawing.Point(intRoiOrgX + (int)Math.Round(m_arrSampleBlobPads[i].fFeretCenterX - m_arrSampleBlobPads[i].fFeretWidth / 2), intRoiOrgY + (int)Math.Round(m_arrSampleBlobPads[i].fFeretCenterY - m_arrSampleBlobPads[i].fFeretHeight / 2));
                                p2 = new System.Drawing.Point(intRoiOrgX + (int)Math.Round(m_arrSampleBlobPads[i].fFeretCenterX + m_arrSampleBlobPads[i].fFeretWidth / 2), intRoiOrgY + (int)Math.Round(m_arrSampleBlobPads[i].fFeretCenterY - m_arrSampleBlobPads[i].fFeretHeight / 2));
                                p3 = new System.Drawing.Point(intRoiOrgX + (int)Math.Round(m_arrSampleBlobPads[i].fFeretCenterX - m_arrSampleBlobPads[i].fFeretWidth / 2), intRoiOrgY + (int)Math.Round(m_arrSampleBlobPads[i].fFeretCenterY + m_arrSampleBlobPads[i].fFeretHeight / 2));
                                p4 = new System.Drawing.Point(intRoiOrgX + (int)Math.Round(m_arrSampleBlobPads[i].fFeretCenterX + m_arrSampleBlobPads[i].fFeretWidth / 2), intRoiOrgY + (int)Math.Round(m_arrSampleBlobPads[i].fFeretCenterY + m_arrSampleBlobPads[i].fFeretHeight / 2));

                                float newX1 = 0, newY1 = 0;
                                float newX2 = 0, newY2 = 0;
                                float newX3 = 0, newY3 = 0;
                                float newX4 = 0, newY4 = 0;
                                Math2.RotateWithAngleAccordingToReferencePoint(intRoiOrgX + m_arrSampleBlobPads[i].fFeretCenterX, intRoiOrgY + m_arrSampleBlobPads[i].fFeretCenterY, (float)p1.X, (float)p1.Y, m_stcBlobPad.fFeretAngle, ref newX1, ref newY1);
                                Math2.RotateWithAngleAccordingToReferencePoint(intRoiOrgX + m_arrSampleBlobPads[i].fFeretCenterX, intRoiOrgY + m_arrSampleBlobPads[i].fFeretCenterY, (float)p2.X, (float)p2.Y, m_stcBlobPad.fFeretAngle, ref newX2, ref newY2);
                                Math2.RotateWithAngleAccordingToReferencePoint(intRoiOrgX + m_arrSampleBlobPads[i].fFeretCenterX, intRoiOrgY + m_arrSampleBlobPads[i].fFeretCenterY, (float)p3.X, (float)p3.Y, m_stcBlobPad.fFeretAngle, ref newX3, ref newY3);
                                Math2.RotateWithAngleAccordingToReferencePoint(intRoiOrgX + m_arrSampleBlobPads[i].fFeretCenterX, intRoiOrgY + m_arrSampleBlobPads[i].fFeretCenterY, (float)p4.X, (float)p4.Y, m_stcBlobPad.fFeretAngle, ref newX4, ref newY4);
                                //Math2.RotateWithAngleAccordingToReferencePoint(intRoiOrgX + m_arrSampleBlobPads[i].fStartX + m_arrSampleBlobPads[i].fWidth / 2, intRoiOrgY + m_arrSampleBlobPads[i].fStartY + m_arrSampleBlobPads[i].fHeight / 2, (float)p1.X, (float)p1.Y, m_stcBlobPad.fFeretAngle, ref newX1, ref newY1);
                                //Math2.RotateWithAngleAccordingToReferencePoint(intRoiOrgX + m_arrSampleBlobPads[i].fEndX - m_arrSampleBlobPads[i].fWidth / 2, intRoiOrgY + m_arrSampleBlobPads[i].fStartY + m_arrSampleBlobPads[i].fHeight / 2, (float)p2.X, (float)p2.Y, m_stcBlobPad.fFeretAngle, ref newX2, ref newY2);
                                //Math2.RotateWithAngleAccordingToReferencePoint(intRoiOrgX + m_arrSampleBlobPads[i].fStartX + m_arrSampleBlobPads[i].fWidth / 2, intRoiOrgY + m_arrSampleBlobPads[i].fEndY - m_arrSampleBlobPads[i].fHeight / 2, (float)p3.X, (float)p3.Y, m_stcBlobPad.fFeretAngle, ref newX3, ref newY3);
                                //Math2.RotateWithAngleAccordingToReferencePoint(intRoiOrgX + m_arrSampleBlobPads[i].fEndX - m_arrSampleBlobPads[i].fWidth / 2, intRoiOrgY + m_arrSampleBlobPads[i].fEndY - m_arrSampleBlobPads[i].fHeight / 2, (float)p4.X, (float)p4.Y, m_stcBlobPad.fFeretAngle, ref newX4, ref newY4);
                                //Math2.RotateWithAngleAccordingToReferencePoint(intRoiOrgX + m_stcBlobPad.fFeretCenterX, intRoiOrgY + m_stcBlobPad.fFeretCenterY, (float)p1.X, (float)p1.Y, m_stcBlobPad.fFeretAngle, ref newX1, ref newY1);
                                //Math2.RotateWithAngleAccordingToReferencePoint(intRoiOrgX + m_stcBlobPad.fFeretCenterX, intRoiOrgY + m_stcBlobPad.fFeretCenterY, (float)p3.X, (float)p3.Y, m_stcBlobPad.fFeretAngle, ref newX2, ref newY2);
                                //Math2.RotateWithAngleAccordingToReferencePoint(intRoiOrgX + m_stcBlobPad.fFeretCenterX, intRoiOrgY + m_stcBlobPad.fFeretCenterY, (float)p2.X, (float)p2.Y, m_stcBlobPad.fFeretAngle, ref newX3, ref newY3);
                                //Math2.RotateWithAngleAccordingToReferencePoint(intRoiOrgX + m_stcBlobPad.fFeretCenterX, intRoiOrgY + m_stcBlobPad.fFeretCenterY, (float)p4.X, (float)p4.Y, m_stcBlobPad.fFeretAngle, ref newX4, ref newY4);
                                //Math2.RotateWithAngleAccordingToReferencePoint(intRoiOrgX + ((p1.X + p2.X) / 2), intRoiOrgY + ((p1.Y + p3.Y) / 2), (float)p1.X, (float)p1.Y, m_stcBlobPad.fFeretAngle, ref newX1, ref newY1);
                                //Math2.RotateWithAngleAccordingToReferencePoint(intRoiOrgX + ((p1.X + p2.X) / 2), intRoiOrgY + ((p1.Y + p3.Y) / 2), (float)p2.X, (float)p2.Y, m_stcBlobPad.fFeretAngle, ref newX2, ref newY2);
                                //Math2.RotateWithAngleAccordingToReferencePoint(intRoiOrgX + ((p1.X + p2.X) / 2), intRoiOrgY + ((p1.Y + p3.Y) / 2), (float)p3.X, (float)p3.Y, m_stcBlobPad.fFeretAngle, ref newX3, ref newY3);
                                //Math2.RotateWithAngleAccordingToReferencePoint(intRoiOrgX + ((p1.X + p2.X) / 2), intRoiOrgY + ((p1.Y + p3.Y) / 2), (float)p4.X, (float)p4.Y, m_stcBlobPad.fFeretAngle, ref newX4, ref newY4);
                                p1.X = (int)newX1;
                                p1.Y = (int)newY1;
                                p2.X = (int)newX2;
                                p2.Y = (int)newY2;
                                p3.X = (int)newX3;
                                p3.Y = (int)newY3;
                                p4.X = (int)newX4;
                                p4.Y = (int)newY4;
                            }

                            if (fDrawingScaleX != 1f || fDrawingScaleY != 1f)
                            {
                                p1.X = (int)Math.Round((float)p1.X * fDrawingScaleX, 0, MidpointRounding.AwayFromZero);
                                p1.Y = (int)Math.Round((float)p1.Y * fDrawingScaleY, 0, MidpointRounding.AwayFromZero);
                                p2.X = (int)Math.Round((float)p2.X * fDrawingScaleX, 0, MidpointRounding.AwayFromZero);
                                p2.Y = (int)Math.Round((float)p2.Y * fDrawingScaleY, 0, MidpointRounding.AwayFromZero);
                                p3.X = (int)Math.Round((float)p3.X * fDrawingScaleX, 0, MidpointRounding.AwayFromZero);
                                p3.Y = (int)Math.Round((float)p3.Y * fDrawingScaleY, 0, MidpointRounding.AwayFromZero);
                                p4.X = (int)Math.Round((float)p4.X * fDrawingScaleX, 0, MidpointRounding.AwayFromZero);
                                p4.Y = (int)Math.Round((float)p4.Y * fDrawingScaleY, 0, MidpointRounding.AwayFromZero);

                                pStartLine1.X = (int)Math.Round((float)pStartLine1.X * fDrawingScaleX, 0, MidpointRounding.AwayFromZero);
                                pStartLine1.Y = (int)Math.Round((float)pStartLine1.Y * fDrawingScaleY, 0, MidpointRounding.AwayFromZero);
                                pEndLine1.X = (int)Math.Round((float)pEndLine1.X * fDrawingScaleX, 0, MidpointRounding.AwayFromZero);
                                pEndLine1.Y = (int)Math.Round((float)pEndLine1.Y * fDrawingScaleY, 0, MidpointRounding.AwayFromZero);

                                pStartLine2.X = (int)Math.Round((float)pStartLine2.X * fDrawingScaleX, 0, MidpointRounding.AwayFromZero);
                                pStartLine2.Y = (int)Math.Round((float)pStartLine2.Y * fDrawingScaleY, 0, MidpointRounding.AwayFromZero);
                                pEndLine2.X = (int)Math.Round((float)pEndLine2.X * fDrawingScaleX, 0, MidpointRounding.AwayFromZero);
                                pEndLine2.Y = (int)Math.Round((float)pEndLine2.Y * fDrawingScaleY, 0, MidpointRounding.AwayFromZero);

                                pStartLine3.X = (int)Math.Round((float)pStartLine3.X * fDrawingScaleX, 0, MidpointRounding.AwayFromZero);
                                pStartLine3.Y = (int)Math.Round((float)pStartLine3.Y * fDrawingScaleY, 0, MidpointRounding.AwayFromZero);
                                pEndLine3.X = (int)Math.Round((float)pEndLine3.X * fDrawingScaleX, 0, MidpointRounding.AwayFromZero);
                                pEndLine3.Y = (int)Math.Round((float)pEndLine3.Y * fDrawingScaleY, 0, MidpointRounding.AwayFromZero);

                                pStartLine4.X = (int)Math.Round((float)pStartLine4.X * fDrawingScaleX, 0, MidpointRounding.AwayFromZero);
                                pStartLine4.Y = (int)Math.Round((float)pStartLine4.Y * fDrawingScaleY, 0, MidpointRounding.AwayFromZero);
                                pEndLine4.X = (int)Math.Round((float)pEndLine4.X * fDrawingScaleX, 0, MidpointRounding.AwayFromZero);
                                pEndLine4.Y = (int)Math.Round((float)pEndLine4.Y * fDrawingScaleY, 0, MidpointRounding.AwayFromZero);

                                pStartLine5.X = (int)Math.Round((float)pStartLine5.X * fDrawingScaleX, 0, MidpointRounding.AwayFromZero);
                                pStartLine5.Y = (int)Math.Round((float)pStartLine5.Y * fDrawingScaleY, 0, MidpointRounding.AwayFromZero);
                                pEndLine5.X = (int)Math.Round((float)pEndLine5.X * fDrawingScaleX, 0, MidpointRounding.AwayFromZero);
                                pEndLine5.Y = (int)Math.Round((float)pEndLine5.Y * fDrawingScaleY, 0, MidpointRounding.AwayFromZero);

                                pStartLine6.X = (int)Math.Round((float)pStartLine6.X * fDrawingScaleX, 0, MidpointRounding.AwayFromZero);
                                pStartLine6.Y = (int)Math.Round((float)pStartLine6.Y * fDrawingScaleY, 0, MidpointRounding.AwayFromZero);
                                pEndLine6.X = (int)Math.Round((float)pEndLine6.X * fDrawingScaleX, 0, MidpointRounding.AwayFromZero);
                                pEndLine6.Y = (int)Math.Round((float)pEndLine6.Y * fDrawingScaleY, 0, MidpointRounding.AwayFromZero);

                                pStartLine7.X = (int)Math.Round((float)pStartLine7.X * fDrawingScaleX, 0, MidpointRounding.AwayFromZero);
                                pStartLine7.Y = (int)Math.Round((float)pStartLine7.Y * fDrawingScaleY, 0, MidpointRounding.AwayFromZero);
                                pEndLine7.X = (int)Math.Round((float)pEndLine7.X * fDrawingScaleX, 0, MidpointRounding.AwayFromZero);
                                pEndLine7.Y = (int)Math.Round((float)pEndLine7.Y * fDrawingScaleY, 0, MidpointRounding.AwayFromZero);

                                pStartLine8.X = (int)Math.Round((float)pStartLine8.X * fDrawingScaleX, 0, MidpointRounding.AwayFromZero);
                                pStartLine8.Y = (int)Math.Round((float)pStartLine8.Y * fDrawingScaleY, 0, MidpointRounding.AwayFromZero);
                                pEndLine8.X = (int)Math.Round((float)pEndLine8.X * fDrawingScaleX, 0, MidpointRounding.AwayFromZero);
                                pEndLine8.Y = (int)Math.Round((float)pEndLine8.Y * fDrawingScaleY, 0, MidpointRounding.AwayFromZero);

                                pStartLine9.X = (int)Math.Round((float)pStartLine9.X * fDrawingScaleX, 0, MidpointRounding.AwayFromZero);
                                pStartLine9.Y = (int)Math.Round((float)pStartLine9.Y * fDrawingScaleY, 0, MidpointRounding.AwayFromZero);
                                pEndLine9.X = (int)Math.Round((float)pEndLine9.X * fDrawingScaleX, 0, MidpointRounding.AwayFromZero);
                                pEndLine9.Y = (int)Math.Round((float)pEndLine9.Y * fDrawingScaleY, 0, MidpointRounding.AwayFromZero);

                                pStartLine10.X = (int)Math.Round((float)pStartLine10.X * fDrawingScaleX, 0, MidpointRounding.AwayFromZero);
                                pStartLine10.Y = (int)Math.Round((float)pStartLine10.Y * fDrawingScaleY, 0, MidpointRounding.AwayFromZero);
                                pEndLine10.X = (int)Math.Round((float)pEndLine10.X * fDrawingScaleX, 0, MidpointRounding.AwayFromZero);
                                pEndLine10.Y = (int)Math.Round((float)pEndLine10.Y * fDrawingScaleY, 0, MidpointRounding.AwayFromZero);

                                pStartLine11.X = (int)Math.Round((float)pStartLine11.X * fDrawingScaleX, 0, MidpointRounding.AwayFromZero);
                                pStartLine11.Y = (int)Math.Round((float)pStartLine11.Y * fDrawingScaleY, 0, MidpointRounding.AwayFromZero);
                                pEndLine11.X = (int)Math.Round((float)pEndLine11.X * fDrawingScaleX, 0, MidpointRounding.AwayFromZero);
                                pEndLine11.Y = (int)Math.Round((float)pEndLine11.Y * fDrawingScaleY, 0, MidpointRounding.AwayFromZero);

                                pStartLine12.X = (int)Math.Round((float)pStartLine12.X * fDrawingScaleX, 0, MidpointRounding.AwayFromZero);
                                pStartLine12.Y = (int)Math.Round((float)pStartLine12.Y * fDrawingScaleY, 0, MidpointRounding.AwayFromZero);
                                pEndLine12.X = (int)Math.Round((float)pEndLine12.X * fDrawingScaleX, 0, MidpointRounding.AwayFromZero);
                                pEndLine12.Y = (int)Math.Round((float)pEndLine12.Y * fDrawingScaleY, 0, MidpointRounding.AwayFromZero);
                            }
                       
                            if (i == intPadSelectingNumber)
                            {
                                g.DrawLine(YellowPen, p1, p2);
                                g.DrawLine(YellowPen, p2, p4);
                                g.DrawLine(YellowPen, p4, p3);
                                g.DrawLine(YellowPen, p3, p1);
                                //g.DrawLine(YellowPen, p1, p4);
                                
                                g.DrawLine(limePen, pStartLine1, pEndLine1);
                                g.DrawLine(BluePen, pStartLine2, pEndLine2);
                                g.DrawLine(redPen, pStartLine3, pEndLine3);
                                g.DrawLine(YellowPen, pStartLine4, pEndLine4);
                                g.DrawLine(PinkPen, pStartLine5, pEndLine5);
                                g.DrawLine(OrangePen, pStartLine6, pEndLine6);
                                g.DrawLine(CyanPen, pStartLine7, pEndLine7);
                                g.DrawLine(MagentaPen, pStartLine8, pEndLine8);
                                g.DrawLine(SilverPen, pStartLine9, pEndLine9);
                                g.DrawLine(WheatPen, pStartLine10, pEndLine10);
                                g.DrawLine(BrownPen, pStartLine11, pEndLine11);
                                g.DrawLine(GreenPen, pStartLine12, pEndLine12);
                            }
                            else
                            {
                                g.DrawLine(redPen, p1, p2);
                                g.DrawLine(redPen, p2, p4);
                                g.DrawLine(redPen, p4, p3);
                                g.DrawLine(redPen, p3, p1);
                                //g.DrawLine(redPen, p1, p4);
                                
                                g.DrawLine(limePen, pStartLine1, pEndLine1);
                                g.DrawLine(BluePen, pStartLine2, pEndLine2);
                                g.DrawLine(redPen, pStartLine3, pEndLine3);
                                g.DrawLine(YellowPen, pStartLine4, pEndLine4);
                                g.DrawLine(PinkPen, pStartLine5, pEndLine5);
                                g.DrawLine(OrangePen, pStartLine6, pEndLine6);
                                g.DrawLine(CyanPen, pStartLine7, pEndLine7);
                                g.DrawLine(MagentaPen, pStartLine8, pEndLine8);
                                g.DrawLine(SilverPen, pStartLine9, pEndLine9);
                                g.DrawLine(WheatPen, pStartLine10, pEndLine10);
                                g.DrawLine(BrownPen, pStartLine11, pEndLine11);
                                g.DrawLine(GreenPen, pStartLine12, pEndLine12);
                            }



                            if (m_blnInspectLock)
                                return;
                            g.DrawString((i + 1).ToString(), m_Font, new SolidBrush(Color.Red),
                                (float)(m_arrSampleBlobPads[i].fCenterX + intRoiOrgX - 8) * fDrawingScaleX,
                                (float)(m_arrSampleBlobPads[i].fCenterY + intRoiOrgY - 8) * fDrawingScaleY);

                        }
                    }
                }

                for (int i = 0; i < m_arrPadDefectList.Count; i++)
                {
                    if (m_blnInspectLock)
                        return;
                    if ((intPadDefectSelectingNumber == -1) || (i != intPadDefectSelectingNumber))
                    {
                        g.DrawRectangle(redPen, (m_arrPadDefectList[i].ref_fCenterX - m_arrPadDefectList[i].ref_fWidth / 2) * fDrawingScaleX,
                        (m_arrPadDefectList[i].ref_fCenterY - m_arrPadDefectList[i].ref_fHeight / 2) * fDrawingScaleY,
                        m_arrPadDefectList[i].ref_fWidth * fDrawingScaleX, m_arrPadDefectList[i].ref_fHeight * fDrawingScaleY);
                    }
                    else
                    {
                        g.DrawRectangle(YellowPen, (m_arrPadDefectList[i].ref_fCenterX - m_arrPadDefectList[i].ref_fWidth / 2) * fDrawingScaleX,
                        (m_arrPadDefectList[i].ref_fCenterY - m_arrPadDefectList[i].ref_fHeight / 2) * fDrawingScaleY,
                        m_arrPadDefectList[i].ref_fWidth * fDrawingScaleX, m_arrPadDefectList[i].ref_fHeight * fDrawingScaleY);
                    }
                }

                for (int i = 0; i < m_arrFailPitchGapList.Count; i++)
                {
                    if (m_blnInspectLock)
                        return;

                    g.DrawLine(redPen, (float)(m_arrFailPitchGapList[i].intStartPointX - 5) * fDrawingScaleX,
                                       (float)(m_arrFailPitchGapList[i].intStartPointY - 5) * fDrawingScaleY,
                                       (float)(m_arrFailPitchGapList[i].intStartPointX + 5) * fDrawingScaleX,
                                       (float)(m_arrFailPitchGapList[i].intStartPointY + 5) * fDrawingScaleY);
                    g.DrawLine(redPen, (float)(m_arrFailPitchGapList[i].intStartPointX + 5) * fDrawingScaleX,
                                       (float)(m_arrFailPitchGapList[i].intStartPointY - 5) * fDrawingScaleY,
                                       (float)(m_arrFailPitchGapList[i].intStartPointX - 5) * fDrawingScaleX,
                                       (float)(m_arrFailPitchGapList[i].intStartPointY + 5) * fDrawingScaleY);
                    g.DrawLine(redPen, (float)(m_arrFailPitchGapList[i].intEndPointX - 5) * fDrawingScaleX,
                                       (float)(m_arrFailPitchGapList[i].intEndPointY - 5) * fDrawingScaleY,
                                       (float)(m_arrFailPitchGapList[i].intEndPointX + 5) * fDrawingScaleX,
                                       (float)(m_arrFailPitchGapList[i].intEndPointY + 5) * fDrawingScaleY);
                    g.DrawLine(redPen, (float)(m_arrFailPitchGapList[i].intEndPointX + 5) * fDrawingScaleX,
                                       (float)(m_arrFailPitchGapList[i].intEndPointY - 5) * fDrawingScaleY,
                                       (float)(m_arrFailPitchGapList[i].intEndPointX - 5) * fDrawingScaleX,
                                       (float)(m_arrFailPitchGapList[i].intEndPointY + 5) * fDrawingScaleY);
                    g.DrawLine(redPen, (float)(m_arrFailPitchGapList[i].intStartPointX) * fDrawingScaleX,
                                       (float)(m_arrFailPitchGapList[i].intStartPointY) * fDrawingScaleY,
                                       (float)(m_arrFailPitchGapList[i].intEndPointX) * fDrawingScaleX,
                                       (float)(m_arrFailPitchGapList[i].intEndPointY) * fDrawingScaleY);
                }
            }
        }


        /// <summary>
        /// Draw selected objects
        /// </summary>
        /// <param name="g">destination image to be drawn</param>
        /// <param name="fScale"></param>
        /// <param name="intZoomImageEdgeX">translation factor for panning in the horizontal direction</param>
        /// <param name="intZoomImageEdgeY">translation factor for panning in the vertical direction</param>
        public void DrawSelectedObjects(Graphics g, float fDrawingScaleX, float fDrawingScaleY)
        {
            for (int i = 0; i < m_arrTemplateBlobPads.Count; i++)
            {
                if (((BlobsFeatures)m_arrTemplateBlobPads[i]).blnSelected)
                    m_objEBlobs.DrawSelectedBlob(g, fDrawingScaleX, fDrawingScaleY, Color.Lime, i);
                else
                    m_objEBlobs.DrawSelectedBlob(g, fDrawingScaleX, fDrawingScaleY, Color.Red, i);
            }
        }

        public void DrawPadEdgeLimitTolerance(Graphics g, float fDrawingScaleX, float fDrawingScaleY, float fPkgStartX, float fPkgStartY, float fPkgWidth, float fPkgHeight, int intBlobIndex, Color objColor)
        {
            if (intBlobIndex < 0)
                return;

            if (m_arrTemplateBlobPads.Count <= intBlobIndex)
                return;

            float fTopSetting = ((BlobsFeatures)m_arrTemplateBlobPads[intBlobIndex]).fEdgeLimitTop / m_fMMPerPixelY * fDrawingScaleY;
            float fBottomSetting = ((BlobsFeatures)m_arrTemplateBlobPads[intBlobIndex]).fEdgeLimitBottom / m_fMMPerPixelY * fDrawingScaleY;
            float fLeftSetting = ((BlobsFeatures)m_arrTemplateBlobPads[intBlobIndex]).fEdgeLimitLeft / m_fMMPerPixelX * fDrawingScaleX;
            float fRightSetting = ((BlobsFeatures)m_arrTemplateBlobPads[intBlobIndex]).fEdgeLimitRight / m_fMMPerPixelX * fDrawingScaleX;
   

            g.DrawRectangle(new Pen(objColor),
                fPkgStartX + fLeftSetting,
                fPkgStartY + fTopSetting,
                fPkgWidth - fRightSetting - fLeftSetting,
                fPkgHeight - fBottomSetting - fTopSetting);
        }
        public void DrawPadEdgeLimitTolerance_Group(Graphics g, float fDrawingScaleX, float fDrawingScaleY, float fPkgStartX, float fPkgStartY, float fPkgWidth, float fPkgHeight, int intBlobIndex, Color objColor)
        {
            if (intBlobIndex < 0)
                return;
            for (int i = 0; i < m_arrTemplateBlobPads.Count; i++)
            {

                if (((BlobsFeatures)m_arrTemplateBlobPads[i]).intGroupID != intBlobIndex)
                {
                    continue;
                }

                float fTopSetting = ((BlobsFeatures)m_arrGroupTemplateBlobPads[intBlobIndex]).fEdgeLimitTop / m_fMMPerPixelY * fDrawingScaleY;
                float fBottomSetting = ((BlobsFeatures)m_arrGroupTemplateBlobPads[intBlobIndex]).fEdgeLimitBottom / m_fMMPerPixelY * fDrawingScaleY;
                float fLeftSetting = ((BlobsFeatures)m_arrGroupTemplateBlobPads[intBlobIndex]).fEdgeLimitLeft / m_fMMPerPixelX * fDrawingScaleX;
                float fRightSetting = ((BlobsFeatures)m_arrGroupTemplateBlobPads[intBlobIndex]).fEdgeLimitRight / m_fMMPerPixelX * fDrawingScaleX;


                g.DrawRectangle(new Pen(objColor),
                    fPkgStartX + fLeftSetting,
                    fPkgStartY + fTopSetting,
                    fPkgWidth - fRightSetting - fLeftSetting,
                    fPkgHeight - fBottomSetting - fTopSetting);
            }
        }
        public void DrawPadStandOffTolerance(Graphics g, float fDrawingScaleX, float fDrawingScaleY, float fPkgStartX, float fPkgStartY, float fPkgWidth, float fPkgHeight, int intBlobIndex, ROI objPadROI, Color objColor)
        {
            if (intBlobIndex < 0)
                return;

            if (m_arrTemplateBlobPads.Count <= intBlobIndex)
                return;

            float fTopSetting = ((BlobsFeatures)m_arrTemplateBlobPads[intBlobIndex]).fMaxStandOffTop / m_fMMPerPixelY * fDrawingScaleY;
            float fBottomSetting = ((BlobsFeatures)m_arrTemplateBlobPads[intBlobIndex]).fMaxStandOffBottom / m_fMMPerPixelY * fDrawingScaleY;
            float fLeftSetting = ((BlobsFeatures)m_arrTemplateBlobPads[intBlobIndex]).fMaxStandOffLeft / m_fMMPerPixelX * fDrawingScaleX;
            float fRightSetting = ((BlobsFeatures)m_arrTemplateBlobPads[intBlobIndex]).fMaxStandOffRight / m_fMMPerPixelX * fDrawingScaleX;

            float fPadCenterX = (objPadROI.ref_ROITotalX + m_arrSampleBlobPads[intBlobIndex].fCenterX) * fDrawingScaleX;
            float fPadCenterY = (objPadROI.ref_ROITotalY + m_arrSampleBlobPads[intBlobIndex].fCenterY) * fDrawingScaleY;
            float fPadWidth = (m_arrSampleBlobPads[intBlobIndex].fWidth / 2) * fDrawingScaleX;
            float fPadLength = (m_arrSampleBlobPads[intBlobIndex].fHeight / 2) * fDrawingScaleY;

            //refer Top
            if (((BlobsFeatures)m_arrTemplateBlobPads[intBlobIndex]).intReferTopBottom == 0)
            {
                if (((BlobsFeatures)m_arrTemplateBlobPads[intBlobIndex]).blnCheckTop)
                {
                    if (m_intPadROIDirection == 1 || m_intPadROIDirection == 0)
                        g.DrawLine(new Pen(objColor, 2),
                            fPadCenterX - fPadWidth,
                            fPkgStartY + fTopSetting,
                            fPadCenterX + fPadWidth,
                            fPkgStartY + fTopSetting);
                    else if (m_intPadROIDirection == 3)
                        g.DrawLine(new Pen(objColor, 2),
                           fPadCenterX - fPadWidth,
                           fPkgStartY - fTopSetting + fPkgHeight,//+ fTopSetting
                           fPadCenterX + fPadWidth,
                           fPkgStartY - fTopSetting + fPkgHeight);//+ fTopSetting
                    else if (m_intPadROIDirection == 2)
                        g.DrawLine(new Pen(objColor, 2),
                             fPkgStartX - fTopSetting + fPkgWidth,//fPadCenterX + fTopSetting - fPadLength
                             fPadCenterY - fPadWidth,
                             fPkgStartX - fTopSetting + fPkgWidth,//fPadCenterX + fTopSetting - fPadLength
                             fPadCenterY + fPadWidth);
                    else if (m_intPadROIDirection == 4)
                        g.DrawLine(new Pen(objColor, 2),
                           fPkgStartX + fTopSetting,//fPadCenterX + fTopSetting - fPadLength
                           fPadCenterY - fPadWidth,
                           fPkgStartX + fTopSetting,//fPadCenterX + fTopSetting - fPadLength
                           fPadCenterY + fPadWidth);
                }

                if (((BlobsFeatures)m_arrTemplateBlobPads[intBlobIndex]).blnCheckBottom)
                {
                    if (m_intPadROIDirection == 1 || m_intPadROIDirection == 0)
                        g.DrawLine(new Pen(objColor, 2),
                             fPadCenterX - fPadWidth,
                             fPkgStartY + fBottomSetting,
                             fPadCenterX + fPadWidth,
                             fPkgStartY + fBottomSetting);
                    else if (m_intPadROIDirection == 3)
                        g.DrawLine(new Pen(objColor, 2),
                           fPadCenterX - fPadWidth,
                           fPkgStartY - fBottomSetting + fPkgHeight,//+ fBottomSetting
                           fPadCenterX + fPadWidth,
                           fPkgStartY - fBottomSetting + fPkgHeight);//+ fBottomSetting
                    else if (m_intPadROIDirection == 2)
                        g.DrawLine(new Pen(objColor, 2),
                             fPkgStartX - fBottomSetting + fPkgWidth,//fPadCenterX + fBottomSetting - fPadLength
                             fPadCenterY - fPadWidth,
                             fPkgStartX - fBottomSetting + fPkgWidth,//fPadCenterX + fBottomSetting - fPadLength
                             fPadCenterY + fPadWidth);
                    else if (m_intPadROIDirection == 4)
                        g.DrawLine(new Pen(objColor, 2),
                           fPkgStartX + fBottomSetting,//fPadCenterX + fBottomSetting - fPadLength
                           fPadCenterY - fPadWidth,
                           fPkgStartX + fBottomSetting,//fPadCenterX + fBottomSetting - fPadLength
                           fPadCenterY + fPadWidth);
                }

            }
            else // refer Bottom
            {
                if (((BlobsFeatures)m_arrTemplateBlobPads[intBlobIndex]).blnCheckTop)
                {
                    if (m_intPadROIDirection == 1 || m_intPadROIDirection == 0)
                        g.DrawLine(new Pen(objColor, 2),
                            fPadCenterX - fPadWidth,
                            fPkgStartY + fPkgHeight - fTopSetting,
                            fPadCenterX + fPadWidth,
                            fPkgStartY + fPkgHeight - fTopSetting);
                    else if (m_intPadROIDirection == 3)
                        g.DrawLine(new Pen(objColor, 2),
                       fPadCenterX - fPadWidth,
                       fPkgStartY + fTopSetting,
                       fPadCenterX + fPadWidth,
                       fPkgStartY + fTopSetting);
                    else if (m_intPadROIDirection == 2)
                        g.DrawLine(new Pen(objColor, 2),
                             fPkgStartX + fTopSetting,//fPadCenterX + fTopSetting - fPkgWidth
                             fPadCenterY - fPadWidth,
                             fPkgStartX + fTopSetting,//fPadCenterX + fTopSetting - fPkgWidth
                             fPadCenterY + fPadWidth);
                    else if (m_intPadROIDirection == 4)
                        g.DrawLine(new Pen(objColor, 2),
                           fPkgStartX - fTopSetting + fPkgWidth,//fPadCenterX - fTopSetting + fPkgWidth
                           fPadCenterY - fPadWidth,
                           fPkgStartX - fTopSetting + fPkgWidth,//fPadCenterX - fTopSetting + fPkgWidth
                           fPadCenterY + fPadWidth);

                }

                if (((BlobsFeatures)m_arrTemplateBlobPads[intBlobIndex]).blnCheckBottom)
                {
                    if (m_intPadROIDirection == 1 || m_intPadROIDirection == 0)
                        g.DrawLine(new Pen(objColor, 2),
                             fPadCenterX - fPadWidth,
                             fPkgStartY + fPkgHeight - fBottomSetting,
                             fPadCenterX + fPadWidth,
                             fPkgStartY + fPkgHeight - fBottomSetting);
                    else if (m_intPadROIDirection == 3)
                        g.DrawLine(new Pen(objColor, 2),
                           fPadCenterX - fPadWidth,
                           fPkgStartY + fBottomSetting,
                           fPadCenterX + fPadWidth,
                           fPkgStartY + fBottomSetting);
                    else if (m_intPadROIDirection == 2)
                        g.DrawLine(new Pen(objColor, 2),
                             fPkgStartX + fBottomSetting,//fPadCenterX + fBottomSetting - fPkgWidth
                             fPadCenterY - fPadWidth,
                             fPkgStartX + fBottomSetting,//fPadCenterX + fBottomSetting - fPkgWidth
                             fPadCenterY + fPadWidth);
                    else if (m_intPadROIDirection == 4)
                        g.DrawLine(new Pen(objColor, 2),
                           fPkgStartX - fBottomSetting + fPkgWidth,//fPadCenterX - fBottomSetting + fPkgWidth
                           fPadCenterY - fPadWidth,
                           fPkgStartX - fBottomSetting + fPkgWidth,//fPadCenterX - fBottomSetting + fPkgWidth
                           fPadCenterY + fPadWidth);

                }
            }
            // refer Left
            if (((BlobsFeatures)m_arrTemplateBlobPads[intBlobIndex]).intReferLeftRight == 0)
            {
                if (((BlobsFeatures)m_arrTemplateBlobPads[intBlobIndex]).blnCheckLeft)
                {
                    if (m_intPadROIDirection == 1 || m_intPadROIDirection == 0)
                        g.DrawLine(new Pen(objColor, 2),
                              fPkgStartX + fLeftSetting,
                              fPadCenterY - fPadLength,//+ fPkgHeight
                              fPkgStartX + fLeftSetting,
                              fPadCenterY + fPadLength );//+ fPkgHeight
                    else if (m_intPadROIDirection == 3)
                        g.DrawLine(new Pen(objColor, 2),
                              fPkgStartX - fLeftSetting + fPkgWidth,
                              fPadCenterY - fPadLength,//- fPkgHeight
                              fPkgStartX - fLeftSetting + fPkgWidth,
                              fPadCenterY + fPadLength );//- fPkgHeight
                    else if (m_intPadROIDirection == 2)
                        g.DrawLine(new Pen(objColor, 2),
                              fPadCenterX - fPadWidth,//fPadCenterX - fPadLength - fPkgWidth
                              fPkgStartY + fLeftSetting,//fPadCenterY
                              fPadCenterX + fPadWidth,//fPadCenterX + fPadLength - fPkgWidth
                              fPkgStartY + fLeftSetting);//fPadCenterY
                    else if (m_intPadROIDirection == 4)
                        g.DrawLine(new Pen(objColor, 2),
                              fPadCenterX - fPadWidth,//fPadCenterX - fPadLength + fPkgWidth
                              fPkgStartY - fLeftSetting + fPkgHeight,//fPadCenterY
                              fPadCenterX + fPadWidth,//fPadCenterX + fPadLength + fPkgWidth
                              fPkgStartY - fLeftSetting + fPkgHeight);//fPadCenterY

                }

                if (((BlobsFeatures)m_arrTemplateBlobPads[intBlobIndex]).blnCheckRight)
                {
                    if (m_intPadROIDirection == 1 || m_intPadROIDirection == 0)
                        g.DrawLine(new Pen(objColor, 2),
                           fPkgStartX + fRightSetting,
                           fPadCenterY - fPadLength,//+ fPkgHeight
                           fPkgStartX + fRightSetting,
                           fPadCenterY + fPadLength );//+ fPkgHeight
                    else if (m_intPadROIDirection == 3)
                        g.DrawLine(new Pen(objColor, 2),
                          fPkgStartX - fRightSetting + fPkgWidth,
                          fPadCenterY - fPadLength,//- fPkgHeight
                          fPkgStartX - fRightSetting + fPkgWidth,
                          fPadCenterY + fPadLength );//- fPkgHeight
                    else if (m_intPadROIDirection == 2)
                        g.DrawLine(new Pen(objColor, 2),
                          fPadCenterX - fPadWidth,//fPadCenterX - fPadLength - fPkgWidth
                          fPkgStartY + fRightSetting,//fPadCenterY
                          fPadCenterX + fPadWidth,//fPadCenterX + fPadLength - fPkgWidth
                          fPkgStartY + fRightSetting);//fPadCenterY
                    else if (m_intPadROIDirection == 4)
                        g.DrawLine(new Pen(objColor, 2),
                          fPadCenterX - fPadWidth,//fPadCenterX - fPadLength + fPkgWidth
                          fPkgStartY - fRightSetting + fPkgHeight,//fPadCenterY
                          fPadCenterX + fPadWidth,//fPadCenterX + fPadLength + fPkgWidth
                          fPkgStartY - fRightSetting + fPkgHeight);//fPadCenterY
                }
            }
            else // refer Right
            {
                if (((BlobsFeatures)m_arrTemplateBlobPads[intBlobIndex]).blnCheckLeft)
                {

                    if (m_intPadROIDirection == 1 || m_intPadROIDirection == 0)
                        g.DrawLine(new Pen(objColor, 2),
                                  fPkgStartX - fLeftSetting + fPkgWidth,
                                  fPadCenterY - fPadLength,
                                  fPkgStartX - fLeftSetting + fPkgWidth,
                                  fPadCenterY + fPadLength);
                    else if (m_intPadROIDirection == 3)
                        g.DrawLine(new Pen(objColor, 2),
                              fPkgStartX + fLeftSetting,
                              fPadCenterY - fPadLength,
                              fPkgStartX + fLeftSetting,
                              fPadCenterY + fPadLength);
                    else if (m_intPadROIDirection == 2)
                        g.DrawLine(new Pen(objColor, 2),
                              fPadCenterX - fPadLength,
                              fPkgStartY - fLeftSetting + fPkgHeight,//fPadCenterY + fLeftSetting
                              fPadCenterX + fPadLength,
                              fPkgStartY - fLeftSetting + fPkgHeight);//fPadCenterY + fLeftSetting
                    else if (m_intPadROIDirection == 4)
                        g.DrawLine(new Pen(objColor, 2),
                              fPadCenterX - fPadLength,
                              fPkgStartY + fLeftSetting,//fPadCenterY + fLeftSetting
                              fPadCenterX + fPadLength,
                              fPkgStartY + fLeftSetting);//fPadCenterY + fLeftSetting
                }

                if (((BlobsFeatures)m_arrTemplateBlobPads[intBlobIndex]).blnCheckRight)
                {
                    if (m_intPadROIDirection == 1 || m_intPadROIDirection == 0)
                        g.DrawLine(new Pen(objColor, 2),
                               fPkgStartX - fRightSetting + fPkgWidth,
                               fPadCenterY - fPadLength,
                               fPkgStartX - fRightSetting + fPkgWidth,
                               fPadCenterY + fPadLength);
                    else if (m_intPadROIDirection == 3)
                        g.DrawLine(new Pen(objColor, 2),
                          fPkgStartX + fRightSetting,
                          fPadCenterY - fPadLength,
                          fPkgStartX + fRightSetting,
                          fPadCenterY + fPadLength);
                    else if (m_intPadROIDirection == 2)
                        g.DrawLine(new Pen(objColor, 2),
                          fPadCenterX - fPadLength,
                          fPkgStartY - fRightSetting + fPkgHeight,//fPadCenterY + fRightSetting
                          fPadCenterX + fPadLength,
                          fPkgStartY - fRightSetting + fPkgHeight);//fPadCenterY + fRightSetting
                    else if (m_intPadROIDirection == 4)
                        g.DrawLine(new Pen(objColor, 2),
                          fPadCenterX - fPadLength,
                          fPkgStartY + fRightSetting,//fPadCenterY + fRightSetting
                          fPadCenterX + fPadLength,
                          fPkgStartY + fRightSetting);//fPadCenterY + fRightSetting
                }
            }
        }
        public void DrawPadStandOffTolerance_Group(Graphics g, float fDrawingScaleX, float fDrawingScaleY, float fPkgStartX, float fPkgStartY, float fPkgWidth, float fPkgHeight, int intBlobIndex, ROI objPadROI, Color objColor)
        {
            if (intBlobIndex < 0)
                return;

            for (int i = 0; i < m_arrTemplateBlobPads.Count; i++)
            {
                //if (m_arrTemplateBlobPads.Count <= intBlobIndex)
                //    return;

                if (((BlobsFeatures)m_arrTemplateBlobPads[i]).intGroupID != intBlobIndex)
                {
                    continue;
                }

                float fTopSetting = ((BlobsFeatures)m_arrGroupTemplateBlobPads[intBlobIndex]).fMaxStandOffTop / m_fMMPerPixelY * fDrawingScaleY;
                float fBottomSetting = ((BlobsFeatures)m_arrGroupTemplateBlobPads[intBlobIndex]).fMaxStandOffBottom / m_fMMPerPixelY * fDrawingScaleY;
                float fLeftSetting = ((BlobsFeatures)m_arrGroupTemplateBlobPads[intBlobIndex]).fMaxStandOffLeft / m_fMMPerPixelX * fDrawingScaleX;
                float fRightSetting = ((BlobsFeatures)m_arrGroupTemplateBlobPads[intBlobIndex]).fMaxStandOffRight / m_fMMPerPixelX * fDrawingScaleX;

                float fPadCenterX = (objPadROI.ref_ROITotalX + m_arrSampleBlobPads[i].fCenterX) * fDrawingScaleX;
                float fPadCenterY = (objPadROI.ref_ROITotalY + m_arrSampleBlobPads[i].fCenterY) * fDrawingScaleY;
                float fPadWidth = (m_arrSampleBlobPads[i].fWidth / 2) * fDrawingScaleX;
                float fPadLength = (m_arrSampleBlobPads[i].fHeight / 2) * fDrawingScaleY;

                //refer Top
                if (((BlobsFeatures)m_arrTemplateBlobPads[i]).intReferTopBottom == 0)
                {
                    if (((BlobsFeatures)m_arrTemplateBlobPads[i]).blnCheckTop)
                    {
                        if (m_intPadROIDirection == 1 || m_intPadROIDirection == 0)
                            g.DrawLine(new Pen(objColor, 2),
                                fPadCenterX - fPadWidth,
                                fPkgStartY + fTopSetting,
                                fPadCenterX + fPadWidth,
                                fPkgStartY + fTopSetting);
                        else if (m_intPadROIDirection == 3)
                            g.DrawLine(new Pen(objColor, 2),
                               fPadCenterX - fPadWidth,
                               fPkgStartY - fTopSetting + fPkgHeight,//+ fTopSetting
                               fPadCenterX + fPadWidth,
                               fPkgStartY - fTopSetting + fPkgHeight);//+ fTopSetting
                        else if (m_intPadROIDirection == 2)
                            g.DrawLine(new Pen(objColor, 2),
                                 fPkgStartX - fTopSetting + fPkgWidth,//fPadCenterX + fTopSetting - fPadLength
                                 fPadCenterY - fPadWidth,
                                 fPkgStartX - fTopSetting + fPkgWidth,//fPadCenterX + fTopSetting - fPadLength
                                 fPadCenterY + fPadWidth);
                        else if (m_intPadROIDirection == 4)
                            g.DrawLine(new Pen(objColor, 2),
                               fPkgStartX + fTopSetting,//fPadCenterX + fTopSetting - fPadLength
                               fPadCenterY - fPadWidth,
                               fPkgStartX + fTopSetting,//fPadCenterX + fTopSetting - fPadLength
                               fPadCenterY + fPadWidth);
                    }

                    if (((BlobsFeatures)m_arrTemplateBlobPads[i]).blnCheckBottom)
                    {
                        if (m_intPadROIDirection == 1 || m_intPadROIDirection == 0)
                            g.DrawLine(new Pen(objColor, 2),
                                 fPadCenterX - fPadWidth,
                                 fPkgStartY + fBottomSetting,
                                 fPadCenterX + fPadWidth,
                                 fPkgStartY + fBottomSetting);
                        else if (m_intPadROIDirection == 3)
                            g.DrawLine(new Pen(objColor, 2),
                               fPadCenterX - fPadWidth,
                               fPkgStartY - fBottomSetting + fPkgHeight,//+ fBottomSetting
                               fPadCenterX + fPadWidth,
                               fPkgStartY - fBottomSetting + fPkgHeight);//+ fBottomSetting
                        else if (m_intPadROIDirection == 2)
                            g.DrawLine(new Pen(objColor, 2),
                                 fPkgStartX - fBottomSetting + fPkgWidth,//fPadCenterX + fBottomSetting - fPadLength
                                 fPadCenterY - fPadWidth,
                                 fPkgStartX - fBottomSetting + fPkgWidth,//fPadCenterX + fBottomSetting - fPadLength
                                 fPadCenterY + fPadWidth);
                        else if (m_intPadROIDirection == 4)
                            g.DrawLine(new Pen(objColor, 2),
                               fPkgStartX + fBottomSetting,//fPadCenterX + fBottomSetting - fPadLength
                               fPadCenterY - fPadWidth,
                               fPkgStartX + fBottomSetting,//fPadCenterX + fBottomSetting - fPadLength
                               fPadCenterY + fPadWidth);
                    }

                }
                else // refer Bottom
                {
                    if (((BlobsFeatures)m_arrTemplateBlobPads[i]).blnCheckTop)
                    {
                        if (m_intPadROIDirection == 1 || m_intPadROIDirection == 0)
                            g.DrawLine(new Pen(objColor, 2),
                                fPadCenterX - fPadWidth,
                                fPkgStartY + fPkgHeight - fTopSetting,
                                fPadCenterX + fPadWidth,
                                fPkgStartY + fPkgHeight - fTopSetting);
                        else if (m_intPadROIDirection == 3)
                            g.DrawLine(new Pen(objColor, 2),
                           fPadCenterX - fPadWidth,
                           fPkgStartY + fTopSetting,
                           fPadCenterX + fPadWidth,
                           fPkgStartY + fTopSetting);
                        else if (m_intPadROIDirection == 2)
                            g.DrawLine(new Pen(objColor, 2),
                                 fPkgStartX + fTopSetting,//fPadCenterX + fTopSetting - fPkgWidth
                                 fPadCenterY - fPadWidth,
                                 fPkgStartX + fTopSetting,//fPadCenterX + fTopSetting - fPkgWidth
                                 fPadCenterY + fPadWidth);
                        else if (m_intPadROIDirection == 4)
                            g.DrawLine(new Pen(objColor, 2),
                               fPkgStartX - fTopSetting + fPkgWidth,//fPadCenterX - fTopSetting + fPkgWidth
                               fPadCenterY - fPadWidth,
                               fPkgStartX - fTopSetting + fPkgWidth,//fPadCenterX - fTopSetting + fPkgWidth
                               fPadCenterY + fPadWidth);

                    }

                    if (((BlobsFeatures)m_arrTemplateBlobPads[i]).blnCheckBottom)
                    {
                        if (m_intPadROIDirection == 1 || m_intPadROIDirection == 0)
                            g.DrawLine(new Pen(objColor, 2),
                                 fPadCenterX - fPadWidth,
                                 fPkgStartY + fPkgHeight - fBottomSetting,
                                 fPadCenterX + fPadWidth,
                                 fPkgStartY + fPkgHeight - fBottomSetting);
                        else if (m_intPadROIDirection == 3)
                            g.DrawLine(new Pen(objColor, 2),
                               fPadCenterX - fPadWidth,
                               fPkgStartY + fBottomSetting,
                               fPadCenterX + fPadWidth,
                               fPkgStartY + fBottomSetting);
                        else if (m_intPadROIDirection == 2)
                            g.DrawLine(new Pen(objColor, 2),
                                 fPkgStartX + fBottomSetting,//fPadCenterX + fBottomSetting - fPkgWidth
                                 fPadCenterY - fPadWidth,
                                 fPkgStartX + fBottomSetting,//fPadCenterX + fBottomSetting - fPkgWidth
                                 fPadCenterY + fPadWidth);
                        else if (m_intPadROIDirection == 4)
                            g.DrawLine(new Pen(objColor, 2),
                               fPkgStartX - fBottomSetting + fPkgWidth,//fPadCenterX - fBottomSetting + fPkgWidth
                               fPadCenterY - fPadWidth,
                               fPkgStartX - fBottomSetting + fPkgWidth,//fPadCenterX - fBottomSetting + fPkgWidth
                               fPadCenterY + fPadWidth);

                    }
                }
                // refer Left
                if (((BlobsFeatures)m_arrTemplateBlobPads[i]).intReferLeftRight == 0)
                {
                    if (((BlobsFeatures)m_arrTemplateBlobPads[i]).blnCheckLeft)
                    {
                        if (m_intPadROIDirection == 1 || m_intPadROIDirection == 0)
                            g.DrawLine(new Pen(objColor, 2),
                                  fPkgStartX + fLeftSetting,
                                  fPadCenterY - fPadLength,//+ fPkgHeight
                                  fPkgStartX + fLeftSetting,
                                  fPadCenterY + fPadLength);//+ fPkgHeight
                        else if (m_intPadROIDirection == 3)
                            g.DrawLine(new Pen(objColor, 2),
                                  fPkgStartX - fLeftSetting + fPkgWidth,
                                  fPadCenterY - fPadLength,//- fPkgHeight
                                  fPkgStartX - fLeftSetting + fPkgWidth,
                                  fPadCenterY + fPadLength);//- fPkgHeight
                        else if (m_intPadROIDirection == 2)
                            g.DrawLine(new Pen(objColor, 2),
                                  fPadCenterX - fPadWidth,//fPadCenterX - fPadLength - fPkgWidth
                                  fPkgStartY + fLeftSetting,//fPadCenterY
                                  fPadCenterX + fPadWidth,//fPadCenterX + fPadLength - fPkgWidth
                                  fPkgStartY + fLeftSetting);//fPadCenterY
                        else if (m_intPadROIDirection == 4)
                            g.DrawLine(new Pen(objColor, 2),
                                  fPadCenterX - fPadWidth,//fPadCenterX - fPadLength + fPkgWidth
                                  fPkgStartY - fLeftSetting + fPkgHeight,//fPadCenterY
                                  fPadCenterX + fPadWidth,//fPadCenterX + fPadLength + fPkgWidth
                                  fPkgStartY - fLeftSetting + fPkgHeight);//fPadCenterY

                    }

                    if (((BlobsFeatures)m_arrTemplateBlobPads[i]).blnCheckRight)
                    {
                        if (m_intPadROIDirection == 1 || m_intPadROIDirection == 0)
                            g.DrawLine(new Pen(objColor, 2),
                               fPkgStartX + fRightSetting,
                               fPadCenterY - fPadLength,//+ fPkgHeight
                               fPkgStartX + fRightSetting,
                               fPadCenterY + fPadLength);//+ fPkgHeight
                        else if (m_intPadROIDirection == 3)
                            g.DrawLine(new Pen(objColor, 2),
                              fPkgStartX - fRightSetting + fPkgWidth,
                              fPadCenterY - fPadLength,//- fPkgHeight
                              fPkgStartX - fRightSetting + fPkgWidth,
                              fPadCenterY + fPadLength);//- fPkgHeight
                        else if (m_intPadROIDirection == 2)
                            g.DrawLine(new Pen(objColor, 2),
                              fPadCenterX - fPadWidth,//fPadCenterX - fPadLength - fPkgWidth
                              fPkgStartY + fRightSetting,//fPadCenterY
                              fPadCenterX + fPadWidth,//fPadCenterX + fPadLength - fPkgWidth
                              fPkgStartY + fRightSetting);//fPadCenterY
                        else if (m_intPadROIDirection == 4)
                            g.DrawLine(new Pen(objColor, 2),
                              fPadCenterX - fPadWidth,//fPadCenterX - fPadLength + fPkgWidth
                              fPkgStartY - fRightSetting + fPkgHeight,//fPadCenterY
                              fPadCenterX + fPadWidth,//fPadCenterX + fPadLength + fPkgWidth
                              fPkgStartY - fRightSetting + fPkgHeight);//fPadCenterY
                    }
                }
                else // refer Right
                {
                    if (((BlobsFeatures)m_arrTemplateBlobPads[i]).blnCheckLeft)
                    {

                        if (m_intPadROIDirection == 1 || m_intPadROIDirection == 0)
                            g.DrawLine(new Pen(objColor, 2),
                                      fPkgStartX - fLeftSetting + fPkgWidth,
                                      fPadCenterY - fPadLength,
                                      fPkgStartX - fLeftSetting + fPkgWidth,
                                      fPadCenterY + fPadLength);
                        else if (m_intPadROIDirection == 3)
                            g.DrawLine(new Pen(objColor, 2),
                                  fPkgStartX + fLeftSetting,
                                  fPadCenterY - fPadLength,
                                  fPkgStartX + fLeftSetting,
                                  fPadCenterY + fPadLength);
                        else if (m_intPadROIDirection == 2)
                            g.DrawLine(new Pen(objColor, 2),
                                  fPadCenterX - fPadLength,
                                  fPkgStartY - fLeftSetting + fPkgHeight,//fPadCenterY + fLeftSetting
                                  fPadCenterX + fPadLength,
                                  fPkgStartY - fLeftSetting + fPkgHeight);//fPadCenterY + fLeftSetting
                        else if (m_intPadROIDirection == 4)
                            g.DrawLine(new Pen(objColor, 2),
                                  fPadCenterX - fPadLength,
                                  fPkgStartY + fLeftSetting,//fPadCenterY + fLeftSetting
                                  fPadCenterX + fPadLength,
                                  fPkgStartY + fLeftSetting);//fPadCenterY + fLeftSetting
                    }

                    if (((BlobsFeatures)m_arrTemplateBlobPads[i]).blnCheckRight)
                    {
                        if (m_intPadROIDirection == 1 || m_intPadROIDirection == 0)
                            g.DrawLine(new Pen(objColor, 2),
                                   fPkgStartX - fRightSetting + fPkgWidth,
                                   fPadCenterY - fPadLength,
                                   fPkgStartX - fRightSetting + fPkgWidth,
                                   fPadCenterY + fPadLength);
                        else if (m_intPadROIDirection == 3)
                            g.DrawLine(new Pen(objColor, 2),
                              fPkgStartX + fRightSetting,
                              fPadCenterY - fPadLength,
                              fPkgStartX + fRightSetting,
                              fPadCenterY + fPadLength);
                        else if (m_intPadROIDirection == 2)
                            g.DrawLine(new Pen(objColor, 2),
                              fPadCenterX - fPadLength,
                              fPkgStartY - fRightSetting + fPkgHeight,//fPadCenterY + fRightSetting
                              fPadCenterX + fPadLength,
                              fPkgStartY - fRightSetting + fPkgHeight);//fPadCenterY + fRightSetting
                        else if (m_intPadROIDirection == 4)
                            g.DrawLine(new Pen(objColor, 2),
                              fPadCenterX - fPadLength,
                              fPkgStartY + fRightSetting,//fPadCenterY + fRightSetting
                              fPadCenterX + fPadLength,
                              fPkgStartY + fRightSetting);//fPadCenterY + fRightSetting
                    }
                }
            }
        }
        /// <summary>
        /// Draw template objects
        /// </summary>
        /// <param name="g">destination image to be drawn</param>
        /// <param name="intRoiOrgX">ROI origin X</param>
        /// <param name="intRoiOrgY">ROI origin Y</param>
        /// <param name="fScale"></param>
        /// <param name="intZoomImageEdgeX">translation factor for panning in the horizontal direction</param>
        /// <param name="intZoomImageEdgeY">translation factor for panning in the vertical direction</param>
        public void DrawTemplateObjects(Graphics g, float fDrawingScaleX, float fDrawingScaleY, int intRoiOrgX, int intRoiOrgY, Color[] arrColor)
        {

            for (int i = 0; i < m_arrTemplateBlobPads.Count; i++)
            {

                BlobsFeatures m_stcBlobPad = (BlobsFeatures)m_arrTemplateBlobPads[i];

                System.Drawing.Point p1 = new System.Drawing.Point(intRoiOrgX + (int)Math.Round(m_stcBlobPad.fLimitCenterX - m_stcBlobPad.fWidth / 2), intRoiOrgY + (int)Math.Round(m_stcBlobPad.fLimitCenterY - m_stcBlobPad.fHeight / 2));
                System.Drawing.Point p2 = new System.Drawing.Point(intRoiOrgX + (int)Math.Round(m_stcBlobPad.fLimitCenterX + m_stcBlobPad.fWidth / 2), intRoiOrgY + (int)Math.Round(m_stcBlobPad.fLimitCenterY - m_stcBlobPad.fHeight / 2));
                System.Drawing.Point p3 = new System.Drawing.Point(intRoiOrgX + (int)Math.Round(m_stcBlobPad.fLimitCenterX - m_stcBlobPad.fWidth / 2), intRoiOrgY + (int)Math.Round(m_stcBlobPad.fLimitCenterY + m_stcBlobPad.fHeight / 2));
                System.Drawing.Point p4 = new System.Drawing.Point(intRoiOrgX + (int)Math.Round(m_stcBlobPad.fLimitCenterX + m_stcBlobPad.fWidth / 2), intRoiOrgY + (int)Math.Round(m_stcBlobPad.fLimitCenterY + m_stcBlobPad.fHeight / 2));

                float Angle = m_stcBlobPad.fFeretAngle;

                if (m_stcBlobPad.blnFeretActivated)
                {
                    p1 = new System.Drawing.Point(intRoiOrgX + (int)Math.Round(m_stcBlobPad.fFeretCenterX - m_stcBlobPad.fFeretWidth / 2), intRoiOrgY + (int)Math.Round(m_stcBlobPad.fFeretCenterY - m_stcBlobPad.fFeretHeight / 2));
                    p2 = new System.Drawing.Point(intRoiOrgX + (int)Math.Round(m_stcBlobPad.fFeretCenterX + m_stcBlobPad.fFeretWidth / 2), intRoiOrgY + (int)Math.Round(m_stcBlobPad.fFeretCenterY - m_stcBlobPad.fFeretHeight / 2));
                    p3 = new System.Drawing.Point(intRoiOrgX + (int)Math.Round(m_stcBlobPad.fFeretCenterX - m_stcBlobPad.fFeretWidth / 2), intRoiOrgY + (int)Math.Round(m_stcBlobPad.fFeretCenterY + m_stcBlobPad.fFeretHeight / 2));
                    p4 = new System.Drawing.Point(intRoiOrgX + (int)Math.Round(m_stcBlobPad.fFeretCenterX + m_stcBlobPad.fFeretWidth / 2), intRoiOrgY + (int)Math.Round(m_stcBlobPad.fFeretCenterY + m_stcBlobPad.fFeretHeight / 2));

                    float newX1 = 0, newY1 = 0;
                    float newX2 = 0, newY2 = 0;
                    float newX3 = 0, newY3 = 0;
                    float newX4 = 0, newY4 = 0;

                    Math2.RotateWithAngleAccordingToReferencePoint(intRoiOrgX + m_stcBlobPad.fFeretCenterX, intRoiOrgY + m_stcBlobPad.fFeretCenterY, (float)p1.X, (float)p1.Y, Angle, ref newX1, ref newY1);
                    Math2.RotateWithAngleAccordingToReferencePoint(intRoiOrgX + m_stcBlobPad.fFeretCenterX, intRoiOrgY + m_stcBlobPad.fFeretCenterY, (float)p3.X, (float)p3.Y, Angle, ref newX3, ref newY3);
                    Math2.RotateWithAngleAccordingToReferencePoint(intRoiOrgX + m_stcBlobPad.fFeretCenterX, intRoiOrgY + m_stcBlobPad.fFeretCenterY, (float)p2.X, (float)p2.Y, Angle, ref newX2, ref newY2);
                    Math2.RotateWithAngleAccordingToReferencePoint(intRoiOrgX + m_stcBlobPad.fFeretCenterX, intRoiOrgY + m_stcBlobPad.fFeretCenterY, (float)p4.X, (float)p4.Y, Angle, ref newX4, ref newY4);
                    p1.X = (int)newX1;
                    p1.Y = (int)newY1;
                    p2.X = (int)newX2;
                    p2.Y = (int)newY2;
                    p3.X = (int)newX3;
                    p3.Y = (int)newY3;
                    p4.X = (int)newX4;
                    p4.Y = (int)newY4;
                }

                m_stcBlobPad.P1X = p1.X;
                m_stcBlobPad.P1Y = p1.Y;
                m_stcBlobPad.P2X = p2.X;
                m_stcBlobPad.P2Y = p2.Y;
                m_stcBlobPad.P3X = p3.X;
                m_stcBlobPad.P3Y = p3.Y;
                m_stcBlobPad.P4X = p4.X;
                m_stcBlobPad.P4Y = p4.Y;
                if (m_stcBlobPad.intLineCount < 2)
                {
                    m_stcBlobPad.intLineCount = 2;
                }

                m_arrTemplateBlobPads.RemoveAt(i);
                m_arrTemplateBlobPads.Insert(i, m_stcBlobPad);


                if (fDrawingScaleX != 1f || fDrawingScaleY != 1f)
                {
                    p1.X = (int)Math.Round((float)p1.X * fDrawingScaleX, 0, MidpointRounding.AwayFromZero);
                    p1.Y = (int)Math.Round((float)p1.Y * fDrawingScaleY, 0, MidpointRounding.AwayFromZero);
                    p2.X = (int)Math.Round((float)p2.X * fDrawingScaleX, 0, MidpointRounding.AwayFromZero);
                    p2.Y = (int)Math.Round((float)p2.Y * fDrawingScaleY, 0, MidpointRounding.AwayFromZero);
                    p3.X = (int)Math.Round((float)p3.X * fDrawingScaleX, 0, MidpointRounding.AwayFromZero);
                    p3.Y = (int)Math.Round((float)p3.Y * fDrawingScaleY, 0, MidpointRounding.AwayFromZero);
                    p4.X = (int)Math.Round((float)p4.X * fDrawingScaleX, 0, MidpointRounding.AwayFromZero);
                    p4.Y = (int)Math.Round((float)p4.Y * fDrawingScaleY, 0, MidpointRounding.AwayFromZero);
                }

                // Draw Square Box
                g.DrawLine(new Pen(arrColor[0], 1), p1, p2);
                g.DrawLine(new Pen(arrColor[0], 1), p2, p4);
                g.DrawLine(new Pen(arrColor[0], 1), p3, p4);
                g.DrawLine(new Pen(arrColor[0], 1), p3, p1);

                if (m_stcBlobPad.blnFeretActivated)
                {
                    if (Angle >= 0 && Angle <= 90)
                    {
                        g.DrawLine(new Pen(Color.Blue, 2),
                            (int)((p1.X + p3.X) / 2) + (int)((Math.Abs(p1.X - p3.X)) * (m_stcBlobPad.fWidthPercentStart1 / 100)) - (int)((Math.Abs(p1.X - p3.X)) * (m_stcBlobPad.fHeightPercentStart1 / 100)),
                            (int)((p1.Y + p3.Y) / 2) + (int)((Math.Abs(p1.Y - p3.Y)) * (m_stcBlobPad.fHeightPercentStart1 / 100)) - (int)((Math.Abs(p1.Y - p3.Y)) * (m_stcBlobPad.fWidthPercentStart1 / 100)),
                            (int)((p2.X + p4.X) / 2) + (int)((Math.Abs(p2.X - p4.X)) * (m_stcBlobPad.fWidthPercentEnd1 / 100)) - (int)((Math.Abs(p2.X - p4.X)) * (m_stcBlobPad.fHeightPercentEnd1 / 100)),
                            (int)((p2.Y + p4.Y) / 2) + (int)((Math.Abs(p2.Y - p4.Y)) * (m_stcBlobPad.fHeightPercentEnd1 / 100)) - (int)((Math.Abs(p2.Y - p4.Y)) * (m_stcBlobPad.fWidthPercentEnd1 / 100)));

                        g.DrawLine(new Pen(Color.Lime, 2),
                            (int)((p1.X + p2.X) / 2) + (int)((Math.Abs(p1.X - p2.X)) * (m_stcBlobPad.fWidthPercentStart2 / 100)) + (int)((Math.Abs(p1.X - p2.X)) * (m_stcBlobPad.fHeightPercentStart2 / 100)),
                            (int)((p1.Y + p2.Y) / 2) + (int)((Math.Abs(p1.Y - p2.Y)) * (m_stcBlobPad.fHeightPercentStart2 / 100)) + (int)((Math.Abs(p1.Y - p2.Y)) * (m_stcBlobPad.fWidthPercentStart2 / 100)),
                            (int)((p3.X + p4.X) / 2) + (int)((Math.Abs(p3.X - p4.X)) * (m_stcBlobPad.fWidthPercentEnd2 / 100)) + (int)((Math.Abs(p3.X - p4.X)) * (m_stcBlobPad.fHeightPercentEnd2 / 100)),
                            (int)((p3.Y + p4.Y) / 2) + (int)((Math.Abs(p3.Y - p4.Y)) * (m_stcBlobPad.fHeightPercentEnd2 / 100)) + (int)((Math.Abs(p3.Y - p4.Y)) * (m_stcBlobPad.fWidthPercentEnd2 / 100)));
                    }
                    else if (Angle > 90)
                    {
                        g.DrawLine(new Pen(Color.Blue, 2),
                            (int)((p1.X + p3.X) / 2) + (int)((Math.Abs(p1.X - p3.X)) * (m_stcBlobPad.fWidthPercentStart1 / 100)) - (int)((Math.Abs(p1.X - p3.X)) * (m_stcBlobPad.fHeightPercentStart1 / 100)),
                            (int)((p1.Y + p3.Y) / 2) - (int)((Math.Abs(p1.Y - p3.Y)) * (m_stcBlobPad.fHeightPercentStart1 / 100)) - (int)((Math.Abs(p1.Y - p3.Y)) * (m_stcBlobPad.fWidthPercentStart1 / 100)),
                            (int)((p2.X + p4.X) / 2) + (int)((Math.Abs(p2.X - p4.X)) * (m_stcBlobPad.fWidthPercentEnd1 / 100)) - (int)((Math.Abs(p2.X - p4.X)) * (m_stcBlobPad.fHeightPercentEnd1 / 100)),
                            (int)((p2.Y + p4.Y) / 2) - (int)((Math.Abs(p2.Y - p4.Y)) * (m_stcBlobPad.fHeightPercentEnd1 / 100)) - (int)((Math.Abs(p2.Y - p4.Y)) * (m_stcBlobPad.fWidthPercentEnd1 / 100)));

                        g.DrawLine(new Pen(Color.Lime, 2),
                            (int)((p1.X + p2.X) / 2) - (int)((Math.Abs(p1.X - p2.X)) * (m_stcBlobPad.fWidthPercentStart2 / 100)) + (int)((Math.Abs(p1.X - p2.X)) * (m_stcBlobPad.fHeightPercentStart2 / 100)),
                            (int)((p1.Y + p2.Y) / 2) + (int)((Math.Abs(p1.Y - p2.Y)) * (m_stcBlobPad.fHeightPercentStart2 / 100)) + (int)((Math.Abs(p1.Y - p2.Y)) * (m_stcBlobPad.fWidthPercentStart2 / 100)),
                            (int)((p3.X + p4.X) / 2) - (int)((Math.Abs(p3.X - p4.X)) * (m_stcBlobPad.fWidthPercentEnd2 / 100)) + (int)((Math.Abs(p3.X - p4.X)) * (m_stcBlobPad.fHeightPercentEnd2 / 100)),
                            (int)((p3.Y + p4.Y) / 2) + (int)((Math.Abs(p3.Y - p4.Y)) * (m_stcBlobPad.fHeightPercentEnd2 / 100)) + (int)((Math.Abs(p3.Y - p4.Y)) * (m_stcBlobPad.fWidthPercentEnd2 / 100)));
                    }
                    else if (Angle < -90)
                    {
                        g.DrawLine(new Pen(Color.Blue, 2),
                            (int)((p1.X + p3.X) / 2) - (int)((Math.Abs(p1.X - p3.X)) * (m_stcBlobPad.fWidthPercentStart1 / 100)) + (int)((Math.Abs(p1.X - p3.X)) * (m_stcBlobPad.fHeightPercentStart1 / 100)),
                            (int)((p1.Y + p3.Y) / 2) + (int)((Math.Abs(p1.Y - p3.Y)) * (m_stcBlobPad.fHeightPercentStart1 / 100)) + (int)((Math.Abs(p1.Y - p3.Y)) * (m_stcBlobPad.fWidthPercentStart1 / 100)),
                            (int)((p2.X + p4.X) / 2) - (int)((Math.Abs(p2.X - p4.X)) * (m_stcBlobPad.fWidthPercentEnd1 / 100)) + (int)((Math.Abs(p2.X - p4.X)) * (m_stcBlobPad.fHeightPercentEnd1 / 100)),
                            (int)((p2.Y + p4.Y) / 2) + (int)((Math.Abs(p2.Y - p4.Y)) * (m_stcBlobPad.fHeightPercentEnd1 / 100)) + (int)((Math.Abs(p2.Y - p4.Y)) * (m_stcBlobPad.fWidthPercentEnd1 / 100)));

                        g.DrawLine(new Pen(Color.Lime, 2),
                            (int)((p1.X + p2.X) / 2) + (int)((Math.Abs(p1.X - p2.X)) * (m_stcBlobPad.fWidthPercentStart2 / 100)) - (int)((Math.Abs(p1.X - p2.X)) * (m_stcBlobPad.fHeightPercentStart2 / 100)),
                            (int)((p1.Y + p2.Y) / 2) - (int)((Math.Abs(p1.Y - p2.Y)) * (m_stcBlobPad.fHeightPercentStart2 / 100)) - (int)((Math.Abs(p1.Y - p2.Y)) * (m_stcBlobPad.fWidthPercentStart2 / 100)),
                            (int)((p3.X + p4.X) / 2) + (int)((Math.Abs(p3.X - p4.X)) * (m_stcBlobPad.fWidthPercentEnd2 / 100)) - (int)((Math.Abs(p3.X - p4.X)) * (m_stcBlobPad.fHeightPercentEnd2 / 100)),
                            (int)((p3.Y + p4.Y) / 2) - (int)((Math.Abs(p3.Y - p4.Y)) * (m_stcBlobPad.fHeightPercentEnd2 / 100)) - (int)((Math.Abs(p3.Y - p4.Y)) * (m_stcBlobPad.fWidthPercentEnd2 / 100)));
                    }
                    else //<=10
                    {
                        g.DrawLine(new Pen(Color.Blue, 2),
                            (int)((p1.X + p3.X) / 2) + (int)((Math.Abs(p1.X - p3.X)) * (m_stcBlobPad.fWidthPercentStart1 / 100)) + (int)((Math.Abs(p1.X - p3.X)) * (m_stcBlobPad.fHeightPercentStart1 / 100)),
                            (int)((p1.Y + p3.Y) / 2) + (int)((Math.Abs(p1.Y - p3.Y)) * (m_stcBlobPad.fHeightPercentStart1 / 100)) + (int)((Math.Abs(p1.Y - p3.Y)) * (m_stcBlobPad.fWidthPercentStart1 / 100)),
                            (int)((p2.X + p4.X) / 2) + (int)((Math.Abs(p2.X - p4.X)) * (m_stcBlobPad.fWidthPercentEnd1 / 100)) + (int)((Math.Abs(p2.X - p4.X)) * (m_stcBlobPad.fHeightPercentEnd1 / 100)),
                            (int)((p2.Y + p4.Y) / 2) + (int)((Math.Abs(p2.Y - p4.Y)) * (m_stcBlobPad.fHeightPercentEnd1 / 100)) + (int)((Math.Abs(p2.Y - p4.Y)) * (m_stcBlobPad.fWidthPercentEnd1 / 100)));

                        g.DrawLine(new Pen(Color.Lime, 2),
                            (int)((p1.X + p2.X) / 2) + (int)((Math.Abs(p1.X - p2.X)) * (m_stcBlobPad.fWidthPercentStart2 / 100)) - (int)((Math.Abs(p1.X - p2.X)) * (m_stcBlobPad.fHeightPercentStart2 / 100)),
                            (int)((p1.Y + p2.Y) / 2) + (int)((Math.Abs(p1.Y - p2.Y)) * (m_stcBlobPad.fHeightPercentStart2 / 100)) - (int)((Math.Abs(p1.Y - p2.Y)) * (m_stcBlobPad.fWidthPercentStart2 / 100)),
                            (int)((p3.X + p4.X) / 2) + (int)((Math.Abs(p3.X - p4.X)) * (m_stcBlobPad.fWidthPercentEnd2 / 100)) - (int)((Math.Abs(p3.X - p4.X)) * (m_stcBlobPad.fHeightPercentEnd2 / 100)),
                            (int)((p3.Y + p4.Y) / 2) + (int)((Math.Abs(p3.Y - p4.Y)) * (m_stcBlobPad.fHeightPercentEnd2 / 100)) - (int)((Math.Abs(p3.Y - p4.Y)) * (m_stcBlobPad.fWidthPercentEnd2 / 100)));
                    }
                    float RotatedX1 = 0;
                    float RotatedX2 = 0;

                    float RotatedY1 = 0;
                    float RotatedY2 = 0;
                    Point OriP1 = new System.Drawing.Point(intRoiOrgX + (int)Math.Round(m_stcBlobPad.fFeretCenterX - m_stcBlobPad.fFeretWidth / 2), intRoiOrgY + (int)Math.Round(m_stcBlobPad.fFeretCenterY - m_stcBlobPad.fFeretHeight / 2));
                    Point OriP2 = new System.Drawing.Point(intRoiOrgX + (int)Math.Round(m_stcBlobPad.fFeretCenterX + m_stcBlobPad.fFeretWidth / 2), intRoiOrgY + (int)Math.Round(m_stcBlobPad.fFeretCenterY - m_stcBlobPad.fFeretHeight / 2));
                    Point OriP3 = new System.Drawing.Point(intRoiOrgX + (int)Math.Round(m_stcBlobPad.fFeretCenterX - m_stcBlobPad.fFeretWidth / 2), intRoiOrgY + (int)Math.Round(m_stcBlobPad.fFeretCenterY + m_stcBlobPad.fFeretHeight / 2));
                    Point OriP4 = new System.Drawing.Point(intRoiOrgX + (int)Math.Round(m_stcBlobPad.fFeretCenterX + m_stcBlobPad.fFeretWidth / 2), intRoiOrgY + (int)Math.Round(m_stcBlobPad.fFeretCenterY + m_stcBlobPad.fFeretHeight / 2));
                    // Draw Extra Dimension Line
                    switch (m_stcBlobPad.intLineCount)
                    {
                        case 3:
                            Math2.RotateWithAngleAccordingToReferencePoint(intRoiOrgX + m_stcBlobPad.fFeretCenterX, intRoiOrgY + m_stcBlobPad.fFeretCenterY,
                                (float)(((OriP1.X + OriP2.X) / 2) + (((Math.Abs(OriP1.X - OriP2.X) / 2) / (m_stcBlobPad.intLineCount - 1))) + (int)((Math.Abs(OriP1.X - OriP2.X)) * (m_stcBlobPad.fWidthPercentStart3 / 100))),
                                (float)(OriP1.Y + ((Math.Abs(OriP1.Y - OriP3.Y) * m_stcBlobPad.fHeightPercentStart3 / 100))), Angle, ref RotatedX1, ref RotatedY1);

                            Math2.RotateWithAngleAccordingToReferencePoint(intRoiOrgX + m_stcBlobPad.fFeretCenterX, intRoiOrgY + m_stcBlobPad.fFeretCenterY,
                                (float)(((OriP3.X + OriP4.X) / 2) + ((Math.Abs(OriP3.X - OriP4.X) / 2) / (m_stcBlobPad.intLineCount - 1)) + (int)((Math.Abs(OriP3.X - OriP4.X)) * (m_stcBlobPad.fWidthPercentEnd3 / 100))),
                                (float)(OriP3.Y + ((Math.Abs(OriP1.Y - OriP3.Y) * m_stcBlobPad.fHeightPercentEnd3 / 100))), Angle, ref RotatedX2, ref RotatedY2);

                            g.DrawLine(new Pen(Color.Red, 2),
                                 (int)RotatedX1 * fDrawingScaleX,
                                 (int)RotatedY1 * fDrawingScaleY,
                                 (int)RotatedX2 * fDrawingScaleX,
                                 (int)RotatedY2 * fDrawingScaleY);

                            break;
                        case 4:
                            Math2.RotateWithAngleAccordingToReferencePoint(intRoiOrgX + m_stcBlobPad.fFeretCenterX, intRoiOrgY + m_stcBlobPad.fFeretCenterY,
                               (float)(((OriP1.X + OriP2.X) / 2) + (((Math.Abs(OriP1.X - OriP2.X) / 2) / (m_stcBlobPad.intLineCount - 2))) + (int)((Math.Abs(OriP1.X - OriP2.X)) * (m_stcBlobPad.fWidthPercentStart3 / 100))),
                               (float)(OriP1.Y + ((Math.Abs(OriP1.Y - OriP3.Y) * m_stcBlobPad.fHeightPercentStart3 / 100))), Angle, ref RotatedX1, ref RotatedY1);

                            Math2.RotateWithAngleAccordingToReferencePoint(intRoiOrgX + m_stcBlobPad.fFeretCenterX, intRoiOrgY + m_stcBlobPad.fFeretCenterY,
                                (float)(((OriP3.X + OriP4.X) / 2) + ((Math.Abs(OriP3.X - OriP4.X) / 2) / (m_stcBlobPad.intLineCount - 2)) + (int)((Math.Abs(OriP3.X - OriP4.X)) * (m_stcBlobPad.fWidthPercentEnd3 / 100))),
                                (float)(OriP3.Y + ((Math.Abs(OriP1.Y - OriP3.Y) * m_stcBlobPad.fHeightPercentEnd3 / 100))), Angle, ref RotatedX2, ref RotatedY2);

                            g.DrawLine(new Pen(Color.Red, 2),
                                 (int)RotatedX1 * fDrawingScaleX,
                                 (int)RotatedY1 * fDrawingScaleY,
                                 (int)RotatedX2 * fDrawingScaleX,
                                 (int)RotatedY2 * fDrawingScaleY);

                            Math2.RotateWithAngleAccordingToReferencePoint(intRoiOrgX + m_stcBlobPad.fFeretCenterX, intRoiOrgY + m_stcBlobPad.fFeretCenterY,
                             (float)(((OriP1.X + OriP2.X) / 2) + (((Math.Abs(OriP1.X - OriP2.X) / 2) / (m_stcBlobPad.intLineCount - 1))) + (int)((Math.Abs(OriP1.X - OriP2.X)) * (m_stcBlobPad.fWidthPercentStart4 / 100))),
                             (float)(OriP1.Y + ((Math.Abs(OriP1.Y - OriP3.Y) * m_stcBlobPad.fHeightPercentStart4 / 100))), Angle, ref RotatedX1, ref RotatedY1);

                            Math2.RotateWithAngleAccordingToReferencePoint(intRoiOrgX + m_stcBlobPad.fFeretCenterX, intRoiOrgY + m_stcBlobPad.fFeretCenterY,
                                (float)(((OriP3.X + OriP4.X) / 2) + ((Math.Abs(OriP3.X - OriP4.X) / 2) / (m_stcBlobPad.intLineCount - 1)) + (int)((Math.Abs(OriP3.X - OriP4.X)) * (m_stcBlobPad.fWidthPercentEnd4 / 100))),
                                (float)(OriP3.Y + ((Math.Abs(OriP1.Y - OriP3.Y) * m_stcBlobPad.fHeightPercentEnd4 / 100))), Angle, ref RotatedX2, ref RotatedY2);

                            g.DrawLine(new Pen(Color.Yellow, 2),
                                 (int)RotatedX1 * fDrawingScaleX,
                                 (int)RotatedY1 * fDrawingScaleY,
                                 (int)RotatedX2 * fDrawingScaleX,
                                 (int)RotatedY2 * fDrawingScaleY);

                            break;
                        case 5:
                            Math2.RotateWithAngleAccordingToReferencePoint(intRoiOrgX + m_stcBlobPad.fFeretCenterX, intRoiOrgY + m_stcBlobPad.fFeretCenterY,
                            (float)(((OriP1.X + OriP2.X) / 2) + (((Math.Abs(OriP1.X - OriP2.X) / 2) / (m_stcBlobPad.intLineCount - 3))) + (int)((Math.Abs(OriP1.X - OriP2.X)) * (m_stcBlobPad.fWidthPercentStart3 / 100))),
                            (float)(OriP1.Y + ((Math.Abs(OriP1.Y - OriP3.Y) * m_stcBlobPad.fHeightPercentStart3 / 100))), Angle, ref RotatedX1, ref RotatedY1);

                            Math2.RotateWithAngleAccordingToReferencePoint(intRoiOrgX + m_stcBlobPad.fFeretCenterX, intRoiOrgY + m_stcBlobPad.fFeretCenterY,
                                (float)(((OriP3.X + OriP4.X) / 2) + ((Math.Abs(OriP3.X - OriP4.X) / 2) / (m_stcBlobPad.intLineCount - 3)) + (int)((Math.Abs(OriP3.X - OriP4.X)) * (m_stcBlobPad.fWidthPercentEnd3 / 100))),
                                (float)(OriP3.Y + ((Math.Abs(OriP1.Y - OriP3.Y) * m_stcBlobPad.fHeightPercentEnd3 / 100))), Angle, ref RotatedX2, ref RotatedY2);

                            g.DrawLine(new Pen(Color.Red, 2),
                                 (int)RotatedX1 * fDrawingScaleX,
                                 (int)RotatedY1 * fDrawingScaleY,
                                 (int)RotatedX2 * fDrawingScaleX,
                                 (int)RotatedY2 * fDrawingScaleY);

                            Math2.RotateWithAngleAccordingToReferencePoint(intRoiOrgX + m_stcBlobPad.fFeretCenterX, intRoiOrgY + m_stcBlobPad.fFeretCenterY,
                             (float)(((OriP1.X + OriP2.X) / 2) + (((Math.Abs(OriP1.X - OriP2.X) / 2) / (m_stcBlobPad.intLineCount - 2))) + (int)((Math.Abs(OriP1.X - OriP2.X)) * (m_stcBlobPad.fWidthPercentStart4 / 100))),
                             (float)(OriP1.Y + ((Math.Abs(OriP1.Y - OriP3.Y) * m_stcBlobPad.fHeightPercentStart4 / 100))), Angle, ref RotatedX1, ref RotatedY1);

                            Math2.RotateWithAngleAccordingToReferencePoint(intRoiOrgX + m_stcBlobPad.fFeretCenterX, intRoiOrgY + m_stcBlobPad.fFeretCenterY,
                                (float)(((OriP3.X + OriP4.X) / 2) + ((Math.Abs(OriP3.X - OriP4.X) / 2) / (m_stcBlobPad.intLineCount - 2)) + (int)((Math.Abs(OriP3.X - OriP4.X)) * (m_stcBlobPad.fWidthPercentEnd4 / 100))),
                                (float)(OriP3.Y + ((Math.Abs(OriP1.Y - OriP3.Y) * m_stcBlobPad.fHeightPercentEnd4 / 100))), Angle, ref RotatedX2, ref RotatedY2);

                            g.DrawLine(new Pen(Color.Yellow, 2),
                                 (int)RotatedX1 * fDrawingScaleX,
                                 (int)RotatedY1 * fDrawingScaleY,
                                 (int)RotatedX2 * fDrawingScaleX,
                                 (int)RotatedY2 * fDrawingScaleY);

                            Math2.RotateWithAngleAccordingToReferencePoint(intRoiOrgX + m_stcBlobPad.fFeretCenterX, intRoiOrgY + m_stcBlobPad.fFeretCenterY,
                            (float)(((OriP1.X + OriP2.X) / 2) + (((Math.Abs(OriP1.X - OriP2.X) / 2) / (m_stcBlobPad.intLineCount - 1))) + (int)((Math.Abs(OriP1.X - OriP2.X)) * (m_stcBlobPad.fWidthPercentStart5 / 100))),
                            (float)(OriP1.Y + ((Math.Abs(OriP1.Y - OriP3.Y) * m_stcBlobPad.fHeightPercentStart5 / 100))), Angle, ref RotatedX1, ref RotatedY1);

                            Math2.RotateWithAngleAccordingToReferencePoint(intRoiOrgX + m_stcBlobPad.fFeretCenterX, intRoiOrgY + m_stcBlobPad.fFeretCenterY,
                                (float)(((OriP3.X + OriP4.X) / 2) + ((Math.Abs(OriP3.X - OriP4.X) / 2) / (m_stcBlobPad.intLineCount - 1)) + (int)((Math.Abs(OriP3.X - OriP4.X)) * (m_stcBlobPad.fWidthPercentEnd5 / 100))),
                                (float)(OriP3.Y + ((Math.Abs(OriP1.Y - OriP3.Y) * m_stcBlobPad.fHeightPercentEnd5 / 100))), Angle, ref RotatedX2, ref RotatedY2);

                            g.DrawLine(new Pen(Color.Pink, 2),
                                 (int)RotatedX1 * fDrawingScaleX,
                                 (int)RotatedY1 * fDrawingScaleY,
                                 (int)RotatedX2 * fDrawingScaleX,
                                 (int)RotatedY2 * fDrawingScaleY);

                            break;
                        case 6:
                            Math2.RotateWithAngleAccordingToReferencePoint(intRoiOrgX + m_stcBlobPad.fFeretCenterX, intRoiOrgY + m_stcBlobPad.fFeretCenterY,
                           (float)(((OriP1.X + OriP2.X) / 2) + (((Math.Abs(OriP1.X - OriP2.X) / 2) / (m_stcBlobPad.intLineCount - 4))) + (int)((Math.Abs(OriP1.X - OriP2.X)) * (m_stcBlobPad.fWidthPercentStart3 / 100))),
                           (float)(OriP1.Y + ((Math.Abs(OriP1.Y - OriP3.Y) * m_stcBlobPad.fHeightPercentStart3 / 100))), Angle, ref RotatedX1, ref RotatedY1);

                            Math2.RotateWithAngleAccordingToReferencePoint(intRoiOrgX + m_stcBlobPad.fFeretCenterX, intRoiOrgY + m_stcBlobPad.fFeretCenterY,
                                (float)(((OriP3.X + OriP4.X) / 2) + ((Math.Abs(OriP3.X - OriP4.X) / 2) / (m_stcBlobPad.intLineCount - 4)) + (int)((Math.Abs(OriP3.X - OriP4.X)) * (m_stcBlobPad.fWidthPercentEnd3 / 100))),
                                (float)(OriP3.Y + ((Math.Abs(OriP1.Y - OriP3.Y) * m_stcBlobPad.fHeightPercentEnd3 / 100))), Angle, ref RotatedX2, ref RotatedY2);

                            g.DrawLine(new Pen(Color.Red, 2),
                                 (int)RotatedX1 * fDrawingScaleX,
                                 (int)RotatedY1 * fDrawingScaleY,
                                 (int)RotatedX2 * fDrawingScaleX,
                                 (int)RotatedY2 * fDrawingScaleY);

                            Math2.RotateWithAngleAccordingToReferencePoint(intRoiOrgX + m_stcBlobPad.fFeretCenterX, intRoiOrgY + m_stcBlobPad.fFeretCenterY,
                             (float)(((OriP1.X + OriP2.X) / 2) + (((Math.Abs(OriP1.X - OriP2.X) / 2) / (m_stcBlobPad.intLineCount - 3))) + (int)((Math.Abs(OriP1.X - OriP2.X)) * (m_stcBlobPad.fWidthPercentStart4 / 100))),
                             (float)(OriP1.Y + ((Math.Abs(OriP1.Y - OriP3.Y) * m_stcBlobPad.fHeightPercentStart4 / 100))), Angle, ref RotatedX1, ref RotatedY1);

                            Math2.RotateWithAngleAccordingToReferencePoint(intRoiOrgX + m_stcBlobPad.fFeretCenterX, intRoiOrgY + m_stcBlobPad.fFeretCenterY,
                                (float)(((OriP3.X + OriP4.X) / 2) + ((Math.Abs(OriP3.X - OriP4.X) / 2) / (m_stcBlobPad.intLineCount - 3)) + (int)((Math.Abs(OriP3.X - OriP4.X)) * (m_stcBlobPad.fWidthPercentEnd4 / 100))),
                                (float)(OriP3.Y + ((Math.Abs(OriP1.Y - OriP3.Y) * m_stcBlobPad.fHeightPercentEnd4 / 100))), Angle, ref RotatedX2, ref RotatedY2);

                            g.DrawLine(new Pen(Color.Yellow, 2),
                                 (int)RotatedX1 * fDrawingScaleX,
                                 (int)RotatedY1 * fDrawingScaleY,
                                 (int)RotatedX2 * fDrawingScaleX,
                                 (int)RotatedY2 * fDrawingScaleY);

                            Math2.RotateWithAngleAccordingToReferencePoint(intRoiOrgX + m_stcBlobPad.fFeretCenterX, intRoiOrgY + m_stcBlobPad.fFeretCenterY,
                            (float)(((OriP1.X + OriP2.X) / 2) + (((Math.Abs(OriP1.X - OriP2.X) / 2) / (m_stcBlobPad.intLineCount - 2))) + (int)((Math.Abs(OriP1.X - OriP2.X)) * (m_stcBlobPad.fWidthPercentStart5 / 100))),
                            (float)(OriP1.Y + ((Math.Abs(OriP1.Y - OriP3.Y) * m_stcBlobPad.fHeightPercentStart5 / 100))), Angle, ref RotatedX1, ref RotatedY1);

                            Math2.RotateWithAngleAccordingToReferencePoint(intRoiOrgX + m_stcBlobPad.fFeretCenterX, intRoiOrgY + m_stcBlobPad.fFeretCenterY,
                                (float)(((OriP3.X + OriP4.X) / 2) + ((Math.Abs(OriP3.X - OriP4.X) / 2) / (m_stcBlobPad.intLineCount - 2)) + (int)((Math.Abs(OriP3.X - OriP4.X)) * (m_stcBlobPad.fWidthPercentEnd5 / 100))),
                                (float)(OriP3.Y + ((Math.Abs(OriP1.Y - OriP3.Y) * m_stcBlobPad.fHeightPercentEnd5 / 100))), Angle, ref RotatedX2, ref RotatedY2);

                            g.DrawLine(new Pen(Color.Pink, 2),
                                 (int)RotatedX1 * fDrawingScaleX,
                                 (int)RotatedY1 * fDrawingScaleY,
                                 (int)RotatedX2 * fDrawingScaleX,
                                 (int)RotatedY2 * fDrawingScaleY);

                            Math2.RotateWithAngleAccordingToReferencePoint(intRoiOrgX + m_stcBlobPad.fFeretCenterX, intRoiOrgY + m_stcBlobPad.fFeretCenterY,
                       (float)(((OriP1.X + OriP2.X) / 2) + (((Math.Abs(OriP1.X - OriP2.X) / 2) / (m_stcBlobPad.intLineCount - 1))) + (int)((Math.Abs(OriP1.X - OriP2.X)) * (m_stcBlobPad.fWidthPercentStart6 / 100))),
                       (float)(OriP1.Y + ((Math.Abs(OriP1.Y - OriP3.Y) * m_stcBlobPad.fHeightPercentStart6 / 100))), Angle, ref RotatedX1, ref RotatedY1);

                            Math2.RotateWithAngleAccordingToReferencePoint(intRoiOrgX + m_stcBlobPad.fFeretCenterX, intRoiOrgY + m_stcBlobPad.fFeretCenterY,
                                (float)(((OriP3.X + OriP4.X) / 2) + ((Math.Abs(OriP3.X - OriP4.X) / 2) / (m_stcBlobPad.intLineCount - 1)) + (int)((Math.Abs(OriP3.X - OriP4.X)) * (m_stcBlobPad.fWidthPercentEnd6 / 100))),
                                (float)(OriP3.Y + ((Math.Abs(OriP1.Y - OriP3.Y) * m_stcBlobPad.fHeightPercentEnd6 / 100))), Angle, ref RotatedX2, ref RotatedY2);

                            g.DrawLine(new Pen(Color.Orange, 2),
                                 (int)RotatedX1 * fDrawingScaleX,
                                 (int)RotatedY1 * fDrawingScaleY,
                                 (int)RotatedX2 * fDrawingScaleX,
                                 (int)RotatedY2 * fDrawingScaleY);

                            break;
                        case 7:
                            Math2.RotateWithAngleAccordingToReferencePoint(intRoiOrgX + m_stcBlobPad.fFeretCenterX, intRoiOrgY + m_stcBlobPad.fFeretCenterY,
                        (float)(((OriP1.X + OriP2.X) / 2) + (((Math.Abs(OriP1.X - OriP2.X) / 2) / (m_stcBlobPad.intLineCount - 5))) + (int)((Math.Abs(OriP1.X - OriP2.X)) * (m_stcBlobPad.fWidthPercentStart3 / 100))),
                        (float)(OriP1.Y + ((Math.Abs(OriP1.Y - OriP3.Y) * m_stcBlobPad.fHeightPercentStart3 / 100))), Angle, ref RotatedX1, ref RotatedY1);

                            Math2.RotateWithAngleAccordingToReferencePoint(intRoiOrgX + m_stcBlobPad.fFeretCenterX, intRoiOrgY + m_stcBlobPad.fFeretCenterY,
                                (float)(((OriP3.X + OriP4.X) / 2) + ((Math.Abs(OriP3.X - OriP4.X) / 2) / (m_stcBlobPad.intLineCount - 5)) + (int)((Math.Abs(OriP3.X - OriP4.X)) * (m_stcBlobPad.fWidthPercentEnd3 / 100))),
                                (float)(OriP3.Y + ((Math.Abs(OriP1.Y - OriP3.Y) * m_stcBlobPad.fHeightPercentEnd3 / 100))), Angle, ref RotatedX2, ref RotatedY2);

                            g.DrawLine(new Pen(Color.Red, 2),
                                 (int)RotatedX1 * fDrawingScaleX,
                                 (int)RotatedY1 * fDrawingScaleY,
                                 (int)RotatedX2 * fDrawingScaleX,
                                 (int)RotatedY2 * fDrawingScaleY);

                            Math2.RotateWithAngleAccordingToReferencePoint(intRoiOrgX + m_stcBlobPad.fFeretCenterX, intRoiOrgY + m_stcBlobPad.fFeretCenterY,
                             (float)(((OriP1.X + OriP2.X) / 2) + (((Math.Abs(OriP1.X - OriP2.X) / 2) / (m_stcBlobPad.intLineCount - 4))) + (int)((Math.Abs(OriP1.X - OriP2.X)) * (m_stcBlobPad.fWidthPercentStart4 / 100))),
                             (float)(OriP1.Y + ((Math.Abs(OriP1.Y - OriP3.Y) * m_stcBlobPad.fHeightPercentStart4 / 100))), Angle, ref RotatedX1, ref RotatedY1);

                            Math2.RotateWithAngleAccordingToReferencePoint(intRoiOrgX + m_stcBlobPad.fFeretCenterX, intRoiOrgY + m_stcBlobPad.fFeretCenterY,
                                (float)(((OriP3.X + OriP4.X) / 2) + ((Math.Abs(OriP3.X - OriP4.X) / 2) / (m_stcBlobPad.intLineCount - 4)) + (int)((Math.Abs(OriP3.X - OriP4.X)) * (m_stcBlobPad.fWidthPercentEnd4 / 100))),
                                (float)(OriP3.Y + ((Math.Abs(OriP1.Y - OriP3.Y) * m_stcBlobPad.fHeightPercentEnd4 / 100))), Angle, ref RotatedX2, ref RotatedY2);

                            g.DrawLine(new Pen(Color.Yellow, 2),
                                 (int)RotatedX1 * fDrawingScaleX,
                                 (int)RotatedY1 * fDrawingScaleY,
                                 (int)RotatedX2 * fDrawingScaleX,
                                 (int)RotatedY2 * fDrawingScaleY);

                            Math2.RotateWithAngleAccordingToReferencePoint(intRoiOrgX + m_stcBlobPad.fFeretCenterX, intRoiOrgY + m_stcBlobPad.fFeretCenterY,
                            (float)(((OriP1.X + OriP2.X) / 2) + (((Math.Abs(OriP1.X - OriP2.X) / 2) / (m_stcBlobPad.intLineCount - 3))) + (int)((Math.Abs(OriP1.X - OriP2.X)) * (m_stcBlobPad.fWidthPercentStart5 / 100))),
                            (float)(OriP1.Y + ((Math.Abs(OriP1.Y - OriP3.Y) * m_stcBlobPad.fHeightPercentStart5 / 100))), Angle, ref RotatedX1, ref RotatedY1);

                            Math2.RotateWithAngleAccordingToReferencePoint(intRoiOrgX + m_stcBlobPad.fFeretCenterX, intRoiOrgY + m_stcBlobPad.fFeretCenterY,
                                (float)(((OriP3.X + OriP4.X) / 2) + ((Math.Abs(OriP3.X - OriP4.X) / 2) / (m_stcBlobPad.intLineCount - 3)) + (int)((Math.Abs(OriP3.X - OriP4.X)) * (m_stcBlobPad.fWidthPercentEnd5 / 100))),
                                (float)(OriP3.Y + ((Math.Abs(OriP1.Y - OriP3.Y) * m_stcBlobPad.fHeightPercentEnd5 / 100))), Angle, ref RotatedX2, ref RotatedY2);

                            g.DrawLine(new Pen(Color.Pink, 2),
                                 (int)RotatedX1 * fDrawingScaleX,
                                 (int)RotatedY1 * fDrawingScaleY,
                                 (int)RotatedX2 * fDrawingScaleX,
                                 (int)RotatedY2 * fDrawingScaleY);

                            Math2.RotateWithAngleAccordingToReferencePoint(intRoiOrgX + m_stcBlobPad.fFeretCenterX, intRoiOrgY + m_stcBlobPad.fFeretCenterY,
                       (float)(((OriP1.X + OriP2.X) / 2) + (((Math.Abs(OriP1.X - OriP2.X) / 2) / (m_stcBlobPad.intLineCount - 2))) + (int)((Math.Abs(OriP1.X - OriP2.X)) * (m_stcBlobPad.fWidthPercentStart6 / 100))),
                       (float)(OriP1.Y + ((Math.Abs(OriP1.Y - OriP3.Y) * m_stcBlobPad.fHeightPercentStart6 / 100))), Angle, ref RotatedX1, ref RotatedY1);

                            Math2.RotateWithAngleAccordingToReferencePoint(intRoiOrgX + m_stcBlobPad.fFeretCenterX, intRoiOrgY + m_stcBlobPad.fFeretCenterY,
                                (float)(((OriP3.X + OriP4.X) / 2) + ((Math.Abs(OriP3.X - OriP4.X) / 2) / (m_stcBlobPad.intLineCount - 2)) + (int)((Math.Abs(OriP3.X - OriP4.X)) * (m_stcBlobPad.fWidthPercentEnd6 / 100))),
                                (float)(OriP3.Y + ((Math.Abs(OriP1.Y - OriP3.Y) * m_stcBlobPad.fHeightPercentEnd6 / 100))), Angle, ref RotatedX2, ref RotatedY2);

                            g.DrawLine(new Pen(Color.Orange, 2),
                                 (int)RotatedX1 * fDrawingScaleX,
                                 (int)RotatedY1 * fDrawingScaleY,
                                 (int)RotatedX2 * fDrawingScaleX,
                                 (int)RotatedY2 * fDrawingScaleY);

                            Math2.RotateWithAngleAccordingToReferencePoint(intRoiOrgX + m_stcBlobPad.fFeretCenterX, intRoiOrgY + m_stcBlobPad.fFeretCenterY,
                     (float)(((OriP1.X + OriP2.X) / 2) + (((Math.Abs(OriP1.X - OriP2.X) / 2) / (m_stcBlobPad.intLineCount - 1))) + (int)((Math.Abs(OriP1.X - OriP2.X)) * (m_stcBlobPad.fWidthPercentStart7 / 100))),
                     (float)(OriP1.Y + ((Math.Abs(OriP1.Y - OriP3.Y) * m_stcBlobPad.fHeightPercentStart7 / 100))), Angle, ref RotatedX1, ref RotatedY1);

                            Math2.RotateWithAngleAccordingToReferencePoint(intRoiOrgX + m_stcBlobPad.fFeretCenterX, intRoiOrgY + m_stcBlobPad.fFeretCenterY,
                                (float)(((OriP3.X + OriP4.X) / 2) + ((Math.Abs(OriP3.X - OriP4.X) / 2) / (m_stcBlobPad.intLineCount - 1)) + (int)((Math.Abs(OriP3.X - OriP4.X)) * (m_stcBlobPad.fWidthPercentEnd7 / 100))),
                                (float)(OriP3.Y + ((Math.Abs(OriP1.Y - OriP3.Y) * m_stcBlobPad.fHeightPercentEnd7 / 100))), Angle, ref RotatedX2, ref RotatedY2);

                            g.DrawLine(new Pen(Color.Cyan, 2),
                                 (int)RotatedX1 * fDrawingScaleX,
                                 (int)RotatedY1 * fDrawingScaleY,
                                 (int)RotatedX2 * fDrawingScaleX,
                                 (int)RotatedY2 * fDrawingScaleY);

                            break;
                        case 8:
                            Math2.RotateWithAngleAccordingToReferencePoint(intRoiOrgX + m_stcBlobPad.fFeretCenterX, intRoiOrgY + m_stcBlobPad.fFeretCenterY,
                        (float)(((OriP1.X + OriP2.X) / 2) + (((Math.Abs(OriP1.X - OriP2.X) / 2) / (m_stcBlobPad.intLineCount - 6))) + (int)((Math.Abs(OriP1.X - OriP2.X)) * (m_stcBlobPad.fWidthPercentStart3 / 100))),
                        (float)(OriP1.Y + ((Math.Abs(OriP1.Y - OriP3.Y) * m_stcBlobPad.fHeightPercentStart3 / 100))), Angle, ref RotatedX1, ref RotatedY1);

                            Math2.RotateWithAngleAccordingToReferencePoint(intRoiOrgX + m_stcBlobPad.fFeretCenterX, intRoiOrgY + m_stcBlobPad.fFeretCenterY,
                                (float)(((OriP3.X + OriP4.X) / 2) + ((Math.Abs(OriP3.X - OriP4.X) / 2) / (m_stcBlobPad.intLineCount - 6)) + (int)((Math.Abs(OriP3.X - OriP4.X)) * (m_stcBlobPad.fWidthPercentEnd3 / 100))),
                                (float)(OriP3.Y + ((Math.Abs(OriP1.Y - OriP3.Y) * m_stcBlobPad.fHeightPercentEnd3 / 100))), Angle, ref RotatedX2, ref RotatedY2);

                            g.DrawLine(new Pen(Color.Red, 2),
                                 (int)RotatedX1 * fDrawingScaleX,
                                 (int)RotatedY1 * fDrawingScaleY,
                                 (int)RotatedX2 * fDrawingScaleX,
                                 (int)RotatedY2 * fDrawingScaleY);

                            Math2.RotateWithAngleAccordingToReferencePoint(intRoiOrgX + m_stcBlobPad.fFeretCenterX, intRoiOrgY + m_stcBlobPad.fFeretCenterY,
                             (float)(((OriP1.X + OriP2.X) / 2) + (((Math.Abs(OriP1.X - OriP2.X) / 2) / (m_stcBlobPad.intLineCount - 5))) + (int)((Math.Abs(OriP1.X - OriP2.X)) * (m_stcBlobPad.fWidthPercentStart4 / 100))),
                             (float)(OriP1.Y + ((Math.Abs(OriP1.Y - OriP3.Y) * m_stcBlobPad.fHeightPercentStart4 / 100))), Angle, ref RotatedX1, ref RotatedY1);

                            Math2.RotateWithAngleAccordingToReferencePoint(intRoiOrgX + m_stcBlobPad.fFeretCenterX, intRoiOrgY + m_stcBlobPad.fFeretCenterY,
                                (float)(((OriP3.X + OriP4.X) / 2) + ((Math.Abs(OriP3.X - OriP4.X) / 2) / (m_stcBlobPad.intLineCount - 5)) + (int)((Math.Abs(OriP3.X - OriP4.X)) * (m_stcBlobPad.fWidthPercentEnd4 / 100))),
                                (float)(OriP3.Y + ((Math.Abs(OriP1.Y - OriP3.Y) * m_stcBlobPad.fHeightPercentEnd4 / 100))), Angle, ref RotatedX2, ref RotatedY2);

                            g.DrawLine(new Pen(Color.Yellow, 2),
                                 (int)RotatedX1 * fDrawingScaleX,
                                 (int)RotatedY1 * fDrawingScaleY,
                                 (int)RotatedX2 * fDrawingScaleX,
                                 (int)RotatedY2 * fDrawingScaleY);

                            Math2.RotateWithAngleAccordingToReferencePoint(intRoiOrgX + m_stcBlobPad.fFeretCenterX, intRoiOrgY + m_stcBlobPad.fFeretCenterY,
                            (float)(((OriP1.X + OriP2.X) / 2) + (((Math.Abs(OriP1.X - OriP2.X) / 2) / (m_stcBlobPad.intLineCount - 4))) + (int)((Math.Abs(OriP1.X - OriP2.X)) * (m_stcBlobPad.fWidthPercentStart5 / 100))),
                            (float)(OriP1.Y + ((Math.Abs(OriP1.Y - OriP3.Y) * m_stcBlobPad.fHeightPercentStart5 / 100))), Angle, ref RotatedX1, ref RotatedY1);

                            Math2.RotateWithAngleAccordingToReferencePoint(intRoiOrgX + m_stcBlobPad.fFeretCenterX, intRoiOrgY + m_stcBlobPad.fFeretCenterY,
                                (float)(((OriP3.X + OriP4.X) / 2) + ((Math.Abs(OriP3.X - OriP4.X) / 2) / (m_stcBlobPad.intLineCount - 4)) + (int)((Math.Abs(OriP3.X - OriP4.X)) * (m_stcBlobPad.fWidthPercentEnd5 / 100))),
                                (float)(OriP3.Y + ((Math.Abs(OriP1.Y - OriP3.Y) * m_stcBlobPad.fHeightPercentEnd5 / 100))), Angle, ref RotatedX2, ref RotatedY2);

                            g.DrawLine(new Pen(Color.Pink, 2),
                                 (int)RotatedX1 * fDrawingScaleX,
                                 (int)RotatedY1 * fDrawingScaleY,
                                 (int)RotatedX2 * fDrawingScaleX,
                                 (int)RotatedY2 * fDrawingScaleY);

                            Math2.RotateWithAngleAccordingToReferencePoint(intRoiOrgX + m_stcBlobPad.fFeretCenterX, intRoiOrgY + m_stcBlobPad.fFeretCenterY,
                       (float)(((OriP1.X + OriP2.X) / 2) + (((Math.Abs(OriP1.X - OriP2.X) / 2) / (m_stcBlobPad.intLineCount - 3))) + (int)((Math.Abs(OriP1.X - OriP2.X)) * (m_stcBlobPad.fWidthPercentStart6 / 100))),
                       (float)(OriP1.Y + ((Math.Abs(OriP1.Y - OriP3.Y) * m_stcBlobPad.fHeightPercentStart6 / 100))), Angle, ref RotatedX1, ref RotatedY1);

                            Math2.RotateWithAngleAccordingToReferencePoint(intRoiOrgX + m_stcBlobPad.fFeretCenterX, intRoiOrgY + m_stcBlobPad.fFeretCenterY,
                                (float)(((OriP3.X + OriP4.X) / 2) + ((Math.Abs(OriP3.X - OriP4.X) / 2) / (m_stcBlobPad.intLineCount - 3)) + (int)((Math.Abs(OriP3.X - OriP4.X)) * (m_stcBlobPad.fWidthPercentEnd6 / 100))),
                                (float)(OriP3.Y + ((Math.Abs(OriP1.Y - OriP3.Y) * m_stcBlobPad.fHeightPercentEnd6 / 100))), Angle, ref RotatedX2, ref RotatedY2);

                            g.DrawLine(new Pen(Color.Orange, 2),
                                 (int)RotatedX1 * fDrawingScaleX,
                                 (int)RotatedY1 * fDrawingScaleY,
                                 (int)RotatedX2 * fDrawingScaleX,
                                 (int)RotatedY2 * fDrawingScaleY);

                            Math2.RotateWithAngleAccordingToReferencePoint(intRoiOrgX + m_stcBlobPad.fFeretCenterX, intRoiOrgY + m_stcBlobPad.fFeretCenterY,
                     (float)(((OriP1.X + OriP2.X) / 2) + (((Math.Abs(OriP1.X - OriP2.X) / 2) / (m_stcBlobPad.intLineCount - 2))) + (int)((Math.Abs(OriP1.X - OriP2.X)) * (m_stcBlobPad.fWidthPercentStart7 / 100))),
                     (float)(OriP1.Y + ((Math.Abs(OriP1.Y - OriP3.Y) * m_stcBlobPad.fHeightPercentStart7 / 100))), Angle, ref RotatedX1, ref RotatedY1);

                            Math2.RotateWithAngleAccordingToReferencePoint(intRoiOrgX + m_stcBlobPad.fFeretCenterX, intRoiOrgY + m_stcBlobPad.fFeretCenterY,
                                (float)(((OriP3.X + OriP4.X) / 2) + ((Math.Abs(OriP3.X - OriP4.X) / 2) / (m_stcBlobPad.intLineCount - 2)) + (int)((Math.Abs(OriP3.X - OriP4.X)) * (m_stcBlobPad.fWidthPercentEnd7 / 100))),
                                (float)(OriP3.Y + ((Math.Abs(OriP1.Y - OriP3.Y) * m_stcBlobPad.fHeightPercentEnd7 / 100))), Angle, ref RotatedX2, ref RotatedY2);

                            g.DrawLine(new Pen(Color.Cyan, 2),
                                 (int)RotatedX1 * fDrawingScaleX,
                                 (int)RotatedY1 * fDrawingScaleY,
                                 (int)RotatedX2 * fDrawingScaleX,
                                 (int)RotatedY2 * fDrawingScaleY);

                            Math2.RotateWithAngleAccordingToReferencePoint(intRoiOrgX + m_stcBlobPad.fFeretCenterX, intRoiOrgY + m_stcBlobPad.fFeretCenterY,
                     (float)(((OriP1.X + OriP2.X) / 2) + (((Math.Abs(OriP1.X - OriP2.X) / 2) / (m_stcBlobPad.intLineCount - 1))) + (int)((Math.Abs(OriP1.X - OriP2.X)) * (m_stcBlobPad.fWidthPercentStart8 / 100))),
                     (float)(OriP1.Y + ((Math.Abs(OriP1.Y - OriP3.Y) * m_stcBlobPad.fHeightPercentStart8 / 100))), Angle, ref RotatedX1, ref RotatedY1);

                            Math2.RotateWithAngleAccordingToReferencePoint(intRoiOrgX + m_stcBlobPad.fFeretCenterX, intRoiOrgY + m_stcBlobPad.fFeretCenterY,
                                (float)(((OriP3.X + OriP4.X) / 2) + ((Math.Abs(OriP3.X - OriP4.X) / 2) / (m_stcBlobPad.intLineCount - 1)) + (int)((Math.Abs(OriP3.X - OriP4.X)) * (m_stcBlobPad.fWidthPercentEnd8 / 100))),
                                (float)(OriP3.Y + ((Math.Abs(OriP1.Y - OriP3.Y) * m_stcBlobPad.fHeightPercentEnd8 / 100))), Angle, ref RotatedX2, ref RotatedY2);

                            g.DrawLine(new Pen(Color.Magenta, 2),
                                 (int)RotatedX1 * fDrawingScaleX,
                                 (int)RotatedY1 * fDrawingScaleY,
                                 (int)RotatedX2 * fDrawingScaleX,
                                 (int)RotatedY2 * fDrawingScaleY);

                            break;
                        case 9:
                            Math2.RotateWithAngleAccordingToReferencePoint(intRoiOrgX + m_stcBlobPad.fFeretCenterX, intRoiOrgY + m_stcBlobPad.fFeretCenterY,
                        (float)(((OriP1.X + OriP2.X) / 2) + (((Math.Abs(OriP1.X - OriP2.X) / 2) / (m_stcBlobPad.intLineCount - 7))) + (int)((Math.Abs(OriP1.X - OriP2.X)) * (m_stcBlobPad.fWidthPercentStart3 / 100))),
                        (float)(OriP1.Y + ((Math.Abs(OriP1.Y - OriP3.Y) * m_stcBlobPad.fHeightPercentStart3 / 100))), Angle, ref RotatedX1, ref RotatedY1);

                            Math2.RotateWithAngleAccordingToReferencePoint(intRoiOrgX + m_stcBlobPad.fFeretCenterX, intRoiOrgY + m_stcBlobPad.fFeretCenterY,
                                (float)(((OriP3.X + OriP4.X) / 2) + ((Math.Abs(OriP3.X - OriP4.X) / 2) / (m_stcBlobPad.intLineCount - 7)) + (int)((Math.Abs(OriP3.X - OriP4.X)) * (m_stcBlobPad.fWidthPercentEnd3 / 100))),
                                (float)(OriP3.Y + ((Math.Abs(OriP1.Y - OriP3.Y) * m_stcBlobPad.fHeightPercentEnd3 / 100))), Angle, ref RotatedX2, ref RotatedY2);

                            g.DrawLine(new Pen(Color.Red, 2),
                                 (int)RotatedX1 * fDrawingScaleX,
                                 (int)RotatedY1 * fDrawingScaleY,
                                 (int)RotatedX2 * fDrawingScaleX,
                                 (int)RotatedY2 * fDrawingScaleY);

                            Math2.RotateWithAngleAccordingToReferencePoint(intRoiOrgX + m_stcBlobPad.fFeretCenterX, intRoiOrgY + m_stcBlobPad.fFeretCenterY,
                             (float)(((OriP1.X + OriP2.X) / 2) + (((Math.Abs(OriP1.X - OriP2.X) / 2) / (m_stcBlobPad.intLineCount - 6))) + (int)((Math.Abs(OriP1.X - OriP2.X)) * (m_stcBlobPad.fWidthPercentStart4 / 100))),
                             (float)(OriP1.Y + ((Math.Abs(OriP1.Y - OriP3.Y) * m_stcBlobPad.fHeightPercentStart4 / 100))), Angle, ref RotatedX1, ref RotatedY1);

                            Math2.RotateWithAngleAccordingToReferencePoint(intRoiOrgX + m_stcBlobPad.fFeretCenterX, intRoiOrgY + m_stcBlobPad.fFeretCenterY,
                                (float)(((OriP3.X + OriP4.X) / 2) + ((Math.Abs(OriP3.X - OriP4.X) / 2) / (m_stcBlobPad.intLineCount - 6)) + (int)((Math.Abs(OriP3.X - OriP4.X)) * (m_stcBlobPad.fWidthPercentEnd4 / 100))),
                                (float)(OriP3.Y + ((Math.Abs(OriP1.Y - OriP3.Y) * m_stcBlobPad.fHeightPercentEnd4 / 100))), Angle, ref RotatedX2, ref RotatedY2);

                            g.DrawLine(new Pen(Color.Yellow, 2),
                                 (int)RotatedX1 * fDrawingScaleX,
                                 (int)RotatedY1 * fDrawingScaleY,
                                 (int)RotatedX2 * fDrawingScaleX,
                                 (int)RotatedY2 * fDrawingScaleY);

                            Math2.RotateWithAngleAccordingToReferencePoint(intRoiOrgX + m_stcBlobPad.fFeretCenterX, intRoiOrgY + m_stcBlobPad.fFeretCenterY,
                            (float)(((OriP1.X + OriP2.X) / 2) + (((Math.Abs(OriP1.X - OriP2.X) / 2) / (m_stcBlobPad.intLineCount - 5))) + (int)((Math.Abs(OriP1.X - OriP2.X)) * (m_stcBlobPad.fWidthPercentStart5 / 100))),
                            (float)(OriP1.Y + ((Math.Abs(OriP1.Y - OriP3.Y) * m_stcBlobPad.fHeightPercentStart5 / 100))), Angle, ref RotatedX1, ref RotatedY1);

                            Math2.RotateWithAngleAccordingToReferencePoint(intRoiOrgX + m_stcBlobPad.fFeretCenterX, intRoiOrgY + m_stcBlobPad.fFeretCenterY,
                                (float)(((OriP3.X + OriP4.X) / 2) + ((Math.Abs(OriP3.X - OriP4.X) / 2) / (m_stcBlobPad.intLineCount - 5)) + (int)((Math.Abs(OriP3.X - OriP4.X)) * (m_stcBlobPad.fWidthPercentEnd5 / 100))),
                                (float)(OriP3.Y + ((Math.Abs(OriP1.Y - OriP3.Y) * m_stcBlobPad.fHeightPercentEnd5 / 100))), Angle, ref RotatedX2, ref RotatedY2);

                            g.DrawLine(new Pen(Color.Pink, 2),
                                 (int)RotatedX1 * fDrawingScaleX,
                                 (int)RotatedY1 * fDrawingScaleY,
                                 (int)RotatedX2 * fDrawingScaleX,
                                 (int)RotatedY2 * fDrawingScaleY);

                            Math2.RotateWithAngleAccordingToReferencePoint(intRoiOrgX + m_stcBlobPad.fFeretCenterX, intRoiOrgY + m_stcBlobPad.fFeretCenterY,
                       (float)(((OriP1.X + OriP2.X) / 2) + (((Math.Abs(OriP1.X - OriP2.X) / 2) / (m_stcBlobPad.intLineCount - 4))) + (int)((Math.Abs(OriP1.X - OriP2.X)) * (m_stcBlobPad.fWidthPercentStart6 / 100))),
                       (float)(OriP1.Y + ((Math.Abs(OriP1.Y - OriP3.Y) * m_stcBlobPad.fHeightPercentStart6 / 100))), Angle, ref RotatedX1, ref RotatedY1);

                            Math2.RotateWithAngleAccordingToReferencePoint(intRoiOrgX + m_stcBlobPad.fFeretCenterX, intRoiOrgY + m_stcBlobPad.fFeretCenterY,
                                (float)(((OriP3.X + OriP4.X) / 2) + ((Math.Abs(OriP3.X - OriP4.X) / 2) / (m_stcBlobPad.intLineCount - 4)) + (int)((Math.Abs(OriP3.X - OriP4.X)) * (m_stcBlobPad.fWidthPercentEnd6 / 100))),
                                (float)(OriP3.Y + ((Math.Abs(OriP1.Y - OriP3.Y) * m_stcBlobPad.fHeightPercentEnd6 / 100))), Angle, ref RotatedX2, ref RotatedY2);

                            g.DrawLine(new Pen(Color.Orange, 2),
                                 (int)RotatedX1 * fDrawingScaleX,
                                 (int)RotatedY1 * fDrawingScaleY,
                                 (int)RotatedX2 * fDrawingScaleX,
                                 (int)RotatedY2 * fDrawingScaleY);

                            Math2.RotateWithAngleAccordingToReferencePoint(intRoiOrgX + m_stcBlobPad.fFeretCenterX, intRoiOrgY + m_stcBlobPad.fFeretCenterY,
                     (float)(((OriP1.X + OriP2.X) / 2) + (((Math.Abs(OriP1.X - OriP2.X) / 2) / (m_stcBlobPad.intLineCount - 3))) + (int)((Math.Abs(OriP1.X - OriP2.X)) * (m_stcBlobPad.fWidthPercentStart7 / 100))),
                     (float)(OriP1.Y + ((Math.Abs(OriP1.Y - OriP3.Y) * m_stcBlobPad.fHeightPercentStart7 / 100))), Angle, ref RotatedX1, ref RotatedY1);

                            Math2.RotateWithAngleAccordingToReferencePoint(intRoiOrgX + m_stcBlobPad.fFeretCenterX, intRoiOrgY + m_stcBlobPad.fFeretCenterY,
                                (float)(((OriP3.X + OriP4.X) / 2) + ((Math.Abs(OriP3.X - OriP4.X) / 2) / (m_stcBlobPad.intLineCount - 3)) + (int)((Math.Abs(OriP3.X - OriP4.X)) * (m_stcBlobPad.fWidthPercentEnd7 / 100))),
                                (float)(OriP3.Y + ((Math.Abs(OriP1.Y - OriP3.Y) * m_stcBlobPad.fHeightPercentEnd7 / 100))), Angle, ref RotatedX2, ref RotatedY2);

                            g.DrawLine(new Pen(Color.Cyan, 2),
                                 (int)RotatedX1 * fDrawingScaleX,
                                 (int)RotatedY1 * fDrawingScaleY,
                                 (int)RotatedX2 * fDrawingScaleX,
                                 (int)RotatedY2 * fDrawingScaleY);

                            Math2.RotateWithAngleAccordingToReferencePoint(intRoiOrgX + m_stcBlobPad.fFeretCenterX, intRoiOrgY + m_stcBlobPad.fFeretCenterY,
                     (float)(((OriP1.X + OriP2.X) / 2) + (((Math.Abs(OriP1.X - OriP2.X) / 2) / (m_stcBlobPad.intLineCount - 2))) + (int)((Math.Abs(OriP1.X - OriP2.X)) * (m_stcBlobPad.fWidthPercentStart8 / 100))),
                     (float)(OriP1.Y + ((Math.Abs(OriP1.Y - OriP3.Y) * m_stcBlobPad.fHeightPercentStart8 / 100))), Angle, ref RotatedX1, ref RotatedY1);

                            Math2.RotateWithAngleAccordingToReferencePoint(intRoiOrgX + m_stcBlobPad.fFeretCenterX, intRoiOrgY + m_stcBlobPad.fFeretCenterY,
                                (float)(((OriP3.X + OriP4.X) / 2) + ((Math.Abs(OriP3.X - OriP4.X) / 2) / (m_stcBlobPad.intLineCount - 2)) + (int)((Math.Abs(OriP3.X - OriP4.X)) * (m_stcBlobPad.fWidthPercentEnd8 / 100))),
                                (float)(OriP3.Y + ((Math.Abs(OriP1.Y - OriP3.Y) * m_stcBlobPad.fHeightPercentEnd8 / 100))), Angle, ref RotatedX2, ref RotatedY2);

                            g.DrawLine(new Pen(Color.Magenta, 2),
                                 (int)RotatedX1 * fDrawingScaleX,
                                 (int)RotatedY1 * fDrawingScaleY,
                                 (int)RotatedX2 * fDrawingScaleX,
                                 (int)RotatedY2 * fDrawingScaleY);

                            Math2.RotateWithAngleAccordingToReferencePoint(intRoiOrgX + m_stcBlobPad.fFeretCenterX, intRoiOrgY + m_stcBlobPad.fFeretCenterY,
                     (float)(((OriP1.X + OriP2.X) / 2) + (((Math.Abs(OriP1.X - OriP2.X) / 2) / (m_stcBlobPad.intLineCount - 1))) + (int)((Math.Abs(OriP1.X - OriP2.X)) * (m_stcBlobPad.fWidthPercentStart9 / 100))),
                     (float)(OriP1.Y + ((Math.Abs(OriP1.Y - OriP3.Y) * m_stcBlobPad.fHeightPercentStart9 / 100))), Angle, ref RotatedX1, ref RotatedY1);

                            Math2.RotateWithAngleAccordingToReferencePoint(intRoiOrgX + m_stcBlobPad.fFeretCenterX, intRoiOrgY + m_stcBlobPad.fFeretCenterY,
                                (float)(((OriP3.X + OriP4.X) / 2) + ((Math.Abs(OriP3.X - OriP4.X) / 2) / (m_stcBlobPad.intLineCount - 1)) + (int)((Math.Abs(OriP3.X - OriP4.X)) * (m_stcBlobPad.fWidthPercentEnd9 / 100))),
                                (float)(OriP3.Y + ((Math.Abs(OriP1.Y - OriP3.Y) * m_stcBlobPad.fHeightPercentEnd9 / 100))), Angle, ref RotatedX2, ref RotatedY2);

                            g.DrawLine(new Pen(Color.Silver, 2),
                                 (int)RotatedX1 * fDrawingScaleX,
                                 (int)RotatedY1 * fDrawingScaleY,
                                 (int)RotatedX2 * fDrawingScaleX,
                                 (int)RotatedY2 * fDrawingScaleY);

                            break;
                        case 10:
                            Math2.RotateWithAngleAccordingToReferencePoint(intRoiOrgX + m_stcBlobPad.fFeretCenterX, intRoiOrgY + m_stcBlobPad.fFeretCenterY,
                        (float)(((OriP1.X + OriP2.X) / 2) + (((Math.Abs(OriP1.X - OriP2.X) / 2) / (m_stcBlobPad.intLineCount - 8))) + (int)((Math.Abs(OriP1.X - OriP2.X)) * (m_stcBlobPad.fWidthPercentStart3 / 100))),
                        (float)(OriP1.Y + ((Math.Abs(OriP1.Y - OriP3.Y) * m_stcBlobPad.fHeightPercentStart3 / 100))), Angle, ref RotatedX1, ref RotatedY1);

                            Math2.RotateWithAngleAccordingToReferencePoint(intRoiOrgX + m_stcBlobPad.fFeretCenterX, intRoiOrgY + m_stcBlobPad.fFeretCenterY,
                                (float)(((OriP3.X + OriP4.X) / 2) + ((Math.Abs(OriP3.X - OriP4.X) / 2) / (m_stcBlobPad.intLineCount - 8)) + (int)((Math.Abs(OriP3.X - OriP4.X)) * (m_stcBlobPad.fWidthPercentEnd3 / 100))),
                                (float)(OriP3.Y + ((Math.Abs(OriP1.Y - OriP3.Y) * m_stcBlobPad.fHeightPercentEnd3 / 100))), Angle, ref RotatedX2, ref RotatedY2);

                            g.DrawLine(new Pen(Color.Red, 2),
                                 (int)RotatedX1 * fDrawingScaleX,
                                 (int)RotatedY1 * fDrawingScaleY,
                                 (int)RotatedX2 * fDrawingScaleX,
                                 (int)RotatedY2 * fDrawingScaleY);

                            Math2.RotateWithAngleAccordingToReferencePoint(intRoiOrgX + m_stcBlobPad.fFeretCenterX, intRoiOrgY + m_stcBlobPad.fFeretCenterY,
                             (float)(((OriP1.X + OriP2.X) / 2) + (((Math.Abs(OriP1.X - OriP2.X) / 2) / (m_stcBlobPad.intLineCount - 7))) + (int)((Math.Abs(OriP1.X - OriP2.X)) * (m_stcBlobPad.fWidthPercentStart4 / 100))),
                             (float)(OriP1.Y + ((Math.Abs(OriP1.Y - OriP3.Y) * m_stcBlobPad.fHeightPercentStart4 / 100))), Angle, ref RotatedX1, ref RotatedY1);

                            Math2.RotateWithAngleAccordingToReferencePoint(intRoiOrgX + m_stcBlobPad.fFeretCenterX, intRoiOrgY + m_stcBlobPad.fFeretCenterY,
                                (float)(((OriP3.X + OriP4.X) / 2) + ((Math.Abs(OriP3.X - OriP4.X) / 2) / (m_stcBlobPad.intLineCount - 7)) + (int)((Math.Abs(OriP3.X - OriP4.X)) * (m_stcBlobPad.fWidthPercentEnd4 / 100))),
                                (float)(OriP3.Y + ((Math.Abs(OriP1.Y - OriP3.Y) * m_stcBlobPad.fHeightPercentEnd4 / 100))), Angle, ref RotatedX2, ref RotatedY2);

                            g.DrawLine(new Pen(Color.Yellow, 2),
                                 (int)RotatedX1 * fDrawingScaleX,
                                 (int)RotatedY1 * fDrawingScaleY,
                                 (int)RotatedX2 * fDrawingScaleX,
                                 (int)RotatedY2 * fDrawingScaleY);

                            Math2.RotateWithAngleAccordingToReferencePoint(intRoiOrgX + m_stcBlobPad.fFeretCenterX, intRoiOrgY + m_stcBlobPad.fFeretCenterY,
                            (float)(((OriP1.X + OriP2.X) / 2) + (((Math.Abs(OriP1.X - OriP2.X) / 2) / (m_stcBlobPad.intLineCount - 6))) + (int)((Math.Abs(OriP1.X - OriP2.X)) * (m_stcBlobPad.fWidthPercentStart5 / 100))),
                            (float)(OriP1.Y + ((Math.Abs(OriP1.Y - OriP3.Y) * m_stcBlobPad.fHeightPercentStart5 / 100))), Angle, ref RotatedX1, ref RotatedY1);

                            Math2.RotateWithAngleAccordingToReferencePoint(intRoiOrgX + m_stcBlobPad.fFeretCenterX, intRoiOrgY + m_stcBlobPad.fFeretCenterY,
                                (float)(((OriP3.X + OriP4.X) / 2) + ((Math.Abs(OriP3.X - OriP4.X) / 2) / (m_stcBlobPad.intLineCount - 6)) + (int)((Math.Abs(OriP3.X - OriP4.X)) * (m_stcBlobPad.fWidthPercentEnd5 / 100))),
                                (float)(OriP3.Y + ((Math.Abs(OriP1.Y - OriP3.Y) * m_stcBlobPad.fHeightPercentEnd5 / 100))), Angle, ref RotatedX2, ref RotatedY2);

                            g.DrawLine(new Pen(Color.Pink, 2),
                                 (int)RotatedX1 * fDrawingScaleX,
                                 (int)RotatedY1 * fDrawingScaleY,
                                 (int)RotatedX2 * fDrawingScaleX,
                                 (int)RotatedY2 * fDrawingScaleY);

                            Math2.RotateWithAngleAccordingToReferencePoint(intRoiOrgX + m_stcBlobPad.fFeretCenterX, intRoiOrgY + m_stcBlobPad.fFeretCenterY,
                       (float)(((OriP1.X + OriP2.X) / 2) + (((Math.Abs(OriP1.X - OriP2.X) / 2) / (m_stcBlobPad.intLineCount - 5))) + (int)((Math.Abs(OriP1.X - OriP2.X)) * (m_stcBlobPad.fWidthPercentStart6 / 100))),
                       (float)(OriP1.Y + ((Math.Abs(OriP1.Y - OriP3.Y) * m_stcBlobPad.fHeightPercentStart6 / 100))), Angle, ref RotatedX1, ref RotatedY1);

                            Math2.RotateWithAngleAccordingToReferencePoint(intRoiOrgX + m_stcBlobPad.fFeretCenterX, intRoiOrgY + m_stcBlobPad.fFeretCenterY,
                                (float)(((OriP3.X + OriP4.X) / 2) + ((Math.Abs(OriP3.X - OriP4.X) / 2) / (m_stcBlobPad.intLineCount - 5)) + (int)((Math.Abs(OriP3.X - OriP4.X)) * (m_stcBlobPad.fWidthPercentEnd6 / 100))),
                                (float)(OriP3.Y + ((Math.Abs(OriP1.Y - OriP3.Y) * m_stcBlobPad.fHeightPercentEnd6 / 100))), Angle, ref RotatedX2, ref RotatedY2);

                            g.DrawLine(new Pen(Color.Orange, 2),
                                 (int)RotatedX1 * fDrawingScaleX,
                                 (int)RotatedY1 * fDrawingScaleY,
                                 (int)RotatedX2 * fDrawingScaleX,
                                 (int)RotatedY2 * fDrawingScaleY);

                            Math2.RotateWithAngleAccordingToReferencePoint(intRoiOrgX + m_stcBlobPad.fFeretCenterX, intRoiOrgY + m_stcBlobPad.fFeretCenterY,
                     (float)(((OriP1.X + OriP2.X) / 2) + (((Math.Abs(OriP1.X - OriP2.X) / 2) / (m_stcBlobPad.intLineCount - 4))) + (int)((Math.Abs(OriP1.X - OriP2.X)) * (m_stcBlobPad.fWidthPercentStart7 / 100))),
                     (float)(OriP1.Y + ((Math.Abs(OriP1.Y - OriP3.Y) * m_stcBlobPad.fHeightPercentStart7 / 100))), Angle, ref RotatedX1, ref RotatedY1);

                            Math2.RotateWithAngleAccordingToReferencePoint(intRoiOrgX + m_stcBlobPad.fFeretCenterX, intRoiOrgY + m_stcBlobPad.fFeretCenterY,
                                (float)(((OriP3.X + OriP4.X) / 2) + ((Math.Abs(OriP3.X - OriP4.X) / 2) / (m_stcBlobPad.intLineCount - 4)) + (int)((Math.Abs(OriP3.X - OriP4.X)) * (m_stcBlobPad.fWidthPercentEnd7 / 100))),
                                (float)(OriP3.Y + ((Math.Abs(OriP1.Y - OriP3.Y) * m_stcBlobPad.fHeightPercentEnd7 / 100))), Angle, ref RotatedX2, ref RotatedY2);

                            g.DrawLine(new Pen(Color.Cyan, 2),
                                 (int)RotatedX1 * fDrawingScaleX,
                                 (int)RotatedY1 * fDrawingScaleY,
                                 (int)RotatedX2 * fDrawingScaleX,
                                 (int)RotatedY2 * fDrawingScaleY);

                            Math2.RotateWithAngleAccordingToReferencePoint(intRoiOrgX + m_stcBlobPad.fFeretCenterX, intRoiOrgY + m_stcBlobPad.fFeretCenterY,
                     (float)(((OriP1.X + OriP2.X) / 2) + (((Math.Abs(OriP1.X - OriP2.X) / 2) / (m_stcBlobPad.intLineCount - 3))) + (int)((Math.Abs(OriP1.X - OriP2.X)) * (m_stcBlobPad.fWidthPercentStart8 / 100))),
                     (float)(OriP1.Y + ((Math.Abs(OriP1.Y - OriP3.Y) * m_stcBlobPad.fHeightPercentStart8 / 100))), Angle, ref RotatedX1, ref RotatedY1);

                            Math2.RotateWithAngleAccordingToReferencePoint(intRoiOrgX + m_stcBlobPad.fFeretCenterX, intRoiOrgY + m_stcBlobPad.fFeretCenterY,
                                (float)(((OriP3.X + OriP4.X) / 2) + ((Math.Abs(OriP3.X - OriP4.X) / 2) / (m_stcBlobPad.intLineCount - 3)) + (int)((Math.Abs(OriP3.X - OriP4.X)) * (m_stcBlobPad.fWidthPercentEnd8 / 100))),
                                (float)(OriP3.Y + ((Math.Abs(OriP1.Y - OriP3.Y) * m_stcBlobPad.fHeightPercentEnd8 / 100))), Angle, ref RotatedX2, ref RotatedY2);

                            g.DrawLine(new Pen(Color.Magenta, 2),
                                 (int)RotatedX1 * fDrawingScaleX,
                                 (int)RotatedY1 * fDrawingScaleY,
                                 (int)RotatedX2 * fDrawingScaleX,
                                 (int)RotatedY2 * fDrawingScaleY);

                            Math2.RotateWithAngleAccordingToReferencePoint(intRoiOrgX + m_stcBlobPad.fFeretCenterX, intRoiOrgY + m_stcBlobPad.fFeretCenterY,
                     (float)(((OriP1.X + OriP2.X) / 2) + (((Math.Abs(OriP1.X - OriP2.X) / 2) / (m_stcBlobPad.intLineCount - 2))) + (int)((Math.Abs(OriP1.X - OriP2.X)) * (m_stcBlobPad.fWidthPercentStart9 / 100))),
                     (float)(OriP1.Y + ((Math.Abs(OriP1.Y - OriP3.Y) * m_stcBlobPad.fHeightPercentStart9 / 100))), Angle, ref RotatedX1, ref RotatedY1);

                            Math2.RotateWithAngleAccordingToReferencePoint(intRoiOrgX + m_stcBlobPad.fFeretCenterX, intRoiOrgY + m_stcBlobPad.fFeretCenterY,
                                (float)(((OriP3.X + OriP4.X) / 2) + ((Math.Abs(OriP3.X - OriP4.X) / 2) / (m_stcBlobPad.intLineCount - 2)) + (int)((Math.Abs(OriP3.X - OriP4.X)) * (m_stcBlobPad.fWidthPercentEnd9 / 100))),
                                (float)(OriP3.Y + ((Math.Abs(OriP1.Y - OriP3.Y) * m_stcBlobPad.fHeightPercentEnd9 / 100))), Angle, ref RotatedX2, ref RotatedY2);

                            g.DrawLine(new Pen(Color.Silver, 2),
                                 (int)RotatedX1 * fDrawingScaleX,
                                 (int)RotatedY1 * fDrawingScaleY,
                                 (int)RotatedX2 * fDrawingScaleX,
                                 (int)RotatedY2 * fDrawingScaleY);

                            Math2.RotateWithAngleAccordingToReferencePoint(intRoiOrgX + m_stcBlobPad.fFeretCenterX, intRoiOrgY + m_stcBlobPad.fFeretCenterY,
                     (float)(((OriP1.X + OriP2.X) / 2) + (((Math.Abs(OriP1.X - OriP2.X) / 2) / (m_stcBlobPad.intLineCount - 1))) + (int)((Math.Abs(OriP1.X - OriP2.X)) * (m_stcBlobPad.fWidthPercentStart10 / 100))),
                     (float)(OriP1.Y + ((Math.Abs(OriP1.Y - OriP3.Y) * m_stcBlobPad.fHeightPercentStart10 / 100))), Angle, ref RotatedX1, ref RotatedY1);

                            Math2.RotateWithAngleAccordingToReferencePoint(intRoiOrgX + m_stcBlobPad.fFeretCenterX, intRoiOrgY + m_stcBlobPad.fFeretCenterY,
                                (float)(((OriP3.X + OriP4.X) / 2) + ((Math.Abs(OriP3.X - OriP4.X) / 2) / (m_stcBlobPad.intLineCount - 1)) + (int)((Math.Abs(OriP3.X - OriP4.X)) * (m_stcBlobPad.fWidthPercentEnd10 / 100))),
                                (float)(OriP3.Y + ((Math.Abs(OriP1.Y - OriP3.Y) * m_stcBlobPad.fHeightPercentEnd10 / 100))), Angle, ref RotatedX2, ref RotatedY2);

                            g.DrawLine(new Pen(Color.Wheat, 2),
                                 (int)RotatedX1 * fDrawingScaleX,
                                 (int)RotatedY1 * fDrawingScaleY,
                                 (int)RotatedX2 * fDrawingScaleX,
                                 (int)RotatedY2 * fDrawingScaleY);

                            break;
                        case 11:
                            Math2.RotateWithAngleAccordingToReferencePoint(intRoiOrgX + m_stcBlobPad.fFeretCenterX, intRoiOrgY + m_stcBlobPad.fFeretCenterY,
                        (float)(((OriP1.X + OriP2.X) / 2) + (((Math.Abs(OriP1.X - OriP2.X) / 2) / (m_stcBlobPad.intLineCount - 9))) + (int)((Math.Abs(OriP1.X - OriP2.X)) * (m_stcBlobPad.fWidthPercentStart3 / 100))),
                        (float)(OriP1.Y + ((Math.Abs(OriP1.Y - OriP3.Y) * m_stcBlobPad.fHeightPercentStart3 / 100))), Angle, ref RotatedX1, ref RotatedY1);

                            Math2.RotateWithAngleAccordingToReferencePoint(intRoiOrgX + m_stcBlobPad.fFeretCenterX, intRoiOrgY + m_stcBlobPad.fFeretCenterY,
                                (float)(((OriP3.X + OriP4.X) / 2) + ((Math.Abs(OriP3.X - OriP4.X) / 2) / (m_stcBlobPad.intLineCount - 9)) + (int)((Math.Abs(OriP3.X - OriP4.X)) * (m_stcBlobPad.fWidthPercentEnd3 / 100))),
                                (float)(OriP3.Y + ((Math.Abs(OriP1.Y - OriP3.Y) * m_stcBlobPad.fHeightPercentEnd3 / 100))), Angle, ref RotatedX2, ref RotatedY2);

                            g.DrawLine(new Pen(Color.Red, 2),
                                 (int)RotatedX1 * fDrawingScaleX,
                                 (int)RotatedY1 * fDrawingScaleY,
                                 (int)RotatedX2 * fDrawingScaleX,
                                 (int)RotatedY2 * fDrawingScaleY);

                            Math2.RotateWithAngleAccordingToReferencePoint(intRoiOrgX + m_stcBlobPad.fFeretCenterX, intRoiOrgY + m_stcBlobPad.fFeretCenterY,
                             (float)(((OriP1.X + OriP2.X) / 2) + (((Math.Abs(OriP1.X - OriP2.X) / 2) / (m_stcBlobPad.intLineCount - 8))) + (int)((Math.Abs(OriP1.X - OriP2.X)) * (m_stcBlobPad.fWidthPercentStart4 / 100))),
                             (float)(OriP1.Y + ((Math.Abs(OriP1.Y - OriP3.Y) * m_stcBlobPad.fHeightPercentStart4 / 100))), Angle, ref RotatedX1, ref RotatedY1);

                            Math2.RotateWithAngleAccordingToReferencePoint(intRoiOrgX + m_stcBlobPad.fFeretCenterX, intRoiOrgY + m_stcBlobPad.fFeretCenterY,
                                (float)(((OriP3.X + OriP4.X) / 2) + ((Math.Abs(OriP3.X - OriP4.X) / 2) / (m_stcBlobPad.intLineCount - 8)) + (int)((Math.Abs(OriP3.X - OriP4.X)) * (m_stcBlobPad.fWidthPercentEnd4 / 100))),
                                (float)(OriP3.Y + ((Math.Abs(OriP1.Y - OriP3.Y) * m_stcBlobPad.fHeightPercentEnd4 / 100))), Angle, ref RotatedX2, ref RotatedY2);

                            g.DrawLine(new Pen(Color.Yellow, 2),
                                 (int)RotatedX1 * fDrawingScaleX,
                                 (int)RotatedY1 * fDrawingScaleY,
                                 (int)RotatedX2 * fDrawingScaleX,
                                 (int)RotatedY2 * fDrawingScaleY);

                            Math2.RotateWithAngleAccordingToReferencePoint(intRoiOrgX + m_stcBlobPad.fFeretCenterX, intRoiOrgY + m_stcBlobPad.fFeretCenterY,
                            (float)(((OriP1.X + OriP2.X) / 2) + (((Math.Abs(OriP1.X - OriP2.X) / 2) / (m_stcBlobPad.intLineCount - 7))) + (int)((Math.Abs(OriP1.X - OriP2.X)) * (m_stcBlobPad.fWidthPercentStart5 / 100))),
                            (float)(OriP1.Y + ((Math.Abs(OriP1.Y - OriP3.Y) * m_stcBlobPad.fHeightPercentStart5 / 100))), Angle, ref RotatedX1, ref RotatedY1);

                            Math2.RotateWithAngleAccordingToReferencePoint(intRoiOrgX + m_stcBlobPad.fFeretCenterX, intRoiOrgY + m_stcBlobPad.fFeretCenterY,
                                (float)(((OriP3.X + OriP4.X) / 2) + ((Math.Abs(OriP3.X - OriP4.X) / 2) / (m_stcBlobPad.intLineCount - 7)) + (int)((Math.Abs(OriP3.X - OriP4.X)) * (m_stcBlobPad.fWidthPercentEnd5 / 100))),
                                (float)(OriP3.Y + ((Math.Abs(OriP1.Y - OriP3.Y) * m_stcBlobPad.fHeightPercentEnd5 / 100))), Angle, ref RotatedX2, ref RotatedY2);

                            g.DrawLine(new Pen(Color.Pink, 2),
                                 (int)RotatedX1 * fDrawingScaleX,
                                 (int)RotatedY1 * fDrawingScaleY,
                                 (int)RotatedX2 * fDrawingScaleX,
                                 (int)RotatedY2 * fDrawingScaleY);

                            Math2.RotateWithAngleAccordingToReferencePoint(intRoiOrgX + m_stcBlobPad.fFeretCenterX, intRoiOrgY + m_stcBlobPad.fFeretCenterY,
                       (float)(((OriP1.X + OriP2.X) / 2) + (((Math.Abs(OriP1.X - OriP2.X) / 2) / (m_stcBlobPad.intLineCount - 6))) + (int)((Math.Abs(OriP1.X - OriP2.X)) * (m_stcBlobPad.fWidthPercentStart6 / 100))),
                       (float)(OriP1.Y + ((Math.Abs(OriP1.Y - OriP3.Y) * m_stcBlobPad.fHeightPercentStart6 / 100))), Angle, ref RotatedX1, ref RotatedY1);

                            Math2.RotateWithAngleAccordingToReferencePoint(intRoiOrgX + m_stcBlobPad.fFeretCenterX, intRoiOrgY + m_stcBlobPad.fFeretCenterY,
                                (float)(((OriP3.X + OriP4.X) / 2) + ((Math.Abs(OriP3.X - OriP4.X) / 2) / (m_stcBlobPad.intLineCount - 6)) + (int)((Math.Abs(OriP3.X - OriP4.X)) * (m_stcBlobPad.fWidthPercentEnd6 / 100))),
                                (float)(OriP3.Y + ((Math.Abs(OriP1.Y - OriP3.Y) * m_stcBlobPad.fHeightPercentEnd6 / 100))), Angle, ref RotatedX2, ref RotatedY2);

                            g.DrawLine(new Pen(Color.Orange, 2),
                                 (int)RotatedX1 * fDrawingScaleX,
                                 (int)RotatedY1 * fDrawingScaleY,
                                 (int)RotatedX2 * fDrawingScaleX,
                                 (int)RotatedY2 * fDrawingScaleY);

                            Math2.RotateWithAngleAccordingToReferencePoint(intRoiOrgX + m_stcBlobPad.fFeretCenterX, intRoiOrgY + m_stcBlobPad.fFeretCenterY,
                     (float)(((OriP1.X + OriP2.X) / 2) + (((Math.Abs(OriP1.X - OriP2.X) / 2) / (m_stcBlobPad.intLineCount - 5))) + (int)((Math.Abs(OriP1.X - OriP2.X)) * (m_stcBlobPad.fWidthPercentStart7 / 100))),
                     (float)(OriP1.Y + ((Math.Abs(OriP1.Y - OriP3.Y) * m_stcBlobPad.fHeightPercentStart7 / 100))), Angle, ref RotatedX1, ref RotatedY1);

                            Math2.RotateWithAngleAccordingToReferencePoint(intRoiOrgX + m_stcBlobPad.fFeretCenterX, intRoiOrgY + m_stcBlobPad.fFeretCenterY,
                                (float)(((OriP3.X + OriP4.X) / 2) + ((Math.Abs(OriP3.X - OriP4.X) / 2) / (m_stcBlobPad.intLineCount - 5)) + (int)((Math.Abs(OriP3.X - OriP4.X)) * (m_stcBlobPad.fWidthPercentEnd7 / 100))),
                                (float)(OriP3.Y + ((Math.Abs(OriP1.Y - OriP3.Y) * m_stcBlobPad.fHeightPercentEnd7 / 100))), Angle, ref RotatedX2, ref RotatedY2);

                            g.DrawLine(new Pen(Color.Cyan, 2),
                                 (int)RotatedX1 * fDrawingScaleX,
                                 (int)RotatedY1 * fDrawingScaleY,
                                 (int)RotatedX2 * fDrawingScaleX,
                                 (int)RotatedY2 * fDrawingScaleY);

                            Math2.RotateWithAngleAccordingToReferencePoint(intRoiOrgX + m_stcBlobPad.fFeretCenterX, intRoiOrgY + m_stcBlobPad.fFeretCenterY,
                     (float)(((OriP1.X + OriP2.X) / 2) + (((Math.Abs(OriP1.X - OriP2.X) / 2) / (m_stcBlobPad.intLineCount - 4))) + (int)((Math.Abs(OriP1.X - OriP2.X)) * (m_stcBlobPad.fWidthPercentStart8 / 100))),
                     (float)(OriP1.Y + ((Math.Abs(OriP1.Y - OriP3.Y) * m_stcBlobPad.fHeightPercentStart8 / 100))), Angle, ref RotatedX1, ref RotatedY1);

                            Math2.RotateWithAngleAccordingToReferencePoint(intRoiOrgX + m_stcBlobPad.fFeretCenterX, intRoiOrgY + m_stcBlobPad.fFeretCenterY,
                                (float)(((OriP3.X + OriP4.X) / 2) + ((Math.Abs(OriP3.X - OriP4.X) / 2) / (m_stcBlobPad.intLineCount - 4)) + (int)((Math.Abs(OriP3.X - OriP4.X)) * (m_stcBlobPad.fWidthPercentEnd8 / 100))),
                                (float)(OriP3.Y + ((Math.Abs(OriP1.Y - OriP3.Y) * m_stcBlobPad.fHeightPercentEnd8 / 100))), Angle, ref RotatedX2, ref RotatedY2);

                            g.DrawLine(new Pen(Color.Magenta, 2),
                                 (int)RotatedX1 * fDrawingScaleX,
                                 (int)RotatedY1 * fDrawingScaleY,
                                 (int)RotatedX2 * fDrawingScaleX,
                                 (int)RotatedY2 * fDrawingScaleY);

                            Math2.RotateWithAngleAccordingToReferencePoint(intRoiOrgX + m_stcBlobPad.fFeretCenterX, intRoiOrgY + m_stcBlobPad.fFeretCenterY,
                     (float)(((OriP1.X + OriP2.X) / 2) + (((Math.Abs(OriP1.X - OriP2.X) / 2) / (m_stcBlobPad.intLineCount - 3))) + (int)((Math.Abs(OriP1.X - OriP2.X)) * (m_stcBlobPad.fWidthPercentStart9 / 100))),
                     (float)(OriP1.Y + ((Math.Abs(OriP1.Y - OriP3.Y) * m_stcBlobPad.fHeightPercentStart9 / 100))), Angle, ref RotatedX1, ref RotatedY1);

                            Math2.RotateWithAngleAccordingToReferencePoint(intRoiOrgX + m_stcBlobPad.fFeretCenterX, intRoiOrgY + m_stcBlobPad.fFeretCenterY,
                                (float)(((OriP3.X + OriP4.X) / 2) + ((Math.Abs(OriP3.X - OriP4.X) / 2) / (m_stcBlobPad.intLineCount - 3)) + (int)((Math.Abs(OriP3.X - OriP4.X)) * (m_stcBlobPad.fWidthPercentEnd9 / 100))),
                                (float)(OriP3.Y + ((Math.Abs(OriP1.Y - OriP3.Y) * m_stcBlobPad.fHeightPercentEnd9 / 100))), Angle, ref RotatedX2, ref RotatedY2);

                            g.DrawLine(new Pen(Color.Silver, 2),
                                 (int)RotatedX1 * fDrawingScaleX,
                                 (int)RotatedY1 * fDrawingScaleY,
                                 (int)RotatedX2 * fDrawingScaleX,
                                 (int)RotatedY2 * fDrawingScaleY);

                            Math2.RotateWithAngleAccordingToReferencePoint(intRoiOrgX + m_stcBlobPad.fFeretCenterX, intRoiOrgY + m_stcBlobPad.fFeretCenterY,
                     (float)(((OriP1.X + OriP2.X) / 2) + (((Math.Abs(OriP1.X - OriP2.X) / 2) / (m_stcBlobPad.intLineCount - 2))) + (int)((Math.Abs(OriP1.X - OriP2.X)) * (m_stcBlobPad.fWidthPercentStart10 / 100))),
                     (float)(OriP1.Y + ((Math.Abs(OriP1.Y - OriP3.Y) * m_stcBlobPad.fHeightPercentStart10 / 100))), Angle, ref RotatedX1, ref RotatedY1);

                            Math2.RotateWithAngleAccordingToReferencePoint(intRoiOrgX + m_stcBlobPad.fFeretCenterX, intRoiOrgY + m_stcBlobPad.fFeretCenterY,
                                (float)(((OriP3.X + OriP4.X) / 2) + ((Math.Abs(OriP3.X - OriP4.X) / 2) / (m_stcBlobPad.intLineCount - 2)) + (int)((Math.Abs(OriP3.X - OriP4.X)) * (m_stcBlobPad.fWidthPercentEnd10 / 100))),
                                (float)(OriP3.Y + ((Math.Abs(OriP1.Y - OriP3.Y) * m_stcBlobPad.fHeightPercentEnd10 / 100))), Angle, ref RotatedX2, ref RotatedY2);

                            g.DrawLine(new Pen(Color.Wheat, 2),
                                 (int)RotatedX1 * fDrawingScaleX,
                                 (int)RotatedY1 * fDrawingScaleY,
                                 (int)RotatedX2 * fDrawingScaleX,
                                 (int)RotatedY2 * fDrawingScaleY);

                            Math2.RotateWithAngleAccordingToReferencePoint(intRoiOrgX + m_stcBlobPad.fFeretCenterX, intRoiOrgY + m_stcBlobPad.fFeretCenterY,
                     (float)(((OriP1.X + OriP2.X) / 2) + (((Math.Abs(OriP1.X - OriP2.X) / 2) / (m_stcBlobPad.intLineCount - 1))) + (int)((Math.Abs(OriP1.X - OriP2.X)) * (m_stcBlobPad.fWidthPercentStart11 / 100))),
                     (float)(OriP1.Y + ((Math.Abs(OriP1.Y - OriP3.Y) * m_stcBlobPad.fHeightPercentStart11 / 100))), Angle, ref RotatedX1, ref RotatedY1);

                            Math2.RotateWithAngleAccordingToReferencePoint(intRoiOrgX + m_stcBlobPad.fFeretCenterX, intRoiOrgY + m_stcBlobPad.fFeretCenterY,
                                (float)(((OriP3.X + OriP4.X) / 2) + ((Math.Abs(OriP3.X - OriP4.X) / 2) / (m_stcBlobPad.intLineCount - 1)) + (int)((Math.Abs(OriP3.X - OriP4.X)) * (m_stcBlobPad.fWidthPercentEnd11 / 100))),
                                (float)(OriP3.Y + ((Math.Abs(OriP1.Y - OriP3.Y) * m_stcBlobPad.fHeightPercentEnd11 / 100))), Angle, ref RotatedX2, ref RotatedY2);

                            g.DrawLine(new Pen(Color.DarkGoldenrod, 2),
                                 (int)RotatedX1 * fDrawingScaleX,
                                 (int)RotatedY1 * fDrawingScaleY,
                                 (int)RotatedX2 * fDrawingScaleX,
                                 (int)RotatedY2 * fDrawingScaleY);

                            break;
                        case 12:
                            Math2.RotateWithAngleAccordingToReferencePoint(intRoiOrgX + m_stcBlobPad.fFeretCenterX, intRoiOrgY + m_stcBlobPad.fFeretCenterY,
                        (float)(((OriP1.X + OriP2.X) / 2) + (((Math.Abs(OriP1.X - OriP2.X) / 2) / (m_stcBlobPad.intLineCount - 10))) + (int)((Math.Abs(OriP1.X - OriP2.X)) * (m_stcBlobPad.fWidthPercentStart3 / 100))),
                        (float)(OriP1.Y + ((Math.Abs(OriP1.Y - OriP3.Y) * m_stcBlobPad.fHeightPercentStart3 / 100))), Angle, ref RotatedX1, ref RotatedY1);

                            Math2.RotateWithAngleAccordingToReferencePoint(intRoiOrgX + m_stcBlobPad.fFeretCenterX, intRoiOrgY + m_stcBlobPad.fFeretCenterY,
                                (float)(((OriP3.X + OriP4.X) / 2) + ((Math.Abs(OriP3.X - OriP4.X) / 2) / (m_stcBlobPad.intLineCount - 10)) + (int)((Math.Abs(OriP3.X - OriP4.X)) * (m_stcBlobPad.fWidthPercentEnd3 / 100))),
                                (float)(OriP3.Y + ((Math.Abs(OriP1.Y - OriP3.Y) * m_stcBlobPad.fHeightPercentEnd3 / 100))), Angle, ref RotatedX2, ref RotatedY2);

                            g.DrawLine(new Pen(Color.Red, 2),
                                 (int)RotatedX1 * fDrawingScaleX,
                                 (int)RotatedY1 * fDrawingScaleY,
                                 (int)RotatedX2 * fDrawingScaleX,
                                 (int)RotatedY2 * fDrawingScaleY);

                            Math2.RotateWithAngleAccordingToReferencePoint(intRoiOrgX + m_stcBlobPad.fFeretCenterX, intRoiOrgY + m_stcBlobPad.fFeretCenterY,
                             (float)(((OriP1.X + OriP2.X) / 2) + (((Math.Abs(OriP1.X - OriP2.X) / 2) / (m_stcBlobPad.intLineCount - 9))) + (int)((Math.Abs(OriP1.X - OriP2.X)) * (m_stcBlobPad.fWidthPercentStart4 / 100))),
                             (float)(OriP1.Y + ((Math.Abs(OriP1.Y - OriP3.Y) * m_stcBlobPad.fHeightPercentStart4 / 100))), Angle, ref RotatedX1, ref RotatedY1);

                            Math2.RotateWithAngleAccordingToReferencePoint(intRoiOrgX + m_stcBlobPad.fFeretCenterX, intRoiOrgY + m_stcBlobPad.fFeretCenterY,
                                (float)(((OriP3.X + OriP4.X) / 2) + ((Math.Abs(OriP3.X - OriP4.X) / 2) / (m_stcBlobPad.intLineCount - 9)) + (int)((Math.Abs(OriP3.X - OriP4.X)) * (m_stcBlobPad.fWidthPercentEnd4 / 100))),
                                (float)(OriP3.Y + ((Math.Abs(OriP1.Y - OriP3.Y) * m_stcBlobPad.fHeightPercentEnd4 / 100))), Angle, ref RotatedX2, ref RotatedY2);

                            g.DrawLine(new Pen(Color.Yellow, 2),
                                 (int)RotatedX1 * fDrawingScaleX,
                                 (int)RotatedY1 * fDrawingScaleY,
                                 (int)RotatedX2 * fDrawingScaleX,
                                 (int)RotatedY2 * fDrawingScaleY);

                            Math2.RotateWithAngleAccordingToReferencePoint(intRoiOrgX + m_stcBlobPad.fFeretCenterX, intRoiOrgY + m_stcBlobPad.fFeretCenterY,
                            (float)(((OriP1.X + OriP2.X) / 2) + (((Math.Abs(OriP1.X - OriP2.X) / 2) / (m_stcBlobPad.intLineCount - 8))) + (int)((Math.Abs(OriP1.X - OriP2.X)) * (m_stcBlobPad.fWidthPercentStart5 / 100))),
                            (float)(OriP1.Y + ((Math.Abs(OriP1.Y - OriP3.Y) * m_stcBlobPad.fHeightPercentStart5 / 100))), Angle, ref RotatedX1, ref RotatedY1);

                            Math2.RotateWithAngleAccordingToReferencePoint(intRoiOrgX + m_stcBlobPad.fFeretCenterX, intRoiOrgY + m_stcBlobPad.fFeretCenterY,
                                (float)(((OriP3.X + OriP4.X) / 2) + ((Math.Abs(OriP3.X - OriP4.X) / 2) / (m_stcBlobPad.intLineCount - 8)) + (int)((Math.Abs(OriP3.X - OriP4.X)) * (m_stcBlobPad.fWidthPercentEnd5 / 100))),
                                (float)(OriP3.Y + ((Math.Abs(OriP1.Y - OriP3.Y) * m_stcBlobPad.fHeightPercentEnd5 / 100))), Angle, ref RotatedX2, ref RotatedY2);

                            g.DrawLine(new Pen(Color.Pink, 2),
                                 (int)RotatedX1 * fDrawingScaleX,
                                 (int)RotatedY1 * fDrawingScaleY,
                                 (int)RotatedX2 * fDrawingScaleX,
                                 (int)RotatedY2 * fDrawingScaleY);

                            Math2.RotateWithAngleAccordingToReferencePoint(intRoiOrgX + m_stcBlobPad.fFeretCenterX, intRoiOrgY + m_stcBlobPad.fFeretCenterY,
                       (float)(((OriP1.X + OriP2.X) / 2) + (((Math.Abs(OriP1.X - OriP2.X) / 2) / (m_stcBlobPad.intLineCount - 7))) + (int)((Math.Abs(OriP1.X - OriP2.X)) * (m_stcBlobPad.fWidthPercentStart6 / 100))),
                       (float)(OriP1.Y + ((Math.Abs(OriP1.Y - OriP3.Y) * m_stcBlobPad.fHeightPercentStart6 / 100))), Angle, ref RotatedX1, ref RotatedY1);

                            Math2.RotateWithAngleAccordingToReferencePoint(intRoiOrgX + m_stcBlobPad.fFeretCenterX, intRoiOrgY + m_stcBlobPad.fFeretCenterY,
                                (float)(((OriP3.X + OriP4.X) / 2) + ((Math.Abs(OriP3.X - OriP4.X) / 2) / (m_stcBlobPad.intLineCount - 7)) + (int)((Math.Abs(OriP3.X - OriP4.X)) * (m_stcBlobPad.fWidthPercentEnd6 / 100))),
                                (float)(OriP3.Y + ((Math.Abs(OriP1.Y - OriP3.Y) * m_stcBlobPad.fHeightPercentEnd6 / 100))), Angle, ref RotatedX2, ref RotatedY2);

                            g.DrawLine(new Pen(Color.Orange, 2),
                                 (int)RotatedX1 * fDrawingScaleX,
                                 (int)RotatedY1 * fDrawingScaleY,
                                 (int)RotatedX2 * fDrawingScaleX,
                                 (int)RotatedY2 * fDrawingScaleY);

                            Math2.RotateWithAngleAccordingToReferencePoint(intRoiOrgX + m_stcBlobPad.fFeretCenterX, intRoiOrgY + m_stcBlobPad.fFeretCenterY,
                     (float)(((OriP1.X + OriP2.X) / 2) + (((Math.Abs(OriP1.X - OriP2.X) / 2) / (m_stcBlobPad.intLineCount - 6))) + (int)((Math.Abs(OriP1.X - OriP2.X)) * (m_stcBlobPad.fWidthPercentStart7 / 100))),
                     (float)(OriP1.Y + ((Math.Abs(OriP1.Y - OriP3.Y) * m_stcBlobPad.fHeightPercentStart7 / 100))), Angle, ref RotatedX1, ref RotatedY1);

                            Math2.RotateWithAngleAccordingToReferencePoint(intRoiOrgX + m_stcBlobPad.fFeretCenterX, intRoiOrgY + m_stcBlobPad.fFeretCenterY,
                                (float)(((OriP3.X + OriP4.X) / 2) + ((Math.Abs(OriP3.X - OriP4.X) / 2) / (m_stcBlobPad.intLineCount - 6)) + (int)((Math.Abs(OriP3.X - OriP4.X)) * (m_stcBlobPad.fWidthPercentEnd7 / 100))),
                                (float)(OriP3.Y + ((Math.Abs(OriP1.Y - OriP3.Y) * m_stcBlobPad.fHeightPercentEnd7 / 100))), Angle, ref RotatedX2, ref RotatedY2);

                            g.DrawLine(new Pen(Color.Cyan, 2),
                                 (int)RotatedX1 * fDrawingScaleX,
                                 (int)RotatedY1 * fDrawingScaleY,
                                 (int)RotatedX2 * fDrawingScaleX,
                                 (int)RotatedY2 * fDrawingScaleY);

                            Math2.RotateWithAngleAccordingToReferencePoint(intRoiOrgX + m_stcBlobPad.fFeretCenterX, intRoiOrgY + m_stcBlobPad.fFeretCenterY,
                     (float)(((OriP1.X + OriP2.X) / 2) + (((Math.Abs(OriP1.X - OriP2.X) / 2) / (m_stcBlobPad.intLineCount - 5))) + (int)((Math.Abs(OriP1.X - OriP2.X)) * (m_stcBlobPad.fWidthPercentStart8 / 100))),
                     (float)(OriP1.Y + ((Math.Abs(OriP1.Y - OriP3.Y) * m_stcBlobPad.fHeightPercentStart8 / 100))), Angle, ref RotatedX1, ref RotatedY1);

                            Math2.RotateWithAngleAccordingToReferencePoint(intRoiOrgX + m_stcBlobPad.fFeretCenterX, intRoiOrgY + m_stcBlobPad.fFeretCenterY,
                                (float)(((OriP3.X + OriP4.X) / 2) + ((Math.Abs(OriP3.X - OriP4.X) / 2) / (m_stcBlobPad.intLineCount - 5)) + (int)((Math.Abs(OriP3.X - OriP4.X)) * (m_stcBlobPad.fWidthPercentEnd8 / 100))),
                                (float)(OriP3.Y + ((Math.Abs(OriP1.Y - OriP3.Y) * m_stcBlobPad.fHeightPercentEnd8 / 100))), Angle, ref RotatedX2, ref RotatedY2);

                            g.DrawLine(new Pen(Color.Magenta, 2),
                                 (int)RotatedX1 * fDrawingScaleX,
                                 (int)RotatedY1 * fDrawingScaleY,
                                 (int)RotatedX2 * fDrawingScaleX,
                                 (int)RotatedY2 * fDrawingScaleY);

                            Math2.RotateWithAngleAccordingToReferencePoint(intRoiOrgX + m_stcBlobPad.fFeretCenterX, intRoiOrgY + m_stcBlobPad.fFeretCenterY,
                     (float)(((OriP1.X + OriP2.X) / 2) + (((Math.Abs(OriP1.X - OriP2.X) / 2) / (m_stcBlobPad.intLineCount - 4))) + (int)((Math.Abs(OriP1.X - OriP2.X)) * (m_stcBlobPad.fWidthPercentStart9 / 100))),
                     (float)(OriP1.Y + ((Math.Abs(OriP1.Y - OriP3.Y) * m_stcBlobPad.fHeightPercentStart9 / 100))), Angle, ref RotatedX1, ref RotatedY1);

                            Math2.RotateWithAngleAccordingToReferencePoint(intRoiOrgX + m_stcBlobPad.fFeretCenterX, intRoiOrgY + m_stcBlobPad.fFeretCenterY,
                                (float)(((OriP3.X + OriP4.X) / 2) + ((Math.Abs(OriP3.X - OriP4.X) / 2) / (m_stcBlobPad.intLineCount - 4)) + (int)((Math.Abs(OriP3.X - OriP4.X)) * (m_stcBlobPad.fWidthPercentEnd9 / 100))),
                                (float)(OriP3.Y + ((Math.Abs(OriP1.Y - OriP3.Y) * m_stcBlobPad.fHeightPercentEnd9 / 100))), Angle, ref RotatedX2, ref RotatedY2);

                            g.DrawLine(new Pen(Color.Silver, 2),
                                 (int)RotatedX1 * fDrawingScaleX,
                                 (int)RotatedY1 * fDrawingScaleY,
                                 (int)RotatedX2 * fDrawingScaleX,
                                 (int)RotatedY2 * fDrawingScaleY);

                            Math2.RotateWithAngleAccordingToReferencePoint(intRoiOrgX + m_stcBlobPad.fFeretCenterX, intRoiOrgY + m_stcBlobPad.fFeretCenterY,
                     (float)(((OriP1.X + OriP2.X) / 2) + (((Math.Abs(OriP1.X - OriP2.X) / 2) / (m_stcBlobPad.intLineCount - 3))) + (int)((Math.Abs(OriP1.X - OriP2.X)) * (m_stcBlobPad.fWidthPercentStart10 / 100))),
                     (float)(OriP1.Y + ((Math.Abs(OriP1.Y - OriP3.Y) * m_stcBlobPad.fHeightPercentStart10 / 100))), Angle, ref RotatedX1, ref RotatedY1);

                            Math2.RotateWithAngleAccordingToReferencePoint(intRoiOrgX + m_stcBlobPad.fFeretCenterX, intRoiOrgY + m_stcBlobPad.fFeretCenterY,
                                (float)(((OriP3.X + OriP4.X) / 2) + ((Math.Abs(OriP3.X - OriP4.X) / 2) / (m_stcBlobPad.intLineCount - 3)) + (int)((Math.Abs(OriP3.X - OriP4.X)) * (m_stcBlobPad.fWidthPercentEnd10 / 100))),
                                (float)(OriP3.Y + ((Math.Abs(OriP1.Y - OriP3.Y) * m_stcBlobPad.fHeightPercentEnd10 / 100))), Angle, ref RotatedX2, ref RotatedY2);

                            g.DrawLine(new Pen(Color.Wheat, 2),
                                 (int)RotatedX1 * fDrawingScaleX,
                                 (int)RotatedY1 * fDrawingScaleY,
                                 (int)RotatedX2 * fDrawingScaleX,
                                 (int)RotatedY2 * fDrawingScaleY);

                            Math2.RotateWithAngleAccordingToReferencePoint(intRoiOrgX + m_stcBlobPad.fFeretCenterX, intRoiOrgY + m_stcBlobPad.fFeretCenterY,
                     (float)(((OriP1.X + OriP2.X) / 2) + (((Math.Abs(OriP1.X - OriP2.X) / 2) / (m_stcBlobPad.intLineCount - 2))) + (int)((Math.Abs(OriP1.X - OriP2.X)) * (m_stcBlobPad.fWidthPercentStart11 / 100))),
                     (float)(OriP1.Y + ((Math.Abs(OriP1.Y - OriP3.Y) * m_stcBlobPad.fHeightPercentStart11 / 100))), Angle, ref RotatedX1, ref RotatedY1);

                            Math2.RotateWithAngleAccordingToReferencePoint(intRoiOrgX + m_stcBlobPad.fFeretCenterX, intRoiOrgY + m_stcBlobPad.fFeretCenterY,
                                (float)(((OriP3.X + OriP4.X) / 2) + ((Math.Abs(OriP3.X - OriP4.X) / 2) / (m_stcBlobPad.intLineCount - 2)) + (int)((Math.Abs(OriP3.X - OriP4.X)) * (m_stcBlobPad.fWidthPercentEnd11 / 100))),
                                (float)(OriP3.Y + ((Math.Abs(OriP1.Y - OriP3.Y) * m_stcBlobPad.fHeightPercentEnd11 / 100))), Angle, ref RotatedX2, ref RotatedY2);

                            g.DrawLine(new Pen(Color.DarkGoldenrod, 2),
                                 (int)RotatedX1 * fDrawingScaleX,
                                 (int)RotatedY1 * fDrawingScaleY,
                                 (int)RotatedX2 * fDrawingScaleX,
                                 (int)RotatedY2 * fDrawingScaleY);

                            Math2.RotateWithAngleAccordingToReferencePoint(intRoiOrgX + m_stcBlobPad.fFeretCenterX, intRoiOrgY + m_stcBlobPad.fFeretCenterY,
                     (float)(((OriP1.X + OriP2.X) / 2) + (((Math.Abs(OriP1.X - OriP2.X) / 2) / (m_stcBlobPad.intLineCount - 1))) + (int)((Math.Abs(OriP1.X - OriP2.X)) * (m_stcBlobPad.fWidthPercentStart12 / 100))),
                     (float)(OriP1.Y + ((Math.Abs(OriP1.Y - OriP3.Y) * m_stcBlobPad.fHeightPercentStart12 / 100))), Angle, ref RotatedX1, ref RotatedY1);

                            Math2.RotateWithAngleAccordingToReferencePoint(intRoiOrgX + m_stcBlobPad.fFeretCenterX, intRoiOrgY + m_stcBlobPad.fFeretCenterY,
                                (float)(((OriP3.X + OriP4.X) / 2) + ((Math.Abs(OriP3.X - OriP4.X) / 2) / (m_stcBlobPad.intLineCount - 1)) + (int)((Math.Abs(OriP3.X - OriP4.X)) * (m_stcBlobPad.fWidthPercentEnd12 / 100))),
                                (float)(OriP3.Y + ((Math.Abs(OriP1.Y - OriP3.Y) * m_stcBlobPad.fHeightPercentEnd12 / 100))), Angle, ref RotatedX2, ref RotatedY2);

                            g.DrawLine(new Pen(Color.MediumSeaGreen, 2),
                                 (int)RotatedX1 * fDrawingScaleX,
                                 (int)RotatedY1 * fDrawingScaleY,
                                 (int)RotatedX2 * fDrawingScaleX,
                                 (int)RotatedY2 * fDrawingScaleY);

                            break;
                    }
                }
                else
                {
                    float fStartX, fEndX, fStartY, fEndY, fX_Start, fX_End, fY_Start, fY_End, fStartX_Draw, fStartY_Draw, fEndX_Draw, fEndY_Draw;
                    

                    // Draw horizontal and vertical dimension line
                    if (m_stcBlobPad.intLengthMode == 1)
                    {
                        //g.DrawLine(new Pen(Color.Blue, 2), p1.X, (int)((p1.Y + p3.Y) / 2) + (int)((Math.Abs(p1.Y - p3.Y)) * (m_stcBlobPad.fHeightPercentStart2 / 100)), p2.X, (int)((p2.Y + p4.Y) / 2) + (int)((Math.Abs(p2.Y - p4.Y)) * (m_stcBlobPad.fHeightPercentEnd2 / 100))); //g.DrawLine(new Pen(Color.Blue, 2), p1.X, (p1.Y + p4.Y) / 2, p2.X, (p2.Y + p3.Y) / 2);
                        //g.DrawLine(new Pen(Color.Lime, 2), (int)((p1.X + p2.X) / 2) + (int)((Math.Abs(p1.X - p2.X)) * (m_stcBlobPad.fWidthPercentStart1 / 100)), p1.Y, (int)((p3.X + p4.X) / 2) + (int)((Math.Abs(p3.X - p4.X)) * (m_stcBlobPad.fWidthPercentEnd1 / 100)), p3.Y); // g.DrawLine(new Pen(Color.Lime, 2), (p1.X + p2.X) / 2, p1.Y, (p3.X + p4.X) / 2, p3.Y);


                        //g.DrawLine(new Pen(Color.Blue, 2), p1.X + (int)((Math.Abs(p1.X - p2.X)) * (m_stcBlobPad.fWidthPercentStart2 / 100)), (int)((p1.Y + p3.Y) / 2) + (int)((Math.Abs(p1.Y - p3.Y)) * (m_stcBlobPad.fHeightPercentStart2 / 100)), p2.X + (int)((Math.Abs(p1.X - p2.X)) * (m_stcBlobPad.fWidthPercentEnd2 / 100)), (int)((p2.Y + p4.Y) / 2) + (int)((Math.Abs(p2.Y - p4.Y)) * (m_stcBlobPad.fHeightPercentEnd2 / 100)));
                        //g.DrawLine(new Pen(Color.Lime, 2), (int)((p1.X + p2.X) / 2) + (int)((Math.Abs(p1.X - p2.X)) * (m_stcBlobPad.fWidthPercentStart1 / 100)), p1.Y + (int)((Math.Abs(p1.Y - p3.Y)) * (m_stcBlobPad.fHeightPercentStart1 / 100)), (int)((p3.X + p4.X) / 2) + (int)((Math.Abs(p3.X - p4.X)) * (m_stcBlobPad.fWidthPercentEnd1 / 100)), p3.Y + (int)((Math.Abs(p2.Y - p4.Y)) * (m_stcBlobPad.fHeightPercentEnd1 / 100)));

                        fStartX = p1.X + (int)((Math.Abs(p1.X - p2.X)) * (m_stcBlobPad.fWidthPercentStart2 / 100));
                        fStartY = (int)((p1.Y + p3.Y) / 2) + (int)((Math.Abs(p1.Y - p3.Y)) * (m_stcBlobPad.fHeightPercentStart2 / 100));
                        fEndX = p2.X + (int)((Math.Abs(p1.X - p2.X)) * (m_stcBlobPad.fWidthPercentEnd2 / 100));
                        fEndY = (int)((p2.Y + p4.Y) / 2) + (int)((Math.Abs(p2.Y - p4.Y)) * (m_stcBlobPad.fHeightPercentEnd2 / 100));

                        fX_Start = Math.Abs(fStartX - fEndX) * (m_stcBlobPad.fInwardPercentStart2 / 100);
                        fX_End = Math.Abs(fStartX - fEndX) * (m_stcBlobPad.fInwardPercentEnd2 / 100);
                        fY_Start = Math.Abs(fStartY - fEndY) * (m_stcBlobPad.fInwardPercentStart2 / 100);
                        fY_End = Math.Abs(fStartY - fEndY) * (m_stcBlobPad.fInwardPercentEnd2 / 100);

                        fStartX_Draw = fStartX + fX_Start;
                        fStartY_Draw = fStartY + fY_Start;
                        fEndX_Draw = fEndX - fX_End;
                        fEndY_Draw = fEndY - fY_End;
                        if (fStartX > fEndX)
                        {
                            fStartX_Draw = fStartX - fX_Start;
                            fEndX_Draw = fEndX + fX_End;
                        }
                        if (fStartY > fEndY)
                        {
                            fStartY_Draw = fStartY - fY_Start;
                            fEndY_Draw = fEndY + fY_End;
                        }

                        g.DrawLine(new Pen(Color.Blue, 2), fStartX_Draw, fStartY_Draw, fEndX_Draw, fEndY_Draw);


                        fStartX = (int)((p1.X + p2.X) / 2) + (int)((Math.Abs(p1.X - p2.X)) * (m_stcBlobPad.fWidthPercentStart1 / 100));
                        fStartY = p1.Y + (int)((Math.Abs(p1.Y - p3.Y)) * (m_stcBlobPad.fHeightPercentStart1 / 100));
                        fEndX = (int)((p3.X + p4.X) / 2) + (int)((Math.Abs(p3.X - p4.X)) * (m_stcBlobPad.fWidthPercentEnd1 / 100));
                        fEndY = p3.Y + (int)((Math.Abs(p2.Y - p4.Y)) * (m_stcBlobPad.fHeightPercentEnd1 / 100));

                        fX_Start = Math.Abs(fStartX - fEndX) * (m_stcBlobPad.fInwardPercentStart1 / 100);
                        fX_End = Math.Abs(fStartX - fEndX) * (m_stcBlobPad.fInwardPercentEnd1 / 100);
                        fY_Start = Math.Abs(fStartY - fEndY) * (m_stcBlobPad.fInwardPercentStart1 / 100);
                        fY_End = Math.Abs(fStartY - fEndY) * (m_stcBlobPad.fInwardPercentEnd1 / 100);

                        fStartX_Draw = fStartX + fX_Start;
                        fStartY_Draw = fStartY + fY_Start;
                        fEndX_Draw = fEndX - fX_End;
                        fEndY_Draw = fEndY - fY_End;
                        if (fStartX > fEndX)
                        {
                            fStartX_Draw = fStartX - fX_Start;
                            fEndX_Draw = fEndX + fX_End;
                        }
                        if (fStartY > fEndY)
                        {
                            fStartY_Draw = fStartY - fY_Start;
                            fEndY_Draw = fEndY + fY_End;
                        }

                        g.DrawLine(new Pen(Color.Lime, 2), fStartX_Draw, fStartY_Draw, fEndX_Draw, fEndY_Draw);

                    }
                    else
                    {
                        //g.DrawLine(new Pen(Color.Lime, 2), p1.X, (int)((p1.Y + p3.Y) / 2) + (int)((Math.Abs(p1.Y - p3.Y)) * (m_stcBlobPad.fHeightPercentStart1 / 100)), p2.X, (int)((p2.Y + p4.Y) / 2) + (int)((Math.Abs(p2.Y - p4.Y)) * (m_stcBlobPad.fHeightPercentEnd1 / 100))); //g.DrawLine(new Pen(Color.Lime, 2), p1.X, (p1.Y + p4.Y) / 2, p2.X, (p2.Y + p3.Y) / 2);
                        //g.DrawLine(new Pen(Color.Blue, 2), (int)((p1.X + p2.X) / 2) + (int)((Math.Abs(p1.X - p2.X)) * (m_stcBlobPad.fWidthPercentStart2 / 100)), p1.Y, (int)((p3.X + p4.X) / 2) + (int)((Math.Abs(p3.X - p4.X)) * (m_stcBlobPad.fWidthPercentEnd2 / 100)), p3.Y);  //g.DrawLine(new Pen(Color.Blue, 2), (p1.X + p2.X) / 2, p1.Y, (p3.X + p4.X) / 2, p3.Y);

                        //g.DrawLine(new Pen(Color.Lime, 2), p1.X + (int)((Math.Abs(p1.X - p2.X)) * (m_stcBlobPad.fWidthPercentStart1 / 100)), (int)((p1.Y + p3.Y) / 2) + (int)((Math.Abs(p1.Y - p3.Y)) * (m_stcBlobPad.fHeightPercentStart1 / 100)), p2.X + (int)((Math.Abs(p1.X - p2.X)) * (m_stcBlobPad.fWidthPercentEnd1 / 100)), (int)((p2.Y + p4.Y) / 2) + (int)((Math.Abs(p2.Y - p4.Y)) * (m_stcBlobPad.fHeightPercentEnd1 / 100)));
                        //g.DrawLine(new Pen(Color.Blue, 2), (int)((p1.X + p2.X) / 2) + (int)((Math.Abs(p1.X - p2.X)) * (m_stcBlobPad.fWidthPercentStart2 / 100)), p1.Y + (int)((Math.Abs(p1.Y - p3.Y)) * (m_stcBlobPad.fHeightPercentStart2 / 100)), (int)((p3.X + p4.X) / 2) + (int)((Math.Abs(p3.X - p4.X)) * (m_stcBlobPad.fWidthPercentEnd2 / 100)), p3.Y + (int)((Math.Abs(p2.Y - p4.Y)) * (m_stcBlobPad.fHeightPercentEnd2 / 100)));

                        fStartX = p1.X + (int)((Math.Abs(p1.X - p2.X)) * (m_stcBlobPad.fWidthPercentStart1 / 100));
                        fStartY = (int)((p1.Y + p3.Y) / 2) + (int)((Math.Abs(p1.Y - p3.Y)) * (m_stcBlobPad.fHeightPercentStart1 / 100));
                        fEndX = p2.X + (int)((Math.Abs(p1.X - p2.X)) * (m_stcBlobPad.fWidthPercentEnd1 / 100));
                        fEndY = (int)((p2.Y + p4.Y) / 2) + (int)((Math.Abs(p2.Y - p4.Y)) * (m_stcBlobPad.fHeightPercentEnd1 / 100));

                        fX_Start = Math.Abs(fStartX - fEndX) * (m_stcBlobPad.fInwardPercentStart1 / 100);
                        fX_End = Math.Abs(fStartX - fEndX) * (m_stcBlobPad.fInwardPercentEnd1 / 100);
                        fY_Start = Math.Abs(fStartY - fEndY) * (m_stcBlobPad.fInwardPercentStart1 / 100);
                        fY_End = Math.Abs(fStartY - fEndY) * (m_stcBlobPad.fInwardPercentEnd1 / 100);

                        fStartX_Draw = fStartX + fX_Start;
                        fStartY_Draw = fStartY + fY_Start;
                        fEndX_Draw = fEndX - fX_End;
                        fEndY_Draw = fEndY - fY_End;
                        if (fStartX > fEndX)
                        {
                            fStartX_Draw = fStartX - fX_Start;
                            fEndX_Draw = fEndX + fX_End;
                        }
                        if (fStartY > fEndY)
                        {
                            fStartY_Draw = fStartY - fY_Start;
                            fEndY_Draw = fEndY + fY_End;
                        }

                        g.DrawLine(new Pen(Color.Lime, 2), fStartX_Draw, fStartY_Draw, fEndX_Draw, fEndY_Draw);


                        fStartX = (int)((p1.X + p2.X) / 2) + (int)((Math.Abs(p1.X - p2.X)) * (m_stcBlobPad.fWidthPercentStart2 / 100));
                        fStartY = p1.Y + (int)((Math.Abs(p1.Y - p3.Y)) * (m_stcBlobPad.fHeightPercentStart2 / 100));
                        fEndX = (int)((p3.X + p4.X) / 2) + (int)((Math.Abs(p3.X - p4.X)) * (m_stcBlobPad.fWidthPercentEnd2 / 100));
                        fEndY = p3.Y + (int)((Math.Abs(p2.Y - p4.Y)) * (m_stcBlobPad.fHeightPercentEnd2 / 100));

                        fX_Start = Math.Abs(fStartX - fEndX) * (m_stcBlobPad.fInwardPercentStart2 / 100);
                        fX_End = Math.Abs(fStartX - fEndX) * (m_stcBlobPad.fInwardPercentEnd2 / 100);
                        fY_Start = Math.Abs(fStartY - fEndY) * (m_stcBlobPad.fInwardPercentStart2 / 100);
                        fY_End = Math.Abs(fStartY - fEndY) * (m_stcBlobPad.fInwardPercentEnd2 / 100);

                        fStartX_Draw = fStartX + fX_Start;
                        fStartY_Draw = fStartY + fY_Start;
                        fEndX_Draw = fEndX - fX_End;
                        fEndY_Draw = fEndY - fY_End;
                        if (fStartX > fEndX)
                        {
                            fStartX_Draw = fStartX - fX_Start;
                            fEndX_Draw = fEndX + fX_End;
                        }
                        if (fStartY > fEndY)
                        {
                            fStartY_Draw = fStartY - fY_Start;
                            fEndY_Draw = fEndY + fY_End;
                        }

                        g.DrawLine(new Pen(Color.Blue, 2), fStartX_Draw, fStartY_Draw, fEndX_Draw, fEndY_Draw);

                    }

                    // Draw Extra Dimension Line
                    switch (m_stcBlobPad.intLineCount)
                    {
                        case 3:
                            //g.DrawLine(new Pen(Color.Red, 2),
                            //    (int)(((p1.X + p2.X) / 2) + (((Math.Abs(p1.X - p2.X) / 2) / (m_stcBlobPad.intLineCount - 1))) + (int)((Math.Abs(p1.X - p2.X)) * (m_stcBlobPad.fWidthPercentStart3 / 100))),
                            //    (int)(p1.Y + ((Math.Abs(p1.Y - p3.Y) * m_stcBlobPad.fHeightPercentStart3 / 100))),
                            //    (int)(((p3.X + p4.X) / 2) + ((Math.Abs(p3.X - p4.X) / 2) / (m_stcBlobPad.intLineCount - 1))) + (int)((Math.Abs(p3.X - p4.X)) * (m_stcBlobPad.fWidthPercentEnd3 / 100)),
                            //    (int)(p3.Y + ((Math.Abs(p1.Y - p3.Y) * m_stcBlobPad.fHeightPercentEnd3 / 100))));  //g.DrawLine(new Pen(Color.Blue, 2), (p1.X + p2.X) / 2, p1.Y, (p3.X + p4.X) / 2, p3.Y);

                            fStartX = (int)(((p1.X + p2.X) / 2) + (((Math.Abs(p1.X - p2.X) / 2) / (m_stcBlobPad.intLineCount - 1))) + (int)((Math.Abs(p1.X - p2.X)) * (m_stcBlobPad.fWidthPercentStart3 / 100)));
                            fStartY = (int)(p1.Y + ((Math.Abs(p1.Y - p3.Y) * m_stcBlobPad.fHeightPercentStart3 / 100)));
                            fEndX = (int)(((p3.X + p4.X) / 2) + ((Math.Abs(p3.X - p4.X) / 2) / (m_stcBlobPad.intLineCount - 1))) + (int)((Math.Abs(p3.X - p4.X)) * (m_stcBlobPad.fWidthPercentEnd3 / 100));
                            fEndY = (int)(p3.Y + ((Math.Abs(p1.Y - p3.Y) * m_stcBlobPad.fHeightPercentEnd3 / 100)));

                            fX_Start = Math.Abs(fStartX - fEndX) * (m_stcBlobPad.fInwardPercentStart3 / 100);
                            fX_End = Math.Abs(fStartX - fEndX) * (m_stcBlobPad.fInwardPercentEnd3 / 100);
                            fY_Start = Math.Abs(fStartY - fEndY) * (m_stcBlobPad.fInwardPercentStart3 / 100);
                            fY_End = Math.Abs(fStartY - fEndY) * (m_stcBlobPad.fInwardPercentEnd3 / 100);

                            fStartX_Draw = fStartX + fX_Start;
                            fStartY_Draw = fStartY + fY_Start;
                            fEndX_Draw = fEndX - fX_End;
                            fEndY_Draw = fEndY - fY_End;
                            if (fStartX > fEndX)
                            {
                                fStartX_Draw = fStartX - fX_Start;
                                fEndX_Draw = fEndX + fX_End;
                            }
                            if (fStartY > fEndY)
                            {
                                fStartY_Draw = fStartY - fY_Start;
                                fEndY_Draw = fEndY + fY_End;
                            }

                            g.DrawLine(new Pen(Color.Red, 2), fStartX_Draw, fStartY_Draw, fEndX_Draw, fEndY_Draw);

                            break;
                        case 4:
                            //g.DrawLine(new Pen(Color.Red, 2),
                            //  (int)(((p1.X + p2.X) / 2) + (((Math.Abs(p1.X - p2.X) / 2) / (m_stcBlobPad.intLineCount - 2))) + (int)((Math.Abs(p1.X - p2.X)) * (m_stcBlobPad.fWidthPercentStart3 / 100))),
                            //  (int)(p1.Y + ((Math.Abs(p1.Y - p3.Y) * m_stcBlobPad.fHeightPercentStart3 / 100))),
                            //  (int)(((p3.X + p4.X) / 2) + ((Math.Abs(p3.X - p4.X) / 2) / (m_stcBlobPad.intLineCount - 2))) + (int)((Math.Abs(p3.X - p4.X)) * (m_stcBlobPad.fWidthPercentEnd3 / 100)),
                            //  (int)(p3.Y + ((Math.Abs(p1.Y - p3.Y) * m_stcBlobPad.fHeightPercentEnd3 / 100))));  //g.DrawLine(new Pen(Color.Blue, 2), (p1.X + p2.X) / 2, p1.Y, (p3.X + p4.X) / 2, p3.Y);
                            //g.DrawLine(new Pen(Color.Yellow, 2),
                            //  (int)(((p1.X + p2.X) / 2) + (((Math.Abs(p1.X - p2.X) / 2) / (m_stcBlobPad.intLineCount - 1))) + (int)((Math.Abs(p1.X - p2.X)) * (m_stcBlobPad.fWidthPercentStart4 / 100))),
                            //  (int)(p1.Y + ((Math.Abs(p1.Y - p3.Y) * m_stcBlobPad.fHeightPercentStart4 / 100))),
                            //  (int)(((p3.X + p4.X) / 2) + ((Math.Abs(p3.X - p4.X) / 2) / (m_stcBlobPad.intLineCount - 1))) + (int)((Math.Abs(p3.X - p4.X)) * (m_stcBlobPad.fWidthPercentEnd4 / 100)),
                            //  (int)(p3.Y + ((Math.Abs(p1.Y - p3.Y) * m_stcBlobPad.fHeightPercentEnd4 / 100))));  //g.DrawLine(new Pen(Color.Blue, 2), (p1.X + p2.X) / 2, p1.Y, (p3.X + p4.X) / 2, p3.Y);

                            fStartX = (int)(((p1.X + p2.X) / 2) + (((Math.Abs(p1.X - p2.X) / 2) / (m_stcBlobPad.intLineCount - 2))) + (int)((Math.Abs(p1.X - p2.X)) * (m_stcBlobPad.fWidthPercentStart3 / 100)));
                            fStartY = (int)(p1.Y + ((Math.Abs(p1.Y - p3.Y) * m_stcBlobPad.fHeightPercentStart3 / 100)));
                            fEndX = (int)(((p3.X + p4.X) / 2) + ((Math.Abs(p3.X - p4.X) / 2) / (m_stcBlobPad.intLineCount - 2))) + (int)((Math.Abs(p3.X - p4.X)) * (m_stcBlobPad.fWidthPercentEnd3 / 100));
                            fEndY = (int)(p3.Y + ((Math.Abs(p1.Y - p3.Y) * m_stcBlobPad.fHeightPercentEnd3 / 100)));

                            fX_Start = Math.Abs(fStartX - fEndX) * (m_stcBlobPad.fInwardPercentStart3 / 100);
                            fX_End = Math.Abs(fStartX - fEndX) * (m_stcBlobPad.fInwardPercentEnd3 / 100);
                            fY_Start = Math.Abs(fStartY - fEndY) * (m_stcBlobPad.fInwardPercentStart3 / 100);
                            fY_End = Math.Abs(fStartY - fEndY) * (m_stcBlobPad.fInwardPercentEnd3 / 100);

                            fStartX_Draw = fStartX + fX_Start;
                            fStartY_Draw = fStartY + fY_Start;
                            fEndX_Draw = fEndX - fX_End;
                            fEndY_Draw = fEndY - fY_End;
                            if (fStartX > fEndX)
                            {
                                fStartX_Draw = fStartX - fX_Start;
                                fEndX_Draw = fEndX + fX_End;
                            }
                            if (fStartY > fEndY)
                            {
                                fStartY_Draw = fStartY - fY_Start;
                                fEndY_Draw = fEndY + fY_End;
                            }

                            g.DrawLine(new Pen(Color.Red, 2), fStartX_Draw, fStartY_Draw, fEndX_Draw, fEndY_Draw);

                            fStartX = (int)(((p1.X + p2.X) / 2) + (((Math.Abs(p1.X - p2.X) / 2) / (m_stcBlobPad.intLineCount - 1))) + (int)((Math.Abs(p1.X - p2.X)) * (m_stcBlobPad.fWidthPercentStart4 / 100)));
                            fStartY = (int)(p1.Y + ((Math.Abs(p1.Y - p3.Y) * m_stcBlobPad.fHeightPercentStart4 / 100)));
                            fEndX = (int)(((p3.X + p4.X) / 2) + ((Math.Abs(p3.X - p4.X) / 2) / (m_stcBlobPad.intLineCount - 1))) + (int)((Math.Abs(p3.X - p4.X)) * (m_stcBlobPad.fWidthPercentEnd4 / 100));
                            fEndY = (int)(p3.Y + ((Math.Abs(p1.Y - p3.Y) * m_stcBlobPad.fHeightPercentEnd4 / 100)));

                            fX_Start = Math.Abs(fStartX - fEndX) * (m_stcBlobPad.fInwardPercentStart4 / 100);
                            fX_End = Math.Abs(fStartX - fEndX) * (m_stcBlobPad.fInwardPercentEnd4 / 100);
                            fY_Start = Math.Abs(fStartY - fEndY) * (m_stcBlobPad.fInwardPercentStart4 / 100);
                            fY_End = Math.Abs(fStartY - fEndY) * (m_stcBlobPad.fInwardPercentEnd4 / 100);

                            fStartX_Draw = fStartX + fX_Start;
                            fStartY_Draw = fStartY + fY_Start;
                            fEndX_Draw = fEndX - fX_End;
                            fEndY_Draw = fEndY - fY_End;
                            if (fStartX > fEndX)
                            {
                                fStartX_Draw = fStartX - fX_Start;
                                fEndX_Draw = fEndX + fX_End;
                            }
                            if (fStartY > fEndY)
                            {
                                fStartY_Draw = fStartY - fY_Start;
                                fEndY_Draw = fEndY + fY_End;
                            }

                            g.DrawLine(new Pen(Color.Yellow, 2), fStartX_Draw, fStartY_Draw, fEndX_Draw, fEndY_Draw);

                            break;
                        case 5:
                            //g.DrawLine(new Pen(Color.Red, 2),
                            //  (int)(((p1.X + p2.X) / 2) + (((Math.Abs(p1.X - p2.X) / 2) / (m_stcBlobPad.intLineCount - 3))) + (int)((Math.Abs(p1.X - p2.X)) * (m_stcBlobPad.fWidthPercentStart3 / 100))),
                            //  (int)(p1.Y + ((Math.Abs(p1.Y - p3.Y) * m_stcBlobPad.fHeightPercentStart3 / 100))),
                            //  (int)(((p3.X + p4.X) / 2) + ((Math.Abs(p3.X - p4.X) / 2) / (m_stcBlobPad.intLineCount - 3))) + (int)((Math.Abs(p3.X - p4.X)) * (m_stcBlobPad.fWidthPercentEnd3 / 100)),
                            //  (int)(p3.Y + ((Math.Abs(p1.Y - p3.Y) * m_stcBlobPad.fHeightPercentEnd3 / 100))));  //g.DrawLine(new Pen(Color.Blue, 2), (p1.X + p2.X) / 2, p1.Y, (p3.X + p4.X) / 2, p3.Y);
                            //g.DrawLine(new Pen(Color.Yellow, 2),
                            //  (int)(((p1.X + p2.X) / 2) + (((Math.Abs(p1.X - p2.X) / 2) / (m_stcBlobPad.intLineCount - 2))) + (int)((Math.Abs(p1.X - p2.X)) * (m_stcBlobPad.fWidthPercentStart4 / 100))),
                            //  (int)(p1.Y + ((Math.Abs(p1.Y - p3.Y) * m_stcBlobPad.fHeightPercentStart4 / 100))),
                            //  (int)(((p3.X + p4.X) / 2) + ((Math.Abs(p3.X - p4.X) / 2) / (m_stcBlobPad.intLineCount - 2))) + (int)((Math.Abs(p3.X - p4.X)) * (m_stcBlobPad.fWidthPercentEnd4 / 100)),
                            //  (int)(p3.Y + ((Math.Abs(p1.Y - p3.Y) * m_stcBlobPad.fHeightPercentEnd4 / 100))));  //g.DrawLine(new Pen(Color.Blue, 2), (p1.X + p2.X) / 2, p1.Y, (p3.X + p4.X) / 2, p3.Y);
                            //g.DrawLine(new Pen(Color.Pink, 2),
                            //  (int)(((p1.X + p2.X) / 2) + (((Math.Abs(p1.X - p2.X) / 2) / (m_stcBlobPad.intLineCount - 1))) + (int)((Math.Abs(p1.X - p2.X)) * (m_stcBlobPad.fWidthPercentStart5 / 100))),
                            //  (int)(p1.Y + ((Math.Abs(p1.Y - p3.Y) * m_stcBlobPad.fHeightPercentStart5 / 100))),
                            //  (int)(((p3.X + p4.X) / 2) + ((Math.Abs(p3.X - p4.X) / 2) / (m_stcBlobPad.intLineCount - 1))) + (int)((Math.Abs(p3.X - p4.X)) * (m_stcBlobPad.fWidthPercentEnd5 / 100)),
                            //  (int)(p3.Y + ((Math.Abs(p1.Y - p3.Y) * m_stcBlobPad.fHeightPercentEnd5 / 100))));  //g.DrawLine(new Pen(Color.Blue, 2), (p1.X + p2.X) / 2, p1.Y, (p3.X + p4.X) / 2, p3.Y);

                            fStartX = (int)(((p1.X + p2.X) / 2) + (((Math.Abs(p1.X - p2.X) / 2) / (m_stcBlobPad.intLineCount - 3))) + (int)((Math.Abs(p1.X - p2.X)) * (m_stcBlobPad.fWidthPercentStart3 / 100)));
                            fStartY = (int)(p1.Y + ((Math.Abs(p1.Y - p3.Y) * m_stcBlobPad.fHeightPercentStart3 / 100)));
                            fEndX = (int)(((p3.X + p4.X) / 2) + ((Math.Abs(p3.X - p4.X) / 2) / (m_stcBlobPad.intLineCount - 3))) + (int)((Math.Abs(p3.X - p4.X)) * (m_stcBlobPad.fWidthPercentEnd3 / 100));
                            fEndY = (int)(p3.Y + ((Math.Abs(p1.Y - p3.Y) * m_stcBlobPad.fHeightPercentEnd3 / 100)));

                            fX_Start = Math.Abs(fStartX - fEndX) * (m_stcBlobPad.fInwardPercentStart3 / 100);
                            fX_End = Math.Abs(fStartX - fEndX) * (m_stcBlobPad.fInwardPercentEnd3 / 100);
                            fY_Start = Math.Abs(fStartY - fEndY) * (m_stcBlobPad.fInwardPercentStart3 / 100);
                            fY_End = Math.Abs(fStartY - fEndY) * (m_stcBlobPad.fInwardPercentEnd3 / 100);

                            fStartX_Draw = fStartX + fX_Start;
                            fStartY_Draw = fStartY + fY_Start;
                            fEndX_Draw = fEndX - fX_End;
                            fEndY_Draw = fEndY - fY_End;
                            if (fStartX > fEndX)
                            {
                                fStartX_Draw = fStartX - fX_Start;
                                fEndX_Draw = fEndX + fX_End;
                            }
                            if (fStartY > fEndY)
                            {
                                fStartY_Draw = fStartY - fY_Start;
                                fEndY_Draw = fEndY + fY_End;
                            }

                            g.DrawLine(new Pen(Color.Red, 2), fStartX_Draw, fStartY_Draw, fEndX_Draw, fEndY_Draw);

                            fStartX = (int)(((p1.X + p2.X) / 2) + (((Math.Abs(p1.X - p2.X) / 2) / (m_stcBlobPad.intLineCount - 2))) + (int)((Math.Abs(p1.X - p2.X)) * (m_stcBlobPad.fWidthPercentStart4 / 100)));
                            fStartY = (int)(p1.Y + ((Math.Abs(p1.Y - p3.Y) * m_stcBlobPad.fHeightPercentStart4 / 100)));
                            fEndX = (int)(((p3.X + p4.X) / 2) + ((Math.Abs(p3.X - p4.X) / 2) / (m_stcBlobPad.intLineCount - 2))) + (int)((Math.Abs(p3.X - p4.X)) * (m_stcBlobPad.fWidthPercentEnd4 / 100));
                            fEndY = (int)(p3.Y + ((Math.Abs(p1.Y - p3.Y) * m_stcBlobPad.fHeightPercentEnd4 / 100)));

                            fX_Start = Math.Abs(fStartX - fEndX) * (m_stcBlobPad.fInwardPercentStart4 / 100);
                            fX_End = Math.Abs(fStartX - fEndX) * (m_stcBlobPad.fInwardPercentEnd4 / 100);
                            fY_Start = Math.Abs(fStartY - fEndY) * (m_stcBlobPad.fInwardPercentStart4 / 100);
                            fY_End = Math.Abs(fStartY - fEndY) * (m_stcBlobPad.fInwardPercentEnd4 / 100);

                            fStartX_Draw = fStartX + fX_Start;
                            fStartY_Draw = fStartY + fY_Start;
                            fEndX_Draw = fEndX - fX_End;
                            fEndY_Draw = fEndY - fY_End;
                            if (fStartX > fEndX)
                            {
                                fStartX_Draw = fStartX - fX_Start;
                                fEndX_Draw = fEndX + fX_End;
                            }
                            if (fStartY > fEndY)
                            {
                                fStartY_Draw = fStartY - fY_Start;
                                fEndY_Draw = fEndY + fY_End;
                            }

                            g.DrawLine(new Pen(Color.Yellow, 2), fStartX_Draw, fStartY_Draw, fEndX_Draw, fEndY_Draw);

                            fStartX = (int)(((p1.X + p2.X) / 2) + (((Math.Abs(p1.X - p2.X) / 2) / (m_stcBlobPad.intLineCount - 1))) + (int)((Math.Abs(p1.X - p2.X)) * (m_stcBlobPad.fWidthPercentStart5 / 100)));
                            fStartY = (int)(p1.Y + ((Math.Abs(p1.Y - p3.Y) * m_stcBlobPad.fHeightPercentStart5 / 100)));
                            fEndX = (int)(((p3.X + p4.X) / 2) + ((Math.Abs(p3.X - p4.X) / 2) / (m_stcBlobPad.intLineCount - 1))) + (int)((Math.Abs(p3.X - p4.X)) * (m_stcBlobPad.fWidthPercentEnd5 / 100));
                            fEndY = (int)(p3.Y + ((Math.Abs(p1.Y - p3.Y) * m_stcBlobPad.fHeightPercentEnd5 / 100)));

                            fX_Start = Math.Abs(fStartX - fEndX) * (m_stcBlobPad.fInwardPercentStart5 / 100);
                            fX_End = Math.Abs(fStartX - fEndX) * (m_stcBlobPad.fInwardPercentEnd5 / 100);
                            fY_Start = Math.Abs(fStartY - fEndY) * (m_stcBlobPad.fInwardPercentStart5 / 100);
                            fY_End = Math.Abs(fStartY - fEndY) * (m_stcBlobPad.fInwardPercentEnd5 / 100);

                            fStartX_Draw = fStartX + fX_Start;
                            fStartY_Draw = fStartY + fY_Start;
                            fEndX_Draw = fEndX - fX_End;
                            fEndY_Draw = fEndY - fY_End;
                            if (fStartX > fEndX)
                            {
                                fStartX_Draw = fStartX - fX_Start;
                                fEndX_Draw = fEndX + fX_End;
                            }
                            if (fStartY > fEndY)
                            {
                                fStartY_Draw = fStartY - fY_Start;
                                fEndY_Draw = fEndY + fY_End;
                            }

                            g.DrawLine(new Pen(Color.Pink, 2), fStartX_Draw, fStartY_Draw, fEndX_Draw, fEndY_Draw);

                            break;
                        case 6:
                            //g.DrawLine(new Pen(Color.Red, 2),
                            //  (int)(((p1.X + p2.X) / 2) + (((Math.Abs(p1.X - p2.X) / 2) / (m_stcBlobPad.intLineCount - 4))) + (int)((Math.Abs(p1.X - p2.X)) * (m_stcBlobPad.fWidthPercentStart3 / 100))),
                            //  (int)(p1.Y + ((Math.Abs(p1.Y - p3.Y) * m_stcBlobPad.fHeightPercentStart3 / 100))),
                            //  (int)(((p3.X + p4.X) / 2) + ((Math.Abs(p3.X - p4.X) / 2) / (m_stcBlobPad.intLineCount - 4))) + (int)((Math.Abs(p3.X - p4.X)) * (m_stcBlobPad.fWidthPercentEnd3 / 100)),
                            //  (int)(p3.Y + ((Math.Abs(p1.Y - p3.Y) * m_stcBlobPad.fHeightPercentEnd3 / 100))));  //g.DrawLine(new Pen(Color.Blue, 2), (p1.X + p2.X) / 2, p1.Y, (p3.X + p4.X) / 2, p3.Y);
                            //g.DrawLine(new Pen(Color.Yellow, 2),
                            //  (int)(((p1.X + p2.X) / 2) + (((Math.Abs(p1.X - p2.X) / 2) / (m_stcBlobPad.intLineCount - 3))) + (int)((Math.Abs(p1.X - p2.X)) * (m_stcBlobPad.fWidthPercentStart4 / 100))),
                            //  (int)(p1.Y + ((Math.Abs(p1.Y - p3.Y) * m_stcBlobPad.fHeightPercentStart4 / 100))),
                            //  (int)(((p3.X + p4.X) / 2) + ((Math.Abs(p3.X - p4.X) / 2) / (m_stcBlobPad.intLineCount - 3))) + (int)((Math.Abs(p3.X - p4.X)) * (m_stcBlobPad.fWidthPercentEnd4 / 100)),
                            //  (int)(p3.Y + ((Math.Abs(p1.Y - p3.Y) * m_stcBlobPad.fHeightPercentEnd4 / 100))));  //g.DrawLine(new Pen(Color.Blue, 2), (p1.X + p2.X) / 2, p1.Y, (p3.X + p4.X) / 2, p3.Y);
                            //g.DrawLine(new Pen(Color.Pink, 2),
                            //  (int)(((p1.X + p2.X) / 2) + (((Math.Abs(p1.X - p2.X) / 2) / (m_stcBlobPad.intLineCount - 2))) + (int)((Math.Abs(p1.X - p2.X)) * (m_stcBlobPad.fWidthPercentStart5 / 100))),
                            //  (int)(p1.Y + ((Math.Abs(p1.Y - p3.Y) * m_stcBlobPad.fHeightPercentStart5 / 100))),
                            //  (int)(((p3.X + p4.X) / 2) + ((Math.Abs(p3.X - p4.X) / 2) / (m_stcBlobPad.intLineCount - 2))) + (int)((Math.Abs(p3.X - p4.X)) * (m_stcBlobPad.fWidthPercentEnd5 / 100)),
                            //  (int)(p3.Y + ((Math.Abs(p1.Y - p3.Y) * m_stcBlobPad.fHeightPercentEnd5 / 100))));  //g.DrawLine(new Pen(Color.Blue, 2), (p1.X + p2.X) / 2, p1.Y, (p3.X + p4.X) / 2, p3.Y);
                            //g.DrawLine(new Pen(Color.Orange, 2),
                            //  (int)(((p1.X + p2.X) / 2) + (((Math.Abs(p1.X - p2.X) / 2) / (m_stcBlobPad.intLineCount - 1))) + (int)((Math.Abs(p1.X - p2.X)) * (m_stcBlobPad.fWidthPercentStart6 / 100))),
                            //  (int)(p1.Y + ((Math.Abs(p1.Y - p3.Y) * m_stcBlobPad.fHeightPercentStart6 / 100))),
                            //  (int)(((p3.X + p4.X) / 2) + ((Math.Abs(p3.X - p4.X) / 2) / (m_stcBlobPad.intLineCount - 1))) + (int)((Math.Abs(p3.X - p4.X)) * (m_stcBlobPad.fWidthPercentEnd6 / 100)),
                            //  (int)(p3.Y + ((Math.Abs(p1.Y - p3.Y) * m_stcBlobPad.fHeightPercentEnd6 / 100))));  //g.DrawLine(new Pen(Color.Blue, 2), (p1.X + p2.X) / 2, p1.Y, (p3.X + p4.X) / 2, p3.Y);

                            fStartX = (int)(((p1.X + p2.X) / 2) + (((Math.Abs(p1.X - p2.X) / 2) / (m_stcBlobPad.intLineCount - 4))) + (int)((Math.Abs(p1.X - p2.X)) * (m_stcBlobPad.fWidthPercentStart3 / 100)));
                            fStartY = (int)(p1.Y + ((Math.Abs(p1.Y - p3.Y) * m_stcBlobPad.fHeightPercentStart3 / 100)));
                            fEndX = (int)(((p3.X + p4.X) / 2) + ((Math.Abs(p3.X - p4.X) / 2) / (m_stcBlobPad.intLineCount - 4))) + (int)((Math.Abs(p3.X - p4.X)) * (m_stcBlobPad.fWidthPercentEnd3 / 100));
                            fEndY = (int)(p3.Y + ((Math.Abs(p1.Y - p3.Y) * m_stcBlobPad.fHeightPercentEnd3 / 100)));

                            fX_Start = Math.Abs(fStartX - fEndX) * (m_stcBlobPad.fInwardPercentStart3 / 100);
                            fX_End = Math.Abs(fStartX - fEndX) * (m_stcBlobPad.fInwardPercentEnd3 / 100);
                            fY_Start = Math.Abs(fStartY - fEndY) * (m_stcBlobPad.fInwardPercentStart3 / 100);
                            fY_End = Math.Abs(fStartY - fEndY) * (m_stcBlobPad.fInwardPercentEnd3 / 100);

                            fStartX_Draw = fStartX + fX_Start;
                            fStartY_Draw = fStartY + fY_Start;
                            fEndX_Draw = fEndX - fX_End;
                            fEndY_Draw = fEndY - fY_End;
                            if (fStartX > fEndX)
                            {
                                fStartX_Draw = fStartX - fX_Start;
                                fEndX_Draw = fEndX + fX_End;
                            }
                            if (fStartY > fEndY)
                            {
                                fStartY_Draw = fStartY - fY_Start;
                                fEndY_Draw = fEndY + fY_End;
                            }

                            g.DrawLine(new Pen(Color.Red, 2), fStartX_Draw, fStartY_Draw, fEndX_Draw, fEndY_Draw);

                            fStartX = (int)(((p1.X + p2.X) / 2) + (((Math.Abs(p1.X - p2.X) / 2) / (m_stcBlobPad.intLineCount - 3))) + (int)((Math.Abs(p1.X - p2.X)) * (m_stcBlobPad.fWidthPercentStart4 / 100)));
                            fStartY = (int)(p1.Y + ((Math.Abs(p1.Y - p3.Y) * m_stcBlobPad.fHeightPercentStart4 / 100)));
                            fEndX = (int)(((p3.X + p4.X) / 2) + ((Math.Abs(p3.X - p4.X) / 2) / (m_stcBlobPad.intLineCount - 3))) + (int)((Math.Abs(p3.X - p4.X)) * (m_stcBlobPad.fWidthPercentEnd4 / 100));
                            fEndY = (int)(p3.Y + ((Math.Abs(p1.Y - p3.Y) * m_stcBlobPad.fHeightPercentEnd4 / 100)));

                            fX_Start = Math.Abs(fStartX - fEndX) * (m_stcBlobPad.fInwardPercentStart4 / 100);
                            fX_End = Math.Abs(fStartX - fEndX) * (m_stcBlobPad.fInwardPercentEnd4 / 100);
                            fY_Start = Math.Abs(fStartY - fEndY) * (m_stcBlobPad.fInwardPercentStart4 / 100);
                            fY_End = Math.Abs(fStartY - fEndY) * (m_stcBlobPad.fInwardPercentEnd4 / 100);

                            fStartX_Draw = fStartX + fX_Start;
                            fStartY_Draw = fStartY + fY_Start;
                            fEndX_Draw = fEndX - fX_End;
                            fEndY_Draw = fEndY - fY_End;
                            if (fStartX > fEndX)
                            {
                                fStartX_Draw = fStartX - fX_Start;
                                fEndX_Draw = fEndX + fX_End;
                            }
                            if (fStartY > fEndY)
                            {
                                fStartY_Draw = fStartY - fY_Start;
                                fEndY_Draw = fEndY + fY_End;
                            }

                            g.DrawLine(new Pen(Color.Yellow, 2), fStartX_Draw, fStartY_Draw, fEndX_Draw, fEndY_Draw);

                            fStartX = (int)(((p1.X + p2.X) / 2) + (((Math.Abs(p1.X - p2.X) / 2) / (m_stcBlobPad.intLineCount - 2))) + (int)((Math.Abs(p1.X - p2.X)) * (m_stcBlobPad.fWidthPercentStart5 / 100)));
                            fStartY = (int)(p1.Y + ((Math.Abs(p1.Y - p3.Y) * m_stcBlobPad.fHeightPercentStart5 / 100)));
                            fEndX = (int)(((p3.X + p4.X) / 2) + ((Math.Abs(p3.X - p4.X) / 2) / (m_stcBlobPad.intLineCount - 2))) + (int)((Math.Abs(p3.X - p4.X)) * (m_stcBlobPad.fWidthPercentEnd5 / 100));
                            fEndY = (int)(p3.Y + ((Math.Abs(p1.Y - p3.Y) * m_stcBlobPad.fHeightPercentEnd5 / 100)));

                            fX_Start = Math.Abs(fStartX - fEndX) * (m_stcBlobPad.fInwardPercentStart5 / 100);
                            fX_End = Math.Abs(fStartX - fEndX) * (m_stcBlobPad.fInwardPercentEnd5 / 100);
                            fY_Start = Math.Abs(fStartY - fEndY) * (m_stcBlobPad.fInwardPercentStart5 / 100);
                            fY_End = Math.Abs(fStartY - fEndY) * (m_stcBlobPad.fInwardPercentEnd5 / 100);

                            fStartX_Draw = fStartX + fX_Start;
                            fStartY_Draw = fStartY + fY_Start;
                            fEndX_Draw = fEndX - fX_End;
                            fEndY_Draw = fEndY - fY_End;
                            if (fStartX > fEndX)
                            {
                                fStartX_Draw = fStartX - fX_Start;
                                fEndX_Draw = fEndX + fX_End;
                            }
                            if (fStartY > fEndY)
                            {
                                fStartY_Draw = fStartY - fY_Start;
                                fEndY_Draw = fEndY + fY_End;
                            }

                            g.DrawLine(new Pen(Color.Pink, 2), fStartX_Draw, fStartY_Draw, fEndX_Draw, fEndY_Draw);

                            fStartX = (int)(((p1.X + p2.X) / 2) + (((Math.Abs(p1.X - p2.X) / 2) / (m_stcBlobPad.intLineCount - 1))) + (int)((Math.Abs(p1.X - p2.X)) * (m_stcBlobPad.fWidthPercentStart6 / 100)));
                            fStartY = (int)(p1.Y + ((Math.Abs(p1.Y - p3.Y) * m_stcBlobPad.fHeightPercentStart6 / 100)));
                            fEndX = (int)(((p3.X + p4.X) / 2) + ((Math.Abs(p3.X - p4.X) / 2) / (m_stcBlobPad.intLineCount - 1))) + (int)((Math.Abs(p3.X - p4.X)) * (m_stcBlobPad.fWidthPercentEnd6 / 100));
                            fEndY = (int)(p3.Y + ((Math.Abs(p1.Y - p3.Y) * m_stcBlobPad.fHeightPercentEnd6 / 100)));

                            fX_Start = Math.Abs(fStartX - fEndX) * (m_stcBlobPad.fInwardPercentStart6 / 100);
                            fX_End = Math.Abs(fStartX - fEndX) * (m_stcBlobPad.fInwardPercentEnd6 / 100);
                            fY_Start = Math.Abs(fStartY - fEndY) * (m_stcBlobPad.fInwardPercentStart6 / 100);
                            fY_End = Math.Abs(fStartY - fEndY) * (m_stcBlobPad.fInwardPercentEnd6 / 100);

                            fStartX_Draw = fStartX + fX_Start;
                            fStartY_Draw = fStartY + fY_Start;
                            fEndX_Draw = fEndX - fX_End;
                            fEndY_Draw = fEndY - fY_End;
                            if (fStartX > fEndX)
                            {
                                fStartX_Draw = fStartX - fX_Start;
                                fEndX_Draw = fEndX + fX_End;
                            }
                            if (fStartY > fEndY)
                            {
                                fStartY_Draw = fStartY - fY_Start;
                                fEndY_Draw = fEndY + fY_End;
                            }

                            g.DrawLine(new Pen(Color.Orange, 2), fStartX_Draw, fStartY_Draw, fEndX_Draw, fEndY_Draw);

                            break;
                        case 7:
                            //g.DrawLine(new Pen(Color.Red, 2),
                            //  (int)(((p1.X + p2.X) / 2) + (((Math.Abs(p1.X - p2.X) / 2) / (m_stcBlobPad.intLineCount - 5))) + (int)((Math.Abs(p1.X - p2.X)) * (m_stcBlobPad.fWidthPercentStart3 / 100))),
                            //  (int)(p1.Y + ((Math.Abs(p1.Y - p3.Y) * m_stcBlobPad.fHeightPercentStart3 / 100))),
                            //  (int)(((p3.X + p4.X) / 2) + ((Math.Abs(p3.X - p4.X) / 2) / (m_stcBlobPad.intLineCount - 5))) + (int)((Math.Abs(p3.X - p4.X)) * (m_stcBlobPad.fWidthPercentEnd3 / 100)),
                            //  (int)(p3.Y + ((Math.Abs(p1.Y - p3.Y) * m_stcBlobPad.fHeightPercentEnd3 / 100))));  //g.DrawLine(new Pen(Color.Blue, 2), (p1.X + p2.X) / 2, p1.Y, (p3.X + p4.X) / 2, p3.Y);
                            //g.DrawLine(new Pen(Color.Yellow, 2),
                            //  (int)(((p1.X + p2.X) / 2) + (((Math.Abs(p1.X - p2.X) / 2) / (m_stcBlobPad.intLineCount - 4))) + (int)((Math.Abs(p1.X - p2.X)) * (m_stcBlobPad.fWidthPercentStart4 / 100))),
                            //  (int)(p1.Y + ((Math.Abs(p1.Y - p3.Y) * m_stcBlobPad.fHeightPercentStart4 / 100))),
                            //  (int)(((p3.X + p4.X) / 2) + ((Math.Abs(p3.X - p4.X) / 2) / (m_stcBlobPad.intLineCount - 4))) + (int)((Math.Abs(p3.X - p4.X)) * (m_stcBlobPad.fWidthPercentEnd4 / 100)),
                            //  (int)(p3.Y + ((Math.Abs(p1.Y - p3.Y) * m_stcBlobPad.fHeightPercentEnd4 / 100))));  //g.DrawLine(new Pen(Color.Blue, 2), (p1.X + p2.X) / 2, p1.Y, (p3.X + p4.X) / 2, p3.Y);
                            //g.DrawLine(new Pen(Color.Pink, 2),
                            //  (int)(((p1.X + p2.X) / 2) + (((Math.Abs(p1.X - p2.X) / 2) / (m_stcBlobPad.intLineCount - 3))) + (int)((Math.Abs(p1.X - p2.X)) * (m_stcBlobPad.fWidthPercentStart5 / 100))),
                            //  (int)(p1.Y + ((Math.Abs(p1.Y - p3.Y) * m_stcBlobPad.fHeightPercentStart5 / 100))),
                            //  (int)(((p3.X + p4.X) / 2) + ((Math.Abs(p3.X - p4.X) / 2) / (m_stcBlobPad.intLineCount - 3))) + (int)((Math.Abs(p3.X - p4.X)) * (m_stcBlobPad.fWidthPercentEnd5 / 100)),
                            //  (int)(p3.Y + ((Math.Abs(p1.Y - p3.Y) * m_stcBlobPad.fHeightPercentEnd5 / 100))));  //g.DrawLine(new Pen(Color.Blue, 2), (p1.X + p2.X) / 2, p1.Y, (p3.X + p4.X) / 2, p3.Y);
                            //g.DrawLine(new Pen(Color.Orange, 2),
                            //  (int)(((p1.X + p2.X) / 2) + (((Math.Abs(p1.X - p2.X) / 2) / (m_stcBlobPad.intLineCount - 2))) + (int)((Math.Abs(p1.X - p2.X)) * (m_stcBlobPad.fWidthPercentStart6 / 100))),
                            //  (int)(p1.Y + ((Math.Abs(p1.Y - p3.Y) * m_stcBlobPad.fHeightPercentStart6 / 100))),
                            //  (int)(((p3.X + p4.X) / 2) + ((Math.Abs(p3.X - p4.X) / 2) / (m_stcBlobPad.intLineCount - 2))) + (int)((Math.Abs(p3.X - p4.X)) * (m_stcBlobPad.fWidthPercentEnd6 / 100)),
                            //  (int)(p3.Y + ((Math.Abs(p1.Y - p3.Y) * m_stcBlobPad.fHeightPercentEnd6 / 100))));  //g.DrawLine(new Pen(Color.Blue, 2), (p1.X + p2.X) / 2, p1.Y, (p3.X + p4.X) / 2, p3.Y);
                            //g.DrawLine(new Pen(Color.Cyan, 2),
                            //  (int)(((p1.X + p2.X) / 2) + (((Math.Abs(p1.X - p2.X) / 2) / (m_stcBlobPad.intLineCount - 1))) + (int)((Math.Abs(p1.X - p2.X)) * (m_stcBlobPad.fWidthPercentStart7 / 100))),
                            //  (int)(p1.Y + ((Math.Abs(p1.Y - p3.Y) * m_stcBlobPad.fHeightPercentStart7 / 100))),
                            //  (int)(((p3.X + p4.X) / 2) + ((Math.Abs(p3.X - p4.X) / 2) / (m_stcBlobPad.intLineCount - 1))) + (int)((Math.Abs(p3.X - p4.X)) * (m_stcBlobPad.fWidthPercentEnd7 / 100)),
                            //  (int)(p3.Y + ((Math.Abs(p1.Y - p3.Y) * m_stcBlobPad.fHeightPercentEnd7 / 100))));  //g.DrawLine(new Pen(Color.Blue, 2), (p1.X + p2.X) / 2, p1.Y, (p3.X + p4.X) / 2, p3.Y);

                            fStartX = (int)(((p1.X + p2.X) / 2) + (((Math.Abs(p1.X - p2.X) / 2) / (m_stcBlobPad.intLineCount - 5))) + (int)((Math.Abs(p1.X - p2.X)) * (m_stcBlobPad.fWidthPercentStart3 / 100)));
                            fStartY = (int)(p1.Y + ((Math.Abs(p1.Y - p3.Y) * m_stcBlobPad.fHeightPercentStart3 / 100)));
                            fEndX = (int)(((p3.X + p4.X) / 2) + ((Math.Abs(p3.X - p4.X) / 2) / (m_stcBlobPad.intLineCount - 5))) + (int)((Math.Abs(p3.X - p4.X)) * (m_stcBlobPad.fWidthPercentEnd3 / 100));
                            fEndY = (int)(p3.Y + ((Math.Abs(p1.Y - p3.Y) * m_stcBlobPad.fHeightPercentEnd3 / 100)));

                            fX_Start = Math.Abs(fStartX - fEndX) * (m_stcBlobPad.fInwardPercentStart3 / 100);
                            fX_End = Math.Abs(fStartX - fEndX) * (m_stcBlobPad.fInwardPercentEnd3 / 100);
                            fY_Start = Math.Abs(fStartY - fEndY) * (m_stcBlobPad.fInwardPercentStart3 / 100);
                            fY_End = Math.Abs(fStartY - fEndY) * (m_stcBlobPad.fInwardPercentEnd3 / 100);

                            fStartX_Draw = fStartX + fX_Start;
                            fStartY_Draw = fStartY + fY_Start;
                            fEndX_Draw = fEndX - fX_End;
                            fEndY_Draw = fEndY - fY_End;
                            if (fStartX > fEndX)
                            {
                                fStartX_Draw = fStartX - fX_Start;
                                fEndX_Draw = fEndX + fX_End;
                            }
                            if (fStartY > fEndY)
                            {
                                fStartY_Draw = fStartY - fY_Start;
                                fEndY_Draw = fEndY + fY_End;
                            }

                            g.DrawLine(new Pen(Color.Red, 2), fStartX_Draw, fStartY_Draw, fEndX_Draw, fEndY_Draw);

                            fStartX = (int)(((p1.X + p2.X) / 2) + (((Math.Abs(p1.X - p2.X) / 2) / (m_stcBlobPad.intLineCount - 4))) + (int)((Math.Abs(p1.X - p2.X)) * (m_stcBlobPad.fWidthPercentStart4 / 100)));
                            fStartY = (int)(p1.Y + ((Math.Abs(p1.Y - p3.Y) * m_stcBlobPad.fHeightPercentStart4 / 100)));
                            fEndX = (int)(((p3.X + p4.X) / 2) + ((Math.Abs(p3.X - p4.X) / 2) / (m_stcBlobPad.intLineCount - 4))) + (int)((Math.Abs(p3.X - p4.X)) * (m_stcBlobPad.fWidthPercentEnd4 / 100));
                            fEndY = (int)(p3.Y + ((Math.Abs(p1.Y - p3.Y) * m_stcBlobPad.fHeightPercentEnd4 / 100)));

                            fX_Start = Math.Abs(fStartX - fEndX) * (m_stcBlobPad.fInwardPercentStart4 / 100);
                            fX_End = Math.Abs(fStartX - fEndX) * (m_stcBlobPad.fInwardPercentEnd4 / 100);
                            fY_Start = Math.Abs(fStartY - fEndY) * (m_stcBlobPad.fInwardPercentStart4 / 100);
                            fY_End = Math.Abs(fStartY - fEndY) * (m_stcBlobPad.fInwardPercentEnd4 / 100);

                            fStartX_Draw = fStartX + fX_Start;
                            fStartY_Draw = fStartY + fY_Start;
                            fEndX_Draw = fEndX - fX_End;
                            fEndY_Draw = fEndY - fY_End;
                            if (fStartX > fEndX)
                            {
                                fStartX_Draw = fStartX - fX_Start;
                                fEndX_Draw = fEndX + fX_End;
                            }
                            if (fStartY > fEndY)
                            {
                                fStartY_Draw = fStartY - fY_Start;
                                fEndY_Draw = fEndY + fY_End;
                            }

                            g.DrawLine(new Pen(Color.Yellow, 2), fStartX_Draw, fStartY_Draw, fEndX_Draw, fEndY_Draw);

                            fStartX = (int)(((p1.X + p2.X) / 2) + (((Math.Abs(p1.X - p2.X) / 2) / (m_stcBlobPad.intLineCount - 3))) + (int)((Math.Abs(p1.X - p2.X)) * (m_stcBlobPad.fWidthPercentStart5 / 100)));
                            fStartY = (int)(p1.Y + ((Math.Abs(p1.Y - p3.Y) * m_stcBlobPad.fHeightPercentStart5 / 100)));
                            fEndX = (int)(((p3.X + p4.X) / 2) + ((Math.Abs(p3.X - p4.X) / 2) / (m_stcBlobPad.intLineCount - 3))) + (int)((Math.Abs(p3.X - p4.X)) * (m_stcBlobPad.fWidthPercentEnd5 / 100));
                            fEndY = (int)(p3.Y + ((Math.Abs(p1.Y - p3.Y) * m_stcBlobPad.fHeightPercentEnd5 / 100)));

                            fX_Start = Math.Abs(fStartX - fEndX) * (m_stcBlobPad.fInwardPercentStart5 / 100);
                            fX_End = Math.Abs(fStartX - fEndX) * (m_stcBlobPad.fInwardPercentEnd5 / 100);
                            fY_Start = Math.Abs(fStartY - fEndY) * (m_stcBlobPad.fInwardPercentStart5 / 100);
                            fY_End = Math.Abs(fStartY - fEndY) * (m_stcBlobPad.fInwardPercentEnd5 / 100);

                            fStartX_Draw = fStartX + fX_Start;
                            fStartY_Draw = fStartY + fY_Start;
                            fEndX_Draw = fEndX - fX_End;
                            fEndY_Draw = fEndY - fY_End;
                            if (fStartX > fEndX)
                            {
                                fStartX_Draw = fStartX - fX_Start;
                                fEndX_Draw = fEndX + fX_End;
                            }
                            if (fStartY > fEndY)
                            {
                                fStartY_Draw = fStartY - fY_Start;
                                fEndY_Draw = fEndY + fY_End;
                            }

                            g.DrawLine(new Pen(Color.Pink, 2), fStartX_Draw, fStartY_Draw, fEndX_Draw, fEndY_Draw);

                            fStartX = (int)(((p1.X + p2.X) / 2) + (((Math.Abs(p1.X - p2.X) / 2) / (m_stcBlobPad.intLineCount - 2))) + (int)((Math.Abs(p1.X - p2.X)) * (m_stcBlobPad.fWidthPercentStart6 / 100)));
                            fStartY = (int)(p1.Y + ((Math.Abs(p1.Y - p3.Y) * m_stcBlobPad.fHeightPercentStart6 / 100)));
                            fEndX = (int)(((p3.X + p4.X) / 2) + ((Math.Abs(p3.X - p4.X) / 2) / (m_stcBlobPad.intLineCount - 2))) + (int)((Math.Abs(p3.X - p4.X)) * (m_stcBlobPad.fWidthPercentEnd6 / 100));
                            fEndY = (int)(p3.Y + ((Math.Abs(p1.Y - p3.Y) * m_stcBlobPad.fHeightPercentEnd6 / 100)));

                            fX_Start = Math.Abs(fStartX - fEndX) * (m_stcBlobPad.fInwardPercentStart6 / 100);
                            fX_End = Math.Abs(fStartX - fEndX) * (m_stcBlobPad.fInwardPercentEnd6 / 100);
                            fY_Start = Math.Abs(fStartY - fEndY) * (m_stcBlobPad.fInwardPercentStart6 / 100);
                            fY_End = Math.Abs(fStartY - fEndY) * (m_stcBlobPad.fInwardPercentEnd6 / 100);

                            fStartX_Draw = fStartX + fX_Start;
                            fStartY_Draw = fStartY + fY_Start;
                            fEndX_Draw = fEndX - fX_End;
                            fEndY_Draw = fEndY - fY_End;
                            if (fStartX > fEndX)
                            {
                                fStartX_Draw = fStartX - fX_Start;
                                fEndX_Draw = fEndX + fX_End;
                            }
                            if (fStartY > fEndY)
                            {
                                fStartY_Draw = fStartY - fY_Start;
                                fEndY_Draw = fEndY + fY_End;
                            }

                            g.DrawLine(new Pen(Color.Orange, 2), fStartX_Draw, fStartY_Draw, fEndX_Draw, fEndY_Draw);

                            fStartX = (int)(((p1.X + p2.X) / 2) + (((Math.Abs(p1.X - p2.X) / 2) / (m_stcBlobPad.intLineCount - 1))) + (int)((Math.Abs(p1.X - p2.X)) * (m_stcBlobPad.fWidthPercentStart7 / 100)));
                            fStartY = (int)(p1.Y + ((Math.Abs(p1.Y - p3.Y) * m_stcBlobPad.fHeightPercentStart7 / 100)));
                            fEndX = (int)(((p3.X + p4.X) / 2) + ((Math.Abs(p3.X - p4.X) / 2) / (m_stcBlobPad.intLineCount - 1))) + (int)((Math.Abs(p3.X - p4.X)) * (m_stcBlobPad.fWidthPercentEnd7 / 100));
                            fEndY = (int)(p3.Y + ((Math.Abs(p1.Y - p3.Y) * m_stcBlobPad.fHeightPercentEnd7 / 100)));

                            fX_Start = Math.Abs(fStartX - fEndX) * (m_stcBlobPad.fInwardPercentStart7 / 100);
                            fX_End = Math.Abs(fStartX - fEndX) * (m_stcBlobPad.fInwardPercentEnd7 / 100);
                            fY_Start = Math.Abs(fStartY - fEndY) * (m_stcBlobPad.fInwardPercentStart7 / 100);
                            fY_End = Math.Abs(fStartY - fEndY) * (m_stcBlobPad.fInwardPercentEnd7 / 100);

                            fStartX_Draw = fStartX + fX_Start;
                            fStartY_Draw = fStartY + fY_Start;
                            fEndX_Draw = fEndX - fX_End;
                            fEndY_Draw = fEndY - fY_End;
                            if (fStartX > fEndX)
                            {
                                fStartX_Draw = fStartX - fX_Start;
                                fEndX_Draw = fEndX + fX_End;
                            }
                            if (fStartY > fEndY)
                            {
                                fStartY_Draw = fStartY - fY_Start;
                                fEndY_Draw = fEndY + fY_End;
                            }

                            g.DrawLine(new Pen(Color.Cyan, 2), fStartX_Draw, fStartY_Draw, fEndX_Draw, fEndY_Draw);

                            break;
                        case 8:
                            fStartX = (int)(((p1.X + p2.X) / 2) + (((Math.Abs(p1.X - p2.X) / 2) / (m_stcBlobPad.intLineCount - 6))) + (int)((Math.Abs(p1.X - p2.X)) * (m_stcBlobPad.fWidthPercentStart3 / 100)));
                            fStartY = (int)(p1.Y + ((Math.Abs(p1.Y - p3.Y) * m_stcBlobPad.fHeightPercentStart3 / 100)));
                            fEndX = (int)(((p3.X + p4.X) / 2) + ((Math.Abs(p3.X - p4.X) / 2) / (m_stcBlobPad.intLineCount - 6))) + (int)((Math.Abs(p3.X - p4.X)) * (m_stcBlobPad.fWidthPercentEnd3 / 100));
                            fEndY = (int)(p3.Y + ((Math.Abs(p1.Y - p3.Y) * m_stcBlobPad.fHeightPercentEnd3 / 100)));

                            fX_Start = Math.Abs(fStartX - fEndX) * (m_stcBlobPad.fInwardPercentStart3 / 100);
                            fX_End = Math.Abs(fStartX - fEndX) * (m_stcBlobPad.fInwardPercentEnd3 / 100);
                            fY_Start = Math.Abs(fStartY - fEndY) * (m_stcBlobPad.fInwardPercentStart3 / 100);
                            fY_End = Math.Abs(fStartY - fEndY) * (m_stcBlobPad.fInwardPercentEnd3 / 100);

                            fStartX_Draw = fStartX + fX_Start;
                            fStartY_Draw = fStartY + fY_Start;
                            fEndX_Draw = fEndX - fX_End;
                            fEndY_Draw = fEndY - fY_End;
                            if (fStartX > fEndX)
                            {
                                fStartX_Draw = fStartX - fX_Start;
                                fEndX_Draw = fEndX + fX_End;
                            }
                            if (fStartY > fEndY)
                            {
                                fStartY_Draw = fStartY - fY_Start;
                                fEndY_Draw = fEndY + fY_End;
                            }

                            g.DrawLine(new Pen(Color.Red, 2), fStartX_Draw, fStartY_Draw, fEndX_Draw, fEndY_Draw);

                            fStartX = (int)(((p1.X + p2.X) / 2) + (((Math.Abs(p1.X - p2.X) / 2) / (m_stcBlobPad.intLineCount - 5))) + (int)((Math.Abs(p1.X - p2.X)) * (m_stcBlobPad.fWidthPercentStart4 / 100)));
                            fStartY = (int)(p1.Y + ((Math.Abs(p1.Y - p3.Y) * m_stcBlobPad.fHeightPercentStart4 / 100)));
                            fEndX = (int)(((p3.X + p4.X) / 2) + ((Math.Abs(p3.X - p4.X) / 2) / (m_stcBlobPad.intLineCount - 5))) + (int)((Math.Abs(p3.X - p4.X)) * (m_stcBlobPad.fWidthPercentEnd4 / 100));
                            fEndY = (int)(p3.Y + ((Math.Abs(p1.Y - p3.Y) * m_stcBlobPad.fHeightPercentEnd4 / 100)));

                            fX_Start = Math.Abs(fStartX - fEndX) * (m_stcBlobPad.fInwardPercentStart4 / 100);
                            fX_End = Math.Abs(fStartX - fEndX) * (m_stcBlobPad.fInwardPercentEnd4 / 100);
                            fY_Start = Math.Abs(fStartY - fEndY) * (m_stcBlobPad.fInwardPercentStart4 / 100);
                            fY_End = Math.Abs(fStartY - fEndY) * (m_stcBlobPad.fInwardPercentEnd4 / 100);

                            fStartX_Draw = fStartX + fX_Start;
                            fStartY_Draw = fStartY + fY_Start;
                            fEndX_Draw = fEndX - fX_End;
                            fEndY_Draw = fEndY - fY_End;
                            if (fStartX > fEndX)
                            {
                                fStartX_Draw = fStartX - fX_Start;
                                fEndX_Draw = fEndX + fX_End;
                            }
                            if (fStartY > fEndY)
                            {
                                fStartY_Draw = fStartY - fY_Start;
                                fEndY_Draw = fEndY + fY_End;
                            }

                            g.DrawLine(new Pen(Color.Yellow, 2), fStartX_Draw, fStartY_Draw, fEndX_Draw, fEndY_Draw);

                            fStartX = (int)(((p1.X + p2.X) / 2) + (((Math.Abs(p1.X - p2.X) / 2) / (m_stcBlobPad.intLineCount - 4))) + (int)((Math.Abs(p1.X - p2.X)) * (m_stcBlobPad.fWidthPercentStart5 / 100)));
                            fStartY = (int)(p1.Y + ((Math.Abs(p1.Y - p3.Y) * m_stcBlobPad.fHeightPercentStart5 / 100)));
                            fEndX = (int)(((p3.X + p4.X) / 2) + ((Math.Abs(p3.X - p4.X) / 2) / (m_stcBlobPad.intLineCount - 4))) + (int)((Math.Abs(p3.X - p4.X)) * (m_stcBlobPad.fWidthPercentEnd5 / 100));
                            fEndY = (int)(p3.Y + ((Math.Abs(p1.Y - p3.Y) * m_stcBlobPad.fHeightPercentEnd5 / 100)));

                            fX_Start = Math.Abs(fStartX - fEndX) * (m_stcBlobPad.fInwardPercentStart5 / 100);
                            fX_End = Math.Abs(fStartX - fEndX) * (m_stcBlobPad.fInwardPercentEnd5 / 100);
                            fY_Start = Math.Abs(fStartY - fEndY) * (m_stcBlobPad.fInwardPercentStart5 / 100);
                            fY_End = Math.Abs(fStartY - fEndY) * (m_stcBlobPad.fInwardPercentEnd5 / 100);

                            fStartX_Draw = fStartX + fX_Start;
                            fStartY_Draw = fStartY + fY_Start;
                            fEndX_Draw = fEndX - fX_End;
                            fEndY_Draw = fEndY - fY_End;
                            if (fStartX > fEndX)
                            {
                                fStartX_Draw = fStartX - fX_Start;
                                fEndX_Draw = fEndX + fX_End;
                            }
                            if (fStartY > fEndY)
                            {
                                fStartY_Draw = fStartY - fY_Start;
                                fEndY_Draw = fEndY + fY_End;
                            }

                            g.DrawLine(new Pen(Color.Pink, 2), fStartX_Draw, fStartY_Draw, fEndX_Draw, fEndY_Draw);

                            fStartX = (int)(((p1.X + p2.X) / 2) + (((Math.Abs(p1.X - p2.X) / 2) / (m_stcBlobPad.intLineCount - 3))) + (int)((Math.Abs(p1.X - p2.X)) * (m_stcBlobPad.fWidthPercentStart6 / 100)));
                            fStartY = (int)(p1.Y + ((Math.Abs(p1.Y - p3.Y) * m_stcBlobPad.fHeightPercentStart6 / 100)));
                            fEndX = (int)(((p3.X + p4.X) / 2) + ((Math.Abs(p3.X - p4.X) / 2) / (m_stcBlobPad.intLineCount - 3))) + (int)((Math.Abs(p3.X - p4.X)) * (m_stcBlobPad.fWidthPercentEnd6 / 100));
                            fEndY = (int)(p3.Y + ((Math.Abs(p1.Y - p3.Y) * m_stcBlobPad.fHeightPercentEnd6 / 100)));

                            fX_Start = Math.Abs(fStartX - fEndX) * (m_stcBlobPad.fInwardPercentStart6 / 100);
                            fX_End = Math.Abs(fStartX - fEndX) * (m_stcBlobPad.fInwardPercentEnd6 / 100);
                            fY_Start = Math.Abs(fStartY - fEndY) * (m_stcBlobPad.fInwardPercentStart6 / 100);
                            fY_End = Math.Abs(fStartY - fEndY) * (m_stcBlobPad.fInwardPercentEnd6 / 100);

                            fStartX_Draw = fStartX + fX_Start;
                            fStartY_Draw = fStartY + fY_Start;
                            fEndX_Draw = fEndX - fX_End;
                            fEndY_Draw = fEndY - fY_End;
                            if (fStartX > fEndX)
                            {
                                fStartX_Draw = fStartX - fX_Start;
                                fEndX_Draw = fEndX + fX_End;
                            }
                            if (fStartY > fEndY)
                            {
                                fStartY_Draw = fStartY - fY_Start;
                                fEndY_Draw = fEndY + fY_End;
                            }

                            g.DrawLine(new Pen(Color.Orange, 2), fStartX_Draw, fStartY_Draw, fEndX_Draw, fEndY_Draw);

                            fStartX = (int)(((p1.X + p2.X) / 2) + (((Math.Abs(p1.X - p2.X) / 2) / (m_stcBlobPad.intLineCount - 2))) + (int)((Math.Abs(p1.X - p2.X)) * (m_stcBlobPad.fWidthPercentStart7 / 100)));
                            fStartY = (int)(p1.Y + ((Math.Abs(p1.Y - p3.Y) * m_stcBlobPad.fHeightPercentStart7 / 100)));
                            fEndX = (int)(((p3.X + p4.X) / 2) + ((Math.Abs(p3.X - p4.X) / 2) / (m_stcBlobPad.intLineCount - 2))) + (int)((Math.Abs(p3.X - p4.X)) * (m_stcBlobPad.fWidthPercentEnd7 / 100));
                            fEndY = (int)(p3.Y + ((Math.Abs(p1.Y - p3.Y) * m_stcBlobPad.fHeightPercentEnd7 / 100)));

                            fX_Start = Math.Abs(fStartX - fEndX) * (m_stcBlobPad.fInwardPercentStart7 / 100);
                            fX_End = Math.Abs(fStartX - fEndX) * (m_stcBlobPad.fInwardPercentEnd7 / 100);
                            fY_Start = Math.Abs(fStartY - fEndY) * (m_stcBlobPad.fInwardPercentStart7 / 100);
                            fY_End = Math.Abs(fStartY - fEndY) * (m_stcBlobPad.fInwardPercentEnd7 / 100);

                            fStartX_Draw = fStartX + fX_Start;
                            fStartY_Draw = fStartY + fY_Start;
                            fEndX_Draw = fEndX - fX_End;
                            fEndY_Draw = fEndY - fY_End;
                            if (fStartX > fEndX)
                            {
                                fStartX_Draw = fStartX - fX_Start;
                                fEndX_Draw = fEndX + fX_End;
                            }
                            if (fStartY > fEndY)
                            {
                                fStartY_Draw = fStartY - fY_Start;
                                fEndY_Draw = fEndY + fY_End;
                            }

                            g.DrawLine(new Pen(Color.Cyan, 2), fStartX_Draw, fStartY_Draw, fEndX_Draw, fEndY_Draw);

                            fStartX = (int)(((p1.X + p2.X) / 2) + (((Math.Abs(p1.X - p2.X) / 2) / (m_stcBlobPad.intLineCount - 1))) + (int)((Math.Abs(p1.X - p2.X)) * (m_stcBlobPad.fWidthPercentStart8 / 100)));
                            fStartY = (int)(p1.Y + ((Math.Abs(p1.Y - p3.Y) * m_stcBlobPad.fHeightPercentStart8 / 100)));
                            fEndX = (int)(((p3.X + p4.X) / 2) + ((Math.Abs(p3.X - p4.X) / 2) / (m_stcBlobPad.intLineCount - 1))) + (int)((Math.Abs(p3.X - p4.X)) * (m_stcBlobPad.fWidthPercentEnd8 / 100));
                            fEndY = (int)(p3.Y + ((Math.Abs(p1.Y - p3.Y) * m_stcBlobPad.fHeightPercentEnd8 / 100)));

                            fX_Start = Math.Abs(fStartX - fEndX) * (m_stcBlobPad.fInwardPercentStart8 / 100);
                            fX_End = Math.Abs(fStartX - fEndX) * (m_stcBlobPad.fInwardPercentEnd8 / 100);
                            fY_Start = Math.Abs(fStartY - fEndY) * (m_stcBlobPad.fInwardPercentStart8 / 100);
                            fY_End = Math.Abs(fStartY - fEndY) * (m_stcBlobPad.fInwardPercentEnd8 / 100);

                            fStartX_Draw = fStartX + fX_Start;
                            fStartY_Draw = fStartY + fY_Start;
                            fEndX_Draw = fEndX - fX_End;
                            fEndY_Draw = fEndY - fY_End;
                            if (fStartX > fEndX)
                            {
                                fStartX_Draw = fStartX - fX_Start;
                                fEndX_Draw = fEndX + fX_End;
                            }
                            if (fStartY > fEndY)
                            {
                                fStartY_Draw = fStartY - fY_Start;
                                fEndY_Draw = fEndY + fY_End;
                            }

                            g.DrawLine(new Pen(Color.Magenta, 2), fStartX_Draw, fStartY_Draw, fEndX_Draw, fEndY_Draw);

                            break;
                        case 9:
                            fStartX = (int)(((p1.X + p2.X) / 2) + (((Math.Abs(p1.X - p2.X) / 2) / (m_stcBlobPad.intLineCount - 7))) + (int)((Math.Abs(p1.X - p2.X)) * (m_stcBlobPad.fWidthPercentStart3 / 100)));
                            fStartY = (int)(p1.Y + ((Math.Abs(p1.Y - p3.Y) * m_stcBlobPad.fHeightPercentStart3 / 100)));
                            fEndX = (int)(((p3.X + p4.X) / 2) + ((Math.Abs(p3.X - p4.X) / 2) / (m_stcBlobPad.intLineCount - 7))) + (int)((Math.Abs(p3.X - p4.X)) * (m_stcBlobPad.fWidthPercentEnd3 / 100));
                            fEndY = (int)(p3.Y + ((Math.Abs(p1.Y - p3.Y) * m_stcBlobPad.fHeightPercentEnd3 / 100)));

                            fX_Start = Math.Abs(fStartX - fEndX) * (m_stcBlobPad.fInwardPercentStart3 / 100);
                            fX_End = Math.Abs(fStartX - fEndX) * (m_stcBlobPad.fInwardPercentEnd3 / 100);
                            fY_Start = Math.Abs(fStartY - fEndY) * (m_stcBlobPad.fInwardPercentStart3 / 100);
                            fY_End = Math.Abs(fStartY - fEndY) * (m_stcBlobPad.fInwardPercentEnd3 / 100);

                            fStartX_Draw = fStartX + fX_Start;
                            fStartY_Draw = fStartY + fY_Start;
                            fEndX_Draw = fEndX - fX_End;
                            fEndY_Draw = fEndY - fY_End;
                            if (fStartX > fEndX)
                            {
                                fStartX_Draw = fStartX - fX_Start;
                                fEndX_Draw = fEndX + fX_End;
                            }
                            if (fStartY > fEndY)
                            {
                                fStartY_Draw = fStartY - fY_Start;
                                fEndY_Draw = fEndY + fY_End;
                            }

                            g.DrawLine(new Pen(Color.Red, 2), fStartX_Draw, fStartY_Draw, fEndX_Draw, fEndY_Draw);

                            fStartX = (int)(((p1.X + p2.X) / 2) + (((Math.Abs(p1.X - p2.X) / 2) / (m_stcBlobPad.intLineCount - 6))) + (int)((Math.Abs(p1.X - p2.X)) * (m_stcBlobPad.fWidthPercentStart4 / 100)));
                            fStartY = (int)(p1.Y + ((Math.Abs(p1.Y - p3.Y) * m_stcBlobPad.fHeightPercentStart4 / 100)));
                            fEndX = (int)(((p3.X + p4.X) / 2) + ((Math.Abs(p3.X - p4.X) / 2) / (m_stcBlobPad.intLineCount - 6))) + (int)((Math.Abs(p3.X - p4.X)) * (m_stcBlobPad.fWidthPercentEnd4 / 100));
                            fEndY = (int)(p3.Y + ((Math.Abs(p1.Y - p3.Y) * m_stcBlobPad.fHeightPercentEnd4 / 100)));

                            fX_Start = Math.Abs(fStartX - fEndX) * (m_stcBlobPad.fInwardPercentStart4 / 100);
                            fX_End = Math.Abs(fStartX - fEndX) * (m_stcBlobPad.fInwardPercentEnd4 / 100);
                            fY_Start = Math.Abs(fStartY - fEndY) * (m_stcBlobPad.fInwardPercentStart4 / 100);
                            fY_End = Math.Abs(fStartY - fEndY) * (m_stcBlobPad.fInwardPercentEnd4 / 100);

                            fStartX_Draw = fStartX + fX_Start;
                            fStartY_Draw = fStartY + fY_Start;
                            fEndX_Draw = fEndX - fX_End;
                            fEndY_Draw = fEndY - fY_End;
                            if (fStartX > fEndX)
                            {
                                fStartX_Draw = fStartX - fX_Start;
                                fEndX_Draw = fEndX + fX_End;
                            }
                            if (fStartY > fEndY)
                            {
                                fStartY_Draw = fStartY - fY_Start;
                                fEndY_Draw = fEndY + fY_End;
                            }

                            g.DrawLine(new Pen(Color.Yellow, 2), fStartX_Draw, fStartY_Draw, fEndX_Draw, fEndY_Draw);

                            fStartX = (int)(((p1.X + p2.X) / 2) + (((Math.Abs(p1.X - p2.X) / 2) / (m_stcBlobPad.intLineCount - 5))) + (int)((Math.Abs(p1.X - p2.X)) * (m_stcBlobPad.fWidthPercentStart5 / 100)));
                            fStartY = (int)(p1.Y + ((Math.Abs(p1.Y - p3.Y) * m_stcBlobPad.fHeightPercentStart5 / 100)));
                            fEndX = (int)(((p3.X + p4.X) / 2) + ((Math.Abs(p3.X - p4.X) / 2) / (m_stcBlobPad.intLineCount - 5))) + (int)((Math.Abs(p3.X - p4.X)) * (m_stcBlobPad.fWidthPercentEnd5 / 100));
                            fEndY = (int)(p3.Y + ((Math.Abs(p1.Y - p3.Y) * m_stcBlobPad.fHeightPercentEnd5 / 100)));

                            fX_Start = Math.Abs(fStartX - fEndX) * (m_stcBlobPad.fInwardPercentStart5 / 100);
                            fX_End = Math.Abs(fStartX - fEndX) * (m_stcBlobPad.fInwardPercentEnd5 / 100);
                            fY_Start = Math.Abs(fStartY - fEndY) * (m_stcBlobPad.fInwardPercentStart5 / 100);
                            fY_End = Math.Abs(fStartY - fEndY) * (m_stcBlobPad.fInwardPercentEnd5 / 100);

                            fStartX_Draw = fStartX + fX_Start;
                            fStartY_Draw = fStartY + fY_Start;
                            fEndX_Draw = fEndX - fX_End;
                            fEndY_Draw = fEndY - fY_End;
                            if (fStartX > fEndX)
                            {
                                fStartX_Draw = fStartX - fX_Start;
                                fEndX_Draw = fEndX + fX_End;
                            }
                            if (fStartY > fEndY)
                            {
                                fStartY_Draw = fStartY - fY_Start;
                                fEndY_Draw = fEndY + fY_End;
                            }

                            g.DrawLine(new Pen(Color.Pink, 2), fStartX_Draw, fStartY_Draw, fEndX_Draw, fEndY_Draw);

                            fStartX = (int)(((p1.X + p2.X) / 2) + (((Math.Abs(p1.X - p2.X) / 2) / (m_stcBlobPad.intLineCount - 4))) + (int)((Math.Abs(p1.X - p2.X)) * (m_stcBlobPad.fWidthPercentStart6 / 100)));
                            fStartY = (int)(p1.Y + ((Math.Abs(p1.Y - p3.Y) * m_stcBlobPad.fHeightPercentStart6 / 100)));
                            fEndX = (int)(((p3.X + p4.X) / 2) + ((Math.Abs(p3.X - p4.X) / 2) / (m_stcBlobPad.intLineCount - 4))) + (int)((Math.Abs(p3.X - p4.X)) * (m_stcBlobPad.fWidthPercentEnd6 / 100));
                            fEndY = (int)(p3.Y + ((Math.Abs(p1.Y - p3.Y) * m_stcBlobPad.fHeightPercentEnd6 / 100)));

                            fX_Start = Math.Abs(fStartX - fEndX) * (m_stcBlobPad.fInwardPercentStart6 / 100);
                            fX_End = Math.Abs(fStartX - fEndX) * (m_stcBlobPad.fInwardPercentEnd6 / 100);
                            fY_Start = Math.Abs(fStartY - fEndY) * (m_stcBlobPad.fInwardPercentStart6 / 100);
                            fY_End = Math.Abs(fStartY - fEndY) * (m_stcBlobPad.fInwardPercentEnd6 / 100);

                            fStartX_Draw = fStartX + fX_Start;
                            fStartY_Draw = fStartY + fY_Start;
                            fEndX_Draw = fEndX - fX_End;
                            fEndY_Draw = fEndY - fY_End;
                            if (fStartX > fEndX)
                            {
                                fStartX_Draw = fStartX - fX_Start;
                                fEndX_Draw = fEndX + fX_End;
                            }
                            if (fStartY > fEndY)
                            {
                                fStartY_Draw = fStartY - fY_Start;
                                fEndY_Draw = fEndY + fY_End;
                            }

                            g.DrawLine(new Pen(Color.Orange, 2), fStartX_Draw, fStartY_Draw, fEndX_Draw, fEndY_Draw);

                            fStartX = (int)(((p1.X + p2.X) / 2) + (((Math.Abs(p1.X - p2.X) / 2) / (m_stcBlobPad.intLineCount - 3))) + (int)((Math.Abs(p1.X - p2.X)) * (m_stcBlobPad.fWidthPercentStart7 / 100)));
                            fStartY = (int)(p1.Y + ((Math.Abs(p1.Y - p3.Y) * m_stcBlobPad.fHeightPercentStart7 / 100)));
                            fEndX = (int)(((p3.X + p4.X) / 2) + ((Math.Abs(p3.X - p4.X) / 2) / (m_stcBlobPad.intLineCount - 3))) + (int)((Math.Abs(p3.X - p4.X)) * (m_stcBlobPad.fWidthPercentEnd7 / 100));
                            fEndY = (int)(p3.Y + ((Math.Abs(p1.Y - p3.Y) * m_stcBlobPad.fHeightPercentEnd7 / 100)));

                            fX_Start = Math.Abs(fStartX - fEndX) * (m_stcBlobPad.fInwardPercentStart7 / 100);
                            fX_End = Math.Abs(fStartX - fEndX) * (m_stcBlobPad.fInwardPercentEnd7 / 100);
                            fY_Start = Math.Abs(fStartY - fEndY) * (m_stcBlobPad.fInwardPercentStart7 / 100);
                            fY_End = Math.Abs(fStartY - fEndY) * (m_stcBlobPad.fInwardPercentEnd7 / 100);

                            fStartX_Draw = fStartX + fX_Start;
                            fStartY_Draw = fStartY + fY_Start;
                            fEndX_Draw = fEndX - fX_End;
                            fEndY_Draw = fEndY - fY_End;
                            if (fStartX > fEndX)
                            {
                                fStartX_Draw = fStartX - fX_Start;
                                fEndX_Draw = fEndX + fX_End;
                            }
                            if (fStartY > fEndY)
                            {
                                fStartY_Draw = fStartY - fY_Start;
                                fEndY_Draw = fEndY + fY_End;
                            }

                            g.DrawLine(new Pen(Color.Cyan, 2), fStartX_Draw, fStartY_Draw, fEndX_Draw, fEndY_Draw);

                            fStartX = (int)(((p1.X + p2.X) / 2) + (((Math.Abs(p1.X - p2.X) / 2) / (m_stcBlobPad.intLineCount - 2))) + (int)((Math.Abs(p1.X - p2.X)) * (m_stcBlobPad.fWidthPercentStart8 / 100)));
                            fStartY = (int)(p1.Y + ((Math.Abs(p1.Y - p3.Y) * m_stcBlobPad.fHeightPercentStart8 / 100)));
                            fEndX = (int)(((p3.X + p4.X) / 2) + ((Math.Abs(p3.X - p4.X) / 2) / (m_stcBlobPad.intLineCount - 2))) + (int)((Math.Abs(p3.X - p4.X)) * (m_stcBlobPad.fWidthPercentEnd8 / 100));
                            fEndY = (int)(p3.Y + ((Math.Abs(p1.Y - p3.Y) * m_stcBlobPad.fHeightPercentEnd8 / 100)));

                            fX_Start = Math.Abs(fStartX - fEndX) * (m_stcBlobPad.fInwardPercentStart8 / 100);
                            fX_End = Math.Abs(fStartX - fEndX) * (m_stcBlobPad.fInwardPercentEnd8 / 100);
                            fY_Start = Math.Abs(fStartY - fEndY) * (m_stcBlobPad.fInwardPercentStart8 / 100);
                            fY_End = Math.Abs(fStartY - fEndY) * (m_stcBlobPad.fInwardPercentEnd8 / 100);

                            fStartX_Draw = fStartX + fX_Start;
                            fStartY_Draw = fStartY + fY_Start;
                            fEndX_Draw = fEndX - fX_End;
                            fEndY_Draw = fEndY - fY_End;
                            if (fStartX > fEndX)
                            {
                                fStartX_Draw = fStartX - fX_Start;
                                fEndX_Draw = fEndX + fX_End;
                            }
                            if (fStartY > fEndY)
                            {
                                fStartY_Draw = fStartY - fY_Start;
                                fEndY_Draw = fEndY + fY_End;
                            }

                            g.DrawLine(new Pen(Color.Magenta, 2), fStartX_Draw, fStartY_Draw, fEndX_Draw, fEndY_Draw);

                            fStartX = (int)(((p1.X + p2.X) / 2) + (((Math.Abs(p1.X - p2.X) / 2) / (m_stcBlobPad.intLineCount - 1))) + (int)((Math.Abs(p1.X - p2.X)) * (m_stcBlobPad.fWidthPercentStart9 / 100)));
                            fStartY = (int)(p1.Y + ((Math.Abs(p1.Y - p3.Y) * m_stcBlobPad.fHeightPercentStart9 / 100)));
                            fEndX = (int)(((p3.X + p4.X) / 2) + ((Math.Abs(p3.X - p4.X) / 2) / (m_stcBlobPad.intLineCount - 1))) + (int)((Math.Abs(p3.X - p4.X)) * (m_stcBlobPad.fWidthPercentEnd9 / 100));
                            fEndY = (int)(p3.Y + ((Math.Abs(p1.Y - p3.Y) * m_stcBlobPad.fHeightPercentEnd9 / 100)));

                            fX_Start = Math.Abs(fStartX - fEndX) * (m_stcBlobPad.fInwardPercentStart9 / 100);
                            fX_End = Math.Abs(fStartX - fEndX) * (m_stcBlobPad.fInwardPercentEnd9 / 100);
                            fY_Start = Math.Abs(fStartY - fEndY) * (m_stcBlobPad.fInwardPercentStart9 / 100);
                            fY_End = Math.Abs(fStartY - fEndY) * (m_stcBlobPad.fInwardPercentEnd9 / 100);

                            fStartX_Draw = fStartX + fX_Start;
                            fStartY_Draw = fStartY + fY_Start;
                            fEndX_Draw = fEndX - fX_End;
                            fEndY_Draw = fEndY - fY_End;
                            if (fStartX > fEndX)
                            {
                                fStartX_Draw = fStartX - fX_Start;
                                fEndX_Draw = fEndX + fX_End;
                            }
                            if (fStartY > fEndY)
                            {
                                fStartY_Draw = fStartY - fY_Start;
                                fEndY_Draw = fEndY + fY_End;
                            }

                            g.DrawLine(new Pen(Color.Silver, 2), fStartX_Draw, fStartY_Draw, fEndX_Draw, fEndY_Draw);

                            break;
                        case 10:
                            fStartX = (int)(((p1.X + p2.X) / 2) + (((Math.Abs(p1.X - p2.X) / 2) / (m_stcBlobPad.intLineCount - 8))) + (int)((Math.Abs(p1.X - p2.X)) * (m_stcBlobPad.fWidthPercentStart3 / 100)));
                            fStartY = (int)(p1.Y + ((Math.Abs(p1.Y - p3.Y) * m_stcBlobPad.fHeightPercentStart3 / 100)));
                            fEndX = (int)(((p3.X + p4.X) / 2) + ((Math.Abs(p3.X - p4.X) / 2) / (m_stcBlobPad.intLineCount - 8))) + (int)((Math.Abs(p3.X - p4.X)) * (m_stcBlobPad.fWidthPercentEnd3 / 100));
                            fEndY = (int)(p3.Y + ((Math.Abs(p1.Y - p3.Y) * m_stcBlobPad.fHeightPercentEnd3 / 100)));

                            fX_Start = Math.Abs(fStartX - fEndX) * (m_stcBlobPad.fInwardPercentStart3 / 100);
                            fX_End = Math.Abs(fStartX - fEndX) * (m_stcBlobPad.fInwardPercentEnd3 / 100);
                            fY_Start = Math.Abs(fStartY - fEndY) * (m_stcBlobPad.fInwardPercentStart3 / 100);
                            fY_End = Math.Abs(fStartY - fEndY) * (m_stcBlobPad.fInwardPercentEnd3 / 100);

                            fStartX_Draw = fStartX + fX_Start;
                            fStartY_Draw = fStartY + fY_Start;
                            fEndX_Draw = fEndX - fX_End;
                            fEndY_Draw = fEndY - fY_End;
                            if (fStartX > fEndX)
                            {
                                fStartX_Draw = fStartX - fX_Start;
                                fEndX_Draw = fEndX + fX_End;
                            }
                            if (fStartY > fEndY)
                            {
                                fStartY_Draw = fStartY - fY_Start;
                                fEndY_Draw = fEndY + fY_End;
                            }

                            g.DrawLine(new Pen(Color.Red, 2), fStartX_Draw, fStartY_Draw, fEndX_Draw, fEndY_Draw);

                            fStartX = (int)(((p1.X + p2.X) / 2) + (((Math.Abs(p1.X - p2.X) / 2) / (m_stcBlobPad.intLineCount - 7))) + (int)((Math.Abs(p1.X - p2.X)) * (m_stcBlobPad.fWidthPercentStart4 / 100)));
                            fStartY = (int)(p1.Y + ((Math.Abs(p1.Y - p3.Y) * m_stcBlobPad.fHeightPercentStart4 / 100)));
                            fEndX = (int)(((p3.X + p4.X) / 2) + ((Math.Abs(p3.X - p4.X) / 2) / (m_stcBlobPad.intLineCount - 7))) + (int)((Math.Abs(p3.X - p4.X)) * (m_stcBlobPad.fWidthPercentEnd4 / 100));
                            fEndY = (int)(p3.Y + ((Math.Abs(p1.Y - p3.Y) * m_stcBlobPad.fHeightPercentEnd4 / 100)));

                            fX_Start = Math.Abs(fStartX - fEndX) * (m_stcBlobPad.fInwardPercentStart4 / 100);
                            fX_End = Math.Abs(fStartX - fEndX) * (m_stcBlobPad.fInwardPercentEnd4 / 100);
                            fY_Start = Math.Abs(fStartY - fEndY) * (m_stcBlobPad.fInwardPercentStart4 / 100);
                            fY_End = Math.Abs(fStartY - fEndY) * (m_stcBlobPad.fInwardPercentEnd4 / 100);

                            fStartX_Draw = fStartX + fX_Start;
                            fStartY_Draw = fStartY + fY_Start;
                            fEndX_Draw = fEndX - fX_End;
                            fEndY_Draw = fEndY - fY_End;
                            if (fStartX > fEndX)
                            {
                                fStartX_Draw = fStartX - fX_Start;
                                fEndX_Draw = fEndX + fX_End;
                            }
                            if (fStartY > fEndY)
                            {
                                fStartY_Draw = fStartY - fY_Start;
                                fEndY_Draw = fEndY + fY_End;
                            }

                            g.DrawLine(new Pen(Color.Yellow, 2), fStartX_Draw, fStartY_Draw, fEndX_Draw, fEndY_Draw);

                            fStartX = (int)(((p1.X + p2.X) / 2) + (((Math.Abs(p1.X - p2.X) / 2) / (m_stcBlobPad.intLineCount - 6))) + (int)((Math.Abs(p1.X - p2.X)) * (m_stcBlobPad.fWidthPercentStart5 / 100)));
                            fStartY = (int)(p1.Y + ((Math.Abs(p1.Y - p3.Y) * m_stcBlobPad.fHeightPercentStart5 / 100)));
                            fEndX = (int)(((p3.X + p4.X) / 2) + ((Math.Abs(p3.X - p4.X) / 2) / (m_stcBlobPad.intLineCount - 6))) + (int)((Math.Abs(p3.X - p4.X)) * (m_stcBlobPad.fWidthPercentEnd5 / 100));
                            fEndY = (int)(p3.Y + ((Math.Abs(p1.Y - p3.Y) * m_stcBlobPad.fHeightPercentEnd5 / 100)));

                            fX_Start = Math.Abs(fStartX - fEndX) * (m_stcBlobPad.fInwardPercentStart5 / 100);
                            fX_End = Math.Abs(fStartX - fEndX) * (m_stcBlobPad.fInwardPercentEnd5 / 100);
                            fY_Start = Math.Abs(fStartY - fEndY) * (m_stcBlobPad.fInwardPercentStart5 / 100);
                            fY_End = Math.Abs(fStartY - fEndY) * (m_stcBlobPad.fInwardPercentEnd5 / 100);

                            fStartX_Draw = fStartX + fX_Start;
                            fStartY_Draw = fStartY + fY_Start;
                            fEndX_Draw = fEndX - fX_End;
                            fEndY_Draw = fEndY - fY_End;
                            if (fStartX > fEndX)
                            {
                                fStartX_Draw = fStartX - fX_Start;
                                fEndX_Draw = fEndX + fX_End;
                            }
                            if (fStartY > fEndY)
                            {
                                fStartY_Draw = fStartY - fY_Start;
                                fEndY_Draw = fEndY + fY_End;
                            }

                            g.DrawLine(new Pen(Color.Pink, 2), fStartX_Draw, fStartY_Draw, fEndX_Draw, fEndY_Draw);

                            fStartX = (int)(((p1.X + p2.X) / 2) + (((Math.Abs(p1.X - p2.X) / 2) / (m_stcBlobPad.intLineCount - 5))) + (int)((Math.Abs(p1.X - p2.X)) * (m_stcBlobPad.fWidthPercentStart6 / 100)));
                            fStartY = (int)(p1.Y + ((Math.Abs(p1.Y - p3.Y) * m_stcBlobPad.fHeightPercentStart6 / 100)));
                            fEndX = (int)(((p3.X + p4.X) / 2) + ((Math.Abs(p3.X - p4.X) / 2) / (m_stcBlobPad.intLineCount - 5))) + (int)((Math.Abs(p3.X - p4.X)) * (m_stcBlobPad.fWidthPercentEnd6 / 100));
                            fEndY = (int)(p3.Y + ((Math.Abs(p1.Y - p3.Y) * m_stcBlobPad.fHeightPercentEnd6 / 100)));

                            fX_Start = Math.Abs(fStartX - fEndX) * (m_stcBlobPad.fInwardPercentStart6 / 100);
                            fX_End = Math.Abs(fStartX - fEndX) * (m_stcBlobPad.fInwardPercentEnd6 / 100);
                            fY_Start = Math.Abs(fStartY - fEndY) * (m_stcBlobPad.fInwardPercentStart6 / 100);
                            fY_End = Math.Abs(fStartY - fEndY) * (m_stcBlobPad.fInwardPercentEnd6 / 100);

                            fStartX_Draw = fStartX + fX_Start;
                            fStartY_Draw = fStartY + fY_Start;
                            fEndX_Draw = fEndX - fX_End;
                            fEndY_Draw = fEndY - fY_End;
                            if (fStartX > fEndX)
                            {
                                fStartX_Draw = fStartX - fX_Start;
                                fEndX_Draw = fEndX + fX_End;
                            }
                            if (fStartY > fEndY)
                            {
                                fStartY_Draw = fStartY - fY_Start;
                                fEndY_Draw = fEndY + fY_End;
                            }

                            g.DrawLine(new Pen(Color.Orange, 2), fStartX_Draw, fStartY_Draw, fEndX_Draw, fEndY_Draw);

                            fStartX = (int)(((p1.X + p2.X) / 2) + (((Math.Abs(p1.X - p2.X) / 2) / (m_stcBlobPad.intLineCount - 4))) + (int)((Math.Abs(p1.X - p2.X)) * (m_stcBlobPad.fWidthPercentStart7 / 100)));
                            fStartY = (int)(p1.Y + ((Math.Abs(p1.Y - p3.Y) * m_stcBlobPad.fHeightPercentStart7 / 100)));
                            fEndX = (int)(((p3.X + p4.X) / 2) + ((Math.Abs(p3.X - p4.X) / 2) / (m_stcBlobPad.intLineCount - 4))) + (int)((Math.Abs(p3.X - p4.X)) * (m_stcBlobPad.fWidthPercentEnd7 / 100));
                            fEndY = (int)(p3.Y + ((Math.Abs(p1.Y - p3.Y) * m_stcBlobPad.fHeightPercentEnd7 / 100)));

                            fX_Start = Math.Abs(fStartX - fEndX) * (m_stcBlobPad.fInwardPercentStart7 / 100);
                            fX_End = Math.Abs(fStartX - fEndX) * (m_stcBlobPad.fInwardPercentEnd7 / 100);
                            fY_Start = Math.Abs(fStartY - fEndY) * (m_stcBlobPad.fInwardPercentStart7 / 100);
                            fY_End = Math.Abs(fStartY - fEndY) * (m_stcBlobPad.fInwardPercentEnd7 / 100);

                            fStartX_Draw = fStartX + fX_Start;
                            fStartY_Draw = fStartY + fY_Start;
                            fEndX_Draw = fEndX - fX_End;
                            fEndY_Draw = fEndY - fY_End;
                            if (fStartX > fEndX)
                            {
                                fStartX_Draw = fStartX - fX_Start;
                                fEndX_Draw = fEndX + fX_End;
                            }
                            if (fStartY > fEndY)
                            {
                                fStartY_Draw = fStartY - fY_Start;
                                fEndY_Draw = fEndY + fY_End;
                            }

                            g.DrawLine(new Pen(Color.Cyan, 2), fStartX_Draw, fStartY_Draw, fEndX_Draw, fEndY_Draw);

                            fStartX = (int)(((p1.X + p2.X) / 2) + (((Math.Abs(p1.X - p2.X) / 2) / (m_stcBlobPad.intLineCount - 3))) + (int)((Math.Abs(p1.X - p2.X)) * (m_stcBlobPad.fWidthPercentStart8 / 100)));
                            fStartY = (int)(p1.Y + ((Math.Abs(p1.Y - p3.Y) * m_stcBlobPad.fHeightPercentStart8 / 100)));
                            fEndX = (int)(((p3.X + p4.X) / 2) + ((Math.Abs(p3.X - p4.X) / 2) / (m_stcBlobPad.intLineCount - 3))) + (int)((Math.Abs(p3.X - p4.X)) * (m_stcBlobPad.fWidthPercentEnd8 / 100));
                            fEndY = (int)(p3.Y + ((Math.Abs(p1.Y - p3.Y) * m_stcBlobPad.fHeightPercentEnd8 / 100)));

                            fX_Start = Math.Abs(fStartX - fEndX) * (m_stcBlobPad.fInwardPercentStart8 / 100);
                            fX_End = Math.Abs(fStartX - fEndX) * (m_stcBlobPad.fInwardPercentEnd8 / 100);
                            fY_Start = Math.Abs(fStartY - fEndY) * (m_stcBlobPad.fInwardPercentStart8 / 100);
                            fY_End = Math.Abs(fStartY - fEndY) * (m_stcBlobPad.fInwardPercentEnd8 / 100);

                            fStartX_Draw = fStartX + fX_Start;
                            fStartY_Draw = fStartY + fY_Start;
                            fEndX_Draw = fEndX - fX_End;
                            fEndY_Draw = fEndY - fY_End;
                            if (fStartX > fEndX)
                            {
                                fStartX_Draw = fStartX - fX_Start;
                                fEndX_Draw = fEndX + fX_End;
                            }
                            if (fStartY > fEndY)
                            {
                                fStartY_Draw = fStartY - fY_Start;
                                fEndY_Draw = fEndY + fY_End;
                            }

                            g.DrawLine(new Pen(Color.Magenta, 2), fStartX_Draw, fStartY_Draw, fEndX_Draw, fEndY_Draw);

                            fStartX = (int)(((p1.X + p2.X) / 2) + (((Math.Abs(p1.X - p2.X) / 2) / (m_stcBlobPad.intLineCount - 2))) + (int)((Math.Abs(p1.X - p2.X)) * (m_stcBlobPad.fWidthPercentStart9 / 100)));
                            fStartY = (int)(p1.Y + ((Math.Abs(p1.Y - p3.Y) * m_stcBlobPad.fHeightPercentStart9 / 100)));
                            fEndX = (int)(((p3.X + p4.X) / 2) + ((Math.Abs(p3.X - p4.X) / 2) / (m_stcBlobPad.intLineCount - 2))) + (int)((Math.Abs(p3.X - p4.X)) * (m_stcBlobPad.fWidthPercentEnd9 / 100));
                            fEndY = (int)(p3.Y + ((Math.Abs(p1.Y - p3.Y) * m_stcBlobPad.fHeightPercentEnd9 / 100)));

                            fX_Start = Math.Abs(fStartX - fEndX) * (m_stcBlobPad.fInwardPercentStart9 / 100);
                            fX_End = Math.Abs(fStartX - fEndX) * (m_stcBlobPad.fInwardPercentEnd9 / 100);
                            fY_Start = Math.Abs(fStartY - fEndY) * (m_stcBlobPad.fInwardPercentStart9 / 100);
                            fY_End = Math.Abs(fStartY - fEndY) * (m_stcBlobPad.fInwardPercentEnd9 / 100);

                            fStartX_Draw = fStartX + fX_Start;
                            fStartY_Draw = fStartY + fY_Start;
                            fEndX_Draw = fEndX - fX_End;
                            fEndY_Draw = fEndY - fY_End;
                            if (fStartX > fEndX)
                            {
                                fStartX_Draw = fStartX - fX_Start;
                                fEndX_Draw = fEndX + fX_End;
                            }
                            if (fStartY > fEndY)
                            {
                                fStartY_Draw = fStartY - fY_Start;
                                fEndY_Draw = fEndY + fY_End;
                            }

                            g.DrawLine(new Pen(Color.Silver, 2), fStartX_Draw, fStartY_Draw, fEndX_Draw, fEndY_Draw);

                            fStartX = (int)(((p1.X + p2.X) / 2) + (((Math.Abs(p1.X - p2.X) / 2) / (m_stcBlobPad.intLineCount - 1))) + (int)((Math.Abs(p1.X - p2.X)) * (m_stcBlobPad.fWidthPercentStart10 / 100)));
                            fStartY = (int)(p1.Y + ((Math.Abs(p1.Y - p3.Y) * m_stcBlobPad.fHeightPercentStart10 / 100)));
                            fEndX = (int)(((p3.X + p4.X) / 2) + ((Math.Abs(p3.X - p4.X) / 2) / (m_stcBlobPad.intLineCount - 1))) + (int)((Math.Abs(p3.X - p4.X)) * (m_stcBlobPad.fWidthPercentEnd10 / 100));
                            fEndY = (int)(p3.Y + ((Math.Abs(p1.Y - p3.Y) * m_stcBlobPad.fHeightPercentEnd10 / 100)));

                            fX_Start = Math.Abs(fStartX - fEndX) * (m_stcBlobPad.fInwardPercentStart10 / 100);
                            fX_End = Math.Abs(fStartX - fEndX) * (m_stcBlobPad.fInwardPercentEnd10 / 100);
                            fY_Start = Math.Abs(fStartY - fEndY) * (m_stcBlobPad.fInwardPercentStart10 / 100);
                            fY_End = Math.Abs(fStartY - fEndY) * (m_stcBlobPad.fInwardPercentEnd10 / 100);

                            fStartX_Draw = fStartX + fX_Start;
                            fStartY_Draw = fStartY + fY_Start;
                            fEndX_Draw = fEndX - fX_End;
                            fEndY_Draw = fEndY - fY_End;
                            if (fStartX > fEndX)
                            {
                                fStartX_Draw = fStartX - fX_Start;
                                fEndX_Draw = fEndX + fX_End;
                            }
                            if (fStartY > fEndY)
                            {
                                fStartY_Draw = fStartY - fY_Start;
                                fEndY_Draw = fEndY + fY_End;
                            }

                            g.DrawLine(new Pen(Color.Wheat, 2), fStartX_Draw, fStartY_Draw, fEndX_Draw, fEndY_Draw);

                            break;
                        case 11:
                            fStartX = (int)(((p1.X + p2.X) / 2) + (((Math.Abs(p1.X - p2.X) / 2) / (m_stcBlobPad.intLineCount - 9))) + (int)((Math.Abs(p1.X - p2.X)) * (m_stcBlobPad.fWidthPercentStart3 / 100)));
                            fStartY = (int)(p1.Y + ((Math.Abs(p1.Y - p3.Y) * m_stcBlobPad.fHeightPercentStart3 / 100)));
                            fEndX = (int)(((p3.X + p4.X) / 2) + ((Math.Abs(p3.X - p4.X) / 2) / (m_stcBlobPad.intLineCount - 9))) + (int)((Math.Abs(p3.X - p4.X)) * (m_stcBlobPad.fWidthPercentEnd3 / 100));
                            fEndY = (int)(p3.Y + ((Math.Abs(p1.Y - p3.Y) * m_stcBlobPad.fHeightPercentEnd3 / 100)));

                            fX_Start = Math.Abs(fStartX - fEndX) * (m_stcBlobPad.fInwardPercentStart3 / 100);
                            fX_End = Math.Abs(fStartX - fEndX) * (m_stcBlobPad.fInwardPercentEnd3 / 100);
                            fY_Start = Math.Abs(fStartY - fEndY) * (m_stcBlobPad.fInwardPercentStart3 / 100);
                            fY_End = Math.Abs(fStartY - fEndY) * (m_stcBlobPad.fInwardPercentEnd3 / 100);

                            fStartX_Draw = fStartX + fX_Start;
                            fStartY_Draw = fStartY + fY_Start;
                            fEndX_Draw = fEndX - fX_End;
                            fEndY_Draw = fEndY - fY_End;
                            if (fStartX > fEndX)
                            {
                                fStartX_Draw = fStartX - fX_Start;
                                fEndX_Draw = fEndX + fX_End;
                            }
                            if (fStartY > fEndY)
                            {
                                fStartY_Draw = fStartY - fY_Start;
                                fEndY_Draw = fEndY + fY_End;
                            }

                            g.DrawLine(new Pen(Color.Red, 2), fStartX_Draw, fStartY_Draw, fEndX_Draw, fEndY_Draw);

                            fStartX = (int)(((p1.X + p2.X) / 2) + (((Math.Abs(p1.X - p2.X) / 2) / (m_stcBlobPad.intLineCount - 8))) + (int)((Math.Abs(p1.X - p2.X)) * (m_stcBlobPad.fWidthPercentStart4 / 100)));
                            fStartY = (int)(p1.Y + ((Math.Abs(p1.Y - p3.Y) * m_stcBlobPad.fHeightPercentStart4 / 100)));
                            fEndX = (int)(((p3.X + p4.X) / 2) + ((Math.Abs(p3.X - p4.X) / 2) / (m_stcBlobPad.intLineCount - 8))) + (int)((Math.Abs(p3.X - p4.X)) * (m_stcBlobPad.fWidthPercentEnd4 / 100));
                            fEndY = (int)(p3.Y + ((Math.Abs(p1.Y - p3.Y) * m_stcBlobPad.fHeightPercentEnd4 / 100)));

                            fX_Start = Math.Abs(fStartX - fEndX) * (m_stcBlobPad.fInwardPercentStart4 / 100);
                            fX_End = Math.Abs(fStartX - fEndX) * (m_stcBlobPad.fInwardPercentEnd4 / 100);
                            fY_Start = Math.Abs(fStartY - fEndY) * (m_stcBlobPad.fInwardPercentStart4 / 100);
                            fY_End = Math.Abs(fStartY - fEndY) * (m_stcBlobPad.fInwardPercentEnd4 / 100);

                            fStartX_Draw = fStartX + fX_Start;
                            fStartY_Draw = fStartY + fY_Start;
                            fEndX_Draw = fEndX - fX_End;
                            fEndY_Draw = fEndY - fY_End;
                            if (fStartX > fEndX)
                            {
                                fStartX_Draw = fStartX - fX_Start;
                                fEndX_Draw = fEndX + fX_End;
                            }
                            if (fStartY > fEndY)
                            {
                                fStartY_Draw = fStartY - fY_Start;
                                fEndY_Draw = fEndY + fY_End;
                            }

                            g.DrawLine(new Pen(Color.Yellow, 2), fStartX_Draw, fStartY_Draw, fEndX_Draw, fEndY_Draw);

                            fStartX = (int)(((p1.X + p2.X) / 2) + (((Math.Abs(p1.X - p2.X) / 2) / (m_stcBlobPad.intLineCount - 7))) + (int)((Math.Abs(p1.X - p2.X)) * (m_stcBlobPad.fWidthPercentStart5 / 100)));
                            fStartY = (int)(p1.Y + ((Math.Abs(p1.Y - p3.Y) * m_stcBlobPad.fHeightPercentStart5 / 100)));
                            fEndX = (int)(((p3.X + p4.X) / 2) + ((Math.Abs(p3.X - p4.X) / 2) / (m_stcBlobPad.intLineCount - 7))) + (int)((Math.Abs(p3.X - p4.X)) * (m_stcBlobPad.fWidthPercentEnd5 / 100));
                            fEndY = (int)(p3.Y + ((Math.Abs(p1.Y - p3.Y) * m_stcBlobPad.fHeightPercentEnd5 / 100)));

                            fX_Start = Math.Abs(fStartX - fEndX) * (m_stcBlobPad.fInwardPercentStart5 / 100);
                            fX_End = Math.Abs(fStartX - fEndX) * (m_stcBlobPad.fInwardPercentEnd5 / 100);
                            fY_Start = Math.Abs(fStartY - fEndY) * (m_stcBlobPad.fInwardPercentStart5 / 100);
                            fY_End = Math.Abs(fStartY - fEndY) * (m_stcBlobPad.fInwardPercentEnd5 / 100);

                            fStartX_Draw = fStartX + fX_Start;
                            fStartY_Draw = fStartY + fY_Start;
                            fEndX_Draw = fEndX - fX_End;
                            fEndY_Draw = fEndY - fY_End;
                            if (fStartX > fEndX)
                            {
                                fStartX_Draw = fStartX - fX_Start;
                                fEndX_Draw = fEndX + fX_End;
                            }
                            if (fStartY > fEndY)
                            {
                                fStartY_Draw = fStartY - fY_Start;
                                fEndY_Draw = fEndY + fY_End;
                            }

                            g.DrawLine(new Pen(Color.Pink, 2), fStartX_Draw, fStartY_Draw, fEndX_Draw, fEndY_Draw);

                            fStartX = (int)(((p1.X + p2.X) / 2) + (((Math.Abs(p1.X - p2.X) / 2) / (m_stcBlobPad.intLineCount - 6))) + (int)((Math.Abs(p1.X - p2.X)) * (m_stcBlobPad.fWidthPercentStart6 / 100)));
                            fStartY = (int)(p1.Y + ((Math.Abs(p1.Y - p3.Y) * m_stcBlobPad.fHeightPercentStart6 / 100)));
                            fEndX = (int)(((p3.X + p4.X) / 2) + ((Math.Abs(p3.X - p4.X) / 2) / (m_stcBlobPad.intLineCount - 6))) + (int)((Math.Abs(p3.X - p4.X)) * (m_stcBlobPad.fWidthPercentEnd6 / 100));
                            fEndY = (int)(p3.Y + ((Math.Abs(p1.Y - p3.Y) * m_stcBlobPad.fHeightPercentEnd6 / 100)));

                            fX_Start = Math.Abs(fStartX - fEndX) * (m_stcBlobPad.fInwardPercentStart6 / 100);
                            fX_End = Math.Abs(fStartX - fEndX) * (m_stcBlobPad.fInwardPercentEnd6 / 100);
                            fY_Start = Math.Abs(fStartY - fEndY) * (m_stcBlobPad.fInwardPercentStart6 / 100);
                            fY_End = Math.Abs(fStartY - fEndY) * (m_stcBlobPad.fInwardPercentEnd6 / 100);

                            fStartX_Draw = fStartX + fX_Start;
                            fStartY_Draw = fStartY + fY_Start;
                            fEndX_Draw = fEndX - fX_End;
                            fEndY_Draw = fEndY - fY_End;
                            if (fStartX > fEndX)
                            {
                                fStartX_Draw = fStartX - fX_Start;
                                fEndX_Draw = fEndX + fX_End;
                            }
                            if (fStartY > fEndY)
                            {
                                fStartY_Draw = fStartY - fY_Start;
                                fEndY_Draw = fEndY + fY_End;
                            }

                            g.DrawLine(new Pen(Color.Orange, 2), fStartX_Draw, fStartY_Draw, fEndX_Draw, fEndY_Draw);

                            fStartX = (int)(((p1.X + p2.X) / 2) + (((Math.Abs(p1.X - p2.X) / 2) / (m_stcBlobPad.intLineCount - 5))) + (int)((Math.Abs(p1.X - p2.X)) * (m_stcBlobPad.fWidthPercentStart7 / 100)));
                            fStartY = (int)(p1.Y + ((Math.Abs(p1.Y - p3.Y) * m_stcBlobPad.fHeightPercentStart7 / 100)));
                            fEndX = (int)(((p3.X + p4.X) / 2) + ((Math.Abs(p3.X - p4.X) / 2) / (m_stcBlobPad.intLineCount - 5))) + (int)((Math.Abs(p3.X - p4.X)) * (m_stcBlobPad.fWidthPercentEnd7 / 100));
                            fEndY = (int)(p3.Y + ((Math.Abs(p1.Y - p3.Y) * m_stcBlobPad.fHeightPercentEnd7 / 100)));

                            fX_Start = Math.Abs(fStartX - fEndX) * (m_stcBlobPad.fInwardPercentStart7 / 100);
                            fX_End = Math.Abs(fStartX - fEndX) * (m_stcBlobPad.fInwardPercentEnd7 / 100);
                            fY_Start = Math.Abs(fStartY - fEndY) * (m_stcBlobPad.fInwardPercentStart7 / 100);
                            fY_End = Math.Abs(fStartY - fEndY) * (m_stcBlobPad.fInwardPercentEnd7 / 100);

                            fStartX_Draw = fStartX + fX_Start;
                            fStartY_Draw = fStartY + fY_Start;
                            fEndX_Draw = fEndX - fX_End;
                            fEndY_Draw = fEndY - fY_End;
                            if (fStartX > fEndX)
                            {
                                fStartX_Draw = fStartX - fX_Start;
                                fEndX_Draw = fEndX + fX_End;
                            }
                            if (fStartY > fEndY)
                            {
                                fStartY_Draw = fStartY - fY_Start;
                                fEndY_Draw = fEndY + fY_End;
                            }

                            g.DrawLine(new Pen(Color.Cyan, 2), fStartX_Draw, fStartY_Draw, fEndX_Draw, fEndY_Draw);

                            fStartX = (int)(((p1.X + p2.X) / 2) + (((Math.Abs(p1.X - p2.X) / 2) / (m_stcBlobPad.intLineCount - 4))) + (int)((Math.Abs(p1.X - p2.X)) * (m_stcBlobPad.fWidthPercentStart8 / 100)));
                            fStartY = (int)(p1.Y + ((Math.Abs(p1.Y - p3.Y) * m_stcBlobPad.fHeightPercentStart8 / 100)));
                            fEndX = (int)(((p3.X + p4.X) / 2) + ((Math.Abs(p3.X - p4.X) / 2) / (m_stcBlobPad.intLineCount - 4))) + (int)((Math.Abs(p3.X - p4.X)) * (m_stcBlobPad.fWidthPercentEnd8 / 100));
                            fEndY = (int)(p3.Y + ((Math.Abs(p1.Y - p3.Y) * m_stcBlobPad.fHeightPercentEnd8 / 100)));

                            fX_Start = Math.Abs(fStartX - fEndX) * (m_stcBlobPad.fInwardPercentStart8 / 100);
                            fX_End = Math.Abs(fStartX - fEndX) * (m_stcBlobPad.fInwardPercentEnd8 / 100);
                            fY_Start = Math.Abs(fStartY - fEndY) * (m_stcBlobPad.fInwardPercentStart8 / 100);
                            fY_End = Math.Abs(fStartY - fEndY) * (m_stcBlobPad.fInwardPercentEnd8 / 100);

                            fStartX_Draw = fStartX + fX_Start;
                            fStartY_Draw = fStartY + fY_Start;
                            fEndX_Draw = fEndX - fX_End;
                            fEndY_Draw = fEndY - fY_End;
                            if (fStartX > fEndX)
                            {
                                fStartX_Draw = fStartX - fX_Start;
                                fEndX_Draw = fEndX + fX_End;
                            }
                            if (fStartY > fEndY)
                            {
                                fStartY_Draw = fStartY - fY_Start;
                                fEndY_Draw = fEndY + fY_End;
                            }

                            g.DrawLine(new Pen(Color.Magenta, 2), fStartX_Draw, fStartY_Draw, fEndX_Draw, fEndY_Draw);

                            fStartX = (int)(((p1.X + p2.X) / 2) + (((Math.Abs(p1.X - p2.X) / 2) / (m_stcBlobPad.intLineCount - 3))) + (int)((Math.Abs(p1.X - p2.X)) * (m_stcBlobPad.fWidthPercentStart9 / 100)));
                            fStartY = (int)(p1.Y + ((Math.Abs(p1.Y - p3.Y) * m_stcBlobPad.fHeightPercentStart9 / 100)));
                            fEndX = (int)(((p3.X + p4.X) / 2) + ((Math.Abs(p3.X - p4.X) / 2) / (m_stcBlobPad.intLineCount - 3))) + (int)((Math.Abs(p3.X - p4.X)) * (m_stcBlobPad.fWidthPercentEnd9 / 100));
                            fEndY = (int)(p3.Y + ((Math.Abs(p1.Y - p3.Y) * m_stcBlobPad.fHeightPercentEnd9 / 100)));

                            fX_Start = Math.Abs(fStartX - fEndX) * (m_stcBlobPad.fInwardPercentStart9 / 100);
                            fX_End = Math.Abs(fStartX - fEndX) * (m_stcBlobPad.fInwardPercentEnd9 / 100);
                            fY_Start = Math.Abs(fStartY - fEndY) * (m_stcBlobPad.fInwardPercentStart9 / 100);
                            fY_End = Math.Abs(fStartY - fEndY) * (m_stcBlobPad.fInwardPercentEnd9 / 100);

                            fStartX_Draw = fStartX + fX_Start;
                            fStartY_Draw = fStartY + fY_Start;
                            fEndX_Draw = fEndX - fX_End;
                            fEndY_Draw = fEndY - fY_End;
                            if (fStartX > fEndX)
                            {
                                fStartX_Draw = fStartX - fX_Start;
                                fEndX_Draw = fEndX + fX_End;
                            }
                            if (fStartY > fEndY)
                            {
                                fStartY_Draw = fStartY - fY_Start;
                                fEndY_Draw = fEndY + fY_End;
                            }

                            g.DrawLine(new Pen(Color.Silver, 2), fStartX_Draw, fStartY_Draw, fEndX_Draw, fEndY_Draw);

                            fStartX = (int)(((p1.X + p2.X) / 2) + (((Math.Abs(p1.X - p2.X) / 2) / (m_stcBlobPad.intLineCount - 2))) + (int)((Math.Abs(p1.X - p2.X)) * (m_stcBlobPad.fWidthPercentStart10 / 100)));
                            fStartY = (int)(p1.Y + ((Math.Abs(p1.Y - p3.Y) * m_stcBlobPad.fHeightPercentStart10 / 100)));
                            fEndX = (int)(((p3.X + p4.X) / 2) + ((Math.Abs(p3.X - p4.X) / 2) / (m_stcBlobPad.intLineCount - 2))) + (int)((Math.Abs(p3.X - p4.X)) * (m_stcBlobPad.fWidthPercentEnd10 / 100));
                            fEndY = (int)(p3.Y + ((Math.Abs(p1.Y - p3.Y) * m_stcBlobPad.fHeightPercentEnd10 / 100)));

                            fX_Start = Math.Abs(fStartX - fEndX) * (m_stcBlobPad.fInwardPercentStart10 / 100);
                            fX_End = Math.Abs(fStartX - fEndX) * (m_stcBlobPad.fInwardPercentEnd10 / 100);
                            fY_Start = Math.Abs(fStartY - fEndY) * (m_stcBlobPad.fInwardPercentStart10 / 100);
                            fY_End = Math.Abs(fStartY - fEndY) * (m_stcBlobPad.fInwardPercentEnd10 / 100);

                            fStartX_Draw = fStartX + fX_Start;
                            fStartY_Draw = fStartY + fY_Start;
                            fEndX_Draw = fEndX - fX_End;
                            fEndY_Draw = fEndY - fY_End;
                            if (fStartX > fEndX)
                            {
                                fStartX_Draw = fStartX - fX_Start;
                                fEndX_Draw = fEndX + fX_End;
                            }
                            if (fStartY > fEndY)
                            {
                                fStartY_Draw = fStartY - fY_Start;
                                fEndY_Draw = fEndY + fY_End;
                            }

                            g.DrawLine(new Pen(Color.Wheat, 2), fStartX_Draw, fStartY_Draw, fEndX_Draw, fEndY_Draw);

                            fStartX = (int)(((p1.X + p2.X) / 2) + (((Math.Abs(p1.X - p2.X) / 2) / (m_stcBlobPad.intLineCount - 1))) + (int)((Math.Abs(p1.X - p2.X)) * (m_stcBlobPad.fWidthPercentStart11 / 100)));
                            fStartY = (int)(p1.Y + ((Math.Abs(p1.Y - p3.Y) * m_stcBlobPad.fHeightPercentStart11 / 100)));
                            fEndX = (int)(((p3.X + p4.X) / 2) + ((Math.Abs(p3.X - p4.X) / 2) / (m_stcBlobPad.intLineCount - 1))) + (int)((Math.Abs(p3.X - p4.X)) * (m_stcBlobPad.fWidthPercentEnd11 / 100));
                            fEndY = (int)(p3.Y + ((Math.Abs(p1.Y - p3.Y) * m_stcBlobPad.fHeightPercentEnd11 / 100)));

                            fX_Start = Math.Abs(fStartX - fEndX) * (m_stcBlobPad.fInwardPercentStart11 / 100);
                            fX_End = Math.Abs(fStartX - fEndX) * (m_stcBlobPad.fInwardPercentEnd11 / 100);
                            fY_Start = Math.Abs(fStartY - fEndY) * (m_stcBlobPad.fInwardPercentStart11 / 100);
                            fY_End = Math.Abs(fStartY - fEndY) * (m_stcBlobPad.fInwardPercentEnd11 / 100);

                            fStartX_Draw = fStartX + fX_Start;
                            fStartY_Draw = fStartY + fY_Start;
                            fEndX_Draw = fEndX - fX_End;
                            fEndY_Draw = fEndY - fY_End;
                            if (fStartX > fEndX)
                            {
                                fStartX_Draw = fStartX - fX_Start;
                                fEndX_Draw = fEndX + fX_End;
                            }
                            if (fStartY > fEndY)
                            {
                                fStartY_Draw = fStartY - fY_Start;
                                fEndY_Draw = fEndY + fY_End;
                            }

                            g.DrawLine(new Pen(Color.DarkGoldenrod, 2), fStartX_Draw, fStartY_Draw, fEndX_Draw, fEndY_Draw);

                            break;
                        case 12:
                            fStartX = (int)(((p1.X + p2.X) / 2) + (((Math.Abs(p1.X - p2.X) / 2) / (m_stcBlobPad.intLineCount - 10))) + (int)((Math.Abs(p1.X - p2.X)) * (m_stcBlobPad.fWidthPercentStart3 / 100)));
                            fStartY = (int)(p1.Y + ((Math.Abs(p1.Y - p3.Y) * m_stcBlobPad.fHeightPercentStart3 / 100)));
                            fEndX = (int)(((p3.X + p4.X) / 2) + ((Math.Abs(p3.X - p4.X) / 2) / (m_stcBlobPad.intLineCount - 10))) + (int)((Math.Abs(p3.X - p4.X)) * (m_stcBlobPad.fWidthPercentEnd3 / 100));
                            fEndY = (int)(p3.Y + ((Math.Abs(p1.Y - p3.Y) * m_stcBlobPad.fHeightPercentEnd3 / 100)));

                            fX_Start = Math.Abs(fStartX - fEndX) * (m_stcBlobPad.fInwardPercentStart3 / 100);
                            fX_End = Math.Abs(fStartX - fEndX) * (m_stcBlobPad.fInwardPercentEnd3 / 100);
                            fY_Start = Math.Abs(fStartY - fEndY) * (m_stcBlobPad.fInwardPercentStart3 / 100);
                            fY_End = Math.Abs(fStartY - fEndY) * (m_stcBlobPad.fInwardPercentEnd3 / 100);

                            fStartX_Draw = fStartX + fX_Start;
                            fStartY_Draw = fStartY + fY_Start;
                            fEndX_Draw = fEndX - fX_End;
                            fEndY_Draw = fEndY - fY_End;
                            if (fStartX > fEndX)
                            {
                                fStartX_Draw = fStartX - fX_Start;
                                fEndX_Draw = fEndX + fX_End;
                            }
                            if (fStartY > fEndY)
                            {
                                fStartY_Draw = fStartY - fY_Start;
                                fEndY_Draw = fEndY + fY_End;
                            }

                            g.DrawLine(new Pen(Color.Red, 2), fStartX_Draw, fStartY_Draw, fEndX_Draw, fEndY_Draw);

                            fStartX = (int)(((p1.X + p2.X) / 2) + (((Math.Abs(p1.X - p2.X) / 2) / (m_stcBlobPad.intLineCount - 9))) + (int)((Math.Abs(p1.X - p2.X)) * (m_stcBlobPad.fWidthPercentStart4 / 100)));
                            fStartY = (int)(p1.Y + ((Math.Abs(p1.Y - p3.Y) * m_stcBlobPad.fHeightPercentStart4 / 100)));
                            fEndX = (int)(((p3.X + p4.X) / 2) + ((Math.Abs(p3.X - p4.X) / 2) / (m_stcBlobPad.intLineCount - 9))) + (int)((Math.Abs(p3.X - p4.X)) * (m_stcBlobPad.fWidthPercentEnd4 / 100));
                            fEndY = (int)(p3.Y + ((Math.Abs(p1.Y - p3.Y) * m_stcBlobPad.fHeightPercentEnd4 / 100)));

                            fX_Start = Math.Abs(fStartX - fEndX) * (m_stcBlobPad.fInwardPercentStart4 / 100);
                            fX_End = Math.Abs(fStartX - fEndX) * (m_stcBlobPad.fInwardPercentEnd4 / 100);
                            fY_Start = Math.Abs(fStartY - fEndY) * (m_stcBlobPad.fInwardPercentStart4 / 100);
                            fY_End = Math.Abs(fStartY - fEndY) * (m_stcBlobPad.fInwardPercentEnd4 / 100);

                            fStartX_Draw = fStartX + fX_Start;
                            fStartY_Draw = fStartY + fY_Start;
                            fEndX_Draw = fEndX - fX_End;
                            fEndY_Draw = fEndY - fY_End;
                            if (fStartX > fEndX)
                            {
                                fStartX_Draw = fStartX - fX_Start;
                                fEndX_Draw = fEndX + fX_End;
                            }
                            if (fStartY > fEndY)
                            {
                                fStartY_Draw = fStartY - fY_Start;
                                fEndY_Draw = fEndY + fY_End;
                            }

                            g.DrawLine(new Pen(Color.Yellow, 2), fStartX_Draw, fStartY_Draw, fEndX_Draw, fEndY_Draw);

                            fStartX = (int)(((p1.X + p2.X) / 2) + (((Math.Abs(p1.X - p2.X) / 2) / (m_stcBlobPad.intLineCount - 8))) + (int)((Math.Abs(p1.X - p2.X)) * (m_stcBlobPad.fWidthPercentStart5 / 100)));
                            fStartY = (int)(p1.Y + ((Math.Abs(p1.Y - p3.Y) * m_stcBlobPad.fHeightPercentStart5 / 100)));
                            fEndX = (int)(((p3.X + p4.X) / 2) + ((Math.Abs(p3.X - p4.X) / 2) / (m_stcBlobPad.intLineCount - 8))) + (int)((Math.Abs(p3.X - p4.X)) * (m_stcBlobPad.fWidthPercentEnd5 / 100));
                            fEndY = (int)(p3.Y + ((Math.Abs(p1.Y - p3.Y) * m_stcBlobPad.fHeightPercentEnd5 / 100)));

                            fX_Start = Math.Abs(fStartX - fEndX) * (m_stcBlobPad.fInwardPercentStart5 / 100);
                            fX_End = Math.Abs(fStartX - fEndX) * (m_stcBlobPad.fInwardPercentEnd5 / 100);
                            fY_Start = Math.Abs(fStartY - fEndY) * (m_stcBlobPad.fInwardPercentStart5 / 100);
                            fY_End = Math.Abs(fStartY - fEndY) * (m_stcBlobPad.fInwardPercentEnd5 / 100);

                            fStartX_Draw = fStartX + fX_Start;
                            fStartY_Draw = fStartY + fY_Start;
                            fEndX_Draw = fEndX - fX_End;
                            fEndY_Draw = fEndY - fY_End;
                            if (fStartX > fEndX)
                            {
                                fStartX_Draw = fStartX - fX_Start;
                                fEndX_Draw = fEndX + fX_End;
                            }
                            if (fStartY > fEndY)
                            {
                                fStartY_Draw = fStartY - fY_Start;
                                fEndY_Draw = fEndY + fY_End;
                            }

                            g.DrawLine(new Pen(Color.Pink, 2), fStartX_Draw, fStartY_Draw, fEndX_Draw, fEndY_Draw);

                            fStartX = (int)(((p1.X + p2.X) / 2) + (((Math.Abs(p1.X - p2.X) / 2) / (m_stcBlobPad.intLineCount - 7))) + (int)((Math.Abs(p1.X - p2.X)) * (m_stcBlobPad.fWidthPercentStart6 / 100)));
                            fStartY = (int)(p1.Y + ((Math.Abs(p1.Y - p3.Y) * m_stcBlobPad.fHeightPercentStart6 / 100)));
                            fEndX = (int)(((p3.X + p4.X) / 2) + ((Math.Abs(p3.X - p4.X) / 2) / (m_stcBlobPad.intLineCount - 7))) + (int)((Math.Abs(p3.X - p4.X)) * (m_stcBlobPad.fWidthPercentEnd6 / 100));
                            fEndY = (int)(p3.Y + ((Math.Abs(p1.Y - p3.Y) * m_stcBlobPad.fHeightPercentEnd6 / 100)));

                            fX_Start = Math.Abs(fStartX - fEndX) * (m_stcBlobPad.fInwardPercentStart6 / 100);
                            fX_End = Math.Abs(fStartX - fEndX) * (m_stcBlobPad.fInwardPercentEnd6 / 100);
                            fY_Start = Math.Abs(fStartY - fEndY) * (m_stcBlobPad.fInwardPercentStart6 / 100);
                            fY_End = Math.Abs(fStartY - fEndY) * (m_stcBlobPad.fInwardPercentEnd6 / 100);

                            fStartX_Draw = fStartX + fX_Start;
                            fStartY_Draw = fStartY + fY_Start;
                            fEndX_Draw = fEndX - fX_End;
                            fEndY_Draw = fEndY - fY_End;
                            if (fStartX > fEndX)
                            {
                                fStartX_Draw = fStartX - fX_Start;
                                fEndX_Draw = fEndX + fX_End;
                            }
                            if (fStartY > fEndY)
                            {
                                fStartY_Draw = fStartY - fY_Start;
                                fEndY_Draw = fEndY + fY_End;
                            }

                            g.DrawLine(new Pen(Color.Orange, 2), fStartX_Draw, fStartY_Draw, fEndX_Draw, fEndY_Draw);

                            fStartX = (int)(((p1.X + p2.X) / 2) + (((Math.Abs(p1.X - p2.X) / 2) / (m_stcBlobPad.intLineCount - 6))) + (int)((Math.Abs(p1.X - p2.X)) * (m_stcBlobPad.fWidthPercentStart7 / 100)));
                            fStartY = (int)(p1.Y + ((Math.Abs(p1.Y - p3.Y) * m_stcBlobPad.fHeightPercentStart7 / 100)));
                            fEndX = (int)(((p3.X + p4.X) / 2) + ((Math.Abs(p3.X - p4.X) / 2) / (m_stcBlobPad.intLineCount - 6))) + (int)((Math.Abs(p3.X - p4.X)) * (m_stcBlobPad.fWidthPercentEnd7 / 100));
                            fEndY = (int)(p3.Y + ((Math.Abs(p1.Y - p3.Y) * m_stcBlobPad.fHeightPercentEnd7 / 100)));

                            fX_Start = Math.Abs(fStartX - fEndX) * (m_stcBlobPad.fInwardPercentStart7 / 100);
                            fX_End = Math.Abs(fStartX - fEndX) * (m_stcBlobPad.fInwardPercentEnd7 / 100);
                            fY_Start = Math.Abs(fStartY - fEndY) * (m_stcBlobPad.fInwardPercentStart7 / 100);
                            fY_End = Math.Abs(fStartY - fEndY) * (m_stcBlobPad.fInwardPercentEnd7 / 100);

                            fStartX_Draw = fStartX + fX_Start;
                            fStartY_Draw = fStartY + fY_Start;
                            fEndX_Draw = fEndX - fX_End;
                            fEndY_Draw = fEndY - fY_End;
                            if (fStartX > fEndX)
                            {
                                fStartX_Draw = fStartX - fX_Start;
                                fEndX_Draw = fEndX + fX_End;
                            }
                            if (fStartY > fEndY)
                            {
                                fStartY_Draw = fStartY - fY_Start;
                                fEndY_Draw = fEndY + fY_End;
                            }

                            g.DrawLine(new Pen(Color.Cyan, 2), fStartX_Draw, fStartY_Draw, fEndX_Draw, fEndY_Draw);

                            fStartX = (int)(((p1.X + p2.X) / 2) + (((Math.Abs(p1.X - p2.X) / 2) / (m_stcBlobPad.intLineCount - 5))) + (int)((Math.Abs(p1.X - p2.X)) * (m_stcBlobPad.fWidthPercentStart8 / 100)));
                            fStartY = (int)(p1.Y + ((Math.Abs(p1.Y - p3.Y) * m_stcBlobPad.fHeightPercentStart8 / 100)));
                            fEndX = (int)(((p3.X + p4.X) / 2) + ((Math.Abs(p3.X - p4.X) / 2) / (m_stcBlobPad.intLineCount - 5))) + (int)((Math.Abs(p3.X - p4.X)) * (m_stcBlobPad.fWidthPercentEnd8 / 100));
                            fEndY = (int)(p3.Y + ((Math.Abs(p1.Y - p3.Y) * m_stcBlobPad.fHeightPercentEnd8 / 100)));

                            fX_Start = Math.Abs(fStartX - fEndX) * (m_stcBlobPad.fInwardPercentStart8 / 100);
                            fX_End = Math.Abs(fStartX - fEndX) * (m_stcBlobPad.fInwardPercentEnd8 / 100);
                            fY_Start = Math.Abs(fStartY - fEndY) * (m_stcBlobPad.fInwardPercentStart8 / 100);
                            fY_End = Math.Abs(fStartY - fEndY) * (m_stcBlobPad.fInwardPercentEnd8 / 100);

                            fStartX_Draw = fStartX + fX_Start;
                            fStartY_Draw = fStartY + fY_Start;
                            fEndX_Draw = fEndX - fX_End;
                            fEndY_Draw = fEndY - fY_End;
                            if (fStartX > fEndX)
                            {
                                fStartX_Draw = fStartX - fX_Start;
                                fEndX_Draw = fEndX + fX_End;
                            }
                            if (fStartY > fEndY)
                            {
                                fStartY_Draw = fStartY - fY_Start;
                                fEndY_Draw = fEndY + fY_End;
                            }

                            g.DrawLine(new Pen(Color.Magenta, 2), fStartX_Draw, fStartY_Draw, fEndX_Draw, fEndY_Draw);

                            fStartX = (int)(((p1.X + p2.X) / 2) + (((Math.Abs(p1.X - p2.X) / 2) / (m_stcBlobPad.intLineCount - 4))) + (int)((Math.Abs(p1.X - p2.X)) * (m_stcBlobPad.fWidthPercentStart9 / 100)));
                            fStartY = (int)(p1.Y + ((Math.Abs(p1.Y - p3.Y) * m_stcBlobPad.fHeightPercentStart9 / 100)));
                            fEndX = (int)(((p3.X + p4.X) / 2) + ((Math.Abs(p3.X - p4.X) / 2) / (m_stcBlobPad.intLineCount - 4))) + (int)((Math.Abs(p3.X - p4.X)) * (m_stcBlobPad.fWidthPercentEnd9 / 100));
                            fEndY = (int)(p3.Y + ((Math.Abs(p1.Y - p3.Y) * m_stcBlobPad.fHeightPercentEnd9 / 100)));

                            fX_Start = Math.Abs(fStartX - fEndX) * (m_stcBlobPad.fInwardPercentStart9 / 100);
                            fX_End = Math.Abs(fStartX - fEndX) * (m_stcBlobPad.fInwardPercentEnd9 / 100);
                            fY_Start = Math.Abs(fStartY - fEndY) * (m_stcBlobPad.fInwardPercentStart9 / 100);
                            fY_End = Math.Abs(fStartY - fEndY) * (m_stcBlobPad.fInwardPercentEnd9 / 100);

                            fStartX_Draw = fStartX + fX_Start;
                            fStartY_Draw = fStartY + fY_Start;
                            fEndX_Draw = fEndX - fX_End;
                            fEndY_Draw = fEndY - fY_End;
                            if (fStartX > fEndX)
                            {
                                fStartX_Draw = fStartX - fX_Start;
                                fEndX_Draw = fEndX + fX_End;
                            }
                            if (fStartY > fEndY)
                            {
                                fStartY_Draw = fStartY - fY_Start;
                                fEndY_Draw = fEndY + fY_End;
                            }

                            g.DrawLine(new Pen(Color.Silver, 2), fStartX_Draw, fStartY_Draw, fEndX_Draw, fEndY_Draw);

                            fStartX = (int)(((p1.X + p2.X) / 2) + (((Math.Abs(p1.X - p2.X) / 2) / (m_stcBlobPad.intLineCount - 3))) + (int)((Math.Abs(p1.X - p2.X)) * (m_stcBlobPad.fWidthPercentStart10 / 100)));
                            fStartY = (int)(p1.Y + ((Math.Abs(p1.Y - p3.Y) * m_stcBlobPad.fHeightPercentStart10 / 100)));
                            fEndX = (int)(((p3.X + p4.X) / 2) + ((Math.Abs(p3.X - p4.X) / 2) / (m_stcBlobPad.intLineCount - 3))) + (int)((Math.Abs(p3.X - p4.X)) * (m_stcBlobPad.fWidthPercentEnd10 / 100));
                            fEndY = (int)(p3.Y + ((Math.Abs(p1.Y - p3.Y) * m_stcBlobPad.fHeightPercentEnd10 / 100)));

                            fX_Start = Math.Abs(fStartX - fEndX) * (m_stcBlobPad.fInwardPercentStart10 / 100);
                            fX_End = Math.Abs(fStartX - fEndX) * (m_stcBlobPad.fInwardPercentEnd10 / 100);
                            fY_Start = Math.Abs(fStartY - fEndY) * (m_stcBlobPad.fInwardPercentStart10 / 100);
                            fY_End = Math.Abs(fStartY - fEndY) * (m_stcBlobPad.fInwardPercentEnd10 / 100);

                            fStartX_Draw = fStartX + fX_Start;
                            fStartY_Draw = fStartY + fY_Start;
                            fEndX_Draw = fEndX - fX_End;
                            fEndY_Draw = fEndY - fY_End;
                            if (fStartX > fEndX)
                            {
                                fStartX_Draw = fStartX - fX_Start;
                                fEndX_Draw = fEndX + fX_End;
                            }
                            if (fStartY > fEndY)
                            {
                                fStartY_Draw = fStartY - fY_Start;
                                fEndY_Draw = fEndY + fY_End;
                            }

                            g.DrawLine(new Pen(Color.Wheat, 2), fStartX_Draw, fStartY_Draw, fEndX_Draw, fEndY_Draw);

                            fStartX = (int)(((p1.X + p2.X) / 2) + (((Math.Abs(p1.X - p2.X) / 2) / (m_stcBlobPad.intLineCount - 2))) + (int)((Math.Abs(p1.X - p2.X)) * (m_stcBlobPad.fWidthPercentStart11 / 100)));
                            fStartY = (int)(p1.Y + ((Math.Abs(p1.Y - p3.Y) * m_stcBlobPad.fHeightPercentStart11 / 100)));
                            fEndX = (int)(((p3.X + p4.X) / 2) + ((Math.Abs(p3.X - p4.X) / 2) / (m_stcBlobPad.intLineCount - 2))) + (int)((Math.Abs(p3.X - p4.X)) * (m_stcBlobPad.fWidthPercentEnd11 / 100));
                            fEndY = (int)(p3.Y + ((Math.Abs(p1.Y - p3.Y) * m_stcBlobPad.fHeightPercentEnd11 / 100)));

                            fX_Start = Math.Abs(fStartX - fEndX) * (m_stcBlobPad.fInwardPercentStart11 / 100);
                            fX_End = Math.Abs(fStartX - fEndX) * (m_stcBlobPad.fInwardPercentEnd11 / 100);
                            fY_Start = Math.Abs(fStartY - fEndY) * (m_stcBlobPad.fInwardPercentStart11 / 100);
                            fY_End = Math.Abs(fStartY - fEndY) * (m_stcBlobPad.fInwardPercentEnd11 / 100);

                            fStartX_Draw = fStartX + fX_Start;
                            fStartY_Draw = fStartY + fY_Start;
                            fEndX_Draw = fEndX - fX_End;
                            fEndY_Draw = fEndY - fY_End;
                            if (fStartX > fEndX)
                            {
                                fStartX_Draw = fStartX - fX_Start;
                                fEndX_Draw = fEndX + fX_End;
                            }
                            if (fStartY > fEndY)
                            {
                                fStartY_Draw = fStartY - fY_Start;
                                fEndY_Draw = fEndY + fY_End;
                            }

                            g.DrawLine(new Pen(Color.DarkGoldenrod, 2), fStartX_Draw, fStartY_Draw, fEndX_Draw, fEndY_Draw);

                            fStartX = (int)(((p1.X + p2.X) / 2) + (((Math.Abs(p1.X - p2.X) / 2) / (m_stcBlobPad.intLineCount - 1))) + (int)((Math.Abs(p1.X - p2.X)) * (m_stcBlobPad.fWidthPercentStart12 / 100)));
                            fStartY = (int)(p1.Y + ((Math.Abs(p1.Y - p3.Y) * m_stcBlobPad.fHeightPercentStart12 / 100)));
                            fEndX = (int)(((p3.X + p4.X) / 2) + ((Math.Abs(p3.X - p4.X) / 2) / (m_stcBlobPad.intLineCount - 1))) + (int)((Math.Abs(p3.X - p4.X)) * (m_stcBlobPad.fWidthPercentEnd12 / 100));
                            fEndY = (int)(p3.Y + ((Math.Abs(p1.Y - p3.Y) * m_stcBlobPad.fHeightPercentEnd12 / 100)));

                            fX_Start = Math.Abs(fStartX - fEndX) * (m_stcBlobPad.fInwardPercentStart12 / 100);
                            fX_End = Math.Abs(fStartX - fEndX) * (m_stcBlobPad.fInwardPercentEnd12 / 100);
                            fY_Start = Math.Abs(fStartY - fEndY) * (m_stcBlobPad.fInwardPercentStart12 / 100);
                            fY_End = Math.Abs(fStartY - fEndY) * (m_stcBlobPad.fInwardPercentEnd12 / 100);

                            fStartX_Draw = fStartX + fX_Start;
                            fStartY_Draw = fStartY + fY_Start;
                            fEndX_Draw = fEndX - fX_End;
                            fEndY_Draw = fEndY - fY_End;
                            if (fStartX > fEndX)
                            {
                                fStartX_Draw = fStartX - fX_Start;
                                fEndX_Draw = fEndX + fX_End;
                            }
                            if (fStartY > fEndY)
                            {
                                fStartY_Draw = fStartY - fY_Start;
                                fEndY_Draw = fEndY + fY_End;
                            }

                            g.DrawLine(new Pen(Color.MediumSeaGreen, 2), fStartX_Draw, fStartY_Draw, fEndX_Draw, fEndY_Draw);

                            break;
                    }
                }

                if (!m_stcBlobPad.blnEnable)
                {
                    g.DrawLine(new Pen(arrColor[1], 2), p1, p4);
                    g.DrawLine(new Pen(arrColor[1], 2), p2, p3);
                }

                g.DrawString(((BlobsFeatures)m_arrTemplateBlobPads[i]).intNoID.ToString(), m_Font, new SolidBrush(arrColor[3]),
                    ((float)((BlobsFeatures)m_arrTemplateBlobPads[i]).fCenterX + intRoiOrgX - 8) * fDrawingScaleX,
                    ((float)((BlobsFeatures)m_arrTemplateBlobPads[i]).fCenterY + intRoiOrgY - 8) * fDrawingScaleY);
            }
        }

        /// <summary>
        /// Draw template object tolerance
        /// </summary>
        /// <param name="g">destination image to be drawn</param>
        /// <param name="intRoiOrgX"></param>
        /// <param name="intRoiOrgY"></param>
        /// <param name="fScale"></param>
        /// <param name="intZoomImageEdgeX">translation factor for panning in the horizontal direction</param>
        /// <param name="intZoomImageEdgeY">translation factor for panning in the vertical direction</param>
        public void DrawTemplateObjectsTolerance(Graphics g, float fDrawingScaleX, float fDrawingScaleY, int intRoiOrgX, int intRoiOrgY, float fScale, int intZoomImageEdgeX, int intZoomImageEdgeY)
        {
            for (int i = 0; i < m_arrTemplateBlobPads.Count; i++)
            {
                BlobsFeatures m_stcBlobPad = (BlobsFeatures)m_arrTemplateBlobPads[i];

                System.Drawing.Point p1 = new System.Drawing.Point(intRoiOrgX + (int)Math.Round(m_stcBlobPad.fLimitCenterX - m_stcBlobPad.fWidth / 2), intRoiOrgY + (int)Math.Round(m_stcBlobPad.fLimitCenterY - m_stcBlobPad.fHeight / 2));
                System.Drawing.Point p2 = new System.Drawing.Point(intRoiOrgX + (int)Math.Round(m_stcBlobPad.fLimitCenterX + m_stcBlobPad.fWidth / 2), intRoiOrgY + (int)Math.Round(m_stcBlobPad.fLimitCenterY - m_stcBlobPad.fHeight / 2));
                System.Drawing.Point p3 = new System.Drawing.Point(intRoiOrgX + (int)Math.Round(m_stcBlobPad.fLimitCenterX - m_stcBlobPad.fWidth / 2), intRoiOrgY + (int)Math.Round(m_stcBlobPad.fLimitCenterY + m_stcBlobPad.fHeight / 2));
                System.Drawing.Point p4 = new System.Drawing.Point(intRoiOrgX + (int)Math.Round(m_stcBlobPad.fLimitCenterX + m_stcBlobPad.fWidth / 2), intRoiOrgY + (int)Math.Round(m_stcBlobPad.fLimitCenterY + m_stcBlobPad.fHeight / 2));
                if (fDrawingScaleX != 1f || fDrawingScaleY != 1f)
                {
                    p1.X = (int)Math.Round((float)p1.X * fDrawingScaleX, 0, MidpointRounding.AwayFromZero);
                    p1.Y = (int)Math.Round((float)p1.Y * fDrawingScaleY, 0, MidpointRounding.AwayFromZero);
                    p2.X = (int)Math.Round((float)p2.X * fDrawingScaleX, 0, MidpointRounding.AwayFromZero);
                    p2.Y = (int)Math.Round((float)p2.Y * fDrawingScaleY, 0, MidpointRounding.AwayFromZero);
                    p3.X = (int)Math.Round((float)p3.X * fDrawingScaleX, 0, MidpointRounding.AwayFromZero);
                    p3.Y = (int)Math.Round((float)p3.Y * fDrawingScaleY, 0, MidpointRounding.AwayFromZero);
                    p4.X = (int)Math.Round((float)p4.X * fDrawingScaleX, 0, MidpointRounding.AwayFromZero);
                    p4.Y = (int)Math.Round((float)p4.Y * fDrawingScaleY, 0, MidpointRounding.AwayFromZero);
                }

                g.DrawLine(new Pen(Color.Lime), p1, p2);
                g.DrawLine(new Pen(Color.Lime), p2, p4);
                g.DrawLine(new Pen(Color.Lime), p4, p3);
                g.DrawLine(new Pen(Color.Lime), p3, p1);

                p1 = new System.Drawing.Point(intRoiOrgX + (int)Math.Round(m_stcBlobPad.fLimitCenterX - m_stcBlobPad.fMaxWidth / 2), intRoiOrgY + (int)Math.Round(m_stcBlobPad.fLimitCenterY - m_stcBlobPad.fMaxLength / 2));
                p2 = new System.Drawing.Point(intRoiOrgX + (int)Math.Round(m_stcBlobPad.fLimitCenterX + m_stcBlobPad.fMaxWidth / 2), intRoiOrgY + (int)Math.Round(m_stcBlobPad.fLimitCenterY - m_stcBlobPad.fMaxLength / 2));
                p3 = new System.Drawing.Point(intRoiOrgX + (int)Math.Round(m_stcBlobPad.fLimitCenterX - m_stcBlobPad.fMaxWidth / 2), intRoiOrgY + (int)Math.Round(m_stcBlobPad.fLimitCenterY + m_stcBlobPad.fMaxLength / 2));
                p4 = new System.Drawing.Point(intRoiOrgX + (int)Math.Round(m_stcBlobPad.fLimitCenterX + m_stcBlobPad.fMaxWidth / 2), intRoiOrgY + (int)Math.Round(m_stcBlobPad.fLimitCenterY + m_stcBlobPad.fMaxLength / 2));
                if (fDrawingScaleX != 1f || fDrawingScaleY != 1f)
                {
                    p1.X = (int)Math.Round((float)p1.X * fDrawingScaleX, 0, MidpointRounding.AwayFromZero);
                    p1.Y = (int)Math.Round((float)p1.Y * fDrawingScaleY, 0, MidpointRounding.AwayFromZero);
                    p2.X = (int)Math.Round((float)p2.X * fDrawingScaleX, 0, MidpointRounding.AwayFromZero);
                    p2.Y = (int)Math.Round((float)p2.Y * fDrawingScaleY, 0, MidpointRounding.AwayFromZero);
                    p3.X = (int)Math.Round((float)p3.X * fDrawingScaleX, 0, MidpointRounding.AwayFromZero);
                    p3.Y = (int)Math.Round((float)p3.Y * fDrawingScaleY, 0, MidpointRounding.AwayFromZero);
                    p4.X = (int)Math.Round((float)p4.X * fDrawingScaleX, 0, MidpointRounding.AwayFromZero);
                    p4.Y = (int)Math.Round((float)p4.Y * fDrawingScaleY, 0, MidpointRounding.AwayFromZero);
                }

                g.DrawLine(new Pen(Color.Aqua), p1, p2);
                g.DrawLine(new Pen(Color.Aqua), p2, p4);
                g.DrawLine(new Pen(Color.Aqua), p4, p3);
                g.DrawLine(new Pen(Color.Aqua), p3, p1);


                p1 = new System.Drawing.Point(intRoiOrgX + (int)Math.Round(m_stcBlobPad.fLimitCenterX - m_stcBlobPad.fMinWidth / 2), intRoiOrgY + (int)Math.Round(m_stcBlobPad.fLimitCenterY - m_stcBlobPad.fMinLength / 2));
                p2 = new System.Drawing.Point(intRoiOrgX + (int)Math.Round(m_stcBlobPad.fLimitCenterX + m_stcBlobPad.fMinWidth / 2), intRoiOrgY + (int)Math.Round(m_stcBlobPad.fLimitCenterY - m_stcBlobPad.fMinLength / 2));
                p3 = new System.Drawing.Point(intRoiOrgX + (int)Math.Round(m_stcBlobPad.fLimitCenterX - m_stcBlobPad.fMinWidth / 2), intRoiOrgY + (int)Math.Round(m_stcBlobPad.fLimitCenterY + m_stcBlobPad.fMinLength / 2));
                p4 = new System.Drawing.Point(intRoiOrgX + (int)Math.Round(m_stcBlobPad.fLimitCenterX + m_stcBlobPad.fMinWidth / 2), intRoiOrgY + (int)Math.Round(m_stcBlobPad.fLimitCenterY + m_stcBlobPad.fMinLength / 2));
                if (fDrawingScaleX != 1f || fDrawingScaleY != 1f)
                {
                    p1.X = (int)Math.Round((float)p1.X * fDrawingScaleX, 0, MidpointRounding.AwayFromZero);
                    p1.Y = (int)Math.Round((float)p1.Y * fDrawingScaleY, 0, MidpointRounding.AwayFromZero);
                    p2.X = (int)Math.Round((float)p2.X * fDrawingScaleX, 0, MidpointRounding.AwayFromZero);
                    p2.Y = (int)Math.Round((float)p2.Y * fDrawingScaleY, 0, MidpointRounding.AwayFromZero);
                    p3.X = (int)Math.Round((float)p3.X * fDrawingScaleX, 0, MidpointRounding.AwayFromZero);
                    p3.Y = (int)Math.Round((float)p3.Y * fDrawingScaleY, 0, MidpointRounding.AwayFromZero);
                    p4.X = (int)Math.Round((float)p4.X * fDrawingScaleX, 0, MidpointRounding.AwayFromZero);
                    p4.Y = (int)Math.Round((float)p4.Y * fDrawingScaleY, 0, MidpointRounding.AwayFromZero);
                }

                g.DrawLine(new Pen(Color.Blue), p1, p2);
                g.DrawLine(new Pen(Color.Blue), p2, p4);
                g.DrawLine(new Pen(Color.Blue), p4, p3);
                g.DrawLine(new Pen(Color.Blue), p3, p1);

                g.DrawString(((BlobsFeatures)m_arrTemplateBlobPads[i]).intNoID.ToString(), m_Font, new SolidBrush(Color.Red),
                    ((float)((BlobsFeatures)m_arrTemplateBlobPads[i]).fCenterX + intRoiOrgX - 8) * fDrawingScaleX,
                    ((float)((BlobsFeatures)m_arrTemplateBlobPads[i]).fCenterY + intRoiOrgY - 8) * fDrawingScaleY);
            }
        }

        public void DrawGroupClassification(Graphics g, float fDrawingScaleX, float fDrawingScaleY, int intRoiOrgX, int intRoiOrgY, Color[] arrColor)
        {
            for (int i = 0; i < m_arrTemplateBlobPads.Count; i++)
            {

                BlobsFeatures m_stcBlobPad = (BlobsFeatures)m_arrTemplateBlobPads[i];

                System.Drawing.Point p1 = new System.Drawing.Point(intRoiOrgX + (int)Math.Round(m_stcBlobPad.fLimitCenterX - m_stcBlobPad.fWidth / 2), intRoiOrgY + (int)Math.Round(m_stcBlobPad.fLimitCenterY - m_stcBlobPad.fHeight / 2));
                System.Drawing.Point p2 = new System.Drawing.Point(intRoiOrgX + (int)Math.Round(m_stcBlobPad.fLimitCenterX + m_stcBlobPad.fWidth / 2), intRoiOrgY + (int)Math.Round(m_stcBlobPad.fLimitCenterY - m_stcBlobPad.fHeight / 2));
                System.Drawing.Point p3 = new System.Drawing.Point(intRoiOrgX + (int)Math.Round(m_stcBlobPad.fLimitCenterX - m_stcBlobPad.fWidth / 2), intRoiOrgY + (int)Math.Round(m_stcBlobPad.fLimitCenterY + m_stcBlobPad.fHeight / 2));
                System.Drawing.Point p4 = new System.Drawing.Point(intRoiOrgX + (int)Math.Round(m_stcBlobPad.fLimitCenterX + m_stcBlobPad.fWidth / 2), intRoiOrgY + (int)Math.Round(m_stcBlobPad.fLimitCenterY + m_stcBlobPad.fHeight / 2));

                if (fDrawingScaleX != 1f || fDrawingScaleY != 1f)
                {
                    p1.X = (int)Math.Round((float)p1.X * fDrawingScaleX, 0, MidpointRounding.AwayFromZero);
                    p1.Y = (int)Math.Round((float)p1.Y * fDrawingScaleY, 0, MidpointRounding.AwayFromZero);
                    p2.X = (int)Math.Round((float)p2.X * fDrawingScaleX, 0, MidpointRounding.AwayFromZero);
                    p2.Y = (int)Math.Round((float)p2.Y * fDrawingScaleY, 0, MidpointRounding.AwayFromZero);
                    p3.X = (int)Math.Round((float)p3.X * fDrawingScaleX, 0, MidpointRounding.AwayFromZero);
                    p3.Y = (int)Math.Round((float)p3.Y * fDrawingScaleY, 0, MidpointRounding.AwayFromZero);
                    p4.X = (int)Math.Round((float)p4.X * fDrawingScaleX, 0, MidpointRounding.AwayFromZero);
                    p4.Y = (int)Math.Round((float)p4.Y * fDrawingScaleY, 0, MidpointRounding.AwayFromZero);
                }

                bool blnFound = false;
                for (int groupNo = 0; groupNo < m_arrSelectedPadForGrouping.Count; groupNo++)
                {

                    if (i == m_arrSelectedPadForGrouping[groupNo])
                    {
                        blnFound = true;
                        break;
                    }
                }

                if (blnFound)
                {
                    g.DrawLine(new Pen(arrColor[2], 2), p1, p2);
                    g.DrawLine(new Pen(arrColor[2], 2), p2, p4);
                    g.DrawLine(new Pen(arrColor[2], 2), p4, p3);
                    g.DrawLine(new Pen(arrColor[2], 2), p3, p1);
                }
                else
                {
                    g.DrawLine(new Pen(arrColor[0], 1), p1, p2);
                    g.DrawLine(new Pen(arrColor[0], 1), p2, p4);
                    g.DrawLine(new Pen(arrColor[0], 1), p4, p3);
                    g.DrawLine(new Pen(arrColor[0], 1), p3, p1);
                }

                if (!m_stcBlobPad.blnEnable)
                {
                    g.DrawLine(new Pen(arrColor[1], 2), p1, p4);
                    g.DrawLine(new Pen(arrColor[1], 2), p2, p3);
                }

                g.DrawString(((BlobsFeatures)m_arrTemplateBlobPads[i]).intNoID.ToString(), m_Font, new SolidBrush(arrColor[3]),
                    ((float)((BlobsFeatures)m_arrTemplateBlobPads[i]).fCenterX + intRoiOrgX - 8) * fDrawingScaleX,
                    ((float)((BlobsFeatures)m_arrTemplateBlobPads[i]).fCenterY + intRoiOrgY - 8) * fDrawingScaleY);
            }
        }

        /// <summary>
        /// Get pitch gap from pad no and to pad no
        /// </summary>
        /// <param name="intPitchGapIndex">pitch gap index</param>
        /// <param name="intFromPadNo">from pad no</param>
        /// <param name="intToPadNo">to pad no</param>
        public void GetPitchGapPadLink(int intPitchGapIndex, ref int intFromPadNo, ref int intToPadNo)
        {
            if (intPitchGapIndex < m_arrPitchGap.Count)
            {
                intFromPadNo = m_arrPitchGap[intPitchGapIndex].intFromPadNo + 1;
                intToPadNo = m_arrPitchGap[intPitchGapIndex].intToPadNo + 1;
            }
        }

        public int GetPackageDefectListCount()
        {
            return m_arrPkgDefectList.Count;
        }

        public int GetPadDefectListCount()
        {
            if (m_arrPadDefectList != null)
                return m_arrPadDefectList.Count;
            else
                return 0;
        }

        public int GetExtraBlobCount()
        {
            if (m_arrExtraBlobs != null)
                return m_arrExtraBlobs.Count;
            else
                return 0;
        }

        public void GetPackageDefectListData(int intRowIndex, ref string strDefectName, ref float fWidth, ref float fHeight, ref float fArea)
        {
            strDefectName = m_arrPkgDefectList[intRowIndex].ref_strName;
            fWidth = m_arrPkgDefectList[intRowIndex].ref_fWidth;
            fHeight = m_arrPkgDefectList[intRowIndex].ref_fHeight;
            fArea = m_arrPkgDefectList[intRowIndex].ref_fArea;
        }

        public List<List<string>> GetPkgDefectList()
        {
            List<List<string>> arrPkgDefectList = new List<List<string>>();

            for (int i = 0; i < m_arrPkgDefectList.Count; i++)
            {
                arrPkgDefectList.Add(new List<string>());
                arrPkgDefectList[i].Add(m_arrPkgDefectList[i].ref_intImageNo.ToString());
                arrPkgDefectList[i].Add(m_arrPkgDefectList[i].ref_intFailCriteria.ToString());
                arrPkgDefectList[i].Add(m_arrPkgDefectList[i].ref_strName);
                //arrPkgDefectList[i].Add(m_arrPkgDefectList[i].ref_fFailValue.ToString("F4"));
                arrPkgDefectList[i].Add(m_arrPkgDefectList[i].ref_fWidthInMM.ToString("F4"));
                arrPkgDefectList[i].Add(m_arrPkgDefectList[i].ref_fHeightInMM.ToString("F4"));
                arrPkgDefectList[i].Add(m_arrPkgDefectList[i].ref_fAreaInMM2.ToString("F6"));
            }

            return arrPkgDefectList;
        }

        /// <summary>
        /// Initialize sample data by init m_arrSampleBlobPads and m_arrExtraBlobs
        /// </summary>
        public void ResetInspectionData(bool blnResetGauge)
        {
            //m_blnInspectLock = true;
            //m_strTrack2 += "T1,";
            lock (m_objLockBlobs)
            {
                m_strErrorMessage = "";
                m_blnPadInspected = false;
                m_blnExcessPadInspected = false;
                m_blnBrokenPadInspected = false;
                m_blnViewPadResultDrawing = false;
                m_pUnitCenterPoint.X = 0;
                m_pUnitCenterPoint.Y = 0;
                m_fUnitAngle = 0;

                m_intFailResultMask = 0;
                m_intFailPkgResultMask = 0;
                m_intFailColorResultMask = 0;

                m_blnFailForeignMaterialLength = false;
                m_blnFailForeignMaterialArea = false;
                m_blnFailBrokenArea = false;
                m_blnFailBrokenLength = false;
                m_blnFailExcessArea = false;
                m_blnFailExcessLength = false;

                m_arrBackupBlobPads = new SampleBlobsFeatures[m_arrTemplateBlobPads.Count];
                m_arrSampleBlobPads = new SampleBlobsFeatures[m_arrTemplateBlobPads.Count];
                m_arrSamplePadBroken = new SampleBlobsFeatures[m_arrTemplateBlobPads.Count];
                m_arrSamplePadSmear = new SampleBlobsFeatures[m_arrTemplateBlobPads.Count];
                m_arrSamplePadEdge = new SampleBlobsFeatures[m_arrTemplateBlobPads.Count];
                m_arrSamplePadStandOff = new SampleBlobsFeatures[m_arrTemplateBlobPads.Count];
                m_arrSamplePadExcess = new SampleBlobsFeatures[m_arrTemplateBlobPads.Count];
                m_arrExtraBlobs = new List<SampleExtraBlobsFeatures>();
                m_arrPadDefectList = new List<Defect>();
                m_arrPkgDefectList = new List<Defect>();
                m_arrColorDefectList = new List<ColorDefect>();
                m_arrFailPitchGapList = new List<PitchGap>();
                m_intTemplateMatchStatus = new int[0];
                m_intSampleMatchNumber = new int[0];
                for (int i = 0; i < m_arrPitchGap.Count; i++)
                {
                    m_stcPitchGap = m_arrPitchGap[i];
                    m_stcPitchGap.intFailMask = 0;
                    m_arrPitchGap.RemoveAt(i);
                    m_arrPitchGap.Insert(i, m_stcPitchGap);
                }

                m_fResultExtraPadMaxArea = -1;
                m_fResultExtraPadMinArea = -1;
                m_fResultTotalExtraPadArea = -1;
                m_fResultBrightFieldTotalArea = -1;
                m_fResultDarkFieldTotalArea = -1;
                m_fResultBrokenMinArea = -1;
                m_fResultBrokenMaxArea = -1;
                m_fResultSmearMinLength = -1;
                m_fResultSmearMaxLength = -1;
                m_fResultExcessMinArea = -1;
                m_fResultExcessMaxArea = -1;
                m_fResultScratchMinArea = -1;
                m_fResultScratchMaxArea = -1;

                m_fResultPadEdgeDistance_Top = 0;
                m_fResultPadEdgeDistance_Right = 0;
                m_fResultPadEdgeDistance_Bottom = 0;
                m_fResultPadEdgeDistance_Left = 0;
                m_intResultPadNoEdgeDistance_Top = -1;
                m_intResultPadNoEdgeDistance_Right = -1;
                m_intResultPadNoEdgeDistance_Bottom = -1;
                m_intResultPadNoEdgeDistance_Left = -1;

                m_fResultPadSpanX = -999;
                m_fResultPadSpanY = -999;

                m_blnViewPkgSizeDrawing = false;

                //2020-12-16 ZJYEOH : Only reset during inspection, because when learning we need gauge result as we got one function that find gauge will refer template package size
                //2020-06-01 ZJYEOH : Reset previous package gauge result 
                if (blnResetGauge)
                {
                    m_objRectGauge4L.ref_fRectWidth = 0;
                    m_objRectGauge4L.ref_fRectUpWidth = 0;
                    m_objRectGauge4L.ref_fRectDownWidth = 0;
                    m_objRectGauge4L.ref_fRectHeight = 0;
                    m_objRectGauge4L.ref_fRectLeftHeight = 0;
                    m_objRectGauge4L.ref_fRectRightHeight = 0;
                    m_objRectGauge4L.ref_fRectAngle = 0;
                }
            }
        }

        public bool InspectPositioning()
        {
            PointF pResultCenterPoint = GetResultCenterPoint_RectGauge4L();
            bool blnResult = true;
            m_strErrorMessage = "";

            if (((Math.Abs(pResultCenterPoint.X - m_objPosCrosshair.ref_intCrosshairX)) / m_fMMToPixelXValue) > m_fPosToleranceX)
            {
                m_strErrorMessage += "*Positioning X Fail. Set Tolerance=" + m_fPosToleranceX.ToString() +
                                     ", Result OffSet=" +
                                     ((pResultCenterPoint.X - m_objPosCrosshair.ref_intCrosshairX) / m_fMMToPixelXValue).ToString("F4");

                m_intFailResultMask |= 0x10000;
                blnResult = false;
            }

            if (((Math.Abs(pResultCenterPoint.Y - m_objPosCrosshair.ref_intCrosshairY)) / m_fMMToPixelYValue) > m_fPosToleranceY)
            {
                m_strErrorMessage += "*Positioning Y Fail. Set Tolerance=" + m_fPosToleranceY.ToString() +
                     ", Result OffSet=" +
                     ((pResultCenterPoint.Y - m_objPosCrosshair.ref_intCrosshairY) / m_fMMToPixelYValue).ToString("F4");

                m_intFailResultMask |= 0x10000;
                blnResult = false;
            }

            return blnResult;
        }

//        public bool InspectPad_Eblob(ROI objROI, ROI objUnitSurfaceROI, List<ROI> arrPadROIs, List<List<PointF>> arrDontCare, bool blnCheckContamination, CROI objCROI, bool blnCheckColor, List<CImageDrawing> arrColorImages, ImageDrawing objBlackImage)
//        {
//            //m_blnInspectLock = true;
//            //m_strTrack2 += "T2,";
//            lock (m_objLockBlobs)
//            {
//                m_T2.Start();
//                m_fTiming2 = 0;
//                m_fTimingPrev2 = 0;
//                m_strTrack = "";

//                //Subtract Pad Dont Care Area
//                if (m_blnWantDontCareArea_Pad)
//                {
//                    ROI objDontCareROI = new ROI();
//                    objDontCareROI.LoadROISetting(0, 0, objUnitSurfaceROI.ref_ROIWidth, objUnitSurfaceROI.ref_ROIHeight);
//                    objDontCareROI.AttachImage(m_objPadDontCareImage);
//                    ROI.SubtractROI(objUnitSurfaceROI, objDontCareROI);
//                    objDontCareROI.Dispose();
//                }
//#if (Debug_2_12 || Release_2_12)
//                if (m_intSensitivityOnPadMethod == 1)   // Split or segment object
//                {
//                    //objROI.ref_ROI.TopParent.Save("D:\\TS\\1_TopParent.bmp");
//                    //objROI.ref_ROI.Save("D:\\TS\\objROI.bmp");
//                    EasyImage.OpenBox(objROI.ref_ROI, objROI.ref_ROI, (uint)m_intSensitivityOnPadValue);
//                }
//                else if (m_intSensitivityOnPadMethod == 2)  // Merge object
//                {
//                    EasyImage.CloseBox(objROI.ref_ROI, objROI.ref_ROI, (uint)m_intSensitivityOnPadValue);
//                }

//#elif (DEBUG || RELEASE || RTXRelease || RTXDebug)
//                if (m_intSensitivityOnPadMethod == 1)   // Split or segment object
//                {
//                    //objROI.ref_ROI.TopParent.Save("D:\\TS\\1_TopParent.bmp");
//                    //objROI.ref_ROI.Save("D:\\TS\\objROI.bmp");
//                    EasyImage.OpenBox(objROI.ref_ROI, objROI.ref_ROI, m_intSensitivityOnPadValue);
//                }
//                else if (m_intSensitivityOnPadMethod == 2)  // Merge object
//                {
//                    EasyImage.CloseBox(objROI.ref_ROI, objROI.ref_ROI, m_intSensitivityOnPadValue);
//                }

//#endif

//                //Draw don't care ROI edge to make sure Don't Care Area is not inspected
//                //for (int k = 4; k < arrPadROIs.Count; k++)
//                //{
//                //    arrPadROIs[k].AttachImage(objROI);    // objROI == m_smVisionInfo.g_arrInspectROI[intPadIndex]
//                //    arrPadROIs[k].DrawDontCareEdge(0);
//                //}

//                //System.Threading.Thread.Sleep(3);   // 2018 06 06 - CCENG: not sure why need to slepp 3ms. I am hiding it to save inspection time. 

//                // Define actual threshold value
//                m_intThresholdValuePrev = m_intThresholdValue;
//                if (m_intThresholdValue == -4)
//                    m_intThresholdValue = GetAutoThresholdValue(objROI, 3);

//                if (m_blnWantTightSetting)
//                {
//                    /*
//                     * When Setting is tight, mean unit easiy fail.
//                     *  - When test run for Pass unit, set tight to true for the first time filtering. and set tight to false for the subsequence 3x test run.
//                     *     - when setting is tight, minus 25 to current threshold value for white area inspection (Foreignn Material, Excess Area, dimension)
//                     *     - when setting is tight, add 25 to current threshold value for black area inspection (Pad broken Area)
//                     */
//                    m_intDarkThresholdValue = m_intThresholdValue + m_intTightSettingThresholdTolerance;
//                    if (m_intDarkThresholdValue > 254)
//                        m_intDarkThresholdValue = 254;

//                    m_intThresholdValue -= m_intTightSettingThresholdTolerance;
//                    if (m_intThresholdValue < 1)
//                        m_intThresholdValue = 1;
//                }
//                else
//                {
//                    m_intDarkThresholdValue = m_intThresholdValue;
//                }

//                m_fTiming2 = m_T2.Timing;
//                m_strTrack += "AA=" + (m_fTiming2 - m_fTimingPrev2).ToString();
//                m_fTimingPrev2 = m_fTiming2;

//                //WriteDebug("B");
//                // Define blobs min area
//                //DefineBlobsMinArea();     // 2018 11 08 Not need define. Direct use fBlobsMinAreaMM which is set by user in Advance Setting Form.

//                // Build Pad as blobs objects and holes
//                //m_objBlobs.ref_Blob.RemoveAllObjects();

//                if (m_fPadImageGain != 1f)
//                {
//                    ROI objROI2 = new ROI();
//                    objROI2.LoadROISetting(objROI.ref_ROITotalX, objROI.ref_ROITotalY, objROI.ref_ROIWidth, objROI.ref_ROIHeight);
//                    ImageDrawing objImage = new ImageDrawing(objROI.ref_ROI.TopParent.Width, objROI.ref_ROI.TopParent.Height);
//                    EasyImage.Copy(objROI.ref_ROI.TopParent, objImage.ref_objMainImage);
//                    objROI2.AttachImage(objImage);

//                    EasyImage.GainOffset(objROI2.ref_ROI, objROI2.ref_ROI, m_fPadImageGain);

//                    m_objEBlobs.BuildObjects_Filter_GetElement(objROI2, !m_blnWhiteOnBlack, true, 0, m_intThresholdValue,
//                     (int)Math.Floor(m_fBlobsMinArea), m_intMaxArea, false, 0xFF);

//                    objROI2.Dispose();
//                    objImage.Dispose();
//                }
//                else
//                {
//                    m_objEBlobs.BuildObjects_Filter_GetElement(objROI, !m_blnWhiteOnBlack, true, 0, m_intThresholdValue,
//                (int)Math.Floor(m_fBlobsMinArea), m_intMaxArea, false, 0xFF);
//                }

//                m_fTiming2 = m_T2.Timing;
//                m_strTrack += ", A=" + (m_fTiming2 - m_fTimingPrev2).ToString();
//                m_fTimingPrev2 = m_fTiming2;

//                //WriteDebug("A");
//                // Init data base on ROI and Blobs size
//                int intNumSelectedObject = m_objEBlobs.ref_intNumSelectedObject;
//                if (intNumSelectedObject == 0 && m_arrTemplateBlobPads.Count > 0)   // Missing pad if template got pads but sample is empty
//                {
//                    for (int i = 0; i < m_arrTemplateBlobPads.Count; i++)
//                    {
//                        if (((BlobsFeatures)m_arrTemplateBlobPads[i]).blnEnable)
//                        {
//                            m_intFailResultMask |= 0x04;
//                            m_arrSampleBlobPads[i].intFailMask |= 0x04;
//                        }
//                    }
//                    //m_blnInspectLock = false;
//                    //m_strTrack2 += "F1,";
//                    return false;
//                }

//                InitPadInspectionData(objROI, intNumSelectedObject);

//                m_fTiming2 = m_T2.Timing;
//                m_strTrack += ", D=" + (m_fTiming2 - m_fTimingPrev2).ToString();
//                m_fTimingPrev2 = m_fTiming2;

//                //WriteDebug("D");

//                //CheckPadHole(objROI, intNumSelectedObject);

//                try
//                {
//                    PadTestStage1_Eblob(objROI, objUnitSurfaceROI, arrDontCare, blnCheckContamination);

//                }
//                catch (Exception ex)
//                {

//                }

//                m_fTiming2 = m_T2.Timing;
//                m_strTrack += ", E=" + (m_fTiming2 - m_fTimingPrev2).ToString();
//                m_fTimingPrev2 = m_fTiming2;

//                //WriteDebug("E");
//                CheckBrokenMissingPad2_EBlob(objROI, intNumSelectedObject, blnCheckContamination);

//                m_fTiming2 = m_T2.Timing;
//                m_strTrack += ", F=" + (m_fTiming2 - m_fTimingPrev2).ToString();
//                m_fTimingPrev2 = m_fTiming2;

//                //WriteDebug("F");
//                CheckDimention(objROI);

//                m_fTiming2 = m_T2.Timing;
//                m_strTrack += ", G=" + (m_fTiming2 - m_fTimingPrev2).ToString();
//                m_fTimingPrev2 = m_fTiming2;

//                //WriteDebug("G");
//                CheckPitchGap(objROI);

//                m_fTiming2 = m_T2.Timing;
//                m_strTrack += ", H=" + (m_fTiming2 - m_fTimingPrev2).ToString();
//                m_fTimingPrev2 = m_fTiming2;

//                //Excess Pad
//                //WriteDebug("H");
//                if (m_intFailResultMask == 0 && (m_intFailOptionMask & 0x800) > 0)
//                {
//                    if (m_intPadSubtractMethod == 1) // 2021-02-09 ZJYEOH : Optimum pad offset
//                        CheckExcessPad2(objROI);
//                    else
//                        CheckExcessPad(objROI);
//                    m_blnExcessPadInspected = true;
//                }

//                m_fTiming2 = m_T2.Timing;
//                m_strTrack += ", I=" + (m_fTiming2 - m_fTimingPrev2).ToString();
//                m_fTimingPrev2 = m_fTiming2;

//                //WriteDebug("I");
//                // Broken Pad (Scratch/Broken/Incomplete Plate)
//                if (m_intFailResultMask == 0 && (m_intFailOptionMask & 0x08) > 0)
//                {
//                    CheckImage1PadDefect_PadUse(objROI);
//                    m_blnBrokenPadInspected = true;
//                }


//                m_fTiming2 = m_T2.Timing;
//                m_strTrack += ", J=" + (m_fTiming2 - m_fTimingPrev2).ToString();
//                m_fTimingPrev2 = m_fTiming2;

//                //WriteDebug("J");
//                // Check extra pad using unit surface threshold
//                if ((m_intFailResultMask == 0 && (m_intFailOptionMask & 0x1001) > 0) && blnCheckContamination)
//                {
//                    CheckExtraObjectOnUnitSurface2(objROI, objUnitSurfaceROI, arrDontCare);//CheckExtraObjectOnUnitSurface
//                }

//                //Smear Pad
//                if ((m_intFailOptionMask & 0x2000) > 0)
//                {
//                    CheckSmear(objROI);
//                }

//                // Pad Edge Limit
//                if (((m_intFailOptionMask & 0x4000) > 0) && m_blnWantEdgeLimit_Pad)
//                {
//                    CheckPadEdgeLimit(objROI, objUnitSurfaceROI);
//                }

//                // Pad Stand Off
//                if (((m_intFailOptionMask & 0x8000) > 0) && m_blnWantStandOff_Pad)
//                {
//                    CheckPadStandOffLimit(objROI, objUnitSurfaceROI);
//                }

//                // Pad Edge Distance
//                if (((m_intFailOptionMask & 0x10000) > 0) && m_blnWantEdgeDistance_Pad)
//                {
//                    CheckPadEdgeDistance(objROI, objUnitSurfaceROI);
//                }

//                // Pad Color Defect
//                if (blnCheckColor && (m_intFailResultMask & 0x1001) == 0) // 2020-10-19 ZJYEOH : wil not check color when extra fail, because they sharing same table
//                {
//                    if (m_objRectGauge4L.GetGaugeTiltAngle() == 0)
//                    {
//                        if(m_intColorDefectLinkMethod == 1)
//                            CheckColorDefect_CombineSameName_LinkNearest(objCROI, arrColorImages, objROI, objBlackImage);
//                        else
//                            CheckColorDefect_CombineSameName(objCROI, arrColorImages, objROI, objBlackImage);
//                    }
//                    else
//                    {
//                        if (m_intColorDefectLinkMethod == 1)
//                            CheckColorDefect_TiltAngle_CombineSameName_LinkNearest(objCROI, arrColorImages, objROI, objBlackImage);
//                        else
//                            CheckColorDefect_TiltAngle_CombineSameName(objCROI, arrColorImages, objROI, objBlackImage);
//                    }
//                }

//                // Create a blobs backup for inspection result drawing
//                m_intThresholdValue = m_intThresholdValuePrev;

//                m_fTiming2 = m_T2.Timing;
//                m_strTrack += ", K=" + (m_fTiming2 - m_fTimingPrev2).ToString();
//                m_fTimingPrev2 = m_fTiming2;

//                WriteDebug(m_strTrack);

//                //m_blnInspectLock = false;
//                //m_strTrack2 += "F2,";
//                if (m_intFailResultMask == 0)
//                {
//                    if (!blnCheckColor)
//                        return true;
//                    else
//                    {
//                        if (m_intFailColorResultMask == 0)
//                            return true;
//                        else
//                            return false;
//                    }
//                }
//                else
//                    return false;
//            }
//        }
        public bool InspectPad_Eblob_ImageMerge2(ROI objROI, ROI objUnitSurfaceROI)
        {
            //m_blnInspectLock = true;
            //m_strTrack2 += "T3,";
            lock (m_objLockBlobs)
            {
                m_T2.Start();
                m_fTiming2 = 0;
                m_fTimingPrev2 = 0;
                m_strTrack = "";
                
                //Subtract Pad Dont Care Area
                if (m_blnWantDontCareArea_Pad)
                {
                    ROI objDontCareROI = new ROI();
                    objDontCareROI.LoadROISetting(0, 0, objUnitSurfaceROI.ref_ROIWidth, objUnitSurfaceROI.ref_ROIHeight);
                    objDontCareROI.AttachImage(m_objPadDontCareImage);
                    ROI.SubtractROI(objUnitSurfaceROI, objDontCareROI);
                    objDontCareROI.Dispose();
                }

                //if (m_intSensitivityOnPadMethod == 1)   // Split or segment object
                //{
                //    EasyImage.OpenBox(objROI.ref_ROI, objROI.ref_ROI, m_intSensitivityOnPadValue);
                //}
                //else if (m_intSensitivityOnPadMethod == 2)  // Merge object
                //{
                //    EasyImage.CloseBox(objROI.ref_ROI, objROI.ref_ROI, m_intSensitivityOnPadValue);
                //}

                //Draw don't care ROI edge to make sure Don't Care Area is not inspected
                //for (int k = 4; k < arrPadROIs.Count; k++)
                //{
                //    arrPadROIs[k].AttachImage(objROI);    // objROI == m_smVisionInfo.g_arrInspectROI[intPadIndex]
                //    arrPadROIs[k].DrawDontCareEdge(0);
                //}

                //System.Threading.Thread.Sleep(3);   // 2018 06 06 - CCENG: not sure why need to slepp 3ms. I am hiding it to save inspection time. 

                // Define actual threshold value
                m_intThresholdValuePrev = m_intThresholdValue;
                if (m_intThresholdValue == -4)
                    m_intThresholdValue = GetAutoThresholdValue(objROI, 3);

                if (m_blnWantTightSetting)
                {
                    /*
                     * When Setting is tight, mean unit easiy fail.
                     *  - When test run for Pass unit, set tight to true for the first time filtering. and set tight to false for the subsequence 3x test run.
                     *     - when setting is tight, minus 25 to current threshold value for white area inspection (Foreignn Material, Excess Area, dimension)
                     *     - when setting is tight, add 25 to current threshold value for black area inspection (Pad broken Area)
                     */
                    m_intDarkThresholdValue = m_intThresholdValue + m_intTightSettingThresholdTolerance;
                    if (m_intDarkThresholdValue > 254)
                        m_intDarkThresholdValue = 254;

                    m_intThresholdValue -= m_intTightSettingThresholdTolerance;
                    if (m_intThresholdValue < 1)
                        m_intThresholdValue = 1;
                }
                else
                {
                    m_intDarkThresholdValue = m_intThresholdValue;
                }

                m_fTiming2 = m_T2.Timing;
                m_strTrack += "B=" + (m_fTiming2 - m_fTimingPrev2).ToString();
                m_fTimingPrev2 = m_fTiming2;

                //WriteDebug("B");
                // Define blobs min area
                //DefineBlobsMinArea();     // 2018 11 08 Not need define. Direct use fBlobsMinAreaMM which is set by user in Advance Setting Form.

                // Build Pad as blobs objects and holes
                //m_objBlobs.ref_Blob.RemoveAllObjects();

                //WriteDebug("C");
                //objROI.SaveImage("D:\\DebugobjROI.bmp");
                //m_objEBlobs.BuildObjects_Filter_GetElement(objROI, !m_blnWhiteOnBlack, true, 0, m_intThresholdValue,
                //    (int)Math.Floor(m_fBlobsMinArea), m_intMaxArea, false, 0x0F);

                //m_fTiming2 = m_T2.Timing;
                //m_strTrack += ", A=" + (m_fTiming2 - m_fTimingPrev2).ToString();
                //m_fTimingPrev2 = m_fTiming2;

                ////WriteDebug("A");
                //// Init data base on ROI and Blobs size
                //int intNumSelectedObject = m_objEBlobs.ref_intNumSelectedObject;
                //if (intNumSelectedObject == 0 && m_arrTemplateBlobPads.Count > 0)   // Missing pad if template got pads but sample is empty
                //{
                //    for (int i = 0; i < m_arrTemplateBlobPads.Count; i++)
                //    {
                //        if (((BlobsFeatures)m_arrTemplateBlobPads[i]).blnEnable)
                //        {
                //            m_intFailResultMask |= 0x04;
                //            m_arrSampleBlobPads[i].intFailMask |= 0x04;
                //        }
                //    }
                //    m_blnInspectLock = false;
                //    return false;
                //}

                //InitPadInspectionData(objROI, intNumSelectedObject);

                //WriteDebug("I");
                // Broken Pad (Scratch/Broken/Incomplete Plate)
                if (m_intFailResultMask == 0 && (m_intFailOptionMask & 0x08) > 0)
                {
                    CheckImageMerge2PadDefect_PadUse(objROI);
                    m_blnBrokenPadInspected = true;
                }

                //m_blnInspectLock = false;
                //m_strTrack2 += "F3,";
                if (m_intFailResultMask == 0)
                    return true;
                else
                    return false;
            }
        }
        
        public bool InspectPad_WantConsiderPadImage2(ROI objROI, ROI objUnitSurfaceROI, List<List<PointF>> arrDontCare, ImageDrawing objImage2, int intPadIndex, bool blnCheckContamination)
        {
            //m_blnInspectLock = true;
            //m_strTrack2 += "T4,";
            lock (m_objLockBlobs)
            {
                try
                {
                    System.Threading.Thread.Sleep(3);

                    WriteDebug("SA");

                    // Define actual threshold value
                    m_intThresholdValuePrev = m_intThresholdValue;
                    if (m_intThresholdValue == -4)
                        m_intThresholdValue = GetAutoThresholdValue(objROI, 3);

                    if (m_blnWantTightSetting)
                    {
                        /*
                        * When Setting is tight, mean unit easiy fail.
                        *  - When test run for Pass unit, set tight to true for the first time filtering. and set tight to false for the subsequence 3x test run.
                        *     - when setting is tight, minus 25 to current threshold value for white area inspection (Foreignn Material, Excess Area, dimension)
                        *     - when setting is tight, add 25 to current threshold value for black area inspection (Pad broken Area)
                        */

                        m_intDarkThresholdValue = m_intThresholdValue + m_intTightSettingThresholdTolerance;
                        if (m_intDarkThresholdValue > 254)
                            m_intDarkThresholdValue = 254;

                        m_intThresholdValue -= m_intTightSettingThresholdTolerance;
                        if (m_intThresholdValue < 1)
                            m_intThresholdValue = 1;
                    }
                    else
                    {
                        m_intDarkThresholdValue = m_intThresholdValue;
                    }

                    WriteDebug("SB");
                    // Define blobs min area
                    //DefineBlobsMinArea();     // 2018 11 08 Not need define. Direct use fBlobsMinAreaMM which is set by user in Advance Setting Form.

                    // Build Pad as blobs objects and holes

                    // ==== For Want Consider Pad Image 2 Feature============================================

                    WriteDebug("SC");
                    if (m_fPadImageGain != 1f)
                    {
                        ROI objROI2 = new ROI();
                        objROI2.LoadROISetting(objROI.ref_ROITotalX, objROI.ref_ROITotalY, objROI.ref_ROIWidth, objROI.ref_ROIHeight);
                        ImageDrawing objImage = new ImageDrawing(objROI.ref_ROI.TopParent.Width, objROI.ref_ROI.TopParent.Height);
                        EasyImage.Copy(objROI.ref_ROI.TopParent, objImage.ref_objMainImage);
                        objROI2.AttachImage(objImage);

                        EasyImage.GainOffset(objROI2.ref_ROI, objROI2.ref_ROI, m_fPadImageGain);

                        m_objEBlobs.BuildObjects_Filter_GetElement(objROI2, !m_blnWhiteOnBlack, true, 0, m_intThresholdValue,
                        (int)Math.Floor(m_fBlobsMinArea), m_intMaxArea, false, 0xFF);

                        objROI2.Dispose();
                        objImage.Dispose();
                    }
                    else
                    {
                        m_objEBlobs.BuildObjects_Filter_GetElement(objROI, !m_blnWhiteOnBlack, true, 0, m_intThresholdValue,
                        (int)Math.Floor(m_fBlobsMinArea), m_intMaxArea, false, 0xFF);
                    }

                    WriteDebug("SD");
                    AddImage2PadToImage1(objROI, objImage2, intPadIndex);

                    WriteDebug("SE");
                    //-----Add Mophor Open to Side pad outer edge-----------------------------------------------------

                    //AddMorphologyOpenToOuterEdge(objROI, objUnitSurfaceROI, intPadIndex); // ENG

                    // ---------------------------------------------------------------------------------------------

                    WriteDebug("SF");
                    BuildObjectsWithHole(objROI, (int)Math.Floor(m_fBlobsMinArea));



                    WriteDebug("SG");
                    // Init data base on ROI and Blobs size
                    int intNumSelectedObject = m_objEBlobs.ref_intNumSelectedObject;
                    if (intNumSelectedObject == 0 && m_arrTemplateBlobPads.Count > 0)   // Missing pad if template got pads but sample is empty
                    {
                        for (int i = 0; i < m_arrTemplateBlobPads.Count; i++)
                        {
                            if (((BlobsFeatures)m_arrTemplateBlobPads[i]).blnEnable)
                            {
                                m_intFailResultMask |= 0x04;
                                m_arrSampleBlobPads[i].intFailMask |= 0x04;
                            }
                        }
                        //m_blnInspectLock = false;
                        //m_strTrack2 += "F5,";
                        return false;
                    }

                    InitPadInspectionData(objROI, intNumSelectedObject);

                    PadTestStage1_Eblob(objROI, objUnitSurfaceROI, arrDontCare, true);//blnCheckContamination

                    //CheckPadHole(objROI, intNumSelectedObject);

                    WriteDebug("SH");
                    CheckBrokenMissingPad2(objROI, intNumSelectedObject, blnCheckContamination);

                    WriteDebug("SI");
                    CheckDimention(objROI);

                    CheckSpan();

                    WriteDebug("SJ");
                    CheckPitchGap(objROI);

                    WriteDebug("SK");
                    //Excess Pad
                    if (m_intFailResultMask == 0 && (m_intFailOptionMask & 0x800) > 0)
                    {
                        if (m_intPadSubtractMethod == 1) // 2021-02-09 ZJYEOH : Optimum pad offset
                            CheckExcessPad2(objROI);
                        else
                            CheckExcessPad(objROI);
                        m_blnExcessPadInspected = true;
                    }

                    WriteDebug("SL");
                    // Broken Pad (Scratch/Broken/Incomplete Plate)
                    if (m_intFailResultMask == 0 && (m_intFailOptionMask & 0x08) > 0)
                    {
                        CheckImage1PadDefect_PadUse(objROI);
                        m_blnBrokenPadInspected = true;
                    }

                    WriteDebug("SM");
                    // Check extra pad using unit surface threshold
                    if (m_intFailResultMask == 0 && (m_intFailOptionMask & 0x1001) > 0 && blnCheckContamination)
                    {
                        CheckExtraObjectOnUnitSurface2(objROI, objUnitSurfaceROI, arrDontCare);
                    }

                    ////Smear Pad
                    //if ((m_intFailOptionMask & 0x2000) > 0)
                    //{
                    //    CheckSmear(objROI);
                    //}

                    // Create a blobs backup for inspection result drawing
                    m_intThresholdValue = m_intThresholdValuePrev;

                    WriteDebug("SN");
                    //m_blnInspectLock = false;
                    //m_strTrack2 += "F6,";
                    if (m_intFailResultMask == 0)
                        return true;
                    else
                        return false;
                }
                catch (Exception ex)
                {
                    //m_blnInspectLock = false;
                    //m_strTrack2 += "F7,";
                    return false;
                }
            }
        }

        public bool InspectPad_WantConsiderPadImage2_0306(ROI objROI, ROI objUnitSurfaceROI, List<List<PointF>> arrDontCare, ImageDrawing objImage2, int intPadIndex, bool blnCheckContamination)
        {
            WriteDebug("PA");
            // Define actual threshold value
            m_intThresholdValuePrev = m_intThresholdValue;
            if (m_intThresholdValue == -4)
                m_intThresholdValue = GetAutoThresholdValue(objROI, 3);

            if (m_blnWantTightSetting)
            {
                m_intThresholdValue += 25;
                if (m_intThresholdValue > 254)
                    m_intThresholdValue = 254;
            }

            WriteDebug("PB");
            // Define blobs min area
            //DefineBlobsMinArea();     // 2018 11 08 Not need define. Direct use fBlobsMinAreaMM which is set by user in Advance Setting Form.

            // Build Pad as blobs objects and holes

            WriteDebug("PC");
            // =============================================================================================
            if (m_fPadImageGain != 1f)
            {
                ROI objROI2 = new ROI();
                objROI2.LoadROISetting(objROI.ref_ROITotalX, objROI.ref_ROITotalY, objROI.ref_ROIWidth, objROI.ref_ROIHeight);
                ImageDrawing objImage = new ImageDrawing(objROI.ref_ROI.TopParent.Width, objROI.ref_ROI.TopParent.Height);
                EasyImage.Copy(objROI.ref_ROI.TopParent, objImage.ref_objMainImage);
                objROI2.AttachImage(objImage);

                EasyImage.GainOffset(objROI2.ref_ROI, objROI2.ref_ROI, m_fPadImageGain);

                m_objEBlobs.BuildObjects_Filter_GetElement(objROI2, !m_blnWhiteOnBlack, true, 0, m_intThresholdValue,
                (int)Math.Floor(m_fBlobsMinArea), m_intMaxArea, false, 0xFF);

                objROI2.Dispose();
                objImage.Dispose();
            }
            else
            {
                m_objEBlobs.BuildObjects_Filter_GetElement(objROI, !m_blnWhiteOnBlack, true, 0, m_intThresholdValue,
                (int)Math.Floor(m_fBlobsMinArea), m_intMaxArea, false, 0xFF);
            }

            WriteDebug("PD");
            AddImage2PadToImage1(objROI, objImage2, intPadIndex);

            WriteDebug("PE");
            //----------------------------------------------------------------------------------------------

            //            objROI.SaveImage("D:\\TS\\objROI.bmp");

            BuildObjectsWithHole(objROI, (int)Math.Floor(m_fBlobsMinArea));

            WriteDebug("PF");
            // Init data base on ROI and Blobs size
            int intNumSelectedObject = m_objEBlobs.ref_intNumSelectedObject;
            if (intNumSelectedObject == 0 && m_arrTemplateBlobPads.Count > 0)   // Missing pad if template got pads but sample is empty
            {
                for (int i = 0; i < m_arrTemplateBlobPads.Count; i++)
                {
                    if (((BlobsFeatures)m_arrTemplateBlobPads[i]).blnEnable)
                    {
                        m_intFailResultMask |= 0x04;
                        m_arrSampleBlobPads[i].intFailMask |= 0x04;
                    }
                }
                //m_blnInspectLock = false;
                //m_strTrack2 += "F8,";
                return false;
            }
            InitPadInspectionData(objROI, intNumSelectedObject);


            WriteDebug("PG");
            PadTestStage1_Eblob(objROI, objUnitSurfaceROI, arrDontCare, true);

            //CheckPadHole(objROI, intNumSelectedObject);

            WriteDebug("PH");
            CheckBrokenMissingPad2(objROI, intNumSelectedObject, blnCheckContamination);

            WriteDebug("PI");
            CheckDimention(objROI);

            CheckSpan();

            WriteDebug("PJ");
            CheckPitchGap(objROI);

            WriteDebug("PK");
            //Excess Pad
            if (m_intFailResultMask == 0 && (m_intFailOptionMask & 0x800) > 0)
            {
                if (m_intPadSubtractMethod == 1) // 2021-02-09 ZJYEOH : Optimum pad offset
                    CheckExcessPad2(objROI);
                else
                    CheckExcessPad(objROI);
                m_blnExcessPadInspected = true;
            }

            WriteDebug("PL");
            // Broken Pad (Scratch/Broken/Incomplete Plate)
            if (m_intFailResultMask == 0 && (m_intFailOptionMask & 0x08) > 0)
            {
                CheckImage1PadDefect_PadUse(objROI);
                m_blnBrokenPadInspected = true;
            }

            ////Smear Pad
            //if ((m_intFailOptionMask & 0x2000) > 0)
            //{
            //    CheckSmear(objROI);
            //}

            // Create a blobs backup for inspection result drawing
            m_intThresholdValue = m_intThresholdValuePrev;

            WriteDebug("PM");
            if (m_intFailResultMask == 0)
                return true;
            else
                return false;
        }

        /// <summary>
        /// Erode or dilate package image
        /// </summary>
        /// <param name="objSourceROI">source ROI</param>
        /// <param name="objDestROI">destination ROI</param>
        /// <param name="intType">0 = erode, 1 = dilate</param>
        public void ModifyPackageImage(ROI objSourceROI, ref ROI objDestROI, int intType)
        {
            //Erode Image
            if (intType == 0)
            {
                EasyImage.ErodeDisk(objSourceROI.ref_ROI, objDestROI.ref_ROI);
            }
            //Dilate Image
            else
            {
                EasyImage.DilateDisk(objSourceROI.ref_ROI, objDestROI.ref_ROI);
            }
        }

        /// <summary>
        /// Rearrange selected blobs 
        /// </summary>
        public void RearrangeBlobs()
        {
            int intBlobsFeatureCount = m_arrTemplateBlobPads.Count;
            BlobsFeatures[] arrBlobsFeatures = new BlobsFeatures[intBlobsFeatureCount];
            int intNoID;

            // Copy selected blobs from global list (keep previous record) into temporary list
            for (int i = 0; i < intBlobsFeatureCount; i++)
            {
                if (!((BlobsFeatures)m_arrTemplateBlobPads[i]).blnSelected)
                    continue;

                intNoID = ((BlobsFeatures)m_arrTemplateBlobPads[i]).intNoID - 1;
                if (intNoID >= 0 && intNoID < arrBlobsFeatures.Length)
                    arrBlobsFeatures[intNoID] = (BlobsFeatures)m_arrTemplateBlobPads[i];
            }

            // delete global list 
            m_arrTemplateBlobPads = new ArrayList();

            // Copy selected blobs from temporary list into global list.
            for (int i = 0; i < arrBlobsFeatures.Length; i++)
            {
                if (arrBlobsFeatures[i].blnSelected)
                {
                    BlobsFeatures m_stcBlobPad = (BlobsFeatures)arrBlobsFeatures[i];
                    m_arrTemplateBlobPads.Add(m_stcBlobPad);
                }
            }
        }

        /// <summary>
        /// Assign all data from previous backup m_arrTemporaryBlobPads to m_arrTemplateBlobPads (current template)
        /// </summary>
        public void ReverseBlobs()
        {
            BlobsFeatures m_stcBlobPad;
            BlobsFeatures stcTemporaryBlobPad;
            m_arrTemplateBlobPads = new ArrayList();
            for (int i = 0; i < m_arrTemporaryBlobPads.Count; i++)
            {
                m_stcBlobPad = new BlobsFeatures();
                stcTemporaryBlobPad = (BlobsFeatures)m_arrTemporaryBlobPads[i];

                m_stcBlobPad.fArea = stcTemporaryBlobPad.fArea;
                m_stcBlobPad.fCenterX = stcTemporaryBlobPad.fCenterX;
                m_stcBlobPad.fCenterY = stcTemporaryBlobPad.fCenterY;
                m_stcBlobPad.fLimitCenterX = stcTemporaryBlobPad.fLimitCenterX;
                m_stcBlobPad.fLimitCenterY = stcTemporaryBlobPad.fLimitCenterY;
                m_stcBlobPad.fWidth = stcTemporaryBlobPad.fWidth;
                m_stcBlobPad.fHeight = stcTemporaryBlobPad.fHeight;
                m_stcBlobPad.intLengthMode = stcTemporaryBlobPad.intLengthMode;
                m_stcBlobPad.intContourX = stcTemporaryBlobPad.intContourX;
                m_stcBlobPad.intContourY = stcTemporaryBlobPad.intContourY;
                m_stcBlobPad.intObjNo = stcTemporaryBlobPad.intObjNo;
                m_stcBlobPad.fStartX = stcTemporaryBlobPad.fStartX;
                m_stcBlobPad.fEndX = stcTemporaryBlobPad.fEndX;
                m_stcBlobPad.fStartY = stcTemporaryBlobPad.fStartY;
                m_stcBlobPad.fEndY = stcTemporaryBlobPad.fEndY;
                m_stcBlobPad.intStartX = stcTemporaryBlobPad.intStartX;
                m_stcBlobPad.intEndX = stcTemporaryBlobPad.intEndX;
                m_stcBlobPad.intStartY = stcTemporaryBlobPad.intStartY;
                m_stcBlobPad.intEndY = stcTemporaryBlobPad.intEndY;
                m_stcBlobPad.blnSelected = stcTemporaryBlobPad.blnSelected;
                m_stcBlobPad.blnEnable = stcTemporaryBlobPad.blnEnable;
                m_stcBlobPad.intDirection = stcTemporaryBlobPad.intDirection;
                m_stcBlobPad.intGroupID = stcTemporaryBlobPad.intGroupID;
                m_stcBlobPad.fPitch = stcTemporaryBlobPad.fPitch;
                m_stcBlobPad.fGap = stcTemporaryBlobPad.fGap;
                m_stcBlobPad.intNoID = stcTemporaryBlobPad.intNoID;
                m_arrTemplateBlobPads.Add(m_stcBlobPad);
            }
        }


        /// <summary>
        /// Select template objects
        /// </summary>
        /// <param name="p1">rectangle start point</param>
        /// <param name="p2">rectangle stop point</param>
        /// <param name="intROIX">total offset X</param>
        /// <param name="intROIY">total offset Y</param>
        public void SelectTemplateObjects(System.Drawing.Point p1, System.Drawing.Point p2, int intROIX, int intROIY)
        {
            int intOrgX, intOrgY, intWidth, intHeight;

            if (p1.X < p2.X)
            {
                intOrgX = p1.X;
                intWidth = p2.X - p1.X;
            }
            else
            {
                intOrgX = p2.X;
                intWidth = p1.X - p2.X;
            }
            if (p1.Y < p2.Y)
            {
                intOrgY = p1.Y;
                intHeight = p2.Y - p1.Y;
            }
            else
            {
                intOrgY = p2.Y;
                intHeight = p1.Y - p2.Y;
            }

            intOrgX -= intROIX;
            intOrgY -= intROIY;

            // new method
            p1 = new System.Drawing.Point(p1.X - intROIX, p1.Y - intROIY);
            p2 = new System.Drawing.Point(p2.X - intROIX, p2.Y - intROIY);

            List<int> arrSelectedIndex = new List<int>();
            for (int i = 0; i < m_arrTemplateBlobPads.Count; i++)
            {
                BlobsFeatures m_stcBlobPad = (BlobsFeatures)m_arrTemplateBlobPads[i];
                //if ((m_stcBlobPad.fCenterX >= intOrgX) &&
                //    (m_stcBlobPad.fCenterX <= (intOrgX + intWidth)) &&
                //    (m_stcBlobPad.fCenterY >= intOrgY) &&
                //    (m_stcBlobPad.fCenterY <= (intOrgY + intHeight)))
                //{
                //    m_stcBlobPad.blnSelected = true;
                //}
                bool blnFound = false;
                for (int x = p1.X; x < p2.X; x++)
                {
                    for (int y = p1.Y; y < p2.Y; y++)
                    {
                        if ((x >= m_stcBlobPad.fStartX) &&
                               (x <= m_stcBlobPad.fEndX) &&
                               (y >= m_stcBlobPad.fStartY) &&
                               (y <= m_stcBlobPad.fEndY))
                        {
                            m_stcBlobPad.blnSelected = true;
                            blnFound = true;
                            break;
                        }
                    }

                    if (blnFound)
                        break;
                }

                if (blnFound)
                    arrSelectedIndex.Add(i);
                //m_arrTemplateBlobPads.RemoveAt(i);
                //m_arrTemplateBlobPads.Insert(i, m_stcBlobPad);
            }

            for (int i = 0; i < arrSelectedIndex.Count; i++)
            {
                bool blnOverlap = false;
                bool blnSmall = false;
                for (int j = 0; j < arrSelectedIndex.Count; j++)
                {
                    if (i == j)
                        continue;

                    BlobsFeatures objBlob1 = (BlobsFeatures)m_arrTemplateBlobPads[arrSelectedIndex[i]];
                    BlobsFeatures objBlob2 = (BlobsFeatures)m_arrTemplateBlobPads[arrSelectedIndex[j]];

                    // check is blob overlap with other blobs (using 4 corner points matching methodology)?
                    if ((((objBlob1.fStartX > objBlob2.fStartX) &&
                        (objBlob1.fStartX < objBlob2.fEndX) &&
                        (objBlob1.fStartY > objBlob2.fStartY) &&
                        (objBlob1.fStartY < objBlob2.fEndY)) ||
                        ((objBlob1.fStartX > objBlob2.fStartX) &&
                        (objBlob1.fStartX < objBlob2.fEndX) &&
                        (objBlob1.fEndY > objBlob2.fStartY) &&
                        (objBlob1.fEndY < objBlob2.fEndY)) ||
                        ((objBlob1.fEndX > objBlob2.fStartX) &&
                        (objBlob1.fEndX < objBlob2.fEndX) &&
                        (objBlob1.fStartY > objBlob2.fStartY) &&
                        (objBlob1.fStartY < objBlob2.fEndY)) ||
                        ((objBlob1.fEndX > objBlob2.fStartX) &&
                        (objBlob1.fEndX < objBlob2.fEndX) &&
                        (objBlob1.fEndY > objBlob2.fStartY) &&
                        (objBlob1.fEndY < objBlob2.fEndY))) ||

                        (((objBlob2.fStartX > objBlob1.fStartX) &&
                        (objBlob2.fStartX < objBlob1.fEndX) &&
                        (objBlob2.fStartY > objBlob1.fStartY) &&
                        (objBlob2.fStartY < objBlob1.fEndY)) ||
                        ((objBlob2.fStartX > objBlob1.fStartX) &&
                        (objBlob2.fStartX < objBlob1.fEndX) &&
                        (objBlob2.fEndY > objBlob1.fStartY) &&
                        (objBlob2.fEndY < objBlob1.fEndY)) ||
                        ((objBlob2.fEndX > objBlob1.fStartX) &&
                        (objBlob2.fEndX < objBlob1.fEndX) &&
                        (objBlob2.fStartY > objBlob1.fStartY) &&
                        (objBlob2.fStartY < objBlob1.fEndY)) ||
                        ((objBlob2.fEndX > objBlob1.fStartX) &&
                        (objBlob2.fEndX < objBlob1.fEndX) &&
                        (objBlob2.fEndY > objBlob1.fStartY) &&
                        (objBlob2.fEndY < objBlob1.fEndY))))

                    {
                        // check is blob1 size smaller than blob2
                        if (((objBlob1.fEndX - objBlob1.fStartX) * (objBlob1.fEndY - objBlob1.fStartY)) >
                            ((objBlob2.fEndX - objBlob2.fStartX) * (objBlob2.fEndY - objBlob2.fStartY)))
                        {
                            blnOverlap = true;  // no select
                            break;
                        }
                    }
                }

                if (!blnOverlap)
                {
                    BlobsFeatures m_stcBlobPad = (BlobsFeatures)m_arrTemplateBlobPads[arrSelectedIndex[i]];
                    m_stcBlobPad.blnSelected = true;
                    m_arrTemplateBlobPads.RemoveAt(arrSelectedIndex[i]);
                    m_arrTemplateBlobPads.Insert(arrSelectedIndex[i], m_stcBlobPad);
                }
            }
        }

        public void SelectTemplateObject_ForGrouping(System.Drawing.Point p1, int intROIX, int intROIY)
        {
            // new method
            p1 = new System.Drawing.Point(p1.X - intROIX, p1.Y - intROIY);

            int intSelectedPadNo = -1;
            for (int i = 0; i < m_arrTemplateBlobPads.Count; i++)
            {
                BlobsFeatures m_stcBlobPad = (BlobsFeatures)m_arrTemplateBlobPads[i];

                if ((p1.X >= m_stcBlobPad.fStartX) && (p1.Y >= m_stcBlobPad.fStartY) &&
                    (p1.X <= m_stcBlobPad.fEndX) && (p1.Y <= m_stcBlobPad.fEndY))
                {
                    intSelectedPadNo = i;
                    break;
                }
            }

            if (intSelectedPadNo >= 0)
            {
                bool blnFound = false;
                for (int i = 0; i < m_arrSelectedPadForGrouping.Count; i++)
                {
                    if (intSelectedPadNo == m_arrSelectedPadForGrouping[i])
                    {
                        m_arrSelectedPadForGrouping.RemoveAt(i);
                        return;
                    }
                }

                m_arrSelectedPadForGrouping.Add(intSelectedPadNo);
            }
        }

        /// <summary>
        /// Set blobs data in m_objBlobs into m_arrTemporaryBlobPads
        /// </summary>
        public void SetBlobsFeaturesToTempArray(ROI objROI, int OffsetX, int OffsetY)
        {
            SetBlobsFeaturesToArray(m_objEBlobs, m_arrTemporaryBlobPads, objROI, OffsetX, OffsetY);
        }

        /// <summary>
        /// Set blobs data into particular array list
        /// </summary>
        /// <param name="objEBlobs">blobs name</param>
        /// <param name="arrBlobsFeature">array list that used store the blobs data</param>
        public void SetBlobsFeaturesToArray(EBlobs objEBlobs, ArrayList arrBlobsFeature, ROI objROI, int OffsetX, int OffsetY)
        {
            arrBlobsFeature.Clear();

            int intSelectedObjectNum = objEBlobs.ref_intNumSelectedObject;
            float fBorderDistanceX, fBorderDistanceY, fAngle;
            for (int i = 0; i < intSelectedObjectNum; i++)
            {

                BlobsFeatures m_stcBlobPad = new BlobsFeatures();

                m_stcBlobPad.fArea = objEBlobs.ref_arrArea[i];
                m_stcBlobPad.fCenterX = objEBlobs.ref_arrGravityCenterX[i] + Math.Abs(OffsetX);
                m_stcBlobPad.fCenterY = objEBlobs.ref_arrGravityCenterY[i] + Math.Abs(OffsetY);
                m_stcBlobPad.fLimitCenterX = objEBlobs.ref_arrLimitCenterX[i] + Math.Abs(OffsetX);
                m_stcBlobPad.fLimitCenterY = objEBlobs.ref_arrLimitCenterY[i] + Math.Abs(OffsetY);
                m_stcBlobPad.fWidth = objEBlobs.ref_arrWidth[i];
                m_stcBlobPad.fHeight = objEBlobs.ref_arrHeight[i];

                fAngle = objEBlobs.ref_arrRectAngle[i];

                if (objEBlobs.ref_arrRectHeight[i] < objEBlobs.ref_arrRectWidth[i])
                {
                    if (fAngle >= 10)//&& fAngle <= 80)
                        fAngle = objEBlobs.ref_arrRectAngle[i] - 90;
                    //else if (fAngle >= 80)
                    //{
                    //    fAngle = 90 - objEBlobs.ref_arrRectAngle[i];
                    //    fAngle = -fAngle;
                    //}
                    else
                        fAngle = 90 + objEBlobs.ref_arrRectAngle[i];



                    m_stcBlobPad.fFeretWidth = objEBlobs.ref_arrRectHeight[i];
                    m_stcBlobPad.fFeretHeight = objEBlobs.ref_arrRectWidth[i];
                }
                else
                {
                    m_stcBlobPad.fFeretWidth = objEBlobs.ref_arrRectWidth[i];
                    m_stcBlobPad.fFeretHeight = objEBlobs.ref_arrRectHeight[i];
                }
                m_stcBlobPad.fFeretCenterX = objEBlobs.ref_arrRectLimitCenterX[i] + Math.Abs(OffsetX);
                m_stcBlobPad.fFeretCenterY = objEBlobs.ref_arrRectLimitCenterY[i] + Math.Abs(OffsetY);

                //if (fAngle < 0)
                //{
                //    fAngle = fAngle + 360;
                //    if (fAngle >= 270)
                //        fAngle = fAngle - 360;
                //    else if (fAngle > 90 && fAngle < 270)
                //        fAngle = fAngle - 180;
                //}
                //else if (fAngle > 0)
                //{
                //    fAngle = fAngle - 360;
                //    if (fAngle <= -270)
                //        fAngle = fAngle + 360;
                //    else if (fAngle < -90 && fAngle > -270)
                //        fAngle = fAngle + 180;
                //}

                //fAngle = -fAngle;

                fBorderDistanceX = Math.Min(m_stcBlobPad.fLimitCenterX, objROI.ref_ROIWidth - m_stcBlobPad.fLimitCenterX);
                fBorderDistanceY = Math.Min(m_stcBlobPad.fLimitCenterY, objROI.ref_ROIHeight - m_stcBlobPad.fLimitCenterY);

                m_stcBlobPad.fFeretAngle = fAngle;

                if (objEBlobs.ref_arrRectWidth[i] < objEBlobs.ref_arrRectHeight[i])  // width shorter then height
                {
                    m_stcBlobPad.intFeretLengthMode = 1;   // 1 mean length == height
                }
                else
                {
                    m_stcBlobPad.intFeretLengthMode = 2;   // 2 mean length == width
                }

                //if ((fBorderDistanceX / fBorderDistanceY) < 0.7) // point x closer to border compare with point y
                //{
                //    m_stcBlobPad.intLengthMode = 2;   // 2 mean length == width OR set Width == fHeight, Length == fWidth
                //}
                //else if ((fBorderDistanceY / fBorderDistanceX) < 0.7)   // point y closer to border compare with point x
                //{
                //    m_stcBlobPad.intLengthMode = 1;   // 1 mean length == height OR set Width == fWidth, Length == fHeight
                //}
                //else
                {
                    if (m_stcBlobPad.fWidth < m_stcBlobPad.fHeight)  // width shorter then height
                    {
                        m_stcBlobPad.intLengthMode = 1;   // 1 mean length == height
                    }
                    else
                    {
                        m_stcBlobPad.intLengthMode = 2;   // 2 mean length == width
                    }
                }

                m_stcBlobPad.intContourX = objEBlobs.ref_arrContourX[i] + Math.Abs(OffsetX);
                m_stcBlobPad.intContourY = objEBlobs.ref_arrContourY[i] + Math.Abs(OffsetY);
                m_stcBlobPad.intObjNo = i;
                m_stcBlobPad.fStartX = (float)Math.Round(m_stcBlobPad.fLimitCenterX - (m_stcBlobPad.fWidth / 2), 4);
                m_stcBlobPad.fEndX = (float)Math.Round(m_stcBlobPad.fLimitCenterX + (m_stcBlobPad.fWidth / 2), 4);
                m_stcBlobPad.fStartY = (float)Math.Round(m_stcBlobPad.fLimitCenterY - (m_stcBlobPad.fHeight / 2), 4);
                m_stcBlobPad.fEndY = (float)Math.Round(m_stcBlobPad.fLimitCenterY + (m_stcBlobPad.fHeight / 2), 4);
                m_stcBlobPad.intStartX = (int)Math.Round(m_stcBlobPad.fLimitCenterX - (m_stcBlobPad.fWidth / 2), 0, MidpointRounding.AwayFromZero);
                m_stcBlobPad.intEndX = (int)Math.Round(m_stcBlobPad.fLimitCenterX + (m_stcBlobPad.fWidth / 2), 0, MidpointRounding.AwayFromZero);
                m_stcBlobPad.intStartY = (int)Math.Round(m_stcBlobPad.fLimitCenterY - (m_stcBlobPad.fHeight / 2), 0, MidpointRounding.AwayFromZero);
                m_stcBlobPad.intEndY = (int)Math.Round(m_stcBlobPad.fLimitCenterY + (m_stcBlobPad.fHeight / 2), 0, MidpointRounding.AwayFromZero);
                m_stcBlobPad.blnSelected = true;
                m_stcBlobPad.blnEnable = true;
                m_stcBlobPad.intDirection = -1;
                m_stcBlobPad.intGroupID = 0;
                m_stcBlobPad.fPitch = -1;
                m_stcBlobPad.fGap = -1;
                m_stcBlobPad.intNoID = 0;
                arrBlobsFeature.Add(m_stcBlobPad);
            }
        }

        /// <summary>
        /// Set blobs data in m_objBlobs into m_arrTemplateBlobPads
        /// </summary>
        public void SetBlobsFeaturesToArray(ROI objROI, int OffsetX, int OffsetY)
        {
            SetBlobsFeaturesToArray(m_objEBlobs, m_arrTemplateBlobPads, objROI, OffsetX, OffsetY);
        }

        /// <summary>
        /// Set Offset offset settings
        /// </summary>
        /// <param name="fOffsetOffSet">Offset offset</param>
        public void SetOffsetOffSet(float fOffsetOffSet)
        {
            m_fOffsetOffSet = fOffsetOffSet / m_fAreaMMPerPixel / (float)1e-3;
        }

        /// <summary>
        /// Set width offset settings
        /// </summary>
        /// <param name="fWidthOffSet">width offset</param>
        public void SetWidthOffSet(float fWidthOffSet)
        {
            m_fWidthOffSet = fWidthOffSet / m_fAreaMMPerPixel / (float)1e-3;
        }

        /// <summary>
        /// Set height offset settings
        /// </summary>
        /// <param name="fHeightOffSet">height offset</param>
        public void SetHeightOffSet(float fHeightOffSet)
        {
            m_fHeightOffSet = fHeightOffSet / m_fAreaMMPerPixel / (float)1e-3;
        }

        /// <summary>
        /// Set pitch offset settings
        /// </summary>
        /// <param name="fPitchOffSet">pitch offset</param>
        public void SetPitchOffSet(float fPitchOffSet)
        {
            m_fPitchOffSet = fPitchOffSet / m_fAreaMMPerPixel / (float)1e-3;
        }

        /// <summary>
        /// Define pitch gap
        /// </summary>
        /// <param name="intPitchGapIndex">pitch gap index</param>
        /// <param name="intFromPadNo">from pad no</param>
        /// <param name="intToPadNo">to pad no</param>
        public void SetPitchGap(int intPitchGapIndex, int intFromPadNo, int intToPadNo)
        {
            int intFromNo, intToNo;
            if (intFromPadNo < intToPadNo)
            {
                intFromNo = intFromPadNo;
                intToNo = intToPadNo;
            }
            else
            {
                intFromNo = intToPadNo;
                intToNo = intFromPadNo;
            }

            if (DefinePitchGap(intPitchGapIndex, intFromNo, intToNo))
            {

                if ((intFromPadNo > intToPadNo) && !CheckPitchGapLinkInPadAlready(intToPadNo))
                {
                    m_stcPitchGap.intFromPadNo = intToPadNo;
                    m_stcPitchGap.intToPadNo = intFromPadNo;
                }
                else
                {
                    m_stcPitchGap.intFromPadNo = intFromPadNo;
                    m_stcPitchGap.intToPadNo = intToPadNo;
                }

                if (intPitchGapIndex < m_arrPitchGap.Count)
                {
                    m_arrPitchGap.RemoveAt(intPitchGapIndex);
                    m_arrPitchGap.Insert(intPitchGapIndex, m_stcPitchGap);
                }
                else
                {
                    if (intPitchGapIndex <= m_arrPitchGap.Count)
                        m_arrPitchGap.Insert(intPitchGapIndex, m_stcPitchGap);
                    else
                        m_arrPitchGap.Add(m_stcPitchGap);
                }
            }

        }

        public void SetPitchGap(int intFromPadNo, int intToPadNo)
        {
            int intPitchGapIndex = -1;
            for (int i = 0; i < m_arrPitchGap.Count; i++)
            {
                if (intFromPadNo == m_arrPitchGap[i].intFromPadNo)
                    intPitchGapIndex = i;
            }

            if (intToPadNo < 0) // Mean User set to NA 
            {
                if (intPitchGapIndex >= 0 && intPitchGapIndex < m_arrPitchGap.Count)
                    m_arrPitchGap.RemoveAt(intPitchGapIndex);
            }
            else
            {

                int intFromNo, intToNo;
                if (intFromPadNo < intToPadNo)
                {
                    intFromNo = intFromPadNo;
                    intToNo = intToPadNo;
                }
                else
                {
                    intFromNo = intToPadNo;
                    intToNo = intFromPadNo;
                }

                if (DefinePitchGap(intPitchGapIndex, intFromNo, intToNo))
                {

                    if ((intFromPadNo > intToPadNo) && !CheckPitchGapLinkInPadAlready(intToPadNo))
                    {
                        m_stcPitchGap.intFromPadNo = intToPadNo;
                        m_stcPitchGap.intToPadNo = intFromPadNo;
                    }
                    else
                    {
                        m_stcPitchGap.intFromPadNo = intFromPadNo;
                        m_stcPitchGap.intToPadNo = intToPadNo;
                    }

                    //if (intPitchGapIndex < m_arrPitchGap.Count)
                    if (intPitchGapIndex < 0)
                    {
                        m_arrPitchGap.Insert(m_arrPitchGap.Count, m_stcPitchGap);
                    }
                    else
                    {
                        m_arrPitchGap.RemoveAt(intPitchGapIndex);
                        m_arrPitchGap.Insert(intPitchGapIndex, m_stcPitchGap);
                    }
                }
            }
        }

        public void AutoDefineGroupNoToTemplate()
        {
            // 2019 01 10 - JBTAN: Have to find out optimum value for fDifferentTolerancePercent
            float fDifferentTolerancePercent = 0.2f;
            int intGroupNo = 0;
            bool[] arrGroupNoAssigned = new bool[m_arrTemplateBlobPads.Count];
            int[] arrGroupNo = new int[m_arrTemplateBlobPads.Count];
            for (int i = 0; i < m_arrTemplateBlobPads.Count; i++)
            {
                if (arrGroupNoAssigned[i])
                    continue;

                arrGroupNo[i] = intGroupNo;
                arrGroupNoAssigned[i] = true;

                for (int h = 0; h < m_arrTemplateBlobPads.Count; h++)
                {
                    if (i != h)
                    {
                        if (!arrGroupNoAssigned[h])
                            continue;
                    }

                    BlobsFeatures stcBlobsFeatures1 = (BlobsFeatures)m_arrTemplateBlobPads[i];

                    for (int j = 0; j < m_arrTemplateBlobPads.Count; j++)
                    {
                        if (i == j)
                            continue;

                        if (arrGroupNoAssigned[j])
                            continue;

                        BlobsFeatures stcBlobsFeatures2 = (BlobsFeatures)m_arrTemplateBlobPads[j];

                        if (stcBlobsFeatures2.intLengthMode == stcBlobsFeatures1.intLengthMode)
                        {
                            if ((stcBlobsFeatures2.fWidth >= (stcBlobsFeatures1.fWidth * (1 - fDifferentTolerancePercent))) &&
                                (stcBlobsFeatures2.fWidth <= (stcBlobsFeatures1.fWidth * (1 + fDifferentTolerancePercent))) &&
                                (stcBlobsFeatures2.fHeight >= (stcBlobsFeatures1.fHeight * (1 - fDifferentTolerancePercent))) &&
                                (stcBlobsFeatures2.fHeight <= (stcBlobsFeatures1.fHeight * (1 + fDifferentTolerancePercent))))
                            {
                                arrGroupNo[j] = intGroupNo;
                                arrGroupNoAssigned[j] = true;
                            }
                        }
                        else
                        {
                            if ((stcBlobsFeatures2.fWidth >= (stcBlobsFeatures1.fHeight * (1 - fDifferentTolerancePercent))) &&
                                (stcBlobsFeatures2.fWidth <= (stcBlobsFeatures1.fHeight * (1 + fDifferentTolerancePercent))) &&
                                (stcBlobsFeatures2.fHeight >= (stcBlobsFeatures1.fWidth * (1 - fDifferentTolerancePercent))) &&
                                (stcBlobsFeatures2.fHeight <= (stcBlobsFeatures1.fWidth * (1 + fDifferentTolerancePercent))))
                            {
                                arrGroupNo[j] = intGroupNo;
                                arrGroupNoAssigned[j] = true;
                            }

                        }
                    }
                }
                intGroupNo++;
            }

            for (int i = 0; i < m_arrTemplateBlobPads.Count; i++)
            {
                BlobsFeatures m_stcBlobPad = (BlobsFeatures)m_arrTemplateBlobPads[i];

                m_stcBlobPad.intGroupID = arrGroupNo[i];

                m_arrTemplateBlobPads.RemoveAt(i);
                m_arrTemplateBlobPads.Insert(i, m_stcBlobPad);
            }
        }

        /// <summary>
        /// Set min pitch, max pitch, min gap, max gap into certain pitch gap
        /// </summary>
        /// <param name="intPitchGapIndex">pitch gap index</param>
        /// <param name="fMinPitch">min pitch</param>
        /// <param name="fMaxPitch">max pitch</param>
        /// <param name="fMinGap">min gap</param>
        /// <param name="fMaxGap">max gap</param>
        public void SetPitchGapDataFrom(int intPitchGapIndex, float fMinPitch, float fMaxPitch, float fMinGap, float fMaxGap)
        {
            for (int i = 0; i < m_arrPitchGap.Count; i++)
            {
                if (intPitchGapIndex == m_arrPitchGap[i].intFromPadNo)
                {
                    m_stcPitchGap = m_arrPitchGap[i];
                    m_stcPitchGap.fMinPitch = fMinPitch / m_fMMToUnitValue;
                    m_stcPitchGap.fMaxPitch = fMaxPitch / m_fMMToUnitValue;
                    m_stcPitchGap.fMinGap = fMinGap / m_fMMToUnitValue;
                    m_stcPitchGap.fMaxGap = fMaxGap / m_fMMToUnitValue;

                    m_arrPitchGap.RemoveAt(i);
                    m_arrPitchGap.Insert(i, m_stcPitchGap);

                }
            }
        }

        /// <summary>
        /// Set min pitch, max pitch, min gap, max gap into certain pitch gap
        /// </summary>
        /// <param name="intPitchGapIndex">pitch gap index</param>
        /// <param name="fMinPitch">min pitch</param>
        /// <param name="fMaxPitch">max pitch</param>
        /// <param name="fMinGap">min gap</param>
        /// <param name="fMaxGap">max gap</param>
        public void SetSinglePitchGapDataFrom(int intPitchGapIndex, int intFeature, float fValue)
        {
            // 2019 08 20 - CCENG: intPitchGapIndex value may higher then m_arrPitchGap.Count. Because intPitchGapIndex refer to m_arrPitchGap[i].intFromPadNo.
            //                     E.g example There are 3 pads with only 1 pitch gap between pad 2 and 3. in this case, intPitchGapIndex value is 1 (mean for pad 2), but m_arrPitchGap.Count is 1 also only.
            //if (intPitchGapIndex >= m_arrPitchGap.Count)
            //    return;

            for (int i = 0; i < m_arrPitchGap.Count; i++)
            {
                if (intPitchGapIndex == m_arrPitchGap[i].intFromPadNo)
                {
                    m_stcPitchGap = m_arrPitchGap[i];

                    switch (intFeature)
                    {
                        case 15:
                            m_stcPitchGap.fMinPitch = fValue / m_fMMToUnitValue;
                            break;
                        case 17:
                            m_stcPitchGap.fMaxPitch = fValue / m_fMMToUnitValue;
                            break;
                        case 19:
                            m_stcPitchGap.fMinGap = fValue / m_fMMToUnitValue;
                            break;
                        case 21:
                            m_stcPitchGap.fMaxGap = fValue / m_fMMToUnitValue;
                            break;
                    }

                    m_arrPitchGap.RemoveAt(i);
                    m_arrPitchGap.Insert(i, m_stcPitchGap);
                }
            }
        }

        /// <summary>
        /// Set min pitch, max pitch, min gap, max gap into certain pitch gap
        /// </summary>
        /// <param name="intPitchGapIndex">pitch gap index</param>
        /// <param name="fMinPitch">min pitch</param>
        /// <param name="fMaxPitch">max pitch</param>
        /// <param name="fMinGap">min gap</param>
        /// <param name="fMaxGap">max gap</param>
        public void SetPitchGapData(int intPitchGapIndex, int intFromPadNo, int intToPadNo, float fMinPitch, float fMaxPitch, float fMinGap, float fMaxGap)
        {
            // Get pitch gap array index. (Note: Pitch gap array not sequential with template array)
            int i;
            for (i = 0; i < m_arrPitchGap.Count; i++)
            {
                //if (m_arrPitchGap[intPitchGapIndex].intFromPadNo == intPitchGapIndex)
                if (m_arrPitchGap[i].intFromPadNo == intFromPadNo &&
                    m_arrPitchGap[i].intToPadNo == intToPadNo)
                {
                    intPitchGapIndex = i;
                    break;
                }
            }

            // return if index not found
            if (i == m_arrPitchGap.Count)
                return;

            // Update pitch gap with latest information
            m_stcPitchGap = m_arrPitchGap[intPitchGapIndex];
            m_stcPitchGap.fMinPitch = fMinPitch / m_fMMToUnitValue;
            m_stcPitchGap.fMaxPitch = fMaxPitch / m_fMMToUnitValue;
            m_stcPitchGap.fMinGap = fMinGap / m_fMMToUnitValue;
            m_stcPitchGap.fMaxGap = fMaxGap / m_fMMToUnitValue;
            m_arrPitchGap.RemoveAt(i);
            m_arrPitchGap.Insert(i, m_stcPitchGap);

        }

        /// <summary>
        /// Add pitch gap into m_arrPitchGap
        /// </summary>
        /// <param name="intFromPadNo">from pad no</param>
        /// <param name="intToPadNo">to pad no</param>
        /// <param name="fMinPitch">min pitch</param>
        /// <param name="fMaxPitch">max pitch</param>
        /// <param name="fMinGap">min gap</param>
        /// <param name="fMaxGap">max gap</param>
        /// <param name="fPitch">pitch</param>
        /// <param name="fGap">gap</param>
        /// <param name="intStartX">start X position</param>
        /// <param name="intStartY">start Y position</param>
        /// <param name="intEndX">end X position</param>
        /// <param name="intEndY">end Y position</param>
        /// <param name="intDirection">direction</param>
        public void SetPitchGapData(int intFromPadNo, int intToPadNo, float fMinPitch, float fMaxPitch,
            float fMinGap, float fMaxGap, float fPitch, float fGap,
            int intStartX, int intStartY, int intEndX, int intEndY, int intDirection)
        {
            m_stcPitchGap.intFromPadNo = intFromPadNo;
            m_stcPitchGap.intToPadNo = intToPadNo;
            m_stcPitchGap.fMinPitch = fMinPitch;
            m_stcPitchGap.fMaxPitch = fMaxPitch;
            m_stcPitchGap.fMinGap = fMinGap;
            m_stcPitchGap.fMaxGap = fMaxGap;
            m_stcPitchGap.fPitch = fPitch;
            m_stcPitchGap.fGap = fGap;
            m_stcPitchGap.intStartPointX = intStartX;
            m_stcPitchGap.intStartPointY = intStartY;
            m_stcPitchGap.intEndPointX = intEndX;
            m_stcPitchGap.intEndPointY = intEndY;
            m_stcPitchGap.intDirection = intDirection;

            m_arrPitchGap.Add(m_stcPitchGap);
        }

        public void SetPitchGapToleranceOnly(int intPitchGapIndex, float fMinPitch, float fMaxPitch, float fMinGap, float fMaxGap)
        {
            if (intPitchGapIndex < m_arrPitchGap.Count)
            {
                m_stcPitchGap = (PitchGap)m_arrPitchGap[intPitchGapIndex];
                m_stcPitchGap.fMinPitch = fMinPitch;
                m_stcPitchGap.fMaxPitch = fMaxPitch;
                m_stcPitchGap.fMinGap = fMinGap;
                m_stcPitchGap.fMaxGap = fMaxGap;

                m_arrPitchGap.RemoveAt(intPitchGapIndex);
                m_arrPitchGap.Insert(intPitchGapIndex, m_stcPitchGap);
            }
            else
            {
                m_stcPitchGap.fMinPitch = fMinPitch;
                m_stcPitchGap.fMaxPitch = fMaxPitch;
                m_stcPitchGap.fMinGap = fMinGap;
                m_stcPitchGap.fMaxGap = fMaxGap;
                m_arrPitchGap.Add(m_stcPitchGap);
            }
        }

        /// <summary>
        /// Set gap offset settings
        /// </summary>
        /// <param name="fGapOffSet">gap offset</param>
        public void SetGapOffSet(float fGapOffSet)
        {
            m_fGapOffSet = fGapOffSet / m_fAreaMMPerPixel / (float)1e-3;
        }

        /// <summary>
        /// Add blobs features into m_arrTemplateBlobPads
        /// </summary>
        /// <param name="intNoID">id</param>
        /// <param name="intGroupNo">group no</param>
        /// <param name="fArea">area</param>
        /// <param name="intLengthMode">length</param>
        /// <param name="intContourX">contour X</param>
        /// <param name="intContourY">contour Y</param>
        /// <param name="intStartX">start X position in int</param>
        /// <param name="intStartY">start Y position in int</param>
        /// <param name="intEndX">end X position in int</param>
        /// <param name="intEndY">end Y position in int</param>
        /// <param name="fStartX">start X position in float</param>
        /// <param name="fStartY">start Y position in float</param>
        /// <param name="fEndX">end X position in float</param>
        /// <param name="fEndY">end Y position in float</param>
        /// <param name="intDirection">direction</param>
        /// <param name="intSide">side</param>
        /// <param name="fCenterX">center X position</param>
        /// <param name="fCenterY">center Y position</param>
        /// <param name="fLimitCenterX">limit center X position</param>
        /// <param name="fLimitCenterY">limit center Y position</param>
        /// <param name="fWidth">width</param>
        /// <param name="fHeight">height</param>
        /// <param name="blnSelected">whether is selected</param>
        /// <param name="fLeftDistance">left distance</param>
        /// <param name="fRightDistance">right distance</param>
        /// <param name="fTopDistance">top distance</param>
        /// <param name="fBottomDistance">bottom distance</param>
        /// <param name="fPitch">pitch</param>
        /// <param name="fGap">gap</param>
        /// <param name="fOffSet">offset</param>
        /// <param name="fMinArea">min area</param>
        /// <param name="fMaxArea">max area</param>
        /// <param name="fMinWidth">min width</param>
        /// <param name="fMaxWidth">max width</param>
        /// <param name="fMinLength">min height</param>
        /// <param name="fMaxLength">max height</param>
        /// <param name="fMinPitch">min pitch</param>
        /// <param name="fMaxPitch">max pitch</param>
        /// <param name="fMinGap">min gap</param>
        /// <param name="fMaxGap">max gap</param>
        /// <param name="fMaxBroken">max hole</param>
        public void SetTemplateBlobsFeatures(int intNoID, int intGroupID, float fArea, int intLengthMode,
            int intContourX, int intContourY,
            int intStartX, int intStartY, int intEndX, int intEndY,
            float fStartX, float fStartY, float fEndX, float fEndY,
            int intDirection, int intSide, int intSmearSide,
            float fCenterX, float fCenterY, float fLimitCenterX, float fLimitCenterY,
            float fWidth, float fHeight,
            float fWidthPercentStart1, float fHeightPercentStart1, float fWidthPercentEnd1, float fHeightPercentEnd1,
            float fWidthPercentStart2, float fHeightPercentStart2, float fWidthPercentEnd2, float fHeightPercentEnd2,
            float fWidthPercentStart3, float fHeightPercentStart3, float fWidthPercentEnd3, float fHeightPercentEnd3,
            float fWidthPercentStart4, float fHeightPercentStart4, float fWidthPercentEnd4, float fHeightPercentEnd4,
            float fWidthPercentStart5, float fHeightPercentStart5, float fWidthPercentEnd5, float fHeightPercentEnd5,
            float fWidthPercentStart6, float fHeightPercentStart6, float fWidthPercentEnd6, float fHeightPercentEnd6,
            float fWidthPercentStart7, float fHeightPercentStart7, float fWidthPercentEnd7, float fHeightPercentEnd7,
            float fWidthPercentStart8, float fHeightPercentStart8, float fWidthPercentEnd8, float fHeightPercentEnd8,
            float fWidthPercentStart9, float fHeightPercentStart9, float fWidthPercentEnd9, float fHeightPercentEnd9,
            float fWidthPercentStart10, float fHeightPercentStart10, float fWidthPercentEnd10, float fHeightPercentEnd10,
            float fWidthPercentStart11, float fHeightPercentStart11, float fWidthPercentEnd11, float fHeightPercentEnd11,
            float fWidthPercentStart12, float fHeightPercentStart12, float fWidthPercentEnd12, float fHeightPercentEnd12,
            float fInwardPercentStart1, float fInwardPercentEnd1,
            float fInwardPercentStart2, float fInwardPercentEnd2,
            float fInwardPercentStart3, float fInwardPercentEnd3,
            float fInwardPercentStart4, float fInwardPercentEnd4,
            float fInwardPercentStart5, float fInwardPercentEnd5,
            float fInwardPercentStart6, float fInwardPercentEnd6,
            float fInwardPercentStart7, float fInwardPercentEnd7,
            float fInwardPercentStart8, float fInwardPercentEnd8,
            float fInwardPercentStart9, float fInwardPercentEnd9,
            float fInwardPercentStart10, float fInwardPercentEnd10,
            float fInwardPercentStart11, float fInwardPercentEnd11,
            float fInwardPercentStart12, float fInwardPercentEnd12,
            int intMeasureMethod1, int intMeasureMethod2, int intMeasureMethod3, int intMeasureMethod4, int intMeasureMethod5, int intMeasureMethod6, int intMeasureMethod7,
            int intMeasureMethod8, int intMeasureMethod9, int intMeasureMethod10, int intMeasureMethod11, int intMeasureMethod12,
            float fAngle, int intLineCount, float fFeretWidth, float fFeretHeight,
            float fFeretCenterX, float fFeretCenterY, float fFeretAngle, int intFeretLengthMode, bool blnFeretActivated,
            int P1X, int P1Y, int P2X, int P2Y, int P3X, int P3Y, int P4X, int P4Y,
            bool blnSelected, bool blnEnable, float fLeftDistance,
            float fRightDistance, float fTopDistance, float fBottomDistance,
            float fXDistance, float fYDistance,
            float fTemplateROICenterX, float fTemplateROICenterY, float fTemplateROITopLeftCornerX, float fTemplateROITopLeftCornerY,
            float fXDistance_Pattern, float fYDistance_Pattern,
            float fTemplateROICenterX_Pattern, float fTemplateROICenterY_Pattern, float fTemplateROITopLeftCornerX_Pattern, float fTemplateROITopLeftCornerY_Pattern,
            float fPitch, float fGap, float fOffSet, float fMinArea, float fMaxArea,
            float fMinWidth, float fMaxWidth, float fMinLength, float fMaxLength,
            float fMinPitch, float fMaxPitch, float fMinGap, float fMaxGap, float fMaxBroken, float fMaxBrokenLength, float fMaxExcess, float fMaxSmearLength,
            float fMaxEdgeLimitTop, float fMaxEdgeLimitRight, float fMaxEdgeLimitBottom, float fMaxEdgeLimitLeft,
            float fMaxStandOffTop, float fMaxStandOffBottom, float fMaxStandOffLeft, float fMaxStandOffRight,
            float fOffsetOffSet, float fWidthOffset, float fHeightOffset, float fPitchOffset, float fGapOffset,
            float fEdgeDistanceTopOffset, float fEdgeDistanceRightOffset, float fEdgeDistanceBottomOffset, float fEdgeDistanceLeftOffset,
            float fEdgeLimitTopOffset, float fEdgeLimitRightOffset, float fEdgeLimitBottomOffset, float fEdgeLimitLeftOffset,
            float fStandOffTopOffset, float fStandOffBottomOffset, float fStandOffLeftOffset, float fStandOffRightOffset,
            float fMinLine3, float fMaxLine3, float fMinLine4, float fMaxLine4, float fMinLine5, float fMaxLine5, float fMinLine6, float fMaxLine6, float fMinLine7, float fMaxLine7,
            float fMinLine8, float fMaxLine8, float fMinLine9, float fMaxLine9, float fMinLine10, float fMaxLine10, float fMinLine11, float fMaxLine11, float fMinLine12, float fMaxLine12,
            float fPadInspectionAreaFromTop, float fPadInspectionAreaFromRight, float fPadInspectionAreaFromBottom, float fPadInspectionAreaFromLeft,
            int intReferTopBottom, bool blnCheckTop, bool blnCheckBottom, int intReferLeftRight, bool blnCheckLeft, bool blnCheckRight)
        {
            BlobsFeatures m_stcBlobPad = new BlobsFeatures();
            m_stcBlobPad.intNoID = intNoID;
            m_stcBlobPad.intGroupID = intGroupID;
            m_stcBlobPad.fArea = fArea;
            m_stcBlobPad.intLengthMode = intLengthMode;
            m_stcBlobPad.intContourX = intContourX;
            m_stcBlobPad.intContourY = intContourY;
            m_stcBlobPad.intStartX = intStartX;
            m_stcBlobPad.intStartY = intStartY;
            m_stcBlobPad.intEndX = intEndX;
            m_stcBlobPad.intEndY = intEndY;
            m_stcBlobPad.fStartX = fStartX;
            m_stcBlobPad.fStartY = fStartY;
            m_stcBlobPad.fEndX = fEndX;
            m_stcBlobPad.fEndY = fEndY;
            m_stcBlobPad.intDirection = intDirection;
            m_stcBlobPad.intSide = intSide;
            m_stcBlobPad.intSmearSide = intSmearSide;
            m_stcBlobPad.fCenterX = fCenterX;
            m_stcBlobPad.fCenterY = fCenterY;
            m_stcBlobPad.fLimitCenterX = fLimitCenterX;
            m_stcBlobPad.fLimitCenterY = fLimitCenterY;
            m_stcBlobPad.fWidth = fWidth;
            m_stcBlobPad.fHeight = fHeight;
            m_stcBlobPad.fWidthPercentStart1 = fWidthPercentStart1; // for pad dimension start point
            m_stcBlobPad.fHeightPercentStart1 = fHeightPercentStart1;  // for pad dimension start point
            m_stcBlobPad.fWidthPercentEnd1 = fWidthPercentEnd1; // for pad dimension end point 
            m_stcBlobPad.fHeightPercentEnd1 = fHeightPercentEnd1;  // for pad dimension end point
            m_stcBlobPad.fWidthPercentStart2 = fWidthPercentStart2; // for pad dimension start point
            m_stcBlobPad.fHeightPercentStart2 = fHeightPercentStart2;  // for pad dimension start point
            m_stcBlobPad.fWidthPercentEnd2 = fWidthPercentEnd2; // for pad dimension end point 
            m_stcBlobPad.fHeightPercentEnd2 = fHeightPercentEnd2;  // for pad dimension end point
            m_stcBlobPad.fWidthPercentStart3 = fWidthPercentStart3; // for pad dimension start point
            m_stcBlobPad.fHeightPercentStart3 = fHeightPercentStart3;  // for pad dimension start point
            m_stcBlobPad.fWidthPercentEnd3 = fWidthPercentEnd3; // for pad dimension end point 
            m_stcBlobPad.fHeightPercentEnd3 = fHeightPercentEnd3;  // for pad dimension end point
            m_stcBlobPad.fWidthPercentStart4 = fWidthPercentStart4; // for pad dimension start point
            m_stcBlobPad.fHeightPercentStart4 = fHeightPercentStart4;  // for pad dimension start point
            m_stcBlobPad.fWidthPercentEnd4 = fWidthPercentEnd4; // for pad dimension end point 
            m_stcBlobPad.fHeightPercentEnd4 = fHeightPercentEnd4;  // for pad dimension end point
            m_stcBlobPad.fWidthPercentStart5 = fWidthPercentStart5; // for pad dimension start point
            m_stcBlobPad.fHeightPercentStart5 = fHeightPercentStart5;  // for pad dimension start point
            m_stcBlobPad.fWidthPercentEnd5 = fWidthPercentEnd5; // for pad dimension end point 
            m_stcBlobPad.fHeightPercentEnd5 = fHeightPercentEnd5;  // for pad dimension end point
            m_stcBlobPad.fWidthPercentStart6 = fWidthPercentStart6; // for pad dimension start point
            m_stcBlobPad.fHeightPercentStart6 = fHeightPercentStart6;  // for pad dimension start point
            m_stcBlobPad.fWidthPercentEnd6 = fWidthPercentEnd6; // for pad dimension end point 
            m_stcBlobPad.fHeightPercentEnd6 = fHeightPercentEnd6;  // for pad dimension end point
            m_stcBlobPad.fWidthPercentStart7 = fWidthPercentStart7; // for pad dimension start point
            m_stcBlobPad.fHeightPercentStart7 = fHeightPercentStart7;  // for pad dimension start point
            m_stcBlobPad.fWidthPercentEnd7 = fWidthPercentEnd7; // for pad dimension end point 
            m_stcBlobPad.fHeightPercentEnd7 = fHeightPercentEnd7; // for pad dimension end point 
            m_stcBlobPad.fWidthPercentStart8 = fWidthPercentStart8; // for pad dimension start point
            m_stcBlobPad.fHeightPercentStart8 = fHeightPercentStart8;  // for pad dimension start point
            m_stcBlobPad.fWidthPercentEnd8 = fWidthPercentEnd8; // for pad dimension end point 
            m_stcBlobPad.fHeightPercentEnd8 = fHeightPercentEnd8;  // for pad dimension end point
            m_stcBlobPad.fWidthPercentStart9 = fWidthPercentStart9; // for pad dimension start point
            m_stcBlobPad.fHeightPercentStart9 = fHeightPercentStart9;  // for pad dimension start point
            m_stcBlobPad.fWidthPercentEnd9 = fWidthPercentEnd9; // for pad dimension end point 
            m_stcBlobPad.fHeightPercentEnd9 = fHeightPercentEnd9;  // for pad dimension end point
            m_stcBlobPad.fWidthPercentStart10 = fWidthPercentStart10; // for pad dimension start point
            m_stcBlobPad.fHeightPercentStart10 = fHeightPercentStart10;  // for pad dimension start point
            m_stcBlobPad.fWidthPercentEnd10 = fWidthPercentEnd10; // for pad dimension end point 
            m_stcBlobPad.fHeightPercentEnd10 = fHeightPercentEnd10;  // for pad dimension end point
            m_stcBlobPad.fWidthPercentStart11 = fWidthPercentStart11; // for pad dimension start point
            m_stcBlobPad.fHeightPercentStart11 = fHeightPercentStart11;  // for pad dimension start point
            m_stcBlobPad.fWidthPercentEnd11 = fWidthPercentEnd11; // for pad dimension end point 
            m_stcBlobPad.fHeightPercentEnd11 = fHeightPercentEnd11;  // for pad dimension end point
            m_stcBlobPad.fWidthPercentStart12 = fWidthPercentStart12; // for pad dimension start point
            m_stcBlobPad.fHeightPercentStart12 = fHeightPercentStart12;  // for pad dimension start point
            m_stcBlobPad.fWidthPercentEnd12 = fWidthPercentEnd12; // for pad dimension end point 
            m_stcBlobPad.fHeightPercentEnd12 = fHeightPercentEnd12; // for pad dimension end point 
            m_stcBlobPad.intLineCount = intLineCount;

            m_stcBlobPad.fInwardPercentStart1 = fInwardPercentStart1;
            m_stcBlobPad.fInwardPercentEnd1 = fInwardPercentEnd1;
            m_stcBlobPad.fInwardPercentStart2 = fInwardPercentStart2;
            m_stcBlobPad.fInwardPercentEnd2 = fInwardPercentEnd2;
            m_stcBlobPad.fInwardPercentStart3 = fInwardPercentStart3;
            m_stcBlobPad.fInwardPercentEnd3 = fInwardPercentEnd3;
            m_stcBlobPad.fInwardPercentStart4 = fInwardPercentStart4;
            m_stcBlobPad.fInwardPercentEnd4 = fInwardPercentEnd4;
            m_stcBlobPad.fInwardPercentStart5 = fInwardPercentStart5;
            m_stcBlobPad.fInwardPercentEnd5 = fInwardPercentEnd5;
            m_stcBlobPad.fInwardPercentStart6 = fInwardPercentStart6;
            m_stcBlobPad.fInwardPercentEnd6 = fInwardPercentEnd6;
            m_stcBlobPad.fInwardPercentStart7 = fInwardPercentStart7;
            m_stcBlobPad.fInwardPercentEnd7 = fInwardPercentEnd7;
            m_stcBlobPad.fInwardPercentStart8 = fInwardPercentStart8;
            m_stcBlobPad.fInwardPercentEnd8 = fInwardPercentEnd8;
            m_stcBlobPad.fInwardPercentStart9 = fInwardPercentStart9;
            m_stcBlobPad.fInwardPercentEnd9 = fInwardPercentEnd9;
            m_stcBlobPad.fInwardPercentStart10 = fInwardPercentStart10;
            m_stcBlobPad.fInwardPercentEnd10 = fInwardPercentEnd10;
            m_stcBlobPad.fInwardPercentStart11 = fInwardPercentStart11;
            m_stcBlobPad.fInwardPercentEnd11 = fInwardPercentEnd11;
            m_stcBlobPad.fInwardPercentStart12 = fInwardPercentStart12;
            m_stcBlobPad.fInwardPercentEnd12 = fInwardPercentEnd12;

            m_stcBlobPad.intMeasureMethod1 = intMeasureMethod1;
            m_stcBlobPad.intMeasureMethod2 = intMeasureMethod2;
            m_stcBlobPad.intMeasureMethod3 = intMeasureMethod3;
            m_stcBlobPad.intMeasureMethod4 = intMeasureMethod4;
            m_stcBlobPad.intMeasureMethod5 = intMeasureMethod5;
            m_stcBlobPad.intMeasureMethod6 = intMeasureMethod6;
            m_stcBlobPad.intMeasureMethod7 = intMeasureMethod7;
            m_stcBlobPad.intMeasureMethod8 = intMeasureMethod8;
            m_stcBlobPad.intMeasureMethod9 = intMeasureMethod9;
            m_stcBlobPad.intMeasureMethod10 = intMeasureMethod10;
            m_stcBlobPad.intMeasureMethod11 = intMeasureMethod11;
            m_stcBlobPad.intMeasureMethod12 = intMeasureMethod12;

            m_stcBlobPad.fAngle = fAngle;

            SetMaxExtraLineCount(intLineCount);

            m_stcBlobPad.fFeretCenterX = fFeretCenterX;
            m_stcBlobPad.fFeretCenterY = fFeretCenterY;
            m_stcBlobPad.fFeretWidth = fFeretWidth;
            m_stcBlobPad.fFeretHeight = fFeretHeight;
            m_stcBlobPad.fFeretAngle = fFeretAngle;
            m_stcBlobPad.intFeretLengthMode = intFeretLengthMode;
            m_stcBlobPad.blnFeretActivated = blnFeretActivated;
            m_stcBlobPad.P1X = P1X;
            m_stcBlobPad.P1Y = P1Y;
            m_stcBlobPad.P2X = P2X;
            m_stcBlobPad.P2Y = P2Y;
            m_stcBlobPad.P3X = P3X;
            m_stcBlobPad.P3Y = P3Y;
            m_stcBlobPad.P4X = P4X;
            m_stcBlobPad.P4Y = P4Y;

            m_stcBlobPad.blnSelected = blnSelected;
            m_stcBlobPad.blnEnable = blnEnable;
            m_stcBlobPad.fLeftDistance = fLeftDistance;
            m_stcBlobPad.fRightDistance = fRightDistance;
            m_stcBlobPad.fTopDistance = fTopDistance;
            m_stcBlobPad.fBottomDistance = fBottomDistance;
            m_stcBlobPad.fXDistance = fXDistance;
            m_stcBlobPad.fYDistance = fYDistance;
            m_stcBlobPad.fTemplateROICenterX = fTemplateROICenterX;
            m_stcBlobPad.fTemplateROICenterY = fTemplateROICenterY;
            m_stcBlobPad.fTemplateROITopLeftCornerX = fTemplateROITopLeftCornerX;
            m_stcBlobPad.fTemplateROITopLeftCornerY = fTemplateROITopLeftCornerY;
            m_stcBlobPad.fXDistance_Pattern = fXDistance_Pattern;
            m_stcBlobPad.fYDistance_Pattern = fYDistance_Pattern;
            m_stcBlobPad.fTemplateROICenterX_Pattern = fTemplateROICenterX_Pattern;
            m_stcBlobPad.fTemplateROICenterY_Pattern = fTemplateROICenterY_Pattern;
            m_stcBlobPad.fTemplateROITopLeftCornerX_Pattern = fTemplateROITopLeftCornerX_Pattern;
            m_stcBlobPad.fTemplateROITopLeftCornerY_Pattern = fTemplateROITopLeftCornerY_Pattern;
            m_stcBlobPad.fPitch = fPitch;
            m_stcBlobPad.fGap = fGap;

            m_stcBlobPad.fOffSet = fOffSet;
            m_stcBlobPad.fMinArea = fMinArea;
            m_stcBlobPad.fMaxArea = fMaxArea;
            m_stcBlobPad.fMinWidth = fMinWidth;
            m_stcBlobPad.fMaxWidth = fMaxWidth;
            m_stcBlobPad.fMinLength = fMinLength;
            m_stcBlobPad.fMaxLength = fMaxLength;
            m_stcBlobPad.fMinPitch = fMinPitch;
            m_stcBlobPad.fMaxPitch = fMaxPitch;
            m_stcBlobPad.fMinGap = fMinGap;
            m_stcBlobPad.fMaxGap = fMaxGap;
            m_stcBlobPad.fMaxBroken = fMaxBroken;
            m_stcBlobPad.fMaxBrokenLength = fMaxBrokenLength;
            m_stcBlobPad.fMaxExcess = fMaxExcess;
            m_stcBlobPad.fMaxSmearLength = fMaxSmearLength;

            m_stcBlobPad.fEdgeLimitTop = fMaxEdgeLimitTop;
            m_stcBlobPad.fEdgeLimitRight = fMaxEdgeLimitRight;
            m_stcBlobPad.fEdgeLimitBottom = fMaxEdgeLimitBottom;
            m_stcBlobPad.fEdgeLimitLeft = fMaxEdgeLimitLeft;

            m_stcBlobPad.fMaxStandOffTop = fMaxStandOffTop;
            m_stcBlobPad.fMaxStandOffBottom = fMaxStandOffBottom;
            m_stcBlobPad.fMaxStandOffLeft = fMaxStandOffLeft;
            m_stcBlobPad.fMaxStandOffRight = fMaxStandOffRight;
            
            m_stcBlobPad.fOffsetOffSet = fOffsetOffSet;
            m_stcBlobPad.fWidthOffset = fWidthOffset;
            m_stcBlobPad.fHeightOffset = fHeightOffset;
            m_stcBlobPad.fPitchOffset = fPitchOffset;
            m_stcBlobPad.fGapOffset = fGapOffset;

            m_stcBlobPad.fEdgeDistanceTopOffset = fEdgeDistanceTopOffset;
            m_stcBlobPad.fEdgeDistanceRightOffset = fEdgeDistanceRightOffset;
            m_stcBlobPad.fEdgeDistanceBottomOffset = fEdgeDistanceBottomOffset;
            m_stcBlobPad.fEdgeDistanceLeftOffset = fEdgeDistanceLeftOffset;

            m_stcBlobPad.fEdgeLimitTopOffset = fEdgeLimitTopOffset;
            m_stcBlobPad.fEdgeLimitRightOffset = fEdgeLimitRightOffset;
            m_stcBlobPad.fEdgeLimitBottomOffset = fEdgeLimitBottomOffset;
            m_stcBlobPad.fEdgeLimitLeftOffset = fEdgeLimitLeftOffset;

            m_stcBlobPad.fStandOffTopOffset = fStandOffTopOffset;
            m_stcBlobPad.fStandOffBottomOffset = fStandOffBottomOffset;
            m_stcBlobPad.fStandOffLeftOffset = fStandOffLeftOffset;
            m_stcBlobPad.fStandOffRightOffset = fStandOffRightOffset;

            m_stcBlobPad.fMinLine3 = fMinLine3;
            m_stcBlobPad.fMaxLine3 = fMaxLine3;
            m_stcBlobPad.fMinLine4 = fMinLine4;
            m_stcBlobPad.fMaxLine4 = fMaxLine4;
            m_stcBlobPad.fMinLine5 = fMinLine5;
            m_stcBlobPad.fMaxLine5 = fMaxLine5;
            m_stcBlobPad.fMinLine6 = fMinLine6;
            m_stcBlobPad.fMaxLine6 = fMaxLine6;
            m_stcBlobPad.fMinLine7 = fMinLine7;
            m_stcBlobPad.fMaxLine7 = fMaxLine7;
            m_stcBlobPad.fMinLine8 = fMinLine8;
            m_stcBlobPad.fMaxLine8 = fMaxLine8;
            m_stcBlobPad.fMinLine9 = fMinLine9;
            m_stcBlobPad.fMaxLine9 = fMaxLine9;
            m_stcBlobPad.fMinLine10 = fMinLine10;
            m_stcBlobPad.fMaxLine10 = fMaxLine10;
            m_stcBlobPad.fMinLine11 = fMinLine11;
            m_stcBlobPad.fMaxLine11 = fMaxLine11;
            m_stcBlobPad.fMinLine12 = fMinLine12;
            m_stcBlobPad.fMaxLine12 = fMaxLine12;

            m_stcBlobPad.fPadInspectionAreaFromTop = fPadInspectionAreaFromTop;
            m_stcBlobPad.fPadInspectionAreaFromRight = fPadInspectionAreaFromRight;
            m_stcBlobPad.fPadInspectionAreaFromBottom = fPadInspectionAreaFromBottom;
            m_stcBlobPad.fPadInspectionAreaFromLeft = fPadInspectionAreaFromLeft;

            m_stcBlobPad.intReferTopBottom = intReferTopBottom;
            m_stcBlobPad.blnCheckTop = blnCheckTop;
            m_stcBlobPad.blnCheckBottom = blnCheckBottom;
            m_stcBlobPad.intReferLeftRight = intReferLeftRight;
            m_stcBlobPad.blnCheckLeft = blnCheckLeft;
            m_stcBlobPad.blnCheckRight = blnCheckRight;
  
            m_arrTemplateBlobPads.Add(m_stcBlobPad);
        }

        public void SetTemplateBlobsFeatures_ToleranceOnly(int intBlobID, float fOffSet, float fMinArea, float fMaxArea,
            float fMinWidth, float fMaxWidth, float fMinLength, float fMaxLength,
            float fMinPitch, float fMaxPitch, float fMinGap, float fMaxGap, float fMaxBroken, float fMaxBrokenLength, float fMaxExcess, float fMaxSmearLength,
            float fMaxEdgeLimitTop, float fMaxEdgeLimitRight, float fMaxEdgeLimitBottom, float fMaxEdgeLimitLeft,
            float fMaxStandOffTop, float fMaxStandOffBottom, float fMaxStandOffLeft, float fMaxStandOffRight,
            float fOffsetOffSet, float fWidthOffset, float fHeightOffset, float fPitchOffset, float fGapOffset,
            float fEdgeDistanceTopOffset, float fEdgeDistanceRightOffset, float fEdgeDistanceBottomOffset, float fEdgeDistanceLeftOffset,
            float fEdgeLimitTopOffset, float fEdgeLimitRightOffset, float fEdgeLimitBottomOffset, float fEdgeLimitLeftOffset,
            float fStandOffTopOffset, float fStandOffBottomOffset, float fStandOffLeftOffset, float fStandOffRightOffset,
            float fMinLine3, float fMaxLine3, float fMinLine4, float fMaxLine4, float fMinLine5, float fMaxLine5, float fMinLine6, float fMaxLine6, float fMinLine7, float fMaxLine7,
            float fMinLine8, float fMaxLine8, float fMinLine9, float fMaxLine9, float fMinLine10, float fMaxLine10, float fMinLine11, float fMaxLine11, float fMinLine12, float fMaxLine12,
            float fPadInspectionAreaFromTop, float fPadInspectionAreaFromRight, float fPadInspectionAreaFromBottom, float fPadInspectionAreaFromLeft)
        {
            if (intBlobID < m_arrTemplateBlobPads.Count)
            {
                BlobsFeatures m_stcBlobPad = (BlobsFeatures)m_arrTemplateBlobPads[intBlobID];
                m_stcBlobPad.fOffSet = fOffSet;
                m_stcBlobPad.fMinArea = fMinArea;
                m_stcBlobPad.fMaxArea = fMaxArea;
                m_stcBlobPad.fMinWidth = fMinWidth;
                m_stcBlobPad.fMaxWidth = fMaxWidth;
                m_stcBlobPad.fMinLength = fMinLength;
                m_stcBlobPad.fMaxLength = fMaxLength;
                m_stcBlobPad.fMinPitch = fMinPitch;
                m_stcBlobPad.fMaxPitch = fMaxPitch;
                m_stcBlobPad.fMinGap = fMinGap;
                m_stcBlobPad.fMaxGap = fMaxGap;
                m_stcBlobPad.fMaxBroken = fMaxBroken;
                m_stcBlobPad.fMaxBrokenLength = fMaxBrokenLength;
                m_stcBlobPad.fMaxExcess = fMaxExcess;
                m_stcBlobPad.fMaxSmearLength = fMaxSmearLength;

                m_stcBlobPad.fEdgeLimitTop = fMaxEdgeLimitTop;
                m_stcBlobPad.fEdgeLimitRight = fMaxEdgeLimitRight;
                m_stcBlobPad.fEdgeLimitBottom = fMaxEdgeLimitBottom;
                m_stcBlobPad.fEdgeLimitLeft = fMaxEdgeLimitLeft;

                m_stcBlobPad.fMaxStandOffTop = fMaxStandOffTop;
                m_stcBlobPad.fMaxStandOffBottom = fMaxStandOffBottom;
                m_stcBlobPad.fMaxStandOffLeft = fMaxStandOffLeft;
                m_stcBlobPad.fMaxStandOffRight = fMaxStandOffRight;
                
                m_stcBlobPad.fOffsetOffSet = fOffsetOffSet;
                m_stcBlobPad.fWidthOffset = fWidthOffset;
                m_stcBlobPad.fHeightOffset = fHeightOffset;
                m_stcBlobPad.fPitchOffset = fPitchOffset;
                m_stcBlobPad.fGapOffset = fGapOffset;

                m_stcBlobPad.fEdgeDistanceTopOffset = fEdgeDistanceTopOffset;
                m_stcBlobPad.fEdgeDistanceRightOffset = fEdgeDistanceRightOffset;
                m_stcBlobPad.fEdgeDistanceBottomOffset = fEdgeDistanceBottomOffset;
                m_stcBlobPad.fEdgeDistanceLeftOffset = fEdgeDistanceLeftOffset;

                m_stcBlobPad.fEdgeLimitTopOffset = fEdgeLimitTopOffset;
                m_stcBlobPad.fEdgeLimitRightOffset = fEdgeLimitRightOffset;
                m_stcBlobPad.fEdgeLimitBottomOffset = fEdgeLimitBottomOffset;
                m_stcBlobPad.fEdgeLimitLeftOffset = fEdgeLimitLeftOffset;

                m_stcBlobPad.fStandOffTopOffset = fStandOffTopOffset;
                m_stcBlobPad.fStandOffBottomOffset = fStandOffBottomOffset;
                m_stcBlobPad.fStandOffLeftOffset = fStandOffLeftOffset;
                m_stcBlobPad.fStandOffRightOffset = fStandOffRightOffset;

                m_stcBlobPad.fMinLine3 = fMinLine3;
                m_stcBlobPad.fMaxLine3 = fMaxLine3;
                m_stcBlobPad.fMinLine4 = fMinLine4;
                m_stcBlobPad.fMaxLine4 = fMaxLine4;
                m_stcBlobPad.fMinLine5 = fMinLine5;
                m_stcBlobPad.fMaxLine5 = fMaxLine5;
                m_stcBlobPad.fMinLine6 = fMinLine6;
                m_stcBlobPad.fMaxLine6 = fMaxLine6;
                m_stcBlobPad.fMinLine7 = fMinLine7;
                m_stcBlobPad.fMaxLine7 = fMaxLine7;
                m_stcBlobPad.fMinLine8 = fMinLine8;
                m_stcBlobPad.fMaxLine8 = fMaxLine8;
                m_stcBlobPad.fMinLine9 = fMinLine9;
                m_stcBlobPad.fMaxLine9 = fMaxLine9;
                m_stcBlobPad.fMinLine10 = fMinLine10;
                m_stcBlobPad.fMaxLine10 = fMaxLine10;
                m_stcBlobPad.fMinLine11 = fMinLine11;
                m_stcBlobPad.fMaxLine11 = fMaxLine11;
                m_stcBlobPad.fMinLine12 = fMinLine12;
                m_stcBlobPad.fMaxLine12 = fMaxLine12;

                m_stcBlobPad.fPadInspectionAreaFromTop = fPadInspectionAreaFromTop;
                m_stcBlobPad.fPadInspectionAreaFromRight = fPadInspectionAreaFromRight;
                m_stcBlobPad.fPadInspectionAreaFromBottom = fPadInspectionAreaFromBottom;
                m_stcBlobPad.fPadInspectionAreaFromLeft = fPadInspectionAreaFromLeft;

                m_arrTemplateBlobPads.RemoveAt(intBlobID);
                m_arrTemplateBlobPads.Insert(intBlobID, m_stcBlobPad);
            }
            else
            {
                BlobsFeatures m_stcBlobPad = new BlobsFeatures(); ;
                m_stcBlobPad.fOffSet = fOffSet;
                m_stcBlobPad.fMinArea = fMinArea;
                m_stcBlobPad.fMaxArea = fMaxArea;
                m_stcBlobPad.fMinWidth = fMinWidth;
                m_stcBlobPad.fMaxWidth = fMaxWidth;
                m_stcBlobPad.fMinLength = fMinLength;
                m_stcBlobPad.fMaxLength = fMaxLength;
                m_stcBlobPad.fMinPitch = fMinPitch;
                m_stcBlobPad.fMaxPitch = fMaxPitch;
                m_stcBlobPad.fMinGap = fMinGap;
                m_stcBlobPad.fMaxGap = fMaxGap;
                m_stcBlobPad.fMaxBroken = fMaxBroken;
                m_stcBlobPad.fMaxBrokenLength = fMaxBrokenLength;
                m_stcBlobPad.fMaxExcess = fMaxExcess;
                m_stcBlobPad.fMaxSmearLength = fMaxSmearLength;

                m_stcBlobPad.fEdgeLimitTop = fMaxEdgeLimitTop;
                m_stcBlobPad.fEdgeLimitRight = fMaxEdgeLimitRight;
                m_stcBlobPad.fEdgeLimitBottom = fMaxEdgeLimitBottom;
                m_stcBlobPad.fEdgeLimitLeft = fMaxEdgeLimitLeft;

                m_stcBlobPad.fMaxStandOffTop = fMaxStandOffTop;
                m_stcBlobPad.fMaxStandOffBottom = fMaxStandOffBottom;
                m_stcBlobPad.fMaxStandOffLeft = fMaxStandOffLeft;
                m_stcBlobPad.fMaxStandOffRight = fMaxStandOffRight;
                
                m_stcBlobPad.fOffsetOffSet = fOffsetOffSet;
                m_stcBlobPad.fWidthOffset = fWidthOffset;
                m_stcBlobPad.fHeightOffset = fHeightOffset;
                m_stcBlobPad.fPitchOffset = fPitchOffset;
                m_stcBlobPad.fGapOffset = fGapOffset;

                m_stcBlobPad.fEdgeDistanceTopOffset = fEdgeDistanceTopOffset;
                m_stcBlobPad.fEdgeDistanceRightOffset = fEdgeDistanceRightOffset;
                m_stcBlobPad.fEdgeDistanceBottomOffset = fEdgeDistanceBottomOffset;
                m_stcBlobPad.fEdgeDistanceLeftOffset = fEdgeDistanceLeftOffset;

                m_stcBlobPad.fEdgeLimitTopOffset = fEdgeLimitTopOffset;
                m_stcBlobPad.fEdgeLimitRightOffset = fEdgeLimitRightOffset;
                m_stcBlobPad.fEdgeLimitBottomOffset = fEdgeLimitBottomOffset;
                m_stcBlobPad.fEdgeLimitLeftOffset = fEdgeLimitLeftOffset;

                m_stcBlobPad.fStandOffTopOffset = fStandOffTopOffset;
                m_stcBlobPad.fStandOffBottomOffset = fStandOffBottomOffset;
                m_stcBlobPad.fStandOffLeftOffset = fStandOffLeftOffset;
                m_stcBlobPad.fStandOffRightOffset = fStandOffRightOffset;

                m_stcBlobPad.fMinLine3 = fMinLine3;
                m_stcBlobPad.fMaxLine3 = fMaxLine3;
                m_stcBlobPad.fMinLine4 = fMinLine4;
                m_stcBlobPad.fMaxLine4 = fMaxLine4;
                m_stcBlobPad.fMinLine5 = fMinLine5;
                m_stcBlobPad.fMaxLine5 = fMaxLine5;
                m_stcBlobPad.fMinLine6 = fMinLine6;
                m_stcBlobPad.fMaxLine6 = fMaxLine6;
                m_stcBlobPad.fMinLine7 = fMinLine7;
                m_stcBlobPad.fMaxLine7 = fMaxLine7;
                m_stcBlobPad.fMinLine8 = fMinLine8;
                m_stcBlobPad.fMaxLine8 = fMaxLine8;
                m_stcBlobPad.fMinLine9 = fMinLine9;
                m_stcBlobPad.fMaxLine9 = fMaxLine9;
                m_stcBlobPad.fMinLine10 = fMinLine10;
                m_stcBlobPad.fMaxLine10 = fMaxLine10;
                m_stcBlobPad.fMinLine11 = fMinLine11;
                m_stcBlobPad.fMaxLine11 = fMaxLine11;
                m_stcBlobPad.fMinLine12 = fMinLine12;
                m_stcBlobPad.fMaxLine12 = fMaxLine12;

                m_stcBlobPad.fPadInspectionAreaFromTop = fPadInspectionAreaFromTop;
                m_stcBlobPad.fPadInspectionAreaFromRight = fPadInspectionAreaFromRight;
                m_stcBlobPad.fPadInspectionAreaFromBottom = fPadInspectionAreaFromBottom;
                m_stcBlobPad.fPadInspectionAreaFromLeft = fPadInspectionAreaFromLeft;

                m_arrTemplateBlobPads.Add(m_stcBlobPad);
            }
        }

        public void SetCalibrationData(float fPixelPerMMX, float fPixelPerMMY,
            float fSizeOffSetX, float fSizeOffSetY, int intUnitMode)
        {
            m_fMMPerPixelX = 1 / fPixelPerMMX;
            m_fMMPerPixelY = 1 / fPixelPerMMY;
            m_fAreaMMPerPixel = 1 / (fPixelPerMMX * fPixelPerMMY);

            m_fSizeOffSetX = fSizeOffSetX;
            m_fSizeOffSetY = fSizeOffSetY;

            // MM to Pixel formula
            m_fMMToPixelXValue = fPixelPerMMX;
            m_fMMToPixelYValue = fPixelPerMMY;
            m_fMMtoPixelAreaValue = fPixelPerMMX * fPixelPerMMY;

            // MM to Micron or Mil formula
            switch (intUnitMode)
            {
                case 1: // mm
                    m_fMMToUnitValue = 1;
                    m_fMMToUnitValueArea = 1;
                    m_intDecimal = 4;
                    m_intDecimal2 = 6;
                    break;
                case 2: // mil
                    m_fMMToUnitValue = 1 / 0.0254f;
                    m_fMMToUnitValueArea = 1 / (0.0254f * 0.0254f);
                    m_intDecimal = 4;
                    m_intDecimal2 = 6;
                    break;
                case 3: // micron
                    m_fMMToUnitValue = 1000;
                    m_fMMToUnitValueArea = 1000000;
                    m_intDecimal = 2;
                    m_intDecimal2 = 2;
                    break;
            }


        }

        public void SetCurrentMeasureSizeAsUnitSize()
        {
            m_objRectGauge4L.SetCurrentMeasureSizeAsUnitSize();
        }

        /// <summary>
        /// Turn pad width into height or height into width
        /// </summary>
        /// <param name="intSelectedIndex">blobs feature index</param>
        public void TurnPadWidthHeight(int intSelectedIndex)
        {
            BlobsFeatures m_stcBlobPad = (BlobsFeatures)m_arrTemplateBlobPads[intSelectedIndex];
            if (!m_stcBlobPad.blnFeretActivated)
            {
                if (m_stcBlobPad.intLengthMode == 1)
                    m_stcBlobPad.intLengthMode = 2;
                else
                    m_stcBlobPad.intLengthMode = 1;
            }
            else
            {
                if (m_stcBlobPad.intFeretLengthMode == 1)
                    m_stcBlobPad.intFeretLengthMode = 2;
                else
                    m_stcBlobPad.intFeretLengthMode = 1;
            }

            float fWidthPercentStart1 = m_stcBlobPad.fWidthPercentStart1;
            float fWidthPercentEnd1 = m_stcBlobPad.fWidthPercentEnd1;
            float fHeightPercentStart1 = m_stcBlobPad.fHeightPercentStart1;
            float fHeightPercentEnd1 = m_stcBlobPad.fHeightPercentEnd1;
            float fInwardPercentStart1 = m_stcBlobPad.fInwardPercentStart1;
            float fInwardPercentEnd1 = m_stcBlobPad.fInwardPercentEnd1;

            m_stcBlobPad.fWidthPercentStart1 = m_stcBlobPad.fWidthPercentStart2;
            m_stcBlobPad.fWidthPercentEnd1 = m_stcBlobPad.fWidthPercentEnd2;
            m_stcBlobPad.fHeightPercentStart1 = m_stcBlobPad.fHeightPercentStart2;
            m_stcBlobPad.fHeightPercentEnd1 = m_stcBlobPad.fHeightPercentEnd2;
            m_stcBlobPad.fInwardPercentStart1 = m_stcBlobPad.fInwardPercentStart2;
            m_stcBlobPad.fInwardPercentEnd1 = m_stcBlobPad.fInwardPercentEnd2;

            m_stcBlobPad.fWidthPercentStart2 = fWidthPercentStart1;
            m_stcBlobPad.fWidthPercentEnd2 = fWidthPercentEnd1;
            m_stcBlobPad.fHeightPercentStart2 = fHeightPercentStart1;
            m_stcBlobPad.fHeightPercentEnd2 = fHeightPercentEnd1;
            m_stcBlobPad.fInwardPercentStart2 = fInwardPercentStart1;
            m_stcBlobPad.fInwardPercentEnd2 = fInwardPercentEnd1;

            m_arrTemplateBlobPads.RemoveAt(intSelectedIndex);
            m_arrTemplateBlobPads.Insert(intSelectedIndex, m_stcBlobPad);
        }

        public void EnableDisablePad(int intSelectedIndex, bool blnEnable)
        {
            BlobsFeatures m_stcBlobPad = (BlobsFeatures)m_arrTemplateBlobPads[intSelectedIndex];

            m_stcBlobPad.blnEnable = blnEnable;

            m_arrTemplateBlobPads.RemoveAt(intSelectedIndex);
            m_arrTemplateBlobPads.Insert(intSelectedIndex, m_stcBlobPad);
        }

        public bool IsPadEnable(int intSelectedIndex)
        {
            return ((BlobsFeatures)m_arrTemplateBlobPads[intSelectedIndex]).blnEnable;
        }

        public bool IsPadAtPackageEdge(int intFromIndex, int intToIndex)
        {
            /*
             * 0x01 - pad at unit left only
             * 0x02 - pad at unit right only
             * 0x04 - pad at unit top only
             * 0x08 - pad at unit bottom only
             * 0x05 - pad at unit top left
             * 0x06 - pad at unit top right
             * 0x0A - pad at unit bottom right
             * 0x09 - pad at unit bottom left
             */

            if ((((BlobsFeatures)m_arrTemplateBlobPads[intFromIndex]).intDirection == 0x01 ||
                ((BlobsFeatures)m_arrTemplateBlobPads[intFromIndex]).intDirection == 0x02 ||
                ((BlobsFeatures)m_arrTemplateBlobPads[intFromIndex]).intDirection == 0x04 ||
                ((BlobsFeatures)m_arrTemplateBlobPads[intFromIndex]).intDirection == 0x08 ||
                ((BlobsFeatures)m_arrTemplateBlobPads[intFromIndex]).intDirection == 0x05 ||
                ((BlobsFeatures)m_arrTemplateBlobPads[intFromIndex]).intDirection == 0x06 ||
                ((BlobsFeatures)m_arrTemplateBlobPads[intFromIndex]).intDirection == 0x0A ||
                ((BlobsFeatures)m_arrTemplateBlobPads[intFromIndex]).intDirection == 0x09))
                return true;

            if ((((BlobsFeatures)m_arrTemplateBlobPads[intFromIndex]).intDirection == 0x0B &&
              ((BlobsFeatures)m_arrTemplateBlobPads[intToIndex]).intDirection == 0x07 || ((((BlobsFeatures)m_arrTemplateBlobPads[intFromIndex]).intDirection == 0x07 &&
                ((BlobsFeatures)m_arrTemplateBlobPads[intToIndex]).intDirection == 0x0B))))
                return true;

            if ((((BlobsFeatures)m_arrTemplateBlobPads[intFromIndex]).intDirection == 0x0E &&
           ((BlobsFeatures)m_arrTemplateBlobPads[intToIndex]).intDirection == 0x0D || ((((BlobsFeatures)m_arrTemplateBlobPads[intFromIndex]).intDirection == 0x0D &&
             ((BlobsFeatures)m_arrTemplateBlobPads[intToIndex]).intDirection == 0x0E))))
                return true;

            return false;
        }

        /// <summary>
        /// Undo selected object or deselect m_arrTemplateBlobPads object
        /// </summary>
        public void UndoSelectedObject()
        {
            UndoSelectedObject(m_arrTemplateBlobPads);
        }

        /// <summary>
        /// Undo selected object or deselect object
        /// </summary>
        /// <param name="arrBlobsFeatures">blobs features</param>
        public void UndoSelectedObject(ArrayList arrBlobsFeatures)
        {
            for (int i = 0; i < arrBlobsFeatures.Count; i++)
            {
                BlobsFeatures m_stcBlobPad = (BlobsFeatures)arrBlobsFeatures[i];
                m_stcBlobPad.blnSelected = false;
                arrBlobsFeatures.RemoveAt(i);
                arrBlobsFeatures.Insert(i, m_stcBlobPad);
            }
        }
        public void UpdatePadInspectionAreaValueToPixel(int intSelectedIndex,
      float fPadInspectionAreaFromTop, float fPadInspectionAreaFromRight, float fPadInspectionAreaFromBottom, float fPadInspectionAreaFromLeft)
        {
            if (intSelectedIndex >= m_arrTemplateBlobPads.Count)
                return;

            BlobsFeatures m_stcBlobPad = (BlobsFeatures)m_arrTemplateBlobPads[intSelectedIndex];

            m_stcBlobPad.fPadInspectionAreaFromTop = fPadInspectionAreaFromTop / m_fMMToUnitValue;

            m_stcBlobPad.fPadInspectionAreaFromRight = fPadInspectionAreaFromRight / m_fMMToUnitValue;

            m_stcBlobPad.fPadInspectionAreaFromBottom = fPadInspectionAreaFromBottom / m_fMMToUnitValue;

            m_stcBlobPad.fPadInspectionAreaFromLeft = fPadInspectionAreaFromLeft / m_fMMToUnitValue;

            m_arrTemplateBlobPads.RemoveAt(intSelectedIndex);
            m_arrTemplateBlobPads.Insert(intSelectedIndex, m_stcBlobPad);
        }
        public void UpdatePadOffsetSettingValueToPixel(int intSelectedIndex,
            float fOffsetOffSet, float fWidthOffset, float fHeightOffset, float fPitchOffset, float fGapOffset,
            float fEdgeDistanceTopOffset, float fEdgeDistanceRightOffset, float fEdgeDistanceBottomOffset, float fEdgeDistanceLeftOffset,
            float fEdgeLimitTopOffset, float fEdgeLimitRightOffset, float fEdgeLimitBottomOffset, float fEdgeLimitLeftOffset,
            float fStandOffTopOffset, float fStandOffBottomOffset, float fStandOffLeftOffset, float fStandOffRightOffset)
        {
            if (intSelectedIndex >= m_arrTemplateBlobPads.Count)
                return;

            BlobsFeatures m_stcBlobPad = (BlobsFeatures)m_arrTemplateBlobPads[intSelectedIndex];
            
            m_stcBlobPad.fOffsetOffSet = fOffsetOffSet / m_fMMToUnitValue;

            m_stcBlobPad.fWidthOffset = fWidthOffset / m_fMMToUnitValue;

            m_stcBlobPad.fHeightOffset = fHeightOffset / m_fMMToUnitValue;

            m_stcBlobPad.fPitchOffset = fPitchOffset / m_fMMToUnitValue;

            m_stcBlobPad.fGapOffset = fGapOffset / m_fMMToUnitValue;

            m_stcBlobPad.fEdgeDistanceTopOffset = fEdgeDistanceTopOffset / m_fMMToUnitValue;
            m_stcBlobPad.fEdgeDistanceRightOffset = fEdgeDistanceRightOffset / m_fMMToUnitValue;
            m_stcBlobPad.fEdgeDistanceBottomOffset = fEdgeDistanceBottomOffset / m_fMMToUnitValue;
            m_stcBlobPad.fEdgeDistanceLeftOffset = fEdgeDistanceLeftOffset / m_fMMToUnitValue;

            m_stcBlobPad.fEdgeLimitTopOffset = fEdgeLimitTopOffset / m_fMMToUnitValue;
            m_stcBlobPad.fEdgeLimitRightOffset = fEdgeLimitRightOffset / m_fMMToUnitValue;
            m_stcBlobPad.fEdgeLimitBottomOffset = fEdgeLimitBottomOffset / m_fMMToUnitValue;
            m_stcBlobPad.fEdgeLimitLeftOffset = fEdgeLimitLeftOffset / m_fMMToUnitValue;

            m_stcBlobPad.fStandOffTopOffset = fStandOffTopOffset / m_fMMToUnitValue;
            m_stcBlobPad.fStandOffBottomOffset = fStandOffBottomOffset / m_fMMToUnitValue;
            m_stcBlobPad.fStandOffLeftOffset = fStandOffLeftOffset / m_fMMToUnitValue;
            m_stcBlobPad.fStandOffRightOffset = fStandOffRightOffset / m_fMMToUnitValue;

            m_arrTemplateBlobPads.RemoveAt(intSelectedIndex);
            m_arrTemplateBlobPads.Insert(intSelectedIndex, m_stcBlobPad);
        }
        /// <summary>
        /// Update data(mm) in blobs features
        /// </summary>
        /// <param name="intSelectedIndex">blobs feature index</param>
        /// <param name="fOffSet">offset</param>
        /// <param name="fMinArea">min area</param>
        /// <param name="fMaxArea">max area</param>
        /// <param name="fMinWidth">min width</param>
        /// <param name="fMaxWidth">max width</param>
        /// <param name="fMinLength">min height</param>
        /// <param name="fMaxLength">max height</param>
        /// <param name="fMinPitch">min pitch</param>
        /// <param name="fMaxPitch">max pitch</param>
        /// <param name="fMinGap">min gap</param>
        /// <param name="fMaxGap">max gap</param>
        /// <param name="fMaxBroken">max hole</param>
        public void UpdateBlobFeatureToPixel(int intSelectedIndex, float fOffSet,
            float fMinArea, float fMaxArea, float fMinWidth, float fMaxWidth,
            float fMinLength, float fMaxLength, float fMinPitch, float fMaxPitch,
            float fMinGap, float fMaxGap, float fMaxBroken, float fMaxBrokenLength, float fMaxExcessArea, float fMaxSmearLength,
               float fEdgeLimitTop, float fEdgeLimitRight, float fEdgeLimitBottom, float fEdgeLimitLeft,
               float fMaxStandOffTop, float fMaxStandOffBottom, float fMaxStandOffLeft, float fMaxStandOffRight,
            float fMinLine3, float fMaxLine3, float fMinLine4, float fMaxLine4, float fMinLine5, float fMaxLine5, float fMinLine6, float fMaxLine6, float fMinLine7, float fMaxLine7,
            float fMinLine8, float fMaxLine8, float fMinLine9, float fMaxLine9, float fMinLine10, float fMaxLine10, float fMinLine11, float fMaxLine11, float fMinLine12, float fMaxLine12)
            //,float fOffsetOffSet, float fWidthOffset, float fHeightOffset, float fPitchOffset, float fGapOffset)
        {
            BlobsFeatures m_stcBlobPad = (BlobsFeatures)m_arrTemplateBlobPads[intSelectedIndex];

            m_stcBlobPad.fOffSet = fOffSet / m_fMMToUnitValue;
            m_stcBlobPad.fMinArea = fMinArea / m_fMMToUnitValueArea;
            m_stcBlobPad.fMaxArea = fMaxArea / m_fMMToUnitValueArea;

            m_stcBlobPad.fMinWidth = fMinWidth / m_fMMToUnitValue;
            m_stcBlobPad.fMaxWidth = fMaxWidth / m_fMMToUnitValue;
            m_stcBlobPad.fMinLength = fMinLength / m_fMMToUnitValue;
            m_stcBlobPad.fMaxLength = fMaxLength / m_fMMToUnitValue;

            m_stcBlobPad.fMinPitch = fMinPitch / m_fMMToUnitValue;
            m_stcBlobPad.fMaxPitch = fMaxPitch / m_fMMToUnitValue;
            m_stcBlobPad.fMinGap = fMinGap / m_fMMToUnitValue;
            m_stcBlobPad.fMaxGap = fMaxGap / m_fMMToUnitValue;
            m_stcBlobPad.fMaxBroken = fMaxBroken / m_fMMToUnitValueArea;
            m_stcBlobPad.fMaxBrokenLength = fMaxBrokenLength / m_fMMToUnitValue;
            m_stcBlobPad.fMaxExcess = fMaxExcessArea / m_fMMToUnitValueArea;
            m_stcBlobPad.fMaxSmearLength = fMaxSmearLength / m_fMMToUnitValue;

            m_stcBlobPad.fEdgeLimitTop = fEdgeLimitTop / m_fMMToUnitValue;
            m_stcBlobPad.fEdgeLimitRight = fEdgeLimitRight / m_fMMToUnitValue;
            m_stcBlobPad.fEdgeLimitBottom = fEdgeLimitBottom / m_fMMToUnitValue;
            m_stcBlobPad.fEdgeLimitLeft = fEdgeLimitLeft / m_fMMToUnitValue;

            m_stcBlobPad.fMaxStandOffTop = fMaxStandOffTop / m_fMMToUnitValue;
            m_stcBlobPad.fMaxStandOffBottom = fMaxStandOffBottom / m_fMMToUnitValue;
            m_stcBlobPad.fMaxStandOffLeft = fMaxStandOffLeft / m_fMMToUnitValue;
            m_stcBlobPad.fMaxStandOffRight = fMaxStandOffRight / m_fMMToUnitValue;

            m_stcBlobPad.fMinLine3 = fMinLine3 / m_fMMToUnitValue;
            m_stcBlobPad.fMaxLine3 = fMaxLine3 / m_fMMToUnitValue;
            m_stcBlobPad.fMinLine4 = fMinLine4 / m_fMMToUnitValue;
            m_stcBlobPad.fMaxLine4 = fMaxLine4 / m_fMMToUnitValue;
            m_stcBlobPad.fMinLine5 = fMinLine5 / m_fMMToUnitValue;
            m_stcBlobPad.fMaxLine5 = fMaxLine5 / m_fMMToUnitValue;
            m_stcBlobPad.fMinLine6 = fMinLine6 / m_fMMToUnitValue;
            m_stcBlobPad.fMaxLine6 = fMaxLine6 / m_fMMToUnitValue;
            m_stcBlobPad.fMinLine7 = fMinLine7 / m_fMMToUnitValue;
            m_stcBlobPad.fMaxLine7 = fMaxLine7 / m_fMMToUnitValue;
            m_stcBlobPad.fMinLine8 = fMinLine8 / m_fMMToUnitValue;
            m_stcBlobPad.fMaxLine8 = fMaxLine8 / m_fMMToUnitValue;
            m_stcBlobPad.fMinLine9 = fMinLine9 / m_fMMToUnitValue;
            m_stcBlobPad.fMaxLine9 = fMaxLine9 / m_fMMToUnitValue;
            m_stcBlobPad.fMinLine10 = fMinLine10 / m_fMMToUnitValue;
            m_stcBlobPad.fMaxLine10 = fMaxLine10 / m_fMMToUnitValue;
            m_stcBlobPad.fMinLine11 = fMinLine11 / m_fMMToUnitValue;
            m_stcBlobPad.fMaxLine11 = fMaxLine11 / m_fMMToUnitValue;
            m_stcBlobPad.fMinLine12 = fMinLine12 / m_fMMToUnitValue;
            m_stcBlobPad.fMaxLine12 = fMaxLine12 / m_fMMToUnitValue;

            //m_stcBlobPad.fOffsetOffSet = fOffsetOffSet / m_fMMToUnitValue;
            //m_stcBlobPad.fWidthOffset = fWidthOffset / m_fMMToUnitValue;
            //m_stcBlobPad.fHeightOffset = fHeightOffset / m_fMMToUnitValue;
            //m_stcBlobPad.fPitchOffset = fPitchOffset / m_fMMToUnitValue;
            //m_stcBlobPad.fGapOffset = fGapOffset / m_fMMToUnitValue;
            // Recalculate template value so that score set value can maintain as default value
            //m_stcBlobPad.fArea = (int)Math.Round((m_stcBlobPad.fMinArea + m_stcBlobPad.fMaxArea) / 2) * m_fMMtoPixelAreaValue;
            //m_stcBlobPad.fWidth = (m_stcBlobPad.fMinWidth + m_stcBlobPad.fMaxWidth) / 2 * m_fMMToPixelXValue;
            //m_stcBlobPad.fHeight = (m_stcBlobPad.fMinLength + m_stcBlobPad.fMaxLength) / 2 * m_fMMToPixelYValue;
            //if (m_stcBlobPad.fPitch != -1)
            //    m_stcBlobPad.fPitch = (m_stcBlobPad.fMinPitch + m_stcBlobPad.fMaxPitch) / 2 * m_fMMToPixelYValue;
            //if (m_stcBlobPad.fGap != -1)
            //    m_stcBlobPad.fGap = (m_stcBlobPad.fMinGap + m_stcBlobPad.fMaxGap) / 2 * m_fMMToPixelYValue;

            m_arrTemplateBlobPads.RemoveAt(intSelectedIndex);
            m_arrTemplateBlobPads.Insert(intSelectedIndex, m_stcBlobPad);
        }
        public void UpdatePadInspectionAreaValueToPixel(int intSelectedIndex, int intFeature, float fValue)
        {
            if (intSelectedIndex >= m_arrTemplateBlobPads.Count)
                return;

            BlobsFeatures m_stcBlobPad = (BlobsFeatures)m_arrTemplateBlobPads[intSelectedIndex];

            switch (intFeature)
            {
                case 0:
                    m_stcBlobPad.fPadInspectionAreaFromTop = fValue / m_fMMToUnitValue;
                    break;
                case 1:
                    m_stcBlobPad.fPadInspectionAreaFromRight = fValue / m_fMMToUnitValue;
                    break;
                case 2:
                    m_stcBlobPad.fPadInspectionAreaFromBottom = fValue / m_fMMToUnitValue;
                    break;
                case 3:
                    m_stcBlobPad.fPadInspectionAreaFromLeft = fValue / m_fMMToUnitValue;
                    break;
            }

            m_arrTemplateBlobPads.RemoveAt(intSelectedIndex);
            m_arrTemplateBlobPads.Insert(intSelectedIndex, m_stcBlobPad);
        }
        public void UpdatePadOffsetSettingValueToPixel(int intSelectedIndex, int intFeature, float fValue)
        {
            if (intSelectedIndex >= m_arrTemplateBlobPads.Count)
                return;

            BlobsFeatures m_stcBlobPad = (BlobsFeatures)m_arrTemplateBlobPads[intSelectedIndex];

            switch (intFeature)
            {
                case 0:
                    m_stcBlobPad.fOffsetOffSet = fValue / m_fMMToUnitValue;
                    break;
                case 1:
                    m_stcBlobPad.fWidthOffset = fValue / m_fMMToUnitValue;
                    break;
                case 2:
                    m_stcBlobPad.fHeightOffset = fValue / m_fMMToUnitValue;
                    break;
                case 3:
                    m_stcBlobPad.fPitchOffset = fValue / m_fMMToUnitValue;
                    break;
                case 4:
                    m_stcBlobPad.fGapOffset = fValue / m_fMMToUnitValue;
                    break;
                case 5:
                    m_stcBlobPad.fEdgeDistanceTopOffset = fValue / m_fMMToUnitValue;
                    break;
                case 6:
                    m_stcBlobPad.fEdgeDistanceRightOffset = fValue / m_fMMToUnitValue;
                    break;
                case 7:
                    m_stcBlobPad.fEdgeDistanceBottomOffset = fValue / m_fMMToUnitValue;
                    break;
                case 8:
                    m_stcBlobPad.fEdgeDistanceLeftOffset = fValue / m_fMMToUnitValue;
                    break;
                case 9:
                    m_stcBlobPad.fEdgeLimitTopOffset = fValue / m_fMMToUnitValue;
                    break;
                case 10:
                    m_stcBlobPad.fEdgeLimitRightOffset = fValue / m_fMMToUnitValue;
                    break;
                case 11:
                    m_stcBlobPad.fEdgeLimitBottomOffset = fValue / m_fMMToUnitValue;
                    break;
                case 12:
                    m_stcBlobPad.fEdgeLimitLeftOffset = fValue / m_fMMToUnitValue;
                    break;
                case 13:
                    m_stcBlobPad.fStandOffTopOffset = fValue / m_fMMToUnitValue;
                    break;
                case 14:
                    m_stcBlobPad.fStandOffBottomOffset = fValue / m_fMMToUnitValue;
                    break;
                case 15:
                    m_stcBlobPad.fStandOffLeftOffset = fValue / m_fMMToUnitValue;
                    break;
                case 16:
                    m_stcBlobPad.fStandOffRightOffset = fValue / m_fMMToUnitValue;
                    break;
            }

            m_arrTemplateBlobPads.RemoveAt(intSelectedIndex);
            m_arrTemplateBlobPads.Insert(intSelectedIndex, m_stcBlobPad);
        }
        /// <summary>
        /// Update data(mm) in blobs features
        /// </summary>
        /// <param name="intSelectedIndex">blobs feature index</param>
        /// <param name="fOffSet">offset</param>
        /// <param name="fMinArea">min area</param>
        /// <param name="fMaxArea">max area</param>
        /// <param name="fMinWidth">min width</param>
        /// <param name="fMaxWidth">max width</param>
        /// <param name="fMinLength">min height</param>
        /// <param name="fMaxLength">max height</param>
        /// <param name="fMinPitch">min pitch</param>
        /// <param name="fMaxPitch">max pitch</param>
        /// <param name="fMinGap">min gap</param>
        /// <param name="fMaxGap">max gap</param>
        /// <param name="fMaxBroken">max hole</param>
        public void UpdateSingleBlobFeatureToPixel(int intSelectedIndex, int intFeature, float fValue)
        {
            if (intSelectedIndex >= m_arrTemplateBlobPads.Count)
                return;

            BlobsFeatures m_stcBlobPad = (BlobsFeatures)m_arrTemplateBlobPads[intSelectedIndex];

            switch (intFeature)
            {
                case 0:
                    m_stcBlobPad.fOffSet = fValue / m_fMMToUnitValue;
                    break;
                case 3:
                    m_stcBlobPad.fMinArea = fValue / m_fMMToUnitValueArea;
                    break;
                case 5:
                    m_stcBlobPad.fMaxArea = fValue / m_fMMToUnitValueArea;
                    break;
                case 7:
                    // 2019 10 30 - CCENG: m_arrTemplateBlobPads fMinWidth, fMaxWidth, fMinHeigt, fMaxLength are not affacted by lengthmode.
                    //if (((BlobsFeatures)m_arrTemplateBlobPads[intSelectedIndex]).intLengthMode == 1)
                    m_stcBlobPad.fMinWidth = fValue / m_fMMToUnitValue;
                    //else
                    //    m_stcBlobPad.fMinLength = fValue / m_fMMToUnitValue;
                    break;
                case 9:
                    // 2019 10 30 - CCENG: m_arrTemplateBlobPads fMinWidth, fMaxWidth, fMinHeigt, fMaxLength are not affacted by lengthmode.
                    //if (((BlobsFeatures)m_arrTemplateBlobPads[intSelectedIndex]).intLengthMode == 1)
                    m_stcBlobPad.fMaxWidth = fValue / m_fMMToUnitValue;
                    //else
                    //    m_stcBlobPad.fMaxLength = fValue / m_fMMToUnitValue;
                    break;
                case 11:
                    // 2019 10 30 - CCENG: m_arrTemplateBlobPads fMinWidth, fMaxWidth, fMinHeigt, fMaxLength are not affacted by lengthmode.
                    //if (((BlobsFeatures)m_arrTemplateBlobPads[intSelectedIndex]).intLengthMode == 1)
                    m_stcBlobPad.fMinLength = fValue / m_fMMToUnitValue;
                    //else
                    //    m_stcBlobPad.fMinWidth = fValue / m_fMMToUnitValue;
                    break;
                case 13:
                    // 2019 10 30 - CCENG: m_arrTemplateBlobPads fMinWidth, fMaxWidth, fMinHeigt, fMaxLength are not affacted by lengthmode.
                    //if (((BlobsFeatures)m_arrTemplateBlobPads[intSelectedIndex]).intLengthMode == 1)
                    m_stcBlobPad.fMaxLength = fValue / m_fMMToUnitValue;
                    //else
                    //    m_stcBlobPad.fMaxWidth = fValue / m_fMMToUnitValue;
                    break;
                case 15:
                    m_stcBlobPad.fMinPitch = fValue / m_fMMToUnitValue;
                    break;
                case 17:
                    m_stcBlobPad.fMaxPitch = fValue / m_fMMToUnitValue;
                    break;
                case 19:
                    m_stcBlobPad.fMinGap = fValue / m_fMMToUnitValue;
                    break;
                case 21:
                    m_stcBlobPad.fMaxGap = fValue / m_fMMToUnitValue;
                    break;
                case 23:
                    m_stcBlobPad.fMaxBroken = fValue / m_fMMToUnitValueArea;
                    break;
                case 26:
                    m_stcBlobPad.fMaxBrokenLength = fValue / m_fMMToUnitValue;
                    break;
                case 29:
                    m_stcBlobPad.fMaxExcess = fValue / m_fMMToUnitValueArea;
                    break;
                case 32:
                    m_stcBlobPad.fMaxSmearLength = fValue / m_fMMToUnitValue;
                    break;
                case 35:
                    m_stcBlobPad.fEdgeLimitTop = fValue / m_fMMToUnitValue;
                    break;
                case 37:
                    m_stcBlobPad.fEdgeLimitRight = fValue / m_fMMToUnitValue;
                    break;
                case 39:
                    m_stcBlobPad.fEdgeLimitBottom = fValue / m_fMMToUnitValue;
                    break;
                case 41:
                    m_stcBlobPad.fEdgeLimitLeft = fValue / m_fMMToUnitValue;
                    break;
                case 44:
                    m_stcBlobPad.fMaxStandOffTop = fValue / m_fMMToUnitValue;
                    break;
                case 46:
                    m_stcBlobPad.fMaxStandOffBottom = fValue / m_fMMToUnitValue;
                    break;
                case 48:
                    m_stcBlobPad.fMaxStandOffLeft = fValue / m_fMMToUnitValue;
                    break;
                case 50:
                    m_stcBlobPad.fMaxStandOffRight = fValue / m_fMMToUnitValue;
                    break;
                case 53:
                    m_stcBlobPad.fMinLine3 = fValue / m_fMMToUnitValue;
                    break;
                case 55:
                    m_stcBlobPad.fMaxLine3 = fValue / m_fMMToUnitValue;
                    break;
                case 57:
                    m_stcBlobPad.fMinLine4 = fValue / m_fMMToUnitValue;
                    break;
                case 59:
                    m_stcBlobPad.fMaxLine4 = fValue / m_fMMToUnitValue;
                    break;
                case 61:
                    m_stcBlobPad.fMinLine5 = fValue / m_fMMToUnitValue;
                    break;
                case 63:
                    m_stcBlobPad.fMaxLine5 = fValue / m_fMMToUnitValue;
                    break;
                case 65:
                    m_stcBlobPad.fMinLine6 = fValue / m_fMMToUnitValue;
                    break;
                case 67:
                    m_stcBlobPad.fMaxLine6 = fValue / m_fMMToUnitValue;
                    break;
                case 69:
                    m_stcBlobPad.fMinLine7 = fValue / m_fMMToUnitValue;
                    break;
                case 71:
                    m_stcBlobPad.fMaxLine7 = fValue / m_fMMToUnitValue;
                    break;
                case 73:
                    m_stcBlobPad.fMinLine8 = fValue / m_fMMToUnitValue;
                    break;
                case 75:
                    m_stcBlobPad.fMaxLine8 = fValue / m_fMMToUnitValue;
                    break;
                case 77:
                    m_stcBlobPad.fMinLine9 = fValue / m_fMMToUnitValue;
                    break;
                case 79:
                    m_stcBlobPad.fMaxLine9 = fValue / m_fMMToUnitValue;
                    break;
                case 81:
                    m_stcBlobPad.fMinLine10 = fValue / m_fMMToUnitValue;
                    break;
                case 83:
                    m_stcBlobPad.fMaxLine10 = fValue / m_fMMToUnitValue;
                    break;
                case 85:
                    m_stcBlobPad.fMinLine11 = fValue / m_fMMToUnitValue;
                    break;
                case 87:
                    m_stcBlobPad.fMaxLine11 = fValue / m_fMMToUnitValue;
                    break;
                case 89:
                    m_stcBlobPad.fMinLine12 = fValue / m_fMMToUnitValue;
                    break;
                case 91:
                    m_stcBlobPad.fMaxLine12 = fValue / m_fMMToUnitValue;
                    break;
                    //case 73:
                    //    m_stcBlobPad.fWidthOffset = fValue / m_fMMToUnitValue;
                    //    break;
                    //case 75:
                    //    m_stcBlobPad.fHeightOffset = fValue / m_fMMToUnitValue;
                    //    break;
                    //case 77:
                    //    m_stcBlobPad.fPitchOffset = fValue / m_fMMToUnitValue;
                    //    break;
                    //case 79:
                    //    m_stcBlobPad.fGapOffset = fValue / m_fMMToUnitValue;
                    //    break;
            }

            m_arrTemplateBlobPads.RemoveAt(intSelectedIndex);
            m_arrTemplateBlobPads.Insert(intSelectedIndex, m_stcBlobPad);
        }

        public void UpdateBlobFeatureCheckStandOff(int intSelectedIndex, int intFeature, bool blnValue)
        {
            if (intSelectedIndex >= m_arrTemplateBlobPads.Count)
                return;

            BlobsFeatures m_stcBlobPad = (BlobsFeatures)m_arrTemplateBlobPads[intSelectedIndex];

            switch (intFeature)
            {
                case 1:
                    m_stcBlobPad.blnCheckTop = blnValue;
                    break;
                case 2:
                    m_stcBlobPad.blnCheckBottom = blnValue;
                    break;
                case 5:
                    m_stcBlobPad.blnCheckLeft = blnValue;
                    break;
                case 6:
                    m_stcBlobPad.blnCheckRight = blnValue;
                    break;
              
            }

            m_arrTemplateBlobPads.RemoveAt(intSelectedIndex);
            m_arrTemplateBlobPads.Insert(intSelectedIndex, m_stcBlobPad);
        }
        public void UpdateBlobFeatureStandOffReferDirection(int intSelectedIndex, int intFeature, int intValue)
        {
            if (intSelectedIndex >= m_arrTemplateBlobPads.Count)
                return;

            BlobsFeatures m_stcBlobPad = (BlobsFeatures)m_arrTemplateBlobPads[intSelectedIndex];

            switch (intFeature)
            {
                case 0:
                    m_stcBlobPad.intReferTopBottom = intValue;
                    break;
                case 4:
                    m_stcBlobPad.intReferLeftRight = intValue;
                    break;
            }

            m_arrTemplateBlobPads.RemoveAt(intSelectedIndex);
            m_arrTemplateBlobPads.Insert(intSelectedIndex, m_stcBlobPad);
        }
        /// <summary>
        /// Update data(mm) in blobs features
        /// </summary>
        /// <param name="intSelectedIndex">blobs feature index</param>
        /// <param name="fOffSet">offset</param>
        /// <param name="fMinArea">min area</param>
        /// <param name="fMaxArea">max area</param>
        /// <param name="fMinWidth">min width</param>
        /// <param name="fMaxWidth">max width</param>
        /// <param name="fMinLength">min height</param>
        /// <param name="fMaxLength">max height</param>
        /// <param name="fMinPitch">min pitch</param>
        /// <param name="fMaxPitch">max pitch</param>
        /// <param name="fMinGap">min gap</param>
        /// <param name="fMaxGap">max gap</param>
        /// <param name="fMaxBroken">max hole</param>
        public void UpdateBlobFeatureToPixel(int intSelectedIndex, float fOffSet,
            float fMinArea, float fMaxArea, float fMinWidth, float fMaxWidth,
            float fMinLength, float fMaxLength, float fMinPitch, float fMaxPitch,
            float fMinGap, float fMaxGap, float fMaxBroken, float fMaxBrokenLength, float fMaxSmearLength,
            float fEdgeLimitTop, float fEdgeLimitRight, float fEdgeLimitBottom, float fEdgeLimitLeft,
            float fMaxStandOffTop, float fMaxStandOffBottom, float fMaxStandOffLeft, float fMaxStandOffRight,
            float fOffsetOffSet, float fWidthOffset, float fHeightOffset, float fPitchOffset, float fGapOffset,
            float fEdgeDistanceTopOffset, float fEdgeDistanceRightOffset, float fEdgeDistanceBottomOffset, float fEdgeDistanceLeftOffset,
            float fEdgeLimitTopOffset, float fEdgeLimitRightOffset, float fEdgeLimitBottomOffset, float fEdgeLimitLeftOffset,
            float fStandOffTopOffset, float fStandOffBottomOffset, float fStandOffLeftOffset, float fStandOffRightOffset)
        {
            BlobsFeatures m_stcBlobPad = (BlobsFeatures)m_arrTemplateBlobPads[intSelectedIndex];

            m_stcBlobPad.fOffSet = fOffSet / m_fMMToUnitValue;
            m_stcBlobPad.fMinArea = fMinArea / m_fMMToUnitValueArea;
            m_stcBlobPad.fMaxArea = fMaxArea / m_fMMToUnitValueArea;

            m_stcBlobPad.fMinWidth = fMinWidth / m_fMMToUnitValue;
            m_stcBlobPad.fMaxWidth = fMaxWidth / m_fMMToUnitValue;
            m_stcBlobPad.fMinLength = fMinLength / m_fMMToUnitValue;
            m_stcBlobPad.fMaxLength = fMaxLength / m_fMMToUnitValue;

            m_stcBlobPad.fMinPitch = fMinPitch / m_fMMToUnitValue;
            m_stcBlobPad.fMaxPitch = fMaxPitch / m_fMMToUnitValue;
            m_stcBlobPad.fMinGap = fMinGap / m_fMMToUnitValue;
            m_stcBlobPad.fMaxGap = fMaxGap / m_fMMToUnitValue;
            m_stcBlobPad.fMaxBroken = fMaxBroken / m_fMMToUnitValueArea;
            m_stcBlobPad.fMaxBrokenLength = fMaxBrokenLength / m_fMMToUnitValue;
            m_stcBlobPad.fMaxSmearLength = fMaxSmearLength / m_fMMToUnitValue;

            m_stcBlobPad.fEdgeLimitTop = fEdgeLimitTop / m_fMMToUnitValue;
            m_stcBlobPad.fEdgeLimitRight = fEdgeLimitRight / m_fMMToUnitValue;
            m_stcBlobPad.fEdgeLimitBottom = fEdgeLimitBottom / m_fMMToUnitValue;
            m_stcBlobPad.fEdgeLimitLeft = fEdgeLimitLeft / m_fMMToUnitValue;

            m_stcBlobPad.fMaxStandOffTop = fMaxStandOffTop / m_fMMToUnitValue;
            m_stcBlobPad.fMaxStandOffBottom = fMaxStandOffBottom / m_fMMToUnitValue;
            m_stcBlobPad.fMaxStandOffLeft = fMaxStandOffLeft / m_fMMToUnitValue;
            m_stcBlobPad.fMaxStandOffRight = fMaxStandOffRight / m_fMMToUnitValue;
            
            m_stcBlobPad.fOffsetOffSet = fOffsetOffSet / m_fMMToUnitValue;
            m_stcBlobPad.fWidthOffset = fWidthOffset / m_fMMToUnitValue;
            m_stcBlobPad.fHeightOffset = fHeightOffset / m_fMMToUnitValue;
            m_stcBlobPad.fPitchOffset = fPitchOffset / m_fMMToUnitValue;
            m_stcBlobPad.fGapOffset = fGapOffset / m_fMMToUnitValue;

            m_stcBlobPad.fEdgeDistanceTopOffset = fEdgeDistanceTopOffset / m_fMMToUnitValue;
            m_stcBlobPad.fEdgeDistanceRightOffset = fEdgeDistanceRightOffset / m_fMMToUnitValue;
            m_stcBlobPad.fEdgeDistanceBottomOffset = fEdgeDistanceBottomOffset / m_fMMToUnitValue;
            m_stcBlobPad.fEdgeDistanceLeftOffset = fEdgeDistanceLeftOffset / m_fMMToUnitValue;

            m_stcBlobPad.fEdgeLimitTopOffset = fEdgeLimitTopOffset / m_fMMToUnitValue;
            m_stcBlobPad.fEdgeLimitRightOffset = fEdgeLimitRightOffset / m_fMMToUnitValue;
            m_stcBlobPad.fEdgeLimitBottomOffset = fEdgeLimitBottomOffset / m_fMMToUnitValue;
            m_stcBlobPad.fEdgeLimitLeftOffset = fEdgeLimitLeftOffset / m_fMMToUnitValue;

            m_stcBlobPad.fStandOffTopOffset = fStandOffTopOffset / m_fMMToUnitValue;
            m_stcBlobPad.fStandOffBottomOffset = fStandOffBottomOffset / m_fMMToUnitValue;
            m_stcBlobPad.fStandOffLeftOffset = fStandOffLeftOffset / m_fMMToUnitValue;
            m_stcBlobPad.fStandOffRightOffset = fStandOffRightOffset / m_fMMToUnitValue;

            // Recalculate template value so that score set value can maintain as default value
            //m_stcBlobPad.fArea = (int)Math.Round((m_stcBlobPad.fMinArea + m_stcBlobPad.fMaxArea) / 2) * m_fMMtoPixelAreaValue;
            //m_stcBlobPad.fWidth = (m_stcBlobPad.fMinWidth + m_stcBlobPad.fMaxWidth) / 2 * m_fMMToPixelXValue;
            //m_stcBlobPad.fHeight = (m_stcBlobPad.fMinLength + m_stcBlobPad.fMaxLength) / 2 * m_fMMToPixelYValue;
            //if (m_stcBlobPad.fPitch != -1)
            //    m_stcBlobPad.fPitch = (m_stcBlobPad.fMinPitch + m_stcBlobPad.fMaxPitch) / 2 * m_fMMToPixelYValue;
            //if (m_stcBlobPad.fGap != -1)
            //    m_stcBlobPad.fGap = (m_stcBlobPad.fMinGap + m_stcBlobPad.fMaxGap) / 2 * m_fMMToPixelYValue;

            m_arrTemplateBlobPads.RemoveAt(intSelectedIndex);
            m_arrTemplateBlobPads.Insert(intSelectedIndex, m_stcBlobPad);
        }

        public void UpdateGroupBlobFeatureToPixel(int intSelectedIndex, float fOffSet,
            float fMinArea, float fMaxArea, float fMinWidth, float fMaxWidth,
            float fMinLength, float fMaxLength, float fMinPitch, float fMaxPitch,
            float fMinGap, float fMaxGap, float fMaxBroken, float fMaxBrokenLength, float fMaxExcessArea, float fMaxSmearLength,
            float fOffsetOffSet, float fWidthOffset, float fHeightOffset, float fPitchOffset, float fGapOffset,
            float fEdgeDistanceTopOffset, float fEdgeDistanceRightOffset, float fEdgeDistanceBottomOffset, float fEdgeDistanceLeftOffset,
            float fEdgeLimitTopOffset, float fEdgeLimitRightOffset, float fEdgeLimitBottomOffset, float fEdgeLimitLeftOffset,
            float fStandOffTopOffset, float fStandOffBottomOffset, float fStandOffLeftOffset, float fStandOffRightOffset,
            float fMinLine3, float fMaxLine3, float fMinLine4, float fMaxLine4, float fMinLine5, float fMaxLine5, float fMinLine6, float fMaxLine6, float fMinLine7, float fMaxLine7,
            float fMinLine8, float fMaxLine8, float fMinLine9, float fMaxLine9, float fMinLine10, float fMaxLine10, float fMinLine11, float fMaxLine11, float fMinLine12, float fMaxLine12)
        {
            BlobsFeatures m_stcBlobPad = (BlobsFeatures)m_arrGroupTemplateBlobPads[intSelectedIndex];

            m_stcBlobPad.fOffSet = fOffSet / m_fMMToUnitValue;
            m_stcBlobPad.fMinArea = fMinArea / m_fMMToUnitValueArea;
            m_stcBlobPad.fMaxArea = fMaxArea / m_fMMToUnitValueArea;

            m_stcBlobPad.fMinWidth = fMinWidth / m_fMMToUnitValue;
            m_stcBlobPad.fMaxWidth = fMaxWidth / m_fMMToUnitValue;
            m_stcBlobPad.fMinLength = fMinLength / m_fMMToUnitValue;
            m_stcBlobPad.fMaxLength = fMaxLength / m_fMMToUnitValue;

            m_stcBlobPad.fMinPitch = fMinPitch / m_fMMToUnitValue;
            m_stcBlobPad.fMaxPitch = fMaxPitch / m_fMMToUnitValue;
            m_stcBlobPad.fMinGap = fMinGap / m_fMMToUnitValue;
            m_stcBlobPad.fMaxGap = fMaxGap / m_fMMToUnitValue;
            m_stcBlobPad.fMaxBroken = fMaxBroken / m_fMMToUnitValueArea;
            m_stcBlobPad.fMaxBrokenLength = fMaxBrokenLength / m_fMMToUnitValue;
            m_stcBlobPad.fMaxExcess = fMaxExcessArea / m_fMMToUnitValueArea;
            m_stcBlobPad.fMaxSmearLength = fMaxSmearLength / m_fMMToUnitValue;
            m_stcBlobPad.fOffsetOffSet = fOffsetOffSet / m_fMMToUnitValue;
            m_stcBlobPad.fWidthOffset = fWidthOffset / m_fMMToUnitValue;
            m_stcBlobPad.fHeightOffset = fHeightOffset / m_fMMToUnitValue;
            m_stcBlobPad.fPitchOffset = fPitchOffset / m_fMMToUnitValue;
            m_stcBlobPad.fGapOffset = fGapOffset / m_fMMToUnitValue;

            m_stcBlobPad.fEdgeDistanceTopOffset = fEdgeDistanceTopOffset / m_fMMToUnitValue;
            m_stcBlobPad.fEdgeDistanceRightOffset = fEdgeDistanceRightOffset / m_fMMToUnitValue;
            m_stcBlobPad.fEdgeDistanceBottomOffset = fEdgeDistanceBottomOffset / m_fMMToUnitValue;
            m_stcBlobPad.fEdgeDistanceLeftOffset = fEdgeDistanceLeftOffset / m_fMMToUnitValue;

            m_stcBlobPad.fEdgeLimitTopOffset = fEdgeLimitTopOffset / m_fMMToUnitValue;
            m_stcBlobPad.fEdgeLimitRightOffset = fEdgeLimitRightOffset / m_fMMToUnitValue;
            m_stcBlobPad.fEdgeLimitBottomOffset = fEdgeLimitBottomOffset / m_fMMToUnitValue;
            m_stcBlobPad.fEdgeLimitLeftOffset = fEdgeLimitLeftOffset / m_fMMToUnitValue;

            m_stcBlobPad.fStandOffTopOffset = fStandOffTopOffset / m_fMMToUnitValue;
            m_stcBlobPad.fStandOffBottomOffset = fStandOffBottomOffset / m_fMMToUnitValue;
            m_stcBlobPad.fStandOffLeftOffset = fStandOffLeftOffset / m_fMMToUnitValue;
            m_stcBlobPad.fStandOffRightOffset = fStandOffRightOffset / m_fMMToUnitValue;

            m_stcBlobPad.fMinLine3 = fMinLine3 / m_fMMToUnitValue;
            m_stcBlobPad.fMaxLine3 = fMaxLine3 / m_fMMToUnitValue;
            m_stcBlobPad.fMinLine4 = fMinLine4 / m_fMMToUnitValue;
            m_stcBlobPad.fMaxLine4 = fMaxLine4 / m_fMMToUnitValue;
            m_stcBlobPad.fMinLine5 = fMinLine5 / m_fMMToUnitValue;
            m_stcBlobPad.fMaxLine5 = fMaxLine5 / m_fMMToUnitValue;
            m_stcBlobPad.fMinLine6 = fMinLine6 / m_fMMToUnitValue;
            m_stcBlobPad.fMaxLine6 = fMaxLine6 / m_fMMToUnitValue;
            m_stcBlobPad.fMinLine7 = fMinLine7 / m_fMMToUnitValue;
            m_stcBlobPad.fMaxLine7 = fMaxLine7 / m_fMMToUnitValue;
            m_stcBlobPad.fMinLine8 = fMinLine8 / m_fMMToUnitValue;
            m_stcBlobPad.fMaxLine8 = fMaxLine8 / m_fMMToUnitValue;
            m_stcBlobPad.fMinLine9 = fMinLine9 / m_fMMToUnitValue;
            m_stcBlobPad.fMaxLine9 = fMaxLine9 / m_fMMToUnitValue;
            m_stcBlobPad.fMinLine10 = fMinLine10 / m_fMMToUnitValue;
            m_stcBlobPad.fMaxLine10 = fMaxLine10 / m_fMMToUnitValue;
            m_stcBlobPad.fMinLine11 = fMinLine11 / m_fMMToUnitValue;
            m_stcBlobPad.fMaxLine11 = fMaxLine11 / m_fMMToUnitValue;
            m_stcBlobPad.fMinLine12 = fMinLine12 / m_fMMToUnitValue;
            m_stcBlobPad.fMaxLine12 = fMaxLine12 / m_fMMToUnitValue;

            // Recalculate template value so that score set value can maintain as default value
            //m_stcBlobPad.fArea = (int)Math.Round((m_stcBlobPad.fMinArea + m_stcBlobPad.fMaxArea) / 2) * m_fMMtoPixelAreaValue;
            //m_stcBlobPad.fWidth = (m_stcBlobPad.fMinWidth + m_stcBlobPad.fMaxWidth) / 2 * m_fMMToPixelXValue;
            //m_stcBlobPad.fHeight = (m_stcBlobPad.fMinLength + m_stcBlobPad.fMaxLength) / 2 * m_fMMToPixelYValue;
            //if (m_stcBlobPad.fPitch != -1)
            //    m_stcBlobPad.fPitch = (m_stcBlobPad.fMinPitch + m_stcBlobPad.fMaxPitch) / 2 * m_fMMToPixelYValue;
            //if (m_stcBlobPad.fGap != -1)
            //    m_stcBlobPad.fGap = (m_stcBlobPad.fMinGap + m_stcBlobPad.fMaxGap) / 2 * m_fMMToPixelYValue;

            m_arrGroupTemplateBlobPads.RemoveAt(intSelectedIndex);
            m_arrGroupTemplateBlobPads.Insert(intSelectedIndex, m_stcBlobPad);
        }

        public void UpdateGroupBlobSingleFeatureToPixel(int intSelectedIndex, int intFeature, float fValue)
        {
            if (intSelectedIndex >= m_arrGroupTemplateBlobPads.Count)
                return;

            BlobsFeatures m_stcBlobPad = (BlobsFeatures)m_arrGroupTemplateBlobPads[intSelectedIndex];

            switch (intFeature)
            {
                case 0:
                    m_stcBlobPad.fOffSet = fValue / m_fMMToUnitValue;
                    break;
                case 3:
                    m_stcBlobPad.fMinArea = fValue / m_fMMToUnitValueArea;
                    break;
                case 5:
                    m_stcBlobPad.fMaxArea = fValue / m_fMMToUnitValueArea;
                    break;
                case 7:
                    m_stcBlobPad.fMinWidth = fValue / m_fMMToUnitValue;
                    break;
                case 9:
                    m_stcBlobPad.fMaxWidth = fValue / m_fMMToUnitValue;
                    break;
                case 11:
                    m_stcBlobPad.fMinLength = fValue / m_fMMToUnitValue;
                    break;
                case 13:
                    m_stcBlobPad.fMaxLength = fValue / m_fMMToUnitValue;
                    break;
                case 15:
                    m_stcBlobPad.fMinPitch = fValue / m_fMMToUnitValue;
                    break;
                case 17:
                    m_stcBlobPad.fMaxPitch = fValue / m_fMMToUnitValue;
                    break;
                case 19:
                    m_stcBlobPad.fMinGap = fValue / m_fMMToUnitValue;
                    break;
                case 21:
                    m_stcBlobPad.fMaxGap = fValue / m_fMMToUnitValue;
                    break;
                case 23:
                    m_stcBlobPad.fMaxBroken = fValue / m_fMMToUnitValueArea;
                    break;
                case 26:
                    m_stcBlobPad.fMaxBrokenLength = fValue / m_fMMToUnitValue;
                    break;
                case 29:
                    m_stcBlobPad.fMaxExcess = fValue / m_fMMToUnitValueArea;
                    break;
                case 32:
                    m_stcBlobPad.fMaxSmearLength = fValue / m_fMMToUnitValue;
                    break;
                case 35:
                    m_stcBlobPad.fEdgeLimitTop = fValue / m_fMMToUnitValue;
                    break;
                case 37:
                    m_stcBlobPad.fEdgeLimitRight = fValue / m_fMMToUnitValue;
                    break;
                case 39:
                    m_stcBlobPad.fEdgeLimitBottom = fValue / m_fMMToUnitValue;
                    break;
                case 41:
                    m_stcBlobPad.fEdgeLimitLeft = fValue / m_fMMToUnitValue;
                    break;
                case 44:
                    m_stcBlobPad.fMaxStandOffTop = fValue / m_fMMToUnitValue;
                    break;
                case 46:
                    m_stcBlobPad.fMaxStandOffBottom = fValue / m_fMMToUnitValue;
                    break;
                case 48:
                    m_stcBlobPad.fMaxStandOffLeft = fValue / m_fMMToUnitValue;
                    break;
                case 50:
                    m_stcBlobPad.fMaxStandOffRight = fValue / m_fMMToUnitValue;
                    break;
                case 53:
                    m_stcBlobPad.fMinLine3 = fValue / m_fMMToUnitValue;
                    break;
                case 55:
                    m_stcBlobPad.fMaxLine3 = fValue / m_fMMToUnitValue;
                    break;
                case 57:
                    m_stcBlobPad.fMinLine4 = fValue / m_fMMToUnitValue;
                    break;
                case 59:
                    m_stcBlobPad.fMaxLine4 = fValue / m_fMMToUnitValue;
                    break;
                case 61:
                    m_stcBlobPad.fMinLine5 = fValue / m_fMMToUnitValue;
                    break;
                case 63:
                    m_stcBlobPad.fMaxLine5 = fValue / m_fMMToUnitValue;
                    break;
                case 65:
                    m_stcBlobPad.fMinLine6 = fValue / m_fMMToUnitValue;
                    break;
                case 67:
                    m_stcBlobPad.fMaxLine6 = fValue / m_fMMToUnitValue;
                    break;
                case 69:
                    m_stcBlobPad.fMinLine7 = fValue / m_fMMToUnitValue;
                    break;
                case 71:
                    m_stcBlobPad.fMaxLine7 = fValue / m_fMMToUnitValue;
                    break;
                case 73:
                    m_stcBlobPad.fMinLine8 = fValue / m_fMMToUnitValue;
                    break;
                case 75:
                    m_stcBlobPad.fMaxLine8 = fValue / m_fMMToUnitValue;
                    break;
                case 77:
                    m_stcBlobPad.fMinLine9 = fValue / m_fMMToUnitValue;
                    break;
                case 79:
                    m_stcBlobPad.fMaxLine9 = fValue / m_fMMToUnitValue;
                    break;
                case 81:
                    m_stcBlobPad.fMinLine10 = fValue / m_fMMToUnitValue;
                    break;
                case 83:
                    m_stcBlobPad.fMaxLine10 = fValue / m_fMMToUnitValue;
                    break;
                case 85:
                    m_stcBlobPad.fMinLine11 = fValue / m_fMMToUnitValue;
                    break;
                case 87:
                    m_stcBlobPad.fMaxLine11 = fValue / m_fMMToUnitValue;
                    break;
                case 89:
                    m_stcBlobPad.fMinLine12 = fValue / m_fMMToUnitValue;
                    break;
                case 91:
                    m_stcBlobPad.fMaxLine12 = fValue / m_fMMToUnitValue;
                    break;
                    //case 73:
                    //    m_stcBlobPad.fWidthOffset = fValue / m_fMMToUnitValue;
                    //    break;
                    //case 75:
                    //    m_stcBlobPad.fHeightOffset = fValue / m_fMMToUnitValue;
                    //    break;
                    //case 77:
                    //    m_stcBlobPad.fPitchOffset = fValue / m_fMMToUnitValue;
                    //    break;
                    //case 79:
                    //    m_stcBlobPad.fGapOffset = fValue / m_fMMToUnitValue;
                    //    break;
            }

            m_arrGroupTemplateBlobPads.RemoveAt(intSelectedIndex);
            m_arrGroupTemplateBlobPads.Insert(intSelectedIndex, m_stcBlobPad);
        }

        public void UpdateBlobFeatureToPixel_NoPitchGap(int intSelectedIndex, float fOffSet,
          float fMinArea, float fMaxArea, float fMinWidth, float fMaxWidth,
          float fMinLength, float fMaxLength, float fMaxBroken, float fMaxBrokenLength)
        {
            BlobsFeatures m_stcBlobPad = (BlobsFeatures)m_arrTemplateBlobPads[intSelectedIndex];

            m_stcBlobPad.fOffSet = fOffSet / m_fMMToUnitValue;
            m_stcBlobPad.fMinArea = fMinArea / m_fMMToUnitValueArea;
            m_stcBlobPad.fMaxArea = fMaxArea / m_fMMToUnitValueArea;

            m_stcBlobPad.fMinWidth = fMinWidth / m_fMMToUnitValue;
            m_stcBlobPad.fMaxWidth = fMaxWidth / m_fMMToUnitValue;
            m_stcBlobPad.fMinLength = fMinLength / m_fMMToUnitValue;
            m_stcBlobPad.fMaxLength = fMaxLength / m_fMMToUnitValue;

            m_stcBlobPad.fMaxBroken = fMaxBroken / m_fMMToUnitValueArea;
            m_stcBlobPad.fMaxBrokenLength = fMaxBrokenLength / m_fMMToUnitValue;

            m_arrTemplateBlobPads.RemoveAt(intSelectedIndex);
            m_arrTemplateBlobPads.Insert(intSelectedIndex, m_stcBlobPad);
        }

        /// <summary>
        /// Update pad no 
        /// </summary>
        /// <param name="intSelectedIndex">source pad index</param>
        /// <param name="intDestinationIndex">destination pad index</param>
        public void UpdatePadNo(int intSelectedIndex, int intDestinationIndex)
        {
            BlobsFeatures stcBlobsFeatures = (BlobsFeatures)m_arrTemplateBlobPads[intSelectedIndex];
            BlobsFeatures stcReplaceBlobsFeatures = (BlobsFeatures)m_arrTemplateBlobPads[intDestinationIndex];
            BlobsFeatures stcTempBlobsFeatures = (BlobsFeatures)m_arrTemplateBlobPads[intSelectedIndex];
            BlobsFeatures stcTempReplaceBlobsFeatures = (BlobsFeatures)m_arrTemplateBlobPads[intDestinationIndex];

            stcBlobsFeatures.intNoID = intDestinationIndex + 1;
            stcReplaceBlobsFeatures.intNoID = intSelectedIndex + 1;
            
            stcReplaceBlobsFeatures.intGroupID = stcTempBlobsFeatures.intGroupID;
            //2019-10-30 ZJYEOH : Tolerance settings remain when swap between two blobs
            stcReplaceBlobsFeatures.fOffSet = stcTempBlobsFeatures.fOffSet;
            stcReplaceBlobsFeatures.fMinArea = stcTempBlobsFeatures.fMinArea;
            stcReplaceBlobsFeatures.fMaxArea = stcTempBlobsFeatures.fMaxArea;
            stcReplaceBlobsFeatures.fMinWidth = stcTempBlobsFeatures.fMinWidth;
            stcReplaceBlobsFeatures.fMaxWidth = stcTempBlobsFeatures.fMaxWidth;
            stcReplaceBlobsFeatures.fMinLength = stcTempBlobsFeatures.fMinLength;
            stcReplaceBlobsFeatures.fMaxLength = stcTempBlobsFeatures.fMaxLength;
            stcReplaceBlobsFeatures.fMinPitch = stcTempBlobsFeatures.fMinPitch;
            stcReplaceBlobsFeatures.fMaxPitch = stcTempBlobsFeatures.fMaxPitch;
            stcReplaceBlobsFeatures.fMinGap = stcTempBlobsFeatures.fMinGap;
            stcReplaceBlobsFeatures.fMaxGap = stcTempBlobsFeatures.fMaxGap;
            stcReplaceBlobsFeatures.fMaxBroken = stcTempBlobsFeatures.fMaxBroken;
            stcReplaceBlobsFeatures.fMaxBrokenLength = stcTempBlobsFeatures.fMaxBrokenLength;
            stcReplaceBlobsFeatures.fMaxExcess = stcTempBlobsFeatures.fMaxExcess;
            stcReplaceBlobsFeatures.fMaxSmearLength = stcTempBlobsFeatures.fMaxSmearLength;

            stcReplaceBlobsFeatures.fEdgeLimitTop = stcTempBlobsFeatures.fEdgeLimitTop;
            stcReplaceBlobsFeatures.fEdgeLimitRight = stcTempBlobsFeatures.fEdgeLimitRight;
            stcReplaceBlobsFeatures.fEdgeLimitBottom = stcTempBlobsFeatures.fEdgeLimitBottom;
            stcReplaceBlobsFeatures.fEdgeLimitLeft = stcTempBlobsFeatures.fEdgeLimitLeft;

            stcReplaceBlobsFeatures.fMaxStandOffTop = stcTempBlobsFeatures.fMaxStandOffTop;
            stcReplaceBlobsFeatures.fMaxStandOffBottom = stcTempBlobsFeatures.fMaxStandOffBottom;
            stcReplaceBlobsFeatures.fMaxStandOffLeft = stcTempBlobsFeatures.fMaxStandOffLeft;
            stcReplaceBlobsFeatures.fMaxStandOffRight = stcTempBlobsFeatures.fMaxStandOffRight;
            
            stcReplaceBlobsFeatures.fOffsetOffSet = stcTempBlobsFeatures.fOffsetOffSet;
            stcReplaceBlobsFeatures.fWidthOffset = stcTempBlobsFeatures.fWidthOffset;
            stcReplaceBlobsFeatures.fHeightOffset = stcTempBlobsFeatures.fHeightOffset;
            stcReplaceBlobsFeatures.fPitchOffset = stcTempBlobsFeatures.fPitchOffset;
            stcReplaceBlobsFeatures.fGapOffset = stcTempBlobsFeatures.fGapOffset;

            stcReplaceBlobsFeatures.fEdgeDistanceTopOffset = stcTempBlobsFeatures.fEdgeDistanceTopOffset;
            stcReplaceBlobsFeatures.fEdgeDistanceRightOffset = stcTempBlobsFeatures.fEdgeDistanceRightOffset;
            stcReplaceBlobsFeatures.fEdgeDistanceBottomOffset = stcTempBlobsFeatures.fEdgeDistanceBottomOffset;
            stcReplaceBlobsFeatures.fEdgeDistanceLeftOffset = stcTempBlobsFeatures.fEdgeDistanceLeftOffset;

            stcReplaceBlobsFeatures.fEdgeLimitTopOffset = stcTempBlobsFeatures.fEdgeLimitTopOffset;
            stcReplaceBlobsFeatures.fEdgeLimitRightOffset = stcTempBlobsFeatures.fEdgeLimitRightOffset;
            stcReplaceBlobsFeatures.fEdgeLimitBottomOffset = stcTempBlobsFeatures.fEdgeLimitBottomOffset;
            stcReplaceBlobsFeatures.fEdgeLimitLeftOffset = stcTempBlobsFeatures.fEdgeLimitLeftOffset;

            stcReplaceBlobsFeatures.fStandOffTopOffset = stcTempBlobsFeatures.fStandOffTopOffset;
            stcReplaceBlobsFeatures.fStandOffBottomOffset = stcTempBlobsFeatures.fStandOffBottomOffset;
            stcReplaceBlobsFeatures.fStandOffLeftOffset = stcTempBlobsFeatures.fStandOffLeftOffset;
            stcReplaceBlobsFeatures.fStandOffRightOffset = stcTempBlobsFeatures.fStandOffRightOffset;

            stcReplaceBlobsFeatures.fMinLine3 = stcTempBlobsFeatures.fMinLine3;
            stcReplaceBlobsFeatures.fMaxLine3 = stcTempBlobsFeatures.fMaxLine3;
            stcReplaceBlobsFeatures.fMinLine4 = stcTempBlobsFeatures.fMinLine4;
            stcReplaceBlobsFeatures.fMaxLine4 = stcTempBlobsFeatures.fMaxLine4;
            stcReplaceBlobsFeatures.fMinLine5 = stcTempBlobsFeatures.fMinLine5;
            stcReplaceBlobsFeatures.fMaxLine5 = stcTempBlobsFeatures.fMaxLine5;
            stcReplaceBlobsFeatures.fMinLine6 = stcTempBlobsFeatures.fMinLine6;
            stcReplaceBlobsFeatures.fMaxLine6 = stcTempBlobsFeatures.fMaxLine6;
            stcReplaceBlobsFeatures.fMinLine7 = stcTempBlobsFeatures.fMinLine7;
            stcReplaceBlobsFeatures.fMaxLine7 = stcTempBlobsFeatures.fMaxLine7;
            stcReplaceBlobsFeatures.fMinLine8 = stcTempBlobsFeatures.fMinLine8;
            stcReplaceBlobsFeatures.fMaxLine8 = stcTempBlobsFeatures.fMaxLine8;
            stcReplaceBlobsFeatures.fMinLine9 = stcTempBlobsFeatures.fMinLine9;
            stcReplaceBlobsFeatures.fMaxLine9 = stcTempBlobsFeatures.fMaxLine9;
            stcReplaceBlobsFeatures.fMinLine10 = stcTempBlobsFeatures.fMinLine10;
            stcReplaceBlobsFeatures.fMaxLine10 = stcTempBlobsFeatures.fMaxLine10;
            stcReplaceBlobsFeatures.fMinLine11 = stcTempBlobsFeatures.fMinLine11;
            stcReplaceBlobsFeatures.fMaxLine11 = stcTempBlobsFeatures.fMaxLine11;
            stcReplaceBlobsFeatures.fMinLine12 = stcTempBlobsFeatures.fMinLine12;
            stcReplaceBlobsFeatures.fMaxLine12 = stcTempBlobsFeatures.fMaxLine12;

            stcReplaceBlobsFeatures.fPadInspectionAreaFromTop = stcTempBlobsFeatures.fPadInspectionAreaFromTop;
            stcReplaceBlobsFeatures.fPadInspectionAreaFromRight = stcTempBlobsFeatures.fPadInspectionAreaFromRight;
            stcReplaceBlobsFeatures.fPadInspectionAreaFromBottom = stcTempBlobsFeatures.fPadInspectionAreaFromBottom;
            stcReplaceBlobsFeatures.fPadInspectionAreaFromLeft = stcTempBlobsFeatures.fPadInspectionAreaFromLeft;

            stcReplaceBlobsFeatures.intReferTopBottom = stcTempBlobsFeatures.intReferTopBottom;
            stcReplaceBlobsFeatures.blnCheckTop = stcTempBlobsFeatures.blnCheckTop;
            stcReplaceBlobsFeatures.blnCheckBottom = stcTempBlobsFeatures.blnCheckBottom;
            stcReplaceBlobsFeatures.intReferLeftRight = stcTempBlobsFeatures.intReferLeftRight;
            stcReplaceBlobsFeatures.blnCheckLeft = stcTempBlobsFeatures.blnCheckLeft;
            stcReplaceBlobsFeatures.blnCheckRight = stcTempBlobsFeatures.blnCheckRight;

            stcBlobsFeatures.intGroupID = stcTempReplaceBlobsFeatures.intGroupID;
            stcBlobsFeatures.fOffSet = stcTempReplaceBlobsFeatures.fOffSet;
            stcBlobsFeatures.fMinArea = stcTempReplaceBlobsFeatures.fMinArea;
            stcBlobsFeatures.fMaxArea = stcTempReplaceBlobsFeatures.fMaxArea;
            stcBlobsFeatures.fMinWidth = stcTempReplaceBlobsFeatures.fMinWidth;
            stcBlobsFeatures.fMaxWidth = stcTempReplaceBlobsFeatures.fMaxWidth;
            stcBlobsFeatures.fMinLength = stcTempReplaceBlobsFeatures.fMinLength;
            stcBlobsFeatures.fMaxLength = stcTempReplaceBlobsFeatures.fMaxLength;
            stcBlobsFeatures.fMinPitch = stcTempReplaceBlobsFeatures.fMinPitch;
            stcBlobsFeatures.fMaxPitch = stcTempReplaceBlobsFeatures.fMaxPitch;
            stcBlobsFeatures.fMinGap = stcTempReplaceBlobsFeatures.fMinGap;
            stcBlobsFeatures.fMaxGap = stcTempReplaceBlobsFeatures.fMaxGap;
            stcBlobsFeatures.fMaxBroken = stcTempReplaceBlobsFeatures.fMaxBroken;
            stcBlobsFeatures.fMaxBrokenLength = stcTempReplaceBlobsFeatures.fMaxBrokenLength;
            stcBlobsFeatures.fMaxExcess = stcTempReplaceBlobsFeatures.fMaxExcess;
            stcBlobsFeatures.fMaxSmearLength = stcTempReplaceBlobsFeatures.fMaxSmearLength;

            stcBlobsFeatures.fEdgeLimitTop = stcTempReplaceBlobsFeatures.fEdgeLimitTop;
            stcBlobsFeatures.fEdgeLimitRight = stcTempReplaceBlobsFeatures.fEdgeLimitRight;
            stcBlobsFeatures.fEdgeLimitBottom = stcTempReplaceBlobsFeatures.fEdgeLimitBottom;
            stcBlobsFeatures.fEdgeLimitLeft = stcTempReplaceBlobsFeatures.fEdgeLimitLeft;

            stcBlobsFeatures.fMaxStandOffTop = stcTempReplaceBlobsFeatures.fMaxStandOffTop;
            stcBlobsFeatures.fMaxStandOffBottom = stcTempReplaceBlobsFeatures.fMaxStandOffBottom;
            stcBlobsFeatures.fMaxStandOffLeft = stcTempReplaceBlobsFeatures.fMaxStandOffLeft;
            stcBlobsFeatures.fMaxStandOffRight = stcTempReplaceBlobsFeatures.fMaxStandOffRight;
            
            stcBlobsFeatures.fOffsetOffSet = stcTempReplaceBlobsFeatures.fOffsetOffSet;
            stcBlobsFeatures.fWidthOffset = stcTempReplaceBlobsFeatures.fWidthOffset;
            stcBlobsFeatures.fHeightOffset = stcTempReplaceBlobsFeatures.fHeightOffset;
            stcBlobsFeatures.fPitchOffset = stcTempReplaceBlobsFeatures.fPitchOffset;
            stcBlobsFeatures.fGapOffset = stcTempReplaceBlobsFeatures.fGapOffset;

            stcBlobsFeatures.fEdgeDistanceTopOffset = stcTempReplaceBlobsFeatures.fEdgeDistanceTopOffset;
            stcBlobsFeatures.fEdgeDistanceRightOffset = stcTempReplaceBlobsFeatures.fEdgeDistanceRightOffset;
            stcBlobsFeatures.fEdgeDistanceBottomOffset = stcTempReplaceBlobsFeatures.fEdgeDistanceBottomOffset;
            stcBlobsFeatures.fEdgeDistanceLeftOffset = stcTempReplaceBlobsFeatures.fEdgeDistanceLeftOffset;

            stcBlobsFeatures.fEdgeLimitTopOffset = stcTempReplaceBlobsFeatures.fEdgeLimitTopOffset;
            stcBlobsFeatures.fEdgeLimitRightOffset = stcTempReplaceBlobsFeatures.fEdgeLimitRightOffset;
            stcBlobsFeatures.fEdgeLimitBottomOffset = stcTempReplaceBlobsFeatures.fEdgeLimitBottomOffset;
            stcBlobsFeatures.fEdgeLimitLeftOffset = stcTempReplaceBlobsFeatures.fEdgeLimitLeftOffset;

            stcBlobsFeatures.fStandOffTopOffset = stcTempReplaceBlobsFeatures.fStandOffTopOffset;
            stcBlobsFeatures.fStandOffBottomOffset = stcTempReplaceBlobsFeatures.fStandOffBottomOffset;
            stcBlobsFeatures.fStandOffLeftOffset = stcTempReplaceBlobsFeatures.fStandOffLeftOffset;
            stcBlobsFeatures.fStandOffRightOffset = stcTempReplaceBlobsFeatures.fStandOffRightOffset;

            stcBlobsFeatures.fMinLine3 = stcTempReplaceBlobsFeatures.fMinLine3;
            stcBlobsFeatures.fMaxLine3 = stcTempReplaceBlobsFeatures.fMaxLine3;
            stcBlobsFeatures.fMinLine4 = stcTempReplaceBlobsFeatures.fMinLine4;
            stcBlobsFeatures.fMaxLine4 = stcTempReplaceBlobsFeatures.fMaxLine4;
            stcBlobsFeatures.fMinLine5 = stcTempReplaceBlobsFeatures.fMinLine5;
            stcBlobsFeatures.fMaxLine5 = stcTempReplaceBlobsFeatures.fMaxLine5;
            stcBlobsFeatures.fMinLine6 = stcTempReplaceBlobsFeatures.fMinLine6;
            stcBlobsFeatures.fMaxLine6 = stcTempReplaceBlobsFeatures.fMaxLine6;
            stcBlobsFeatures.fMinLine7 = stcTempReplaceBlobsFeatures.fMinLine7;
            stcBlobsFeatures.fMaxLine7 = stcTempReplaceBlobsFeatures.fMaxLine7;
            stcBlobsFeatures.fMinLine8 = stcTempReplaceBlobsFeatures.fMinLine8;
            stcBlobsFeatures.fMaxLine8 = stcTempReplaceBlobsFeatures.fMaxLine8;
            stcBlobsFeatures.fMinLine9 = stcTempReplaceBlobsFeatures.fMinLine9;
            stcBlobsFeatures.fMaxLine9 = stcTempReplaceBlobsFeatures.fMaxLine9;
            stcBlobsFeatures.fMinLine10 = stcTempReplaceBlobsFeatures.fMinLine10;
            stcBlobsFeatures.fMaxLine10 = stcTempReplaceBlobsFeatures.fMaxLine10;
            stcBlobsFeatures.fMinLine11 = stcTempReplaceBlobsFeatures.fMinLine11;
            stcBlobsFeatures.fMaxLine11 = stcTempReplaceBlobsFeatures.fMaxLine11;
            stcBlobsFeatures.fMinLine12 = stcTempReplaceBlobsFeatures.fMinLine12;
            stcBlobsFeatures.fMaxLine12 = stcTempReplaceBlobsFeatures.fMaxLine12;

            stcBlobsFeatures.fPadInspectionAreaFromTop = stcTempReplaceBlobsFeatures.fPadInspectionAreaFromTop;
            stcBlobsFeatures.fPadInspectionAreaFromRight = stcTempReplaceBlobsFeatures.fPadInspectionAreaFromRight;
            stcBlobsFeatures.fPadInspectionAreaFromBottom = stcTempReplaceBlobsFeatures.fPadInspectionAreaFromBottom;
            stcBlobsFeatures.fPadInspectionAreaFromLeft = stcTempReplaceBlobsFeatures.fPadInspectionAreaFromLeft;

            stcBlobsFeatures.intReferTopBottom = stcTempReplaceBlobsFeatures.intReferTopBottom;
            stcBlobsFeatures.blnCheckTop = stcTempReplaceBlobsFeatures.blnCheckTop;
            stcBlobsFeatures.blnCheckBottom = stcTempReplaceBlobsFeatures.blnCheckBottom;
            stcBlobsFeatures.intReferLeftRight = stcTempReplaceBlobsFeatures.intReferLeftRight;
            stcBlobsFeatures.blnCheckLeft = stcTempReplaceBlobsFeatures.blnCheckLeft;
            stcBlobsFeatures.blnCheckRight = stcTempReplaceBlobsFeatures.blnCheckRight;

            if (intSelectedIndex > intDestinationIndex)
            {
                m_arrTemplateBlobPads.RemoveAt(intSelectedIndex);
                m_arrTemplateBlobPads.RemoveAt(intDestinationIndex);
                m_arrTemplateBlobPads.Insert(intDestinationIndex, stcBlobsFeatures);
                m_arrTemplateBlobPads.Insert(intSelectedIndex, stcReplaceBlobsFeatures);
            }
            else if (intSelectedIndex < intDestinationIndex)
            {
                m_arrTemplateBlobPads.RemoveAt(intDestinationIndex);
                m_arrTemplateBlobPads.RemoveAt(intSelectedIndex);
                m_arrTemplateBlobPads.Insert(intSelectedIndex, stcReplaceBlobsFeatures);
                m_arrTemplateBlobPads.Insert(intDestinationIndex, stcBlobsFeatures);
            }
        }
        /// <summary>
        /// Update previous tolerance to current template
        /// </summary>
        public void UpdatePreviousToleranceToTemplate()
        {
            // check is count tally? if tally, then read template index by sequence. If no tally, then then look for closest area blobs first.
            bool blnTally = m_arrBackupTemplateBlobPads.Count == GetSelectedObjectNumber();

            for (int i = 0; i < m_arrTemplateBlobPads.Count; i++)
            {
                if (!((BlobsFeatures)m_arrTemplateBlobPads[i]).blnSelected)
                    continue;

                BlobsFeatures m_stcBlobPad = (BlobsFeatures)m_arrTemplateBlobPads[i];

                int intSelectedIndex;
                if (blnTally)
                {
                    intSelectedIndex = i;
                }
                else
                {
                    //Loop to look for tolerance setting that have previous blob learn area closest to current blob learn area.
                    intSelectedIndex = -1;
                    float fDiffSmallestArea = float.MaxValue;
                    for (int j = 0; j < m_arrBackupTemplateBlobPads.Count; j++)  // Loop previous blobs tolerance list
                    {
                        m_stcBackupTemplateBlobPad = (ToleranceBlobsFeatures)m_arrBackupTemplateBlobPads[j];

                        // Get smallest different area between current and previous learn blob area.
                        if (Math.Abs(m_stcBlobPad.fArea - m_stcBackupTemplateBlobPad.fLearnArea) < fDiffSmallestArea)
                        {
                            fDiffSmallestArea = Math.Abs(m_stcBlobPad.fArea - m_stcBackupTemplateBlobPad.fLearnArea);
                            intSelectedIndex = j;
                        }
                    }
                }

                if (intSelectedIndex >= 0)  // If found the closest area blob
                {
                    // Copy the previous tolerance setting into current learn blob tolerance setting
                    m_stcBackupTemplateBlobPad = (ToleranceBlobsFeatures)m_arrBackupTemplateBlobPads[intSelectedIndex];

                    m_stcBlobPad.fOffSet = m_stcBackupTemplateBlobPad.fOffSet;
                    m_stcBlobPad.fMinArea = m_stcBackupTemplateBlobPad.fMinArea;
                    m_stcBlobPad.fMaxArea = m_stcBackupTemplateBlobPad.fMaxArea;
                    // 2019 10 30 - CCENG: m_arrTemplateBlobPads fMinWidth, fMaxWidth, fMinHeigt, fMaxLength are not affacted by lengthmode.
                    //if (m_stcBlobPad.intLengthMode == m_stcBackupTemplateBlobPad.intLengthMode)
                    //{
                    m_stcBlobPad.fMinWidth = m_stcBackupTemplateBlobPad.fMinWidth;
                    m_stcBlobPad.fMaxWidth = m_stcBackupTemplateBlobPad.fMaxWidth;
                    m_stcBlobPad.fMinLength = m_stcBackupTemplateBlobPad.fMinLength;
                    m_stcBlobPad.fMaxLength = m_stcBackupTemplateBlobPad.fMaxLength;
                    //}
                    //else
                    //{
                    //    m_stcBlobPad.fMinWidth = m_stcBackupTemplateBlobPad.fMinLength;
                    //    m_stcBlobPad.fMaxWidth = m_stcBackupTemplateBlobPad.fMaxLength;
                    //    m_stcBlobPad.fMinLength = m_stcBackupTemplateBlobPad.fMinWidth;
                    //    m_stcBlobPad.fMaxLength = m_stcBackupTemplateBlobPad.fMaxWidth;
                    //}

                    m_stcBlobPad.fMaxBroken = m_stcBackupTemplateBlobPad.fMaxBroken;
                    m_stcBlobPad.fMaxBrokenLength = m_stcBackupTemplateBlobPad.fMaxBrokenLength;
                    m_stcBlobPad.fMaxExcess = m_stcBackupTemplateBlobPad.fMaxExcess;
                    m_stcBlobPad.fMaxSmearLength = m_stcBackupTemplateBlobPad.fMaxSmearLength;

                    m_stcBlobPad.fEdgeLimitTop = m_stcBackupTemplateBlobPad.fEdgeLimitTop;
                    m_stcBlobPad.fEdgeLimitRight = m_stcBackupTemplateBlobPad.fEdgeLimitRight;
                    m_stcBlobPad.fEdgeLimitBottom = m_stcBackupTemplateBlobPad.fEdgeLimitBottom;
                    m_stcBlobPad.fEdgeLimitLeft = m_stcBackupTemplateBlobPad.fEdgeLimitLeft;

                    m_stcBlobPad.fMaxStandOffTop = m_stcBackupTemplateBlobPad.fMaxStandOffTop;
                    m_stcBlobPad.fMaxStandOffBottom = m_stcBackupTemplateBlobPad.fMaxStandOffBottom;
                    m_stcBlobPad.fMaxStandOffLeft = m_stcBackupTemplateBlobPad.fMaxStandOffLeft;
                    m_stcBlobPad.fMaxStandOffRight = m_stcBackupTemplateBlobPad.fMaxStandOffRight;
                    
                    m_stcBlobPad.fOffsetOffSet = m_stcBackupTemplateBlobPad.fOffsetOffSet;
                    m_stcBlobPad.fWidthOffset = m_stcBackupTemplateBlobPad.fWidthOffset;
                    m_stcBlobPad.fHeightOffset = m_stcBackupTemplateBlobPad.fHeightOffset;
                    m_stcBlobPad.fPitchOffset = m_stcBackupTemplateBlobPad.fPitchOffset;
                    m_stcBlobPad.fGapOffset = m_stcBackupTemplateBlobPad.fGapOffset;

                    m_stcBlobPad.fEdgeDistanceTopOffset = m_stcBackupTemplateBlobPad.fEdgeDistanceTopOffset;
                    m_stcBlobPad.fEdgeDistanceRightOffset = m_stcBackupTemplateBlobPad.fEdgeDistanceRightOffset;
                    m_stcBlobPad.fEdgeDistanceBottomOffset = m_stcBackupTemplateBlobPad.fEdgeDistanceBottomOffset;
                    m_stcBlobPad.fEdgeDistanceLeftOffset = m_stcBackupTemplateBlobPad.fEdgeDistanceLeftOffset;

                    m_stcBlobPad.fEdgeLimitTopOffset = m_stcBackupTemplateBlobPad.fEdgeLimitTopOffset;
                    m_stcBlobPad.fEdgeLimitRightOffset = m_stcBackupTemplateBlobPad.fEdgeLimitRightOffset;
                    m_stcBlobPad.fEdgeLimitBottomOffset = m_stcBackupTemplateBlobPad.fEdgeLimitBottomOffset;
                    m_stcBlobPad.fEdgeLimitLeftOffset = m_stcBackupTemplateBlobPad.fEdgeLimitLeftOffset;

                    m_stcBlobPad.fStandOffTopOffset = m_stcBackupTemplateBlobPad.fStandOffTopOffset;
                    m_stcBlobPad.fStandOffBottomOffset = m_stcBackupTemplateBlobPad.fStandOffBottomOffset;
                    m_stcBlobPad.fStandOffLeftOffset = m_stcBackupTemplateBlobPad.fStandOffLeftOffset;
                    m_stcBlobPad.fStandOffRightOffset = m_stcBackupTemplateBlobPad.fStandOffRightOffset;

                    m_stcBlobPad.fPadInspectionAreaFromTop = m_stcBackupTemplateBlobPad.fPadInspectionAreaFromTop;
                    m_stcBlobPad.fPadInspectionAreaFromRight = m_stcBackupTemplateBlobPad.fPadInspectionAreaFromRight;
                    m_stcBlobPad.fPadInspectionAreaFromBottom = m_stcBackupTemplateBlobPad.fPadInspectionAreaFromBottom;
                    m_stcBlobPad.fPadInspectionAreaFromLeft = m_stcBackupTemplateBlobPad.fPadInspectionAreaFromLeft;
                    // if tally, then same location pad will remain enable or disable based on previous setting.
                    // if no tally, then all pad will set to enable.
                    if (blnTally)
                    {
                        m_stcBlobPad.blnEnable = m_stcBackupTemplateBlobPad.bEnable;
                    }
                    else
                        m_stcBlobPad.blnEnable = true;
                }

                m_arrTemplateBlobPads.RemoveAt(i);
                m_arrTemplateBlobPads.Insert(i, m_stcBlobPad);
            }
        }

        public void UpdatePreviousToleranceToGroupTemplate()
        {
            // check is count tally? if tally, then read template index by sequence. If no tally, then look for closest area blobs first.
            bool blnTally = m_arrBackupTemplateBlobPads.Count == m_arrGroupTemplateBlobPads.Count;

            for (int i = 0; i < m_arrTemplateBlobPads.Count; i++)
            {
                if (!((BlobsFeatures)m_arrTemplateBlobPads[i]).blnSelected)
                    continue;

                BlobsFeatures m_stcBlobPad = (BlobsFeatures)m_arrTemplateBlobPads[i];

                int intSelectedIndex;
                if (blnTally)
                {
                    intSelectedIndex = i;
                }
                else
                {
                    //Loop to look for tolerance setting that have previous blob learn area closest to current blob learn area.
                    intSelectedIndex = -1;
                    float fDiffSmallestArea = float.MaxValue;
                    for (int j = 0; j < m_arrBackupTemplateBlobPads.Count; j++)  // Loop previous blobs tolerance list
                    {
                        m_stcBackupTemplateBlobPad = (ToleranceBlobsFeatures)m_arrBackupTemplateBlobPads[j];

                        // Get smallest different area between current and previous learn blob area.
                        if (Math.Abs(m_stcBlobPad.fArea - m_stcBackupTemplateBlobPad.fLearnArea) < fDiffSmallestArea)
                        {
                            fDiffSmallestArea = Math.Abs(m_stcBlobPad.fArea - m_stcBackupTemplateBlobPad.fLearnArea);
                            intSelectedIndex = j;
                        }
                    }
                }

                if (intSelectedIndex >= 0)  // If found the closest area blob
                {
                    // Copy the previous tolerance setting into current learn blob tolerance setting
                    m_stcBackupTemplateBlobPad = (ToleranceBlobsFeatures)m_arrBackupTemplateBlobPads[intSelectedIndex];

                    m_stcBlobPad.fOffSet = m_stcBackupTemplateBlobPad.fOffSet;
                    m_stcBlobPad.fMinArea = m_stcBackupTemplateBlobPad.fMinArea;
                    m_stcBlobPad.fMaxArea = m_stcBackupTemplateBlobPad.fMaxArea;
                    //if (m_stcBlobPad.intLengthMode == m_stcBackupTemplateBlobPad.intLengthMode)
                    //{
                    m_stcBlobPad.fMinWidth = m_stcBackupTemplateBlobPad.fMinWidth;
                    m_stcBlobPad.fMaxWidth = m_stcBackupTemplateBlobPad.fMaxWidth;
                    m_stcBlobPad.fMinLength = m_stcBackupTemplateBlobPad.fMinLength;
                    m_stcBlobPad.fMaxLength = m_stcBackupTemplateBlobPad.fMaxLength;
                    //}
                    //else
                    //{
                    //    m_stcBlobPad.fMinWidth = m_stcBackupTemplateBlobPad.fMinLength;
                    //    m_stcBlobPad.fMaxWidth = m_stcBackupTemplateBlobPad.fMaxLength;
                    //    m_stcBlobPad.fMinLength = m_stcBackupTemplateBlobPad.fMinWidth;
                    //    m_stcBlobPad.fMaxLength = m_stcBackupTemplateBlobPad.fMaxWidth;
                    //}

                    m_stcBlobPad.fMaxBroken = m_stcBackupTemplateBlobPad.fMaxBroken;
                    m_stcBlobPad.fMaxBrokenLength = m_stcBackupTemplateBlobPad.fMaxBrokenLength;
                    m_stcBlobPad.fMaxExcess = m_stcBackupTemplateBlobPad.fMaxExcess;
                    m_stcBlobPad.fMaxSmearLength = m_stcBackupTemplateBlobPad.fMaxSmearLength;

                    m_stcBlobPad.fEdgeLimitTop = m_stcBackupTemplateBlobPad.fEdgeLimitTop;
                    m_stcBlobPad.fEdgeLimitRight = m_stcBackupTemplateBlobPad.fEdgeLimitRight;
                    m_stcBlobPad.fEdgeLimitBottom = m_stcBackupTemplateBlobPad.fEdgeLimitBottom;
                    m_stcBlobPad.fEdgeLimitLeft = m_stcBackupTemplateBlobPad.fEdgeLimitLeft;

                    m_stcBlobPad.fMaxStandOffTop = m_stcBackupTemplateBlobPad.fMaxStandOffTop;
                    m_stcBlobPad.fMaxStandOffBottom = m_stcBackupTemplateBlobPad.fMaxStandOffBottom;
                    m_stcBlobPad.fMaxStandOffLeft = m_stcBackupTemplateBlobPad.fMaxStandOffLeft;
                    m_stcBlobPad.fMaxStandOffRight = m_stcBackupTemplateBlobPad.fMaxStandOffRight;
                    
                    m_stcBlobPad.fOffsetOffSet = m_stcBackupTemplateBlobPad.fOffsetOffSet;
                    m_stcBlobPad.fWidthOffset = m_stcBackupTemplateBlobPad.fWidthOffset;
                    m_stcBlobPad.fHeightOffset = m_stcBackupTemplateBlobPad.fHeightOffset;
                    m_stcBlobPad.fPitchOffset = m_stcBackupTemplateBlobPad.fPitchOffset;
                    m_stcBlobPad.fGapOffset = m_stcBackupTemplateBlobPad.fGapOffset;

                    m_stcBlobPad.fEdgeDistanceTopOffset = m_stcBackupTemplateBlobPad.fEdgeDistanceTopOffset;
                    m_stcBlobPad.fEdgeDistanceRightOffset = m_stcBackupTemplateBlobPad.fEdgeDistanceRightOffset;
                    m_stcBlobPad.fEdgeDistanceBottomOffset = m_stcBackupTemplateBlobPad.fEdgeDistanceBottomOffset;
                    m_stcBlobPad.fEdgeDistanceLeftOffset = m_stcBackupTemplateBlobPad.fEdgeDistanceLeftOffset;

                    m_stcBlobPad.fEdgeLimitTopOffset = m_stcBackupTemplateBlobPad.fEdgeLimitTopOffset;
                    m_stcBlobPad.fEdgeLimitRightOffset = m_stcBackupTemplateBlobPad.fEdgeLimitRightOffset;
                    m_stcBlobPad.fEdgeLimitBottomOffset = m_stcBackupTemplateBlobPad.fEdgeLimitBottomOffset;
                    m_stcBlobPad.fEdgeLimitLeftOffset = m_stcBackupTemplateBlobPad.fEdgeLimitLeftOffset;

                    m_stcBlobPad.fStandOffTopOffset = m_stcBackupTemplateBlobPad.fStandOffTopOffset;
                    m_stcBlobPad.fStandOffBottomOffset = m_stcBackupTemplateBlobPad.fStandOffBottomOffset;
                    m_stcBlobPad.fStandOffLeftOffset = m_stcBackupTemplateBlobPad.fStandOffLeftOffset;
                    m_stcBlobPad.fStandOffRightOffset = m_stcBackupTemplateBlobPad.fStandOffRightOffset;

                    m_stcBlobPad.fPadInspectionAreaFromTop = m_stcBackupTemplateBlobPad.fPadInspectionAreaFromTop;
                    m_stcBlobPad.fPadInspectionAreaFromRight = m_stcBackupTemplateBlobPad.fPadInspectionAreaFromRight;
                    m_stcBlobPad.fPadInspectionAreaFromBottom = m_stcBackupTemplateBlobPad.fPadInspectionAreaFromBottom;
                    m_stcBlobPad.fPadInspectionAreaFromLeft = m_stcBackupTemplateBlobPad.fPadInspectionAreaFromLeft;
                    // if tally, then same location pad will remain enable or disable based on previous setting.
                    // if no tally, then all pad will set to enable.
                    if (blnTally)
                    {
                        m_stcBlobPad.blnEnable = m_stcBackupTemplateBlobPad.bEnable;
                    }
                    else
                        m_stcBlobPad.blnEnable = true;
                }

                m_arrTemplateBlobPads.RemoveAt(i);
                m_arrTemplateBlobPads.Insert(i, m_stcBlobPad);
            }
        }

        /// <summary>
        /// Define pitch gap
        /// </summary>
        /// <param name="intPitchGapIndex">pitch gap index</param>
        /// <param name="intFromPadNo">from pad no</param>
        /// <param name="intToPadNo">to pad no</param>
        private bool DefinePitchGap(int intPitchGapIndex, int intFromPadNo, int intToPadNo)
        {
            if ((intFromPadNo < m_arrTemplateBlobPads.Count) && (intToPadNo < m_arrTemplateBlobPads.Count))
            {
                int intDrawPoint;
                bool blnUpDownFound = false;
                bool blnLeftRightFound = false;
                bool blnUpdateTolerance = false;
                BlobsFeatures stcFromBlobsFeatures = (BlobsFeatures)m_arrTemplateBlobPads[intFromPadNo];
                BlobsFeatures stcToBlobsFeatures = (BlobsFeatures)m_arrTemplateBlobPads[intToPadNo];

                // Check pitch available between up and down pads
                if ((stcFromBlobsFeatures.intStartX >= stcToBlobsFeatures.intStartX) && (stcFromBlobsFeatures.intStartX <= stcToBlobsFeatures.intEndX) ||
                    (stcFromBlobsFeatures.intEndX >= stcToBlobsFeatures.intStartX) && (stcFromBlobsFeatures.intEndX <= stcToBlobsFeatures.intEndX) ||
                    (stcToBlobsFeatures.intStartX >= stcFromBlobsFeatures.intStartX) && (stcToBlobsFeatures.intEndX <= stcFromBlobsFeatures.intEndX) ||
                    (stcToBlobsFeatures.intEndX >= stcFromBlobsFeatures.intStartX) && (stcToBlobsFeatures.intEndX <= stcFromBlobsFeatures.intEndX))
                {
                    blnUpDownFound = true;
                }

                // Check pitch available between left and right pads
                if ((stcFromBlobsFeatures.intStartY >= stcToBlobsFeatures.intStartY) && (stcFromBlobsFeatures.intStartY <= stcToBlobsFeatures.intEndY) ||
                    (stcFromBlobsFeatures.intEndY >= stcToBlobsFeatures.intStartY) && (stcFromBlobsFeatures.intEndY <= stcToBlobsFeatures.intEndY) ||
                    (stcToBlobsFeatures.intStartY >= stcFromBlobsFeatures.intStartY) && (stcToBlobsFeatures.intEndY <= stcFromBlobsFeatures.intEndY) ||
                    (stcToBlobsFeatures.intEndY >= stcFromBlobsFeatures.intStartY) && (stcToBlobsFeatures.intEndY <= stcFromBlobsFeatures.intEndY))
                {
                    blnLeftRightFound = true;
                }

                // Pitch only available in up down or left right only
                if ((blnLeftRightFound && !blnUpDownFound) || (!blnLeftRightFound && blnUpDownFound))
                {
                    if (blnUpDownFound)
                    {
                        // Pitch only available if distance gap between pads > 1 pixel
                        if ((stcToBlobsFeatures.intStartY - stcFromBlobsFeatures.intEndY) > 1)
                        {
                            intDrawPoint = GetDrawPoint(stcFromBlobsFeatures.intStartX, stcFromBlobsFeatures.intEndX, stcToBlobsFeatures.intStartX, stcToBlobsFeatures.intEndX);
                            m_stcPitchGap.intStartPointX = intDrawPoint;
                            m_stcPitchGap.intEndPointX = intDrawPoint;
                            m_stcPitchGap.intStartPointY = stcFromBlobsFeatures.intEndY;
                            m_stcPitchGap.intEndPointY = stcToBlobsFeatures.intStartY;
                            m_stcPitchGap.fGap = stcToBlobsFeatures.intStartY - stcFromBlobsFeatures.intEndY;
                            m_stcPitchGap.fPitch = stcToBlobsFeatures.fLimitCenterY - stcFromBlobsFeatures.fLimitCenterY;
                            m_stcPitchGap.intDirection = 180;
                            //DefinePitchGapTolerance();

                            if (blnUpdateTolerance)
                                DefinePitchGapTolerance();
                            else
                                UpdatePreviousPitchToleranceToTemplate(intPitchGapIndex);
                            return true;
                        }
                        else if ((stcFromBlobsFeatures.intStartY - stcToBlobsFeatures.intEndY) > 1)
                        {
                            intDrawPoint = GetDrawPoint(stcFromBlobsFeatures.intStartX, stcFromBlobsFeatures.intEndX, stcToBlobsFeatures.intStartX, stcToBlobsFeatures.intEndX);
                            m_stcPitchGap.intStartPointX = intDrawPoint;
                            m_stcPitchGap.intEndPointX = intDrawPoint;
                            m_stcPitchGap.intStartPointY = stcFromBlobsFeatures.intStartY;
                            m_stcPitchGap.intEndPointY = stcToBlobsFeatures.intEndY;
                            m_stcPitchGap.fGap = stcFromBlobsFeatures.intStartY - stcToBlobsFeatures.intEndY;
                            m_stcPitchGap.fPitch = stcFromBlobsFeatures.fLimitCenterY - stcToBlobsFeatures.fLimitCenterY;
                            m_stcPitchGap.intDirection = 0;
                            //DefinePitchGapTolerance();
                            if (blnUpdateTolerance)
                                DefinePitchGapTolerance();
                            else
                                UpdatePreviousPitchToleranceToTemplate(intPitchGapIndex);
                            return true;
                        }
                        else
                        {
                            return false;
                        }
                    }
                    else
                    {
                        // Pitch only available if distance gap between pads > 1 pixel
                        if ((stcToBlobsFeatures.intStartX - stcFromBlobsFeatures.intEndX) > 1)
                        {
                            intDrawPoint = GetDrawPoint(stcFromBlobsFeatures.intStartY, stcFromBlobsFeatures.intEndY, stcToBlobsFeatures.intStartY, stcToBlobsFeatures.intEndY);
                            m_stcPitchGap.intStartPointX = stcFromBlobsFeatures.intEndX;
                            m_stcPitchGap.intEndPointX = stcToBlobsFeatures.intStartX;
                            m_stcPitchGap.intStartPointY = intDrawPoint;
                            m_stcPitchGap.intEndPointY = intDrawPoint;
                            m_stcPitchGap.fGap = stcToBlobsFeatures.intStartX - stcFromBlobsFeatures.intEndX;
                            m_stcPitchGap.fPitch = stcToBlobsFeatures.fLimitCenterX - stcFromBlobsFeatures.fLimitCenterX;
                            m_stcPitchGap.intDirection = 90;
                            //DefinePitchGapTolerance();
                            if (blnUpdateTolerance)
                                DefinePitchGapTolerance();
                            else
                                UpdatePreviousPitchToleranceToTemplate(intPitchGapIndex);
                            return true;
                        }
                        else if ((stcFromBlobsFeatures.intStartX - stcToBlobsFeatures.intEndX) > 1)
                        {
                            intDrawPoint = GetDrawPoint(stcFromBlobsFeatures.intStartY, stcFromBlobsFeatures.intEndY, stcToBlobsFeatures.intStartY, stcToBlobsFeatures.intEndY);
                            m_stcPitchGap.intStartPointX = stcFromBlobsFeatures.intStartX;
                            m_stcPitchGap.intEndPointX = stcToBlobsFeatures.intEndX;
                            m_stcPitchGap.intStartPointY = intDrawPoint;
                            m_stcPitchGap.intEndPointY = intDrawPoint;
                            m_stcPitchGap.fGap = stcFromBlobsFeatures.intStartX - stcToBlobsFeatures.intEndX;
                            m_stcPitchGap.fPitch = stcFromBlobsFeatures.fLimitCenterX - stcToBlobsFeatures.fLimitCenterX;
                            //DefinePitchGapTolerance();
                            if (blnUpdateTolerance)
                                DefinePitchGapTolerance();
                            else
                                UpdatePreviousPitchToleranceToTemplate(intPitchGapIndex);
                            m_stcPitchGap.intDirection = 270;
                            return true;
                        }
                        else
                        {
                            return false;
                        }
                    }
                }
                else
                    return false;
            }
            return true;
        }

        /// <summary>
        /// Get pitch gap data include min pitch, max pitch, min gap, max gap
        /// </summary>
        /// <param name="intIndex">pitch gap index</param>
        /// <param name="minPitch">min pitch</param>
        /// <param name="maxPitch">max pitch</param>
        /// <param name="minGap">min gap</param>
        /// <param name="maxGap">max gap</param>
        /// <returns>true = min pitch != 0.0, false = min pitch = 0.0</returns>
        private bool GetPitchGapMinMax(int intIndex, ref float minPitch, ref float maxPitch, ref float minGap, ref float maxGap)
        {
            int iFrom, iTo;
            iFrom = iTo = 0;

            for (int i = 0; i < GetTotalPitchGap(); i++)
            {
                GetPitchGapPadLink(i, ref iFrom, ref iTo);

                if ((intIndex + 1) == iFrom)
                {
                    minPitch = m_arrPitchGap[i].fMinPitch;
                    maxPitch = m_arrPitchGap[i].fMaxPitch;
                    minGap = m_arrPitchGap[i].fMinGap;
                    maxGap = m_arrPitchGap[i].fMaxGap;
                    return true;
                }
            }

            //if (minPitch != 0.0f)
            //    return true;
            //else
            return false;
        }

        /// <summary>
        /// Check whether sample object area fall within template area settings 
        /// </summary>
        /// <param name="intBlobsFeatureIndex">blobs feature index</param>
        /// <param name="fArea">object area to check</param>
        /// <returns>true = valid area, false = invalid area</returns>
        private bool MatchTemplateObjectsArea(int intBlobsFeatureIndex, float fArea)
        {
            BlobsFeatures m_stcBlobPad;
            if (m_blnWantUseGroupToleranceSetting)
            {
                int intGroupNo = ((BlobsFeatures)m_arrTemplateBlobPads[intBlobsFeatureIndex]).intGroupID;
                m_stcBlobPad = (BlobsFeatures)m_arrGroupTemplateBlobPads[intGroupNo];
            }
            else
            {
                m_stcBlobPad = (BlobsFeatures)m_arrTemplateBlobPads[intBlobsFeatureIndex];
            }

            if (m_blnWantTightSetting)
            {
                if ((fArea >= (m_stcBlobPad.fMinArea + Math.Pow(m_fTightSettingTolerance, 4))) && (fArea <= (m_stcBlobPad.fMaxArea - Math.Pow(m_fTightSettingTolerance, 4))))
                    return true;
                else
                    return false;
            }
            else
            {

                if ((fArea >= m_stcBlobPad.fMinArea) && (fArea <= m_stcBlobPad.fMaxArea))
                    return true;
                else
                    return false;
            }

        }

        /// <summary>
        /// Check whether sample object width fall within template width settings 
        /// </summary>
        /// <param name="intBlobsFeatureIndex">blobs feature index</param>
        /// <param name="fWidth">width</param>
        /// <returns>true = valid width, false = invalid width</returns>
        private bool MatchTemplateObjectsWidth(int intBlobsFeatureIndex, float fWidth)
        {
            BlobsFeatures m_stcBlobPad;
            if (m_blnWantUseGroupToleranceSetting)
            {
                int intGroupNo = ((BlobsFeatures)m_arrTemplateBlobPads[intBlobsFeatureIndex]).intGroupID;
                m_stcBlobPad = (BlobsFeatures)m_arrGroupTemplateBlobPads[intGroupNo];
            }
            else
            {
                m_stcBlobPad = (BlobsFeatures)m_arrTemplateBlobPads[intBlobsFeatureIndex];
            }

            if (m_blnWantTightSetting)
            {
                if ((fWidth >= Math.Round(m_stcBlobPad.fMinWidth + m_fTightSettingTolerance, 4)) && (fWidth <= Math.Round(m_stcBlobPad.fMaxWidth - m_fTightSettingTolerance, 4)))
                    return true;
                else
                    return false;
            }
            else
            {
                if (m_blnWantUseGroupToleranceSetting)
                {
                    if (((BlobsFeatures)m_arrTemplateBlobPads[intBlobsFeatureIndex]).blnFeretActivated)
                    {
                        if ((fWidth >= Math.Round(m_stcBlobPad.fMinWidth, 4)) && (fWidth <= Math.Round(m_stcBlobPad.fMaxWidth, 4)))
                            return true;
                        else
                        {
                            if (m_intInspectPadMode == 1 && m_intSensitivityOnPadMethod != 0) // 2021-08-02 ZJYEOH: blnAutoSensitivity
                            {
                                if (fWidth < Math.Round(m_stcBlobPad.fMinWidth, 4))
                                {
                                    if (Math.Abs(m_fSmallestFailWidthLengthValue) > Math.Abs(Math.Round(m_stcBlobPad.fMinWidth, 4) - fWidth))
                                    {
                                        m_fSmallestFailWidthLengthValue = -(float)(Math.Round(m_stcBlobPad.fMinWidth, 4) - fWidth);
                                    }
                                }
                                if (fWidth > Math.Round(m_stcBlobPad.fMaxWidth, 4))
                                {
                                    if (Math.Abs(m_fSmallestFailWidthLengthValue) > Math.Abs(Math.Round(m_stcBlobPad.fMaxWidth, 4) - fWidth))
                                    {
                                        m_fSmallestFailWidthLengthValue = -(float)(Math.Round(m_stcBlobPad.fMaxWidth, 4) - fWidth);
                                    }
                                }
                            }
                            return false;
                        }
                    }
                    else
                    {
                        // CCENG: Lengthmode ok?
                        if (((BlobsFeatures)m_arrTemplateBlobPads[intBlobsFeatureIndex]).intLengthMode == 1)
                        {
                            if ((fWidth >= Math.Round(m_stcBlobPad.fMinWidth, 4)) && (fWidth <= Math.Round(m_stcBlobPad.fMaxWidth, 4)))
                                return true;
                            else
                            {
                                if (m_intInspectPadMode == 1 && m_intSensitivityOnPadMethod != 0) // 2021-08-02 ZJYEOH: blnAutoSensitivity
                                {
                                    if (fWidth < Math.Round(m_stcBlobPad.fMinWidth, 4))
                                    {
                                        if (Math.Abs(m_fSmallestFailWidthLengthValue) > Math.Abs(Math.Round(m_stcBlobPad.fMinWidth, 4) - fWidth))
                                        {
                                            m_fSmallestFailWidthLengthValue = -(float)(Math.Round(m_stcBlobPad.fMinWidth, 4) - fWidth);
                                        }
                                    }
                                    if (fWidth > Math.Round(m_stcBlobPad.fMaxWidth, 4))
                                    {
                                        if (Math.Abs(m_fSmallestFailWidthLengthValue) > Math.Abs(Math.Round(m_stcBlobPad.fMaxWidth, 4) - fWidth))
                                        {
                                            m_fSmallestFailWidthLengthValue = -(float)(Math.Round(m_stcBlobPad.fMaxWidth, 4) - fWidth);
                                        }
                                    }
                                }
                                return false;
                            }
                        }
                        else
                        {
                            if ((fWidth >= Math.Round(m_stcBlobPad.fMinLength, 4)) && (fWidth <= Math.Round(m_stcBlobPad.fMaxLength, 4)))
                                return true;
                            else
                            {
                                if (m_intInspectPadMode == 1 && m_intSensitivityOnPadMethod != 0) // 2021-08-02 ZJYEOH: blnAutoSensitivity
                                {
                                    if (fWidth < Math.Round(m_stcBlobPad.fMinLength, 4))
                                    {
                                        if (Math.Abs(m_fSmallestFailWidthLengthValue) > Math.Abs(Math.Round(m_stcBlobPad.fMinLength, 4) - fWidth))
                                        {
                                            m_fSmallestFailWidthLengthValue = -(float)(Math.Round(m_stcBlobPad.fMinLength, 4) - fWidth);
                                        }
                                    }
                                    if (fWidth > Math.Round(m_stcBlobPad.fMaxLength, 4))
                                    {
                                        if (Math.Abs(m_fSmallestFailWidthLengthValue) > Math.Abs(Math.Round(m_stcBlobPad.fMaxLength, 4) - fWidth))
                                        {
                                            m_fSmallestFailWidthLengthValue = -(float)(Math.Round(m_stcBlobPad.fMaxLength, 4) - fWidth);
                                        }
                                    }
                                }
                                return false;
                            }
                        }
                    }
                }
                else
                {
                    // 2019 10 30 - CCENG: Since m_arrTemplateBlobPads fMinWidth, fMaxWidth, fMinHeigt, fMaxLength are not affacted by lengthmode.
                    //            - but result width height is affected by lengthmode, so need to check length mode when compare with template width height.
                    //if ((fWidth >= Math.Round(m_stcBlobPad.fMinWidth, 4)) && (fWidth <= Math.Round(m_stcBlobPad.fMaxWidth, 4)))
                    //    return true;
                    //else
                    //    return false;
                    if (((BlobsFeatures)m_arrTemplateBlobPads[intBlobsFeatureIndex]).blnFeretActivated)
                    {
                        if ((fWidth >= Math.Round(m_stcBlobPad.fMinWidth, 4)) && (fWidth <= Math.Round(m_stcBlobPad.fMaxWidth, 4)))
                            return true;
                        else
                        {
                            if (m_intInspectPadMode == 1 && m_intSensitivityOnPadMethod != 0) // 2021-08-02 ZJYEOH: blnAutoSensitivity
                            {
                                if (fWidth < Math.Round(m_stcBlobPad.fMinWidth, 4))
                                {
                                    if (Math.Abs(m_fSmallestFailWidthLengthValue) > Math.Abs(Math.Round(m_stcBlobPad.fMinWidth, 4) - fWidth))
                                    {
                                        m_fSmallestFailWidthLengthValue = -(float)(Math.Round(m_stcBlobPad.fMinWidth, 4) - fWidth);
                                    }
                                }
                                if (fWidth > Math.Round(m_stcBlobPad.fMaxWidth, 4))
                                {
                                    if (Math.Abs(m_fSmallestFailWidthLengthValue) > Math.Abs(Math.Round(m_stcBlobPad.fMaxWidth, 4) - fWidth))
                                    {
                                        m_fSmallestFailWidthLengthValue = -(float)(Math.Round(m_stcBlobPad.fMaxWidth, 4) - fWidth);
                                    }
                                }
                            }
                            return false;
                        }
                    }
                    else
                    {
                        if (((BlobsFeatures)m_arrTemplateBlobPads[intBlobsFeatureIndex]).intLengthMode == 1)
                        {
                            if ((fWidth >= Math.Round(m_stcBlobPad.fMinWidth, 4)) && (fWidth <= Math.Round(m_stcBlobPad.fMaxWidth, 4)))
                                return true;
                            else
                            {
                                if (m_intInspectPadMode == 1 && m_intSensitivityOnPadMethod != 0) // 2021-08-02 ZJYEOH: blnAutoSensitivity
                                {
                                    if (fWidth < Math.Round(m_stcBlobPad.fMinWidth, 4))
                                    {
                                        if (Math.Abs(m_fSmallestFailWidthLengthValue) > Math.Abs(Math.Round(m_stcBlobPad.fMinWidth, 4) - fWidth))
                                        {
                                            m_fSmallestFailWidthLengthValue = -(float)(Math.Round(m_stcBlobPad.fMinWidth, 4) - fWidth);
                                        }
                                    }
                                    if (fWidth > Math.Round(m_stcBlobPad.fMaxWidth, 4))
                                    {
                                        if (Math.Abs(m_fSmallestFailWidthLengthValue) > Math.Abs(Math.Round(m_stcBlobPad.fMaxWidth, 4) - fWidth))
                                        {
                                            m_fSmallestFailWidthLengthValue = -(float)(Math.Round(m_stcBlobPad.fMaxWidth, 4) - fWidth);
                                        }
                                    }
                                }
                                return false;
                            }
                        }
                        else
                        {
                            if ((fWidth >= Math.Round(m_stcBlobPad.fMinLength, 4)) && (fWidth <= Math.Round(m_stcBlobPad.fMaxLength, 4)))
                                return true;
                            else
                            {
                                if (m_intInspectPadMode == 1 && m_intSensitivityOnPadMethod != 0) // 2021-08-02 ZJYEOH: blnAutoSensitivity
                                {
                                    if (fWidth < Math.Round(m_stcBlobPad.fMinLength, 4))
                                    {
                                        if (Math.Abs(m_fSmallestFailWidthLengthValue) > Math.Abs(Math.Round(m_stcBlobPad.fMinLength, 4) - fWidth))
                                        {
                                            m_fSmallestFailWidthLengthValue = -(float)(Math.Round(m_stcBlobPad.fMinLength, 4) - fWidth);
                                        }
                                    }
                                    if (fWidth > Math.Round(m_stcBlobPad.fMaxLength, 4))
                                    {
                                        if (Math.Abs(m_fSmallestFailWidthLengthValue) > Math.Abs(Math.Round(m_stcBlobPad.fMaxLength, 4) - fWidth))
                                        {
                                            m_fSmallestFailWidthLengthValue = -(float)(Math.Round(m_stcBlobPad.fMaxLength, 4) - fWidth);
                                        }
                                    }
                                }
                                return false;
                            }
                        }
                    }
                }
            }
        }

        /// <summary>
        /// Check whether sample object height fall within template height settings 
        /// </summary>
        /// <param name="intBlobsFeatureIndex">blobs feature index</param>
        /// <param name="fHeight">height</param>
        /// <returns>true = valid height, false = invalid height</returns>
        private bool MatchTemplateObjectsHeight(int intBlobsFeatureIndex, float fHeight)
        {
            BlobsFeatures m_stcBlobPad;
            if (m_blnWantUseGroupToleranceSetting)
            {
                int intGroupNo = ((BlobsFeatures)m_arrTemplateBlobPads[intBlobsFeatureIndex]).intGroupID;
                m_stcBlobPad = (BlobsFeatures)m_arrGroupTemplateBlobPads[intGroupNo];
            }
            else
            {
                m_stcBlobPad = (BlobsFeatures)m_arrTemplateBlobPads[intBlobsFeatureIndex];
            }

            if (m_blnWantTightSetting)
            {
                if ((fHeight >= Math.Round(m_stcBlobPad.fMinLength + m_fTightSettingTolerance, 4)) && (fHeight <= Math.Round(m_stcBlobPad.fMaxLength - m_fTightSettingTolerance, 4)))
                    return true;
                else
                    return false;
            }
            else
            {
                if (m_blnWantUseGroupToleranceSetting)
                {
                    if (((BlobsFeatures)m_arrTemplateBlobPads[intBlobsFeatureIndex]).blnFeretActivated)
                    {
                        if ((fHeight >= Math.Round(m_stcBlobPad.fMinLength, 4)) && (fHeight <= Math.Round(m_stcBlobPad.fMaxLength, 4)))

                            return true;
                        else
                        {
                            if (m_intInspectPadMode == 1 && m_intSensitivityOnPadMethod != 0) // 2021-08-02 ZJYEOH: blnAutoSensitivity
                            {
                                if (fHeight < Math.Round(m_stcBlobPad.fMinLength, 4))
                                {
                                    if (Math.Abs(m_fSmallestFailWidthLengthValue) > Math.Abs(Math.Round(m_stcBlobPad.fMinLength, 4) - fHeight))
                                    {
                                        m_fSmallestFailWidthLengthValue = -(float)(Math.Round(m_stcBlobPad.fMinLength, 4) - fHeight);
                                    }
                                }
                                if (fHeight > Math.Round(m_stcBlobPad.fMaxLength, 4))
                                {
                                    if (Math.Abs(m_fSmallestFailWidthLengthValue) > Math.Abs(Math.Round(m_stcBlobPad.fMaxLength, 4) - fHeight))
                                    {
                                        m_fSmallestFailWidthLengthValue = -(float)(Math.Round(m_stcBlobPad.fMaxLength, 4) - fHeight);
                                    }
                                }
                            }
                            return false;
                        }
                    }
                    else
                    {
                        // CCENG: Lengthmode ok?
                        if (((BlobsFeatures)m_arrTemplateBlobPads[intBlobsFeatureIndex]).intLengthMode == 1)
                        {
                            if ((fHeight >= Math.Round(m_stcBlobPad.fMinLength, 4)) && (fHeight <= Math.Round(m_stcBlobPad.fMaxLength, 4)))

                                return true;
                            else
                            {
                                if (m_intInspectPadMode == 1 && m_intSensitivityOnPadMethod != 0) // 2021-08-02 ZJYEOH: blnAutoSensitivity
                                {
                                    if (fHeight < Math.Round(m_stcBlobPad.fMinLength, 4))
                                    {
                                        if (Math.Abs(m_fSmallestFailWidthLengthValue) > Math.Abs(Math.Round(m_stcBlobPad.fMinLength, 4) - fHeight))
                                        {
                                            m_fSmallestFailWidthLengthValue = -(float)(Math.Round(m_stcBlobPad.fMinLength, 4) - fHeight);
                                        }
                                    }
                                    if (fHeight > Math.Round(m_stcBlobPad.fMaxLength, 4))
                                    {
                                        if (Math.Abs(m_fSmallestFailWidthLengthValue) > Math.Abs(Math.Round(m_stcBlobPad.fMaxLength, 4) - fHeight))
                                        {
                                            m_fSmallestFailWidthLengthValue = -(float)(Math.Round(m_stcBlobPad.fMaxLength, 4) - fHeight);
                                        }
                                    }
                                }
                                return false;
                            }
                        }
                        else
                        {
                            if ((fHeight >= Math.Round(m_stcBlobPad.fMinWidth, 4)) && (fHeight <= Math.Round(m_stcBlobPad.fMaxWidth, 4)))

                                return true;
                            else
                            {
                                if (m_intInspectPadMode == 1 && m_intSensitivityOnPadMethod != 0) // 2021-08-02 ZJYEOH: blnAutoSensitivity
                                {
                                    if (fHeight < Math.Round(m_stcBlobPad.fMinWidth, 4))
                                    {
                                        if (Math.Abs(m_fSmallestFailWidthLengthValue) > Math.Abs(Math.Round(m_stcBlobPad.fMinWidth, 4) - fHeight))
                                        {
                                            m_fSmallestFailWidthLengthValue = -(float)(Math.Round(m_stcBlobPad.fMinWidth, 4) - fHeight);
                                        }
                                    }
                                    if (fHeight > Math.Round(m_stcBlobPad.fMaxWidth, 4))
                                    {
                                        if (Math.Abs(m_fSmallestFailWidthLengthValue) > Math.Abs(Math.Round(m_stcBlobPad.fMaxWidth, 4) - fHeight))
                                        {
                                            m_fSmallestFailWidthLengthValue = -(float)(Math.Round(m_stcBlobPad.fMaxWidth, 4) - fHeight);
                                        }
                                    }
                                }
                                return false;
                            }
                        }
                    }
                }
                else
                {
                    // 2019 10 30 - CCENG: Since m_arrTemplateBlobPads fMinWidth, fMaxWidth, fMinHeigt, fMaxLength are not affacted by lengthmode.
                    //            - but result width height is affected by lengthmode, so need to check length mode when compare with template width height.
                    //if ((fHeight >= Math.Round(m_stcBlobPad.fMinLength, 4)) && (fHeight <= Math.Round(m_stcBlobPad.fMaxLength, 4)))

                    //    return true;
                    //else
                    //    return false;
                    if (((BlobsFeatures)m_arrTemplateBlobPads[intBlobsFeatureIndex]).blnFeretActivated)
                    {
                        if ((fHeight >= Math.Round(m_stcBlobPad.fMinLength, 4)) && (fHeight <= Math.Round(m_stcBlobPad.fMaxLength, 4)))

                            return true;
                        else
                        {
                            if (m_intInspectPadMode == 1 && m_intSensitivityOnPadMethod != 0) // 2021-08-02 ZJYEOH: blnAutoSensitivity
                            {
                                if (fHeight < Math.Round(m_stcBlobPad.fMinLength, 4))
                                {
                                    if (Math.Abs(m_fSmallestFailWidthLengthValue) > Math.Abs(Math.Round(m_stcBlobPad.fMinLength, 4) - fHeight))
                                    {
                                        m_fSmallestFailWidthLengthValue = -(float)(Math.Round(m_stcBlobPad.fMinLength, 4) - fHeight);
                                    }
                                }
                                if (fHeight > Math.Round(m_stcBlobPad.fMaxLength, 4))
                                {
                                    if (Math.Abs(m_fSmallestFailWidthLengthValue) > Math.Abs(Math.Round(m_stcBlobPad.fMaxLength, 4) - fHeight))
                                    {
                                        m_fSmallestFailWidthLengthValue = -(float)(Math.Round(m_stcBlobPad.fMaxLength, 4) - fHeight);
                                    }
                                }
                            }
                            return false;
                        }
                    }
                    else
                    {
                        if (((BlobsFeatures)m_arrTemplateBlobPads[intBlobsFeatureIndex]).intLengthMode == 1)
                        {
                            if ((fHeight >= Math.Round(m_stcBlobPad.fMinLength, 4)) && (fHeight <= Math.Round(m_stcBlobPad.fMaxLength, 4)))

                                return true;
                            else
                            {
                                if (m_intInspectPadMode == 1 && m_intSensitivityOnPadMethod != 0) // 2021-08-02 ZJYEOH: blnAutoSensitivity
                                {
                                    if (fHeight < Math.Round(m_stcBlobPad.fMinLength, 4))
                                    {
                                        if (Math.Abs(m_fSmallestFailWidthLengthValue) > Math.Abs(Math.Round(m_stcBlobPad.fMinLength, 4) - fHeight))
                                        {
                                            m_fSmallestFailWidthLengthValue = -(float)(Math.Round(m_stcBlobPad.fMinLength, 4) - fHeight);
                                        }
                                    }
                                    if (fHeight > Math.Round(m_stcBlobPad.fMaxLength, 4))
                                    {
                                        if (Math.Abs(m_fSmallestFailWidthLengthValue) > Math.Abs(Math.Round(m_stcBlobPad.fMaxLength, 4) - fHeight))
                                        {
                                            m_fSmallestFailWidthLengthValue = -(float)(Math.Round(m_stcBlobPad.fMaxLength, 4) - fHeight);
                                        }
                                    }
                                }
                                return false;
                            }
                        }
                        else
                        {
                            if ((fHeight >= Math.Round(m_stcBlobPad.fMinWidth, 4)) && (fHeight <= Math.Round(m_stcBlobPad.fMaxWidth, 4)))

                                return true;
                            else
                            {
                                if (m_intInspectPadMode == 1 && m_intSensitivityOnPadMethod != 0) // 2021-08-02 ZJYEOH: blnAutoSensitivity
                                {
                                    if (fHeight < Math.Round(m_stcBlobPad.fMinWidth, 4))
                                    {
                                        if (Math.Abs(m_fSmallestFailWidthLengthValue) > Math.Abs(Math.Round(m_stcBlobPad.fMinWidth, 4) - fHeight))
                                        {
                                            m_fSmallestFailWidthLengthValue = -(float)(Math.Round(m_stcBlobPad.fMinWidth, 4) - fHeight);
                                        }
                                    }
                                    if (fHeight > Math.Round(m_stcBlobPad.fMaxWidth, 4))
                                    {
                                        if (Math.Abs(m_fSmallestFailWidthLengthValue) > Math.Abs(Math.Round(m_stcBlobPad.fMaxWidth, 4) - fHeight))
                                        {
                                            m_fSmallestFailWidthLengthValue = -(float)(Math.Round(m_stcBlobPad.fMaxWidth, 4) - fHeight);
                                        }
                                    }
                                }
                                return false;
                            }
                        }
                    }
                }
            }
        }

        private bool MatchTemplateObjectsLength(int intBlobsFeatureIndex, float fLength, int intLine)
        {
            BlobsFeatures m_stcBlobPad;
            if (m_blnWantUseGroupToleranceSetting)
            {
                int intGroupNo = ((BlobsFeatures)m_arrTemplateBlobPads[intBlobsFeatureIndex]).intGroupID;
                m_stcBlobPad = (BlobsFeatures)m_arrGroupTemplateBlobPads[intGroupNo];
            }
            else
            {
                m_stcBlobPad = (BlobsFeatures)m_arrTemplateBlobPads[intBlobsFeatureIndex];
            }

            float fMinLength = 0, fMaxLength = 0;
            switch (intLine)
            {
                case 3:
                    fMinLength = m_stcBlobPad.fMinLine3;
                    fMaxLength = m_stcBlobPad.fMaxLine3;
                    break;
                case 4:
                    fMinLength = m_stcBlobPad.fMinLine4;
                    fMaxLength = m_stcBlobPad.fMaxLine4;
                    break;
                case 5:
                    fMinLength = m_stcBlobPad.fMinLine5;
                    fMaxLength = m_stcBlobPad.fMaxLine5;
                    break;
                case 6:
                    fMinLength = m_stcBlobPad.fMinLine6;
                    fMaxLength = m_stcBlobPad.fMaxLine6;
                    break;
                case 7:
                    fMinLength = m_stcBlobPad.fMinLine7;
                    fMaxLength = m_stcBlobPad.fMaxLine7;
                    break;
                case 8:
                    fMinLength = m_stcBlobPad.fMinLine8;
                    fMaxLength = m_stcBlobPad.fMaxLine8;
                    break;
                case 9:
                    fMinLength = m_stcBlobPad.fMinLine9;
                    fMaxLength = m_stcBlobPad.fMaxLine9;
                    break;
                case 10:
                    fMinLength = m_stcBlobPad.fMinLine10;
                    fMaxLength = m_stcBlobPad.fMaxLine10;
                    break;
                case 11:
                    fMinLength = m_stcBlobPad.fMinLine11;
                    fMaxLength = m_stcBlobPad.fMaxLine11;
                    break;
                case 12:
                    fMinLength = m_stcBlobPad.fMinLine12;
                    fMaxLength = m_stcBlobPad.fMaxLine12;
                    break;
            }

            if (m_blnWantTightSetting)
            {
                if (fLength >= 0 && (fLength >= Math.Round(fMinLength + m_fTightSettingTolerance, 4)) && (fLength <= Math.Round(fMaxLength - m_fTightSettingTolerance, 4)))
                    return true;
                else
                    return false;
            }
            else
            {
                if (m_blnWantUseGroupToleranceSetting)
                {

                    if (fLength >= 0 && (fLength >= Math.Round(fMinLength, 4)) && (fLength <= Math.Round(fMaxLength, 4)))

                        return true;
                    else
                        return false;

                }
                else
                {
                    if (fLength >= 0 && (fLength >= Math.Round(fMinLength, 4)) && (fLength <= Math.Round(fMaxLength, 4)))
                        return true;
                    else
                        return false;
                }
            }
        }

        /// <summary>
        /// Match sample objects with m_arrTemplateBlobPads
        /// </summary>
        /// <param name="fStartX">start X position</param>
        /// <param name="fStartY">start Y position</param>
        /// <param name="fEndX">end X position</param>
        /// <param name="fEndY">end Y position</param>
        /// <param name="fCenterX">center X position</param>
        /// <param name="fCenterY">center Y position</param>
        /// <returns>-1 = not match, -2 = more than 1 match found, otherwise = m_arrTemplateBlobPads object match index</returns>
        private int Match1TemplateObjects(float fStartX, float fStartY, float fEndX, float fEndY, float fCenterX, float fCenterY)
        {
            int intMatchCount = 0;
            int intMatchNumber = -1;
            float fMatchArea = float.MaxValue;

            for (int i = 0; i < m_arrTemplateBlobPads.Count; i++)
            {
                BlobsFeatures m_stcBlobPad = (BlobsFeatures)m_arrTemplateBlobPads[i];

                // Check is sample gravity center point in template area or not
                if ((fCenterX >= m_stcBlobPad.intStartX) &&
                    (fCenterX <= m_stcBlobPad.intEndX) &&
                    (fCenterY >= m_stcBlobPad.intStartY) &&
                    (fCenterY <= m_stcBlobPad.intEndY))
                {
                    if (fMatchArea > m_stcBlobPad.fArea)    // smallest area will be chosen
                    {
                        intMatchCount++;
                        intMatchNumber = i;
                        fMatchArea = m_stcBlobPad.fArea;
                    }
                }
                // Check is template gravity center point in sample area or not
                else if ((m_stcBlobPad.fCenterX >= fStartX) &&
                    (m_stcBlobPad.fCenterX <= fEndX) &&
                    (m_stcBlobPad.fCenterY >= fStartY) &&
                    (m_stcBlobPad.fCenterY <= fEndY))
                {
                    if (fMatchArea > m_stcBlobPad.fArea)    // smallest area will be chosen
                    {
                        intMatchCount++;
                        intMatchNumber = i;
                        fMatchArea = m_stcBlobPad.fArea;
                    }
                }
            }

            if (intMatchCount == 0)
                return -1;
            else if (intMatchCount == 1)
                return intMatchNumber;
            else
                return -2;

        }


        /// <summary>
        /// Match sample objects with m_arrSampleBlobPads
        /// </summary>
        /// <param name="fStartX">start X position</param>
        /// <param name="fStartY">start Y position</param>
        /// <param name="fEndX">end X position</param>
        /// <param name="fEndY">end Y position</param>
        /// <param name="fCenterX">center X position</param>
        /// <param name="fCenterY">center Y position</param>
        /// <returns>m_arrSampleBlobPads object match index</returns>
        private List<int> MatchOrdinaryBlobsFeatures(float fStartX, float fStartY, float fEndX, float fEndY, float fCenterX, float fCenterY)
        {
            List<int> arrMatch = new List<int>();

            for (int i = 0; i < m_arrBackupBlobPads.Length; i++)
            {
                // Check is sample gravity center point in template area or not
                if ((fCenterX >= m_arrBackupBlobPads[i].fStartX) &&
                    (fCenterX <= m_arrBackupBlobPads[i].fEndX) &&
                    (fCenterY >= m_arrBackupBlobPads[i].fStartY) &&
                    (fCenterY <= m_arrBackupBlobPads[i].fEndY))
                {
                    arrMatch.Add(i);
                }
                // Check is template gravity center point in sample area or not
                else if ((m_arrBackupBlobPads[i].fCenterX >= fStartX) &&
                    (m_arrBackupBlobPads[i].fCenterX <= fEndX) &&
                    (m_arrBackupBlobPads[i].fCenterY >= fStartY) &&
                    (m_arrBackupBlobPads[i].fCenterY <= fEndY))
                {
                    arrMatch.Add(i);
                }
            }

            return arrMatch;
        }
        private List<int> MatchPreviousExtraDefectList(float fStartX, float fStartY, float fEndX, float fEndY, float fCenterX, float fCenterY)
        {
            List<int> arrMatch = new List<int>();

            for (int i = 0; i < m_arrExtraBlobs.Count; i++)
            {
                // Check is sample gravity center point in previous defect area or not
                if ((fCenterX >= m_arrExtraBlobs[i].fStartX) &&
                    (fCenterX <= m_arrExtraBlobs[i].fEndX) &&
                    (fCenterY >= m_arrExtraBlobs[i].fStartY) &&
                    (fCenterY <= m_arrExtraBlobs[i].fEndY))
                {
                    arrMatch.Add(i);
                }
                // Check is previous defect gravity center point in sample area or not
                else if ((m_arrExtraBlobs[i].fCenterX >= fStartX) &&
                    (m_arrExtraBlobs[i].fCenterX <= fEndX) &&
                    (m_arrExtraBlobs[i].fCenterY >= fStartY) &&
                    (m_arrExtraBlobs[i].fCenterY <= fEndY))
                {
                    arrMatch.Add(i);
                }
            }

            return arrMatch;
        }
        /// <summary>
        /// Match sample objects with m_arrTemplateBlobPads
        /// </summary>
        /// <param name="fStartX">start X position</param>
        /// <param name="fStartY">start Y position</param>
        /// <param name="fEndX">end X position</param>
        /// <param name="fEndY">end Y position</param>
        /// <param name="fCenterX">center X position</param>
        /// <param name="fCenterY">center Y position</param>
        /// <returns>m_arrTemplateBlobPads object match index</returns>
        private List<int> MatchTemplateObjects(float fStartX, float fStartY, float fEndX, float fEndY, float fCenterX, float fCenterY)
        {
            /*
             * Template and sample pads will easily match each other when intToleranceOffSet is high.
             * Template may match with wrong sample pads when intToleranceOffSet is high. 
             */

            List<int> arrMatch = new List<int>();
            int intToleranceOffSet = 15;
            for (int i = 0; i < m_arrTemplateBlobPads.Count; i++)
            {
                BlobsFeatures m_stcBlobPad = (BlobsFeatures)m_arrTemplateBlobPads[i];

                // Check is sample gravity center point in template area or not
                if ((fCenterX >= m_stcBlobPad.intStartX - intToleranceOffSet) &&
                    (fCenterX <= m_stcBlobPad.intEndX + intToleranceOffSet) &&
                    (fCenterY >= m_stcBlobPad.intStartY - intToleranceOffSet) &&
                    (fCenterY <= m_stcBlobPad.intEndY + intToleranceOffSet))
                {
                    arrMatch.Add(i);
                }
                // Check is template gravity center point in sample area or not
                else if ((m_stcBlobPad.fCenterX >= fStartX - intToleranceOffSet) &&
                    (m_stcBlobPad.fCenterX <= fEndX + intToleranceOffSet) &&
                    (m_stcBlobPad.fCenterY >= fStartY - intToleranceOffSet) &&
                    (m_stcBlobPad.fCenterY <= fEndY + intToleranceOffSet))
                {
                    arrMatch.Add(i);
                }
            }

            return arrMatch;
        }

        private int MatchTemplateObjects_IgnoreBigOverlapPad(float fStartX, float fStartY, float fEndX, float fEndY, float fCenterX, float fCenterY)
        {
            /*
             * Template and sample pads will easily match each other when intToleranceOffSet is high.
             * Template may match with wrong sample pads when intToleranceOffSet is high. 
             * If template heatsink pad and small pad overlap each other, this function will ignore the big one and return small pad match number only.
             */

            int intToleranceOffSet = 15;
            int intSelectedIndex = -1;
            float fClosestDiffArea = float.MaxValue;
            for (int i = 0; i < m_arrTemplateBlobPads.Count; i++)
            {
                BlobsFeatures m_stcBlobPad = (BlobsFeatures)m_arrTemplateBlobPads[i];

                bool bMatch = false;
                // Check is sample gravity center point in template area or not
                if ((fCenterX >= m_stcBlobPad.intStartX - intToleranceOffSet) &&
                    (fCenterX <= m_stcBlobPad.intEndX + intToleranceOffSet) &&
                    (fCenterY >= m_stcBlobPad.intStartY - intToleranceOffSet) &&
                    (fCenterY <= m_stcBlobPad.intEndY + intToleranceOffSet))
                {
                    bMatch = true;
                }
                // Check is template gravity center point in sample area or not
                else if ((m_stcBlobPad.fCenterX >= fStartX - intToleranceOffSet) &&
                    (m_stcBlobPad.fCenterX <= fEndX + intToleranceOffSet) &&
                    (m_stcBlobPad.fCenterY >= fStartY - intToleranceOffSet) &&
                    (m_stcBlobPad.fCenterY <= fEndY + intToleranceOffSet))
                {
                    bMatch = true;
                }

                if (bMatch)
                {
                    float fWidth = fEndX - fStartX;
                    float fHeight = fEndY - fStartY;
                    float fWidth2 = m_stcBlobPad.intEndX - m_stcBlobPad.intStartX;
                    float fHeight2 = m_stcBlobPad.intEndY - m_stcBlobPad.intStartY;
                    float fDiffArea = Math.Abs((fWidth * fHeight) - (fWidth2 * fHeight2));
                    if (fDiffArea < fClosestDiffArea)
                    {
                        fClosestDiffArea = fDiffArea;
                        intSelectedIndex = i;
                    }
                }
            }

            return intSelectedIndex;
        }

        private int MatchTemplateObjects_BasedOnPositionAndSize(float fStartX, float fStartY, float fEndX, float fEndY, float fCenterX, float fCenterY, float fWidth, float fHeight)
        {
            int intToleranceOffSet = 15;
            bool blnMatch = false;
            float fClosestSize = float.MaxValue;
            int intClosestSizeIndex = -1;

            for (int i = 0; i < m_arrBackupTemplateBlobPads.Count; i++)
            {
                if (blnMatch)
                    blnMatch = false;

                m_stcBackupTemplateBlobPad = (ToleranceBlobsFeatures)m_arrBackupTemplateBlobPads[i];

                // Check is sample gravity center point in template area or not
                if ((fCenterX >= m_stcBackupTemplateBlobPad.fStartX - intToleranceOffSet) &&
                    (fCenterX <= m_stcBackupTemplateBlobPad.fEndX + intToleranceOffSet) &&
                    (fCenterY >= m_stcBackupTemplateBlobPad.fStartY - intToleranceOffSet) &&
                    (fCenterY <= m_stcBackupTemplateBlobPad.fEndY + intToleranceOffSet))
                {
                    blnMatch = true;
                }
                // Check is template gravity center point in sample area or not
                else
                {
                    float fCenterX2 = (m_stcBackupTemplateBlobPad.fStartX + m_stcBackupTemplateBlobPad.fEndX) / 2;
                    float fCenterY2 = (m_stcBackupTemplateBlobPad.fStartY + m_stcBackupTemplateBlobPad.fEndY) / 2;

                    if ((fCenterX2 >= fStartX - intToleranceOffSet) &&
                    (fCenterX2 <= fEndX + intToleranceOffSet) &&
                    (fCenterY2 >= fStartY - intToleranceOffSet) &&
                    (fCenterY2 <= fEndY + intToleranceOffSet))
                    {
                        blnMatch = true;
                    }
                }

                if (blnMatch)
                {
                    if ((Math.Abs(fWidth - m_stcBackupTemplateBlobPad.fLearnWidth) / m_stcBackupTemplateBlobPad.fLearnWidth < 0.2) &&
                        (Math.Abs(fHeight - m_stcBackupTemplateBlobPad.fLearnWidth) / m_stcBackupTemplateBlobPad.fLearnHeight < 0.2))
                    {
                        return i;
                    }
                }

                float fDiffSize = Math.Abs(fWidth - m_stcBackupTemplateBlobPad.fLearnWidth) + Math.Abs(fHeight - m_stcBackupTemplateBlobPad.fLearnHeight);

                if (fDiffSize < fClosestSize)
                {
                    fClosestSize = fDiffSize;
                    intClosestSizeIndex = i;
                }
            }

            return intClosestSizeIndex;
        }


        private List<int> MatchTemplateObjects_Inspection(ROI objROI, float fStartX, float fStartY,
            float fEndX, float fEndY, float fWidth, float fHeight,
            float fCenterX, float fCenterY, int intArea, bool blnForExtraContamination)
        {
            int intToleranceOffSet = 10;
            List<int> arrMatch = new List<int>();
            bool blnDoubleCheck = false;
            try
            {
                for (int i = 0; i < m_arrTemplateBlobPads.Count; i++)
                {
                    BlobsFeatures m_stcBlobPad = (BlobsFeatures)m_arrTemplateBlobPads[i];

                    if (m_stcBlobPad.fWidth < 20 || m_stcBlobPad.fHeight < 20)
                        intToleranceOffSet = 10;
                    else
                        intToleranceOffSet = 0;

                    // Check is sample gravity center point in template area or not
                    if ((fCenterX >= m_stcBlobPad.intStartX - intToleranceOffSet) && // Use center point check the matching btw sample and template is not enough especially when size is small. Miss matching may happen.
                        (fCenterX <= m_stcBlobPad.intEndX + intToleranceOffSet) &&
                        (fCenterY >= m_stcBlobPad.intStartY - intToleranceOffSet) &&
                        (fCenterY <= m_stcBlobPad.intEndY + intToleranceOffSet))
                    //if (((fCenterX >= m_stcBlobPad.intStartX) && (fCenterX <= m_stcBlobPad.intEndX) && (fCenterY >= m_stcBlobPad.intStartY) && (fCenterY <= m_stcBlobPad.intEndY)) ||
                    //    ((fStartX >= m_stcBlobPad.intStartX) && (fStartX <= m_stcBlobPad.intEndX) && (fStartY >= m_stcBlobPad.intStartY) && (fStartY <= m_stcBlobPad.intEndY)) ||
                    //    ((fStartX >= m_stcBlobPad.intStartX) && (fStartX <= m_stcBlobPad.intEndX) && (fEndY >= m_stcBlobPad.intStartY) && (fEndY <= m_stcBlobPad.intEndY)) ||
                    //    ((fEndX >= m_stcBlobPad.intStartX) && (fEndX <= m_stcBlobPad.intEndX) && (fStartY >= m_stcBlobPad.intStartY) && (fStartY <= m_stcBlobPad.intEndY)) ||
                    //    ((fEndX >= m_stcBlobPad.intStartX) && (fEndX <= m_stcBlobPad.intEndX) && (fEndY >= m_stcBlobPad.intStartY) && (fEndY <= m_stcBlobPad.intEndY)))
                    {
                        arrMatch.Add(i);

                        if (!blnDoubleCheck)
                            if ((Math.Abs(fCenterX - m_stcBlobPad.fCenterX) > 10) ||
                                (Math.Abs(fCenterY - m_stcBlobPad.fCenterY) > 10) ||
                                (Math.Abs(fWidth - m_stcBlobPad.fWidth) > 10) ||
                                (Math.Abs(fHeight - m_stcBlobPad.fHeight) > 10))
                            {
                                if (intToleranceOffSet == 0)    // 2020 01 17 - CCENG: intToleranceOffSet is 0 when blob is big. For small blobs, no need double check because sometime sticker together feature cannot work
                                    blnDoubleCheck = true;
                            }
                    }
                    // Check is template gravity center point in sample area or not
                    else if ((m_stcBlobPad.fCenterX >= fStartX - intToleranceOffSet) &&
                        (m_stcBlobPad.fCenterX <= fEndX + intToleranceOffSet) &&
                        (m_stcBlobPad.fCenterY >= fStartY - intToleranceOffSet) &&
                        (m_stcBlobPad.fCenterY <= fEndY + intToleranceOffSet))
                    //else if (((m_stcBlobPad.fCenterX >= fStartX) && (m_stcBlobPad.fCenterX <= fEndX) && (m_stcBlobPad.fCenterY >= fStartY) && (m_stcBlobPad.fCenterY <= fEndY)) ||
                    //    ((m_stcBlobPad.fStartX >= fStartX) && (m_stcBlobPad.fStartX <= fEndX) && (m_stcBlobPad.fStartY >= fStartY) && (m_stcBlobPad.fStartY <= fEndY)) ||
                    //    ((m_stcBlobPad.fStartX >= fStartX) && (m_stcBlobPad.fStartX <= fEndX) && (m_stcBlobPad.fEndY >= fStartY) && (m_stcBlobPad.fEndY <= fEndY)) ||
                    //    ((m_stcBlobPad.fEndX >= fStartX) && (m_stcBlobPad.fEndX <= fEndX) && (m_stcBlobPad.fStartY >= fStartY) && (m_stcBlobPad.fStartY <= fEndY)) ||
                    //    ((m_stcBlobPad.fEndX >= fStartX) && (m_stcBlobPad.fEndX <= fEndX) && (m_stcBlobPad.fEndY >= fStartY) && (m_stcBlobPad.fEndY <= fEndY)))
                    {
                        arrMatch.Add(i);

                        if (!blnDoubleCheck)
                            if ((Math.Abs(fCenterX - m_stcBlobPad.fCenterX) > 5) ||
                                (Math.Abs(fCenterY - m_stcBlobPad.fCenterY) > 5) ||
                                (Math.Abs(fWidth - m_stcBlobPad.fWidth) > 5) ||
                                (Math.Abs(fHeight - m_stcBlobPad.fHeight) > 5))
                            {
                                blnDoubleCheck = true;
                            }
                    }
                }

            }
            catch (Exception ex)
            {
                TrackLog objTL = new TrackLog();
                objTL.WriteLine("MatchTemplateObjects3 Exception Error: " + ex.ToString());
            }


            bool blnDebugImage = false;

            // Double check
            if (blnDoubleCheck)
            {
                //ROI objSampBlobROI = new ROI();   // 2018 09 19 - CCENG: Dun use local ROI, it will consume additional 1.5ms.
                m_objLocalROI.AttachImage(objROI);
                m_objLocalROI.LoadROISetting((int)fStartX, (int)fStartY, (int)(fEndX - fStartX), (int)(fEndY - fStartY));

                if (blnDebugImage)
                {
                    m_objLocalROI.SaveImage("D:\\TS\\1. objSampleBlobROI.bmp");// debug
                }

                //ROI objTempBlobROI = new ROI();   // 2018 09 19 - CCENG: Dun use local ROI, it will consume additional 1.5ms.

                // Double check is match index correct or not by using sample and templete blobs subtraction
                for (int i = 0; i < arrMatch.Count; i++)
                {
                    BlobsFeatures m_stcBlobPad = (BlobsFeatures)m_arrTemplateBlobPads[arrMatch[i]];
                    m_objLocalROI2.ref_ROI.Detach();
                    m_objLocalROI2.ref_ROI.Attach(m_arrImgPadImage[arrMatch[i]]);
                    m_objLocalROI2.LoadROISetting(m_stcBlobPad.intStartX, m_stcBlobPad.intStartY,
                                                  (m_stcBlobPad.intEndX - m_stcBlobPad.intStartX),
                                                  (m_stcBlobPad.intEndY - m_stcBlobPad.intStartY));

                    if (blnDebugImage)
                    {
                        m_arrImgPadImage[arrMatch[i]].Save("D:\\TS\\2.m_arrImgPadImage" + arrMatch[i].ToString() + ".bmp");// debug
                        m_objLocalROI2.SaveImage("D:\\TS\\3.m_objLocalROI2.bmp");// debug
                    }

                    //STTrackLog.WriteLine("Before In");
                    //for (int k = 0; k < 10000
                    //    ; k++)
                    //{
                    //    IsObjectStickTogether_EBlob(objROI, objSampBlobROI, objTempBlobROI, intArea, fCenterX, fCenterY);
                    //}
                    if (blnForExtraContamination)
                    {
                        if (!IsObjectStickTogether_EBlob_WithDilateWidth(objROI, m_objLocalROI, m_objLocalROI2, intArea, fCenterX, fCenterY))
                        {
                            // Remove from list if no stick together
                            arrMatch.RemoveAt(i);
                            i--;
                        }
                    }
                    else
                    {
                        if (!IsObjectStickTogether_EBlob(objROI, m_objLocalROI, m_objLocalROI2, intArea, fCenterX, fCenterY))
                        {
                            // Remove from list if no stick together
                            arrMatch.RemoveAt(i);
                            i--;
                        }
                    }
                    //STTrackLog.WriteLine("After out");

                }
                //objSampBlobROI.Dispose();
                //objTempBlobROI.Dispose();
            }

            return arrMatch;
        }
        //private List<int> MatchTemplateObjects_Inspection2(ROI objROI, float fStartX, float fStartY,
        //    float fEndX, float fEndY, float fWidth, float fHeight,
        //    float fCenterX, float fCenterY, int intArea)
        //{
        //    int intToleranceOffSet = 10;
        //    List<int> arrMatch = new List<int>();
        //    bool blnDoubleCheck = false;
        //    try
        //    {
        //        for (int i = 0; i < m_arrTemplateBlobPads.Count; i++)
        //        {
        //            BlobsFeatures m_stcBlobPad = (BlobsFeatures)m_arrTemplateBlobPads[i];

        //            if (m_stcBlobPad.fWidth < 20 || m_stcBlobPad.fHeight < 20)
        //                intToleranceOffSet = 10;
        //            else
        //                intToleranceOffSet = 0;

        //            float fDistanceX = 0, fDistanceY = 0;
        //            if (m_blnWantGaugeMeasurePkgSize)
        //            {
        //                //fTotalOffSetX += m_stcBlobPad.fXDistance - (objSampleROI.ref_ROITotalX + m_arrSampleBlobPads[i].fCenterX - GetResultCenterPoint_RectGauge4L().X);
        //                //fTotalOffSetY += m_stcBlobPad.fYDistance - (objSampleROI.ref_ROITotalY + m_arrSampleBlobPads[i].fCenterY - GetResultCenterPoint_RectGauge4L().Y);

        //                if (m_intPadOffsetReferencePoint == 0)
        //                {
        //                    fTotalOffSetX += (m_stcBlobPad.fLimitCenterX - m_stcBlobPad.fTemplateROICenterX) - (objSampleROI.ref_ROITotalX + m_arrSampleBlobPads[i].fCenterX - GetResultCenterPoint_RectGauge4L().X);
        //                    fTotalOffSetY += (m_stcBlobPad.fLimitCenterY - m_stcBlobPad.fTemplateROICenterY) - (objSampleROI.ref_ROITotalY + m_arrSampleBlobPads[i].fCenterY - GetResultCenterPoint_RectGauge4L().Y);
        //                }
        //                else
        //                {
        //                    fTotalOffSetX += (m_stcBlobPad.fLimitCenterX - m_stcBlobPad.fTemplateROITopLeftCornerX) - (objSampleROI.ref_ROITotalX + m_arrSampleBlobPads[i].fCenterX - GetResultTopLeftCornerPoint_RectGauge4L().X);
        //                    fTotalOffSetY += (m_stcBlobPad.fLimitCenterY - m_stcBlobPad.fTemplateROITopLeftCornerY) - (objSampleROI.ref_ROITotalY + m_arrSampleBlobPads[i].fCenterY - GetResultTopLeftCornerPoint_RectGauge4L().Y);
        //                }
        //            }
        //            else
        //            {
        //                //fTotalOffSetX += m_stcBlobPad.fXDistance - (objSampleROI.ref_ROITotalX + m_arrSampleBlobPads[i].fCenterX - m_pUnitCenterPoint.X);
        //                //fTotalOffSetY += m_stcBlobPad.fYDistance - (objSampleROI.ref_ROITotalY + m_arrSampleBlobPads[i].fCenterY - m_pUnitCenterPoint.Y);

        //                if (m_intPadOffsetReferencePoint == 0)
        //                {
        //                    fTotalOffSetX += (m_stcBlobPad.fLimitCenterX - m_stcBlobPad.fTemplateROICenterX) - (objSampleROI.ref_ROITotalX + m_arrSampleBlobPads[i].fCenterX - m_pUnitCenterPoint.X);
        //                    fTotalOffSetY += (m_stcBlobPad.fLimitCenterY - m_stcBlobPad.fTemplateROICenterY) - (objSampleROI.ref_ROITotalY + m_arrSampleBlobPads[i].fCenterY - m_pUnitCenterPoint.Y);
        //                }
        //                else
        //                {
        //                    fTotalOffSetX += (m_stcBlobPad.fLimitCenterX - m_stcBlobPad.fTemplateROITopLeftCornerX) - (objSampleROI.ref_ROITotalX + m_arrSampleBlobPads[i].fCenterX - GetResultTopLeftCornerPoint_UnitMatcher().X);
        //                    fTotalOffSetY += (m_stcBlobPad.fLimitCenterY - m_stcBlobPad.fTemplateROITopLeftCornerY) - (objSampleROI.ref_ROITotalY + m_arrSampleBlobPads[i].fCenterY - GetResultTopLeftCornerPoint_UnitMatcher().Y);
        //                }
        //            }
                     

        //            // Check is sample gravity center point in template area or not
        //            if (((objROI.ref_ROITotalX + fCenterX - ) >= (m_stcBlobPad.intStartX - intToleranceOffSet)) && // Use center point check the matching btw sample and template is not enough especially when size is small. Miss matching may happen.
        //                ((objROI.ref_ROITotalX + fCenterX) <= (m_stcBlobPad.intEndX + intToleranceOffSet)) &&
        //                ((objROI.ref_ROITotalY + fCenterY) >= (m_stcBlobPad.intStartY - intToleranceOffSet)) &&
        //                ((objROI.ref_ROITotalY + fCenterY) <= (m_stcBlobPad.intEndY + intToleranceOffSet)))
        //            {
        //                arrMatch.Add(i);

        //                if (!blnDoubleCheck)
        //                    if ((Math.Abs(fCenterX - m_stcBlobPad.fCenterX) > 10) ||
        //                        (Math.Abs(fCenterY - m_stcBlobPad.fCenterY) > 10) ||
        //                        (Math.Abs(fWidth - m_stcBlobPad.fWidth) > 10) ||
        //                        (Math.Abs(fHeight - m_stcBlobPad.fHeight) > 10))
        //                    {
        //                        if (intToleranceOffSet == 0)    // 2020 01 17 - CCENG: intToleranceOffSet is 0 when blob is big. For small blobs, no need double check because sometime sticker together feature cannot work
        //                            blnDoubleCheck = true;
        //                    }
        //            }
        //            // Check is template gravity center point in sample area or not
        //            else if ((m_stcBlobPad.fCenterX >= fStartX - intToleranceOffSet) &&
        //                (m_stcBlobPad.fCenterX <= fEndX + intToleranceOffSet) &&
        //                (m_stcBlobPad.fCenterY >= fStartY - intToleranceOffSet) &&
        //                (m_stcBlobPad.fCenterY <= fEndY + intToleranceOffSet))
        //            {
        //                arrMatch.Add(i);

        //                if (!blnDoubleCheck)
        //                    if ((Math.Abs(fCenterX - m_stcBlobPad.fCenterX) > 5) ||
        //                        (Math.Abs(fCenterY - m_stcBlobPad.fCenterY) > 5) ||
        //                        (Math.Abs(fWidth - m_stcBlobPad.fWidth) > 5) ||
        //                        (Math.Abs(fHeight - m_stcBlobPad.fHeight) > 5))
        //                    {
        //                        blnDoubleCheck = true;
        //                    }
        //            }
        //        }

        //    }
        //    catch (Exception ex)
        //    {
        //        TrackLog objTL = new TrackLog();
        //        objTL.WriteLine("MatchTemplateObjects3 Exception Error: " + ex.ToString());
        //    }


        //    bool blnDebugImage = false;

        //    // Double check
        //    if (blnDoubleCheck)
        //    {
        //        //ROI objSampBlobROI = new ROI();   // 2018 09 19 - CCENG: Dun use local ROI, it will consume additional 1.5ms.
        //        m_objLocalROI.AttachImage(objROI);
        //        m_objLocalROI.LoadROISetting((int)fStartX, (int)fStartY, (int)(fEndX - fStartX), (int)(fEndY - fStartY));

        //        if (blnDebugImage)
        //        {
        //            m_objLocalROI.SaveImage("D:\\TS\\1. objSampleBlobROI.bmp");// debug
        //        }

        //        //ROI objTempBlobROI = new ROI();   // 2018 09 19 - CCENG: Dun use local ROI, it will consume additional 1.5ms.

        //        // Double check is match index correct or not by using sample and templete blobs subtraction
        //        for (int i = 0; i < arrMatch.Count; i++)
        //        {
        //            BlobsFeatures m_stcBlobPad = (BlobsFeatures)m_arrTemplateBlobPads[arrMatch[i]];
        //            m_objLocalROI2.ref_ROI.Detach();
        //            m_objLocalROI2.ref_ROI.Attach(m_arrImgPadImage[arrMatch[i]]);
        //            m_objLocalROI2.LoadROISetting(m_stcBlobPad.intStartX, m_stcBlobPad.intStartY,
        //                                          (m_stcBlobPad.intEndX - m_stcBlobPad.intStartX),
        //                                          (m_stcBlobPad.intEndY - m_stcBlobPad.intStartY));

        //            if (blnDebugImage)
        //            {
        //                m_arrImgPadImage[arrMatch[i]].Save("D:\\TS\\2.m_arrImgPadImage" + arrMatch[i].ToString() + ".bmp");// debug
        //                m_objLocalROI2.SaveImage("D:\\TS\\3.m_objLocalROI2.bmp");// debug
        //            }

        //            //STTrackLog.WriteLine("Before In");
        //            //for (int k = 0; k < 10000
        //            //    ; k++)
        //            //{
        //            //    IsObjectStickTogether_EBlob(objROI, objSampBlobROI, objTempBlobROI, intArea, fCenterX, fCenterY);
        //            //}
        //            if (!IsObjectStickTogether_EBlob(objROI, m_objLocalROI, m_objLocalROI2, intArea, fCenterX, fCenterY))
        //            {
        //                // Remove from list if no stick together
        //                arrMatch.RemoveAt(i);
        //                i--;
        //            }

        //            //STTrackLog.WriteLine("After out");

        //        }
        //        //objSampBlobROI.Dispose();
        //        //objTempBlobROI.Dispose();
        //    }

        //    return arrMatch;
        //}


        private void MatchTemplateObjects(float fStartX, float fStartY, float fEndX, float fEndY, float fCenterX, float fCenterY, List<List<PointF>> arrDontCare,
                                       ref List<int> arrMatch, ref List<int> arrMatchType)
        {
            int intMatchCount = 0;
            arrMatch = new List<int>();
            arrMatchType = new List<int>();

            //Check is in Don't Care area or not
            for (int j = 0; j < arrDontCare.Count; j++)
            {
                float fCareStartX = ((PointF)arrDontCare[j][0]).X;
                float fCareStartY = ((PointF)arrDontCare[j][0]).Y;

                float fCareEndX = ((PointF)arrDontCare[j][1]).X;
                float fCareEndY = ((PointF)arrDontCare[j][1]).Y;

                if ((fCenterX >= fCareStartX) && (fCenterX <= fCareEndX) &&
                    (fCenterY >= fCareStartY) && (fCenterY <= fCareEndY))
                {
                    arrMatch.Add(-3);
                    arrMatchType.Add(-3);
                }
            }

            arrMatch.Clear();

            for (int i = 0; i < m_arrTemplateBlobPads.Count; i++)
            {
                BlobsFeatures m_stcBlobPad = (BlobsFeatures)m_arrTemplateBlobPads[i];

                // Check is sample gravity center point in template area or not
                if ((fCenterX >= m_stcBlobPad.intStartX) &&
                    (fCenterX <= m_stcBlobPad.intEndX) &&
                    (fCenterY >= m_stcBlobPad.intStartY) &&
                    (fCenterY <= m_stcBlobPad.intEndY))
                {
                    m_intTemplateMatchStatus[i]++;
                    intMatchCount++;
                    arrMatch.Add(i);
                    arrMatchType.Add(0);
                }
                // Check is template gravity center point in sample area or not
                else if ((m_stcBlobPad.fCenterX >= fStartX) &&
                    (m_stcBlobPad.fCenterX <= fEndX) &&
                    (m_stcBlobPad.fCenterY >= fStartY) &&
                    (m_stcBlobPad.fCenterY <= fEndY))
                {
                    m_intTemplateMatchStatus[i]++;
                    intMatchCount++;
                    arrMatch.Add(i);
                    arrMatchType.Add(1);
                }
            }

            if (intMatchCount == 0)
            {
                arrMatch.Add(-1);
                arrMatchType.Add(-1);
            }
        }

        /// <summary>
        ///  Match sample objects with m_arrTemplateBlobPads and skip if objects fall in don't care area
        /// </summary>
        /// <param name="fStartX">start X position</param>
        /// <param name="fStartY">start Y position</param>
        /// <param name="fEndX">end X position</param>
        /// <param name="fEndY">end Y position</param>
        /// <param name="fCenterX">center X position</param>
        /// <param name="fCenterY">center Y position</param>
        /// <param name="arrDontCare">don't care area points</param>
        /// <returns>-1 = no match found, otherwise = m_arrTemplateBlobPads object match index</returns>
        private List<int> MatchTemplateObjects(float fStartX, float fStartY, float fEndX, float fEndY, float fCenterX, float fCenterY, List<List<PointF>> arrDontCare)
        {
            int intMatchCount = 0;
            List<int> arrMatch = new List<int>();

            //Check is in Don't Care area or not
            for (int j = 0; j < arrDontCare.Count; j++)
            {
                float fCareStartX = ((PointF)arrDontCare[j][0]).X;
                float fCareStartY = ((PointF)arrDontCare[j][0]).Y;

                float fCareEndX = ((PointF)arrDontCare[j][1]).X;
                float fCareEndY = ((PointF)arrDontCare[j][1]).Y;

                if ((fCenterX >= fCareStartX) && (fCenterX <= fCareEndX) &&
                    (fCenterY >= fCareStartY) && (fCenterY <= fCareEndY))
                {
                    arrMatch.Add(-3);
                    return arrMatch;
                }
            }

            arrMatch.Clear();

            for (int i = 0; i < m_arrTemplateBlobPads.Count; i++)
            {
                BlobsFeatures m_stcBlobPad = (BlobsFeatures)m_arrTemplateBlobPads[i];

                // Check is sample gravity center point in template area or not
                if ((fCenterX >= m_stcBlobPad.intStartX) &&
                    (fCenterX <= m_stcBlobPad.intEndX) &&
                    (fCenterY >= m_stcBlobPad.intStartY) &&
                    (fCenterY <= m_stcBlobPad.intEndY))
                {
                    m_intTemplateMatchStatus[i]++;
                    intMatchCount++;
                    arrMatch.Add(i);
                }
                // Check is template gravity center point in sample area or not
                else if ((m_stcBlobPad.fCenterX >= fStartX) &&
                    (m_stcBlobPad.fCenterX <= fEndX) &&
                    (m_stcBlobPad.fCenterY >= fStartY) &&
                    (m_stcBlobPad.fCenterY <= fEndY))
                {
                    m_intTemplateMatchStatus[i]++;
                    intMatchCount++;
                    arrMatch.Add(i);
                }
            }

            if (intMatchCount == 0)
            {
                arrMatch.Add(-1);
            }

            return arrMatch;
        }

        private bool IsObjectStickTogether_EBlob(ROI objUnitROI1, ROI objBlobROI1, ROI objBlobROI2, int intArea, float fCenterX, float fCenterY)
        {
            /*
             * Using blobs StartX and EndX to do subtraction.
             */

            try
            {
                bool blnDebugImage = false;

                objUnitROI1.CopyToImage(ref m_objDestImage);

                ROI objSourceROI = new ROI();
                objSourceROI.AttachImage(objUnitROI1);
                objSourceROI.LoadROISetting(objBlobROI2.ref_ROIPositionX, objBlobROI2.ref_ROIPositionY, objBlobROI2.ref_ROIWidth, objBlobROI2.ref_ROIHeight);

                ROI objDestROI = new ROI();
                objDestROI.AttachImage(m_objDestImage);
                objDestROI.LoadROISetting(objBlobROI2.ref_ROIPositionX, objBlobROI2.ref_ROIPositionY, objBlobROI2.ref_ROIWidth, objBlobROI2.ref_ROIHeight);

                if (blnDebugImage)
                {
                    objUnitROI1.SaveImage("D:\\TS\\UnitROI.bmp");// debug
                    objSourceROI.ref_ROI.Save("D:\\TS\\objSourceROI.bmp");// debug
                    objBlobROI2.ref_ROI.Save("D:\\TS\\objBlobROI2.bmp");// debug
                    objDestROI.ref_ROI.Save("D:\\TS\\objDestROI.bmp");// debug
                }

                if ((objSourceROI.ref_ROIWidth != objBlobROI2.ref_ROIWidth) || (objSourceROI.ref_ROIHeight != objBlobROI2.ref_ROIHeight) ||
                    (objDestROI.ref_ROIWidth != objBlobROI2.ref_ROIWidth) || (objDestROI.ref_ROIHeight != objBlobROI2.ref_ROIHeight))
                {
                    // If ROI sizes are different, Return true to assume object stick together. 
                    // Return false may cause "escape unit" issue happen.
                    // In normal case, different ROI sizes should not happen. If happen, mean user need to relearn the image.
                    return true;
                }

                EasyImage.Oper(EArithmeticLogicOperation.Subtract, objSourceROI.ref_ROI, objBlobROI2.ref_ROI, objDestROI.ref_ROI);

                if (blnDebugImage)
                {
                    objDestROI.ref_ROI.Save("D:\\TS\\objDestROI1.bmp");// debug
                }

                objDestROI.LoadROISetting(0, 0, m_objDestImage.ref_intImageWidth, m_objDestImage.ref_intImageHeight);

                if (blnDebugImage)
                {
                    objDestROI.ref_ROI.Save("D:\\TS\\objDestROI2.bmp");// debug
                }

                m_objLocalUsedBlobs.BuildObjects_Filter_GetElement(objDestROI, !m_blnWhiteOnBlack, true, 0, m_objEBlobs.ref_intAbsoluteThreshold,
                    Convert.ToInt32(Math.Floor(m_fBlobsMinArea)), m_intMaxArea, false, 0x03);

                int intBlobArea = 0;
                float fGravityCenterX = 0f, fGravityCenterY = 0f;
                for (int i = 0; i < m_objLocalUsedBlobs.ref_intNumSelectedObject; i++)
                {
                    intBlobArea = m_objLocalUsedBlobs.ref_arrArea[i];
                    fGravityCenterX = m_objLocalUsedBlobs.ref_arrGravityCenterX[i];
                    fGravityCenterY = m_objLocalUsedBlobs.ref_arrGravityCenterY[i];
                    if ((intArea == intBlobArea) &&
                        (fCenterX == fGravityCenterX) &&
                        (fCenterY == fGravityCenterY))
                    {
                        objSourceROI.Dispose();
                        objDestROI.Dispose();
                        return false;
                    }
                }

                objSourceROI.Dispose();
                objDestROI.Dispose();
            }
            catch (Exception ex)
            {
                SRMMessageBox.Show("IsObjectStickTogether() -> " + ex.ToString());
            }
            return true;
        }
        private bool IsObjectStickTogether_EBlob_WithDilateWidth(ROI objUnitROI1, ROI objBlobROI1, ROI objBlobROI2, int intArea, float fCenterX, float fCenterY)
        {
            /*
             * Using blobs StartX and EndX to do subtraction.
             */

            try
            {
                bool blnDebugImage = false;

                objUnitROI1.CopyToImage(ref m_objDestImage);

                ROI objSourceROI = new ROI();
                objSourceROI.AttachImage(objUnitROI1);
                objSourceROI.LoadROISetting(objBlobROI2.ref_ROIPositionX, objBlobROI2.ref_ROIPositionY, objBlobROI2.ref_ROIWidth, objBlobROI2.ref_ROIHeight);

                ROI objDestROI = new ROI();
                objDestROI.AttachImage(m_objDestImage);
                objDestROI.LoadROISetting(objBlobROI2.ref_ROIPositionX, objBlobROI2.ref_ROIPositionY, objBlobROI2.ref_ROIWidth, objBlobROI2.ref_ROIHeight);

                if (blnDebugImage)
                {
                    objUnitROI1.SaveImage("D:\\TS\\UnitROI.bmp");// debug
                    objSourceROI.ref_ROI.Save("D:\\TS\\objSourceROI.bmp");// debug
                    objBlobROI2.ref_ROI.Save("D:\\TS\\objBlobROI2.bmp");// debug
                    objDestROI.ref_ROI.Save("D:\\TS\\objDestROI.bmp");// debug
                }

                if ((objSourceROI.ref_ROIWidth != objBlobROI2.ref_ROIWidth) || (objSourceROI.ref_ROIHeight != objBlobROI2.ref_ROIHeight) ||
                    (objDestROI.ref_ROIWidth != objBlobROI2.ref_ROIWidth) || (objDestROI.ref_ROIHeight != objBlobROI2.ref_ROIHeight))
                {
                    // If ROI sizes are different, Return true to assume object stick together. 
                    // Return false may cause "escape unit" issue happen.
                    // In normal case, different ROI sizes should not happen. If happen, mean user need to relearn the image.
                    return true;
                }

                EasyImage.Oper(EArithmeticLogicOperation.Subtract, objSourceROI.ref_ROI, objBlobROI2.ref_ROI, objDestROI.ref_ROI);

                if (blnDebugImage)
                {
                    objDestROI.ref_ROI.Save("D:\\TS\\objDestROI1.bmp");// debug
                }

                objDestROI.LoadROISetting(0, 0, m_objDestImage.ref_intImageWidth, m_objDestImage.ref_intImageHeight);

                if (blnDebugImage)
                {
                    objDestROI.ref_ROI.Save("D:\\TS\\objDestROI2.bmp");// debug
                }

                m_objLocalUsedBlobs.BuildObjects_Filter_GetElement(objDestROI, !m_blnWhiteOnBlack, true, 0, m_objEBlobs.ref_intAbsoluteThreshold,
                    Convert.ToInt32(Math.Floor(m_fBlobsMinArea)), m_intMaxArea, false, 0x03);

                int intBlobArea = 0;
                float fGravityCenterX = 0f, fGravityCenterY = 0f;
                for (int i = 0; i < m_objLocalUsedBlobs.ref_intNumSelectedObject; i++)
                {
                    intBlobArea = m_objLocalUsedBlobs.ref_arrArea[i];
                    fGravityCenterX = m_objLocalUsedBlobs.ref_arrGravityCenterX[i];
                    fGravityCenterY = m_objLocalUsedBlobs.ref_arrGravityCenterY[i];
                    if ((intArea == intBlobArea) &&
                        (Math.Abs(fCenterX - fGravityCenterX) <= (m_intMPDilateHalfWidth + 1)) &&
                        (Math.Abs(fCenterY - fGravityCenterY) <= (m_intMPDilateHalfWidth + 1)))
                    {
                        objSourceROI.Dispose();
                        objDestROI.Dispose();
                        return false;
                    }
                }

                objSourceROI.Dispose();
                objDestROI.Dispose();
            }
            catch (Exception ex)
            {
                SRMMessageBox.Show("IsObjectStickTogether() -> " + ex.ToString());
            }
            return true;
        }
        /// <summary>
        /// Check whether sample objects fall in don't care area
        /// </summary>
        /// <param name="fCenterX">object gravity center X</param>
        /// <param name="fCenterY">object gravity center Y</param>
        /// <param name="arrDontCare">don't care area points</param>
        /// <returns>true = fall in don't care area, false = fall in don't care area</returns>
        private bool IsInDontCareArea(float fCenterX, float fCenterY, List<List<PointF>> arrDontCare)
        {
            //Check is in Don't Care area or not
            for (int j = 0; j < arrDontCare.Count; j++)
            {
                if ((fCenterX >= arrDontCare[j][0].X) && (fCenterX <= arrDontCare[j][1].X) &&
                    (fCenterY >= arrDontCare[j][0].Y) && (fCenterY <= arrDontCare[j][1].Y))
                {
                    return true;
                }
            }

            return false;
        }



        /// <summary>
        /// Check contamination within ROI
        /// </summary>
        /// <param name="objROI">ROI</param>
        private void CheckExcessPad(ROI objSampleROI)
        {
            bool blnDebugImage = false;

            if (blnDebugImage)
            {
                objSampleROI.SaveImage("D:\\TS\\0.objSampleROI.bmp");
            }

            // Get sample pad average offset value
            float fTotalOffSetX = 0;
            float fTotalOffSetY = 0;
            for (int i = 0; i < m_arrSampleBlobPads.Length; i++)
            {
                BlobsFeatures m_stcBlobPad = (BlobsFeatures)m_arrTemplateBlobPads[i];

                if (GetOverallWantGaugeMeasurePkgSize(false))
                {
                    if (m_stcBlobPad.fTemplateROICenterX == 0 && m_stcBlobPad.fTemplateROICenterY == 0 && m_stcBlobPad.fTemplateROITopLeftCornerX == 0 && m_stcBlobPad.fTemplateROITopLeftCornerY == 0)
                    {
                        fTotalOffSetX += m_stcBlobPad.fXDistance - (objSampleROI.ref_ROITotalX + m_arrSampleBlobPads[i].fCenterX - GetResultCenterPoint_RectGauge4L().X);
                        fTotalOffSetY += m_stcBlobPad.fYDistance - (objSampleROI.ref_ROITotalY + m_arrSampleBlobPads[i].fCenterY - GetResultCenterPoint_RectGauge4L().Y);
                    }
                    else
                    {
                        if (m_intPadOffsetReferencePoint == 0)
                        {
                            fTotalOffSetX += (m_stcBlobPad.fLimitCenterX - m_stcBlobPad.fTemplateROICenterX) - (objSampleROI.ref_ROITotalX + m_arrSampleBlobPads[i].fCenterX - GetResultCenterPoint_RectGauge4L().X);
                            fTotalOffSetY += (m_stcBlobPad.fLimitCenterY - m_stcBlobPad.fTemplateROICenterY) - (objSampleROI.ref_ROITotalY + m_arrSampleBlobPads[i].fCenterY - GetResultCenterPoint_RectGauge4L().Y);
                        }
                        else
                        {
                            fTotalOffSetX += (m_stcBlobPad.fLimitCenterX - m_stcBlobPad.fTemplateROITopLeftCornerX) - (objSampleROI.ref_ROITotalX + m_arrSampleBlobPads[i].fCenterX - GetResultTopLeftCornerPoint_RectGauge4L().X);
                            fTotalOffSetY += (m_stcBlobPad.fLimitCenterY - m_stcBlobPad.fTemplateROITopLeftCornerY) - (objSampleROI.ref_ROITotalY + m_arrSampleBlobPads[i].fCenterY - GetResultTopLeftCornerPoint_RectGauge4L().Y);
                        }
                    }
                }
                else
                {
                    if (m_stcBlobPad.fTemplateROICenterX_Pattern == 0 && m_stcBlobPad.fTemplateROICenterY_Pattern == 0 && m_stcBlobPad.fTemplateROITopLeftCornerX_Pattern == 0 && m_stcBlobPad.fTemplateROITopLeftCornerY_Pattern == 0)
                    {
                        fTotalOffSetX += m_stcBlobPad.fXDistance_Pattern - (objSampleROI.ref_ROITotalX + m_arrSampleBlobPads[i].fCenterX - m_pUnitCenterPoint.X);
                        fTotalOffSetY += m_stcBlobPad.fYDistance_Pattern - (objSampleROI.ref_ROITotalY + m_arrSampleBlobPads[i].fCenterY - m_pUnitCenterPoint.Y);
                    }
                    else
                    {
                        if (m_intPadOffsetReferencePoint == 0)
                        {
                            fTotalOffSetX += (m_stcBlobPad.fLimitCenterX - m_stcBlobPad.fTemplateROICenterX_Pattern) - (objSampleROI.ref_ROITotalX + m_arrSampleBlobPads[i].fCenterX - m_pUnitCenterPoint.X);
                            fTotalOffSetY += (m_stcBlobPad.fLimitCenterY - m_stcBlobPad.fTemplateROICenterY_Pattern) - (objSampleROI.ref_ROITotalY + m_arrSampleBlobPads[i].fCenterY - m_pUnitCenterPoint.Y);
                        }
                        else
                        {
                            fTotalOffSetX += (m_stcBlobPad.fLimitCenterX - m_stcBlobPad.fTemplateROITopLeftCornerX_Pattern) - (objSampleROI.ref_ROITotalX + m_arrSampleBlobPads[i].fCenterX - GetResultTopLeftCornerPoint_UnitMatcher().X);
                            fTotalOffSetY += (m_stcBlobPad.fLimitCenterY - m_stcBlobPad.fTemplateROITopLeftCornerY_Pattern) - (objSampleROI.ref_ROITotalY + m_arrSampleBlobPads[i].fCenterY - GetResultTopLeftCornerPoint_UnitMatcher().Y);
                        }
                    }
                }


            }
            int intAverageOffSetX = (int)Math.Round(fTotalOffSetX / m_arrSampleBlobPads.Length, 0, MidpointRounding.AwayFromZero);
            int intAverageOffSetY = (int)Math.Round(fTotalOffSetY / m_arrSampleBlobPads.Length, 0, MidpointRounding.AwayFromZero);

            // Reassign sample ROI to make sure sample pads has almost zero offset with template pads before do the subtration. 
            ROI objROI = new ROI();
            objROI.ref_ROI.Detach();
            objROI.ref_ROI.Attach(objSampleROI.ref_ROI.Parent);
            objROI.LoadROISetting(objSampleROI.ref_ROIPositionX - intAverageOffSetX, objSampleROI.ref_ROIPositionY - intAverageOffSetY,
                                objSampleROI.ref_ROIWidth, objSampleROI.ref_ROIHeight);

            if (blnDebugImage)
            {
                objROI.SaveImage("D:\\TS\\1.objROI.bmp");
            }

            bool blnCheckPadUsingLengthSetting = true;
            try
            {
                // Init
                List<int> arrMultipleMatchNo = new List<int>();
                List<float> arrMultipleMatchArea = new List<float>();
                m_objContaminateImage.SetImageSize(objROI.ref_ROI.TopParent.Width, objROI.ref_ROI.TopParent.Height);
                m_objContaminateImage.SetImageToBlack();

                // Init destination Image
                ROI objContaminate = new ROI();
                objContaminate.LoadROISetting(objROI.ref_ROIPositionX, objROI.ref_ROIPositionY,
                 objROI.ref_ROIWidth, objROI.ref_ROIHeight);
                objContaminate.AttachImage(m_objContaminateImage);

                if (blnDebugImage)
                {
                    m_objContaminateImage.SaveImage("D:\\TS\\2.m_objContaminateImage.bmp");
                    objContaminate.SaveImage("D:\\TS\\3.objContaminate.bmp");
                }
#if (Debug_2_12 || Release_2_12)
                // Threshold sample image
                m_objSampleImage.SetImageSize(objROI.ref_ROIWidth, objROI.ref_ROIHeight);
                if (m_fPadImageGain != 1f)
                {
                    EasyImage.GainOffset(objROI.ref_ROI, m_objSampleImage.ref_objMainImage, m_fPadImageGain);
                    EasyImage.Threshold(m_objSampleImage.ref_objMainImage, m_objSampleImage.ref_objMainImage, (uint)m_intThresholdValue);
                }
                else
                {
                    EasyImage.Threshold(objROI.ref_ROI, m_objSampleImage.ref_objMainImage, (uint)m_intThresholdValue);
                }
#elif (DEBUG || RELEASE || RTXRelease || RTXDebug)
                // Threshold sample image
                m_objSampleImage.SetImageSize(objROI.ref_ROIWidth, objROI.ref_ROIHeight);
                  if (m_fPadImageGain != 1f)
                {
                    EasyImage.GainOffset(objROI.ref_ROI, m_objSampleImage.ref_objMainImage, m_fPadImageGain);
                    EasyImage.Threshold(m_objSampleImage.ref_objMainImage, m_objSampleImage.ref_objMainImage, m_intThresholdValue);
                }
                else
                {
                    EasyImage.Threshold(objROI.ref_ROI, m_objSampleImage.ref_objMainImage, m_intThresholdValue);
                }
#endif

                if (blnDebugImage)
                {
                    m_objSampleImage.SaveImage("D:\\TS\\4.m_objSampleImage.bmp");
                    m_ImgTUnitDilateThresImage.Save("D:\\TS\\5.m_ImgTUnitDilateThresImage.bmp");
                }

                //m_ImgTUnitDilateThresImage.Save("D:\\m_ImgTUnitDilateThresImage.bmp");
                //m_objSampleImage.ref_objMainImage.Save("D:\\m_objSampleImage.bmp");
                // Template Image=m_DilateROI, Sample Image=objROI, Subtract Image=objContaminate
                if ((m_objSampleImage.ref_intImageWidth != m_ImgTUnitDilateThresImage.Width) ||
                    (m_objSampleImage.ref_intImageWidth != objContaminate.ref_ROI.Width) ||
                    (m_objSampleImage.ref_intImageHeight != m_ImgTUnitDilateThresImage.Height) ||
                    (m_objSampleImage.ref_intImageHeight != objContaminate.ref_ROI.Height))
                {
                    STTrackLog.WriteLine("CheckExcessPad > image size not same.");
                    STTrackLog.WriteLine("m_objSampleImage width = " + m_objSampleImage.ref_intImageWidth.ToString() +
                                         "m_ImgTUnitDilateThresImage width = " + m_ImgTUnitDilateThresImage.Width.ToString() +
                                         "objContaminate width = " + objContaminate.ref_ROI.Width.ToString() +
                                         "m_objSampleImage height = " + m_objSampleImage.ref_intImageHeight.ToString() +
                                         "m_ImgTUnitDilateThresImage height = " + m_ImgTUnitDilateThresImage.Height.ToString() +
                                         "objContaminate height = " + objContaminate.ref_ROI.Height.ToString());
                }

                EasyImage.Oper(EArithmeticLogicOperation.Subtract, m_objSampleImage.ref_objMainImage, m_ImgTUnitDilateThresImage, objContaminate.ref_ROI);

                objContaminate.LoadROISetting(objContaminate.ref_ROIPositionX + intAverageOffSetX, objContaminate.ref_ROIPositionY + intAverageOffSetY, // Reassign back to original sample location before build blobs.
                                objContaminate.ref_ROIWidth, objContaminate.ref_ROIHeight);
                BuildDilateObjects(objContaminate, (int)Math.Floor(m_fBlobsMinArea));


                int intNumObject = m_objDilateEBlobs.ref_intNumSelectedObject;
                int intArea, intContourX, intContourY;
                float fGravityCenterX, fGravityCenterY, fLimitCenterX, fLimitCenterY, fWidth, fHeight, fStartX, fStartY, fEndX, fEndY;
                if (blnDebugImage)
                {
                    objContaminate.SaveImage("D:\\TS\\6.objContaminate.bmp"); // debug
                }

                for (int i = 0; i < intNumObject; i++)
                {

                    // Get sample data
                    fGravityCenterX = fGravityCenterY = fLimitCenterX = fLimitCenterY = fWidth = fHeight = fStartX = fStartY = fEndX = fEndY = 0;
                    intArea = intContourX = intContourY = 0;

                    fGravityCenterX = m_objDilateEBlobs.ref_arrGravityCenterX[i];
                    fGravityCenterY = m_objDilateEBlobs.ref_arrGravityCenterY[i];
                    fLimitCenterX = m_objDilateEBlobs.ref_arrLimitCenterX[i];
                    fLimitCenterY = m_objDilateEBlobs.ref_arrLimitCenterY[i];
                    fWidth = m_objDilateEBlobs.ref_arrWidth[i];
                    fHeight = m_objDilateEBlobs.ref_arrHeight[i];
                    intArea = m_objDilateEBlobs.ref_arrArea[i];
                    intContourX = m_objDilateEBlobs.ref_arrContourX[i];
                    intContourY = m_objDilateEBlobs.ref_arrContourY[i];

                    // Get object start point and end point
                    fStartX = fLimitCenterX - (fWidth / 2);
                    fStartY = fLimitCenterY - (fHeight / 2);
                    fEndX = fLimitCenterX + (fWidth / 2);
                    fEndY = fLimitCenterY + (fHeight / 2);

                    // check is extra blob items?
                    bool blnIsExtraBlob = false;
                    for (int j = 0; j < m_arrExtraBlobCenterX.Count; j++)
                    {
                        if ((fLimitCenterX == m_arrExtraBlobCenterX[j]) &&
                            (fLimitCenterY == m_arrExtraBlobCenterY[j]) &&
                            (fWidth == m_arrExtraBlobWidth[j]) &&
                            (fHeight == m_arrExtraBlobHeight[j]))
                        {
                            blnIsExtraBlob = true;
                            break;
                        }

                    }

                    // if the blob is extra blobs, mean it is not a excess area from pad, so continue next blob checking.
                    if (blnIsExtraBlob)
                    {
                        continue;
                    }

                    List<int> intMatch2 = MatchOrdinaryBlobsFeatures(fStartX, fStartY, fEndX, fEndY, fGravityCenterX, fGravityCenterY);
                    List<int> intMatch = new List<int>();
                    for (int j = 0; j < intMatch2.Count; j++)
                    {
                        //if (m_objBlobs.ref_objContour.MatchObject(m_arrSampleBlobPads[intMatch2[j]].intContourIndex, intContourX, intContourY))
                        intMatch.Add(intMatch2[j]);
                    }

                    if (intMatch.Count >= 1)
                    {
                        if (intMatch[0] >= 0 && ((BlobsFeatures)m_arrTemplateBlobPads[intMatch[0]]).blnEnable)
                        {
                            //if (m_blnWantCheckExcessPadLength || m_blnWantCheckExcessPadArea)
                            if (m_blnWantCheckExcessPadArea)
                            {
                                if (m_arrSamplePadExcess[intMatch[0]].fAreaMM == 0)
                                {
                                    m_arrSamplePadExcess[intMatch[0]].fAreaMM = intArea * m_fAreaMMPerPixel;  // Change unit pixel to mm
                                    m_arrSamplePadExcess[intMatch[0]].fWidthMM = fWidth * m_fMMPerPixelX;  // Change unit pixel to mm
                                    m_arrSamplePadExcess[intMatch[0]].fHeightMM = fHeight * m_fMMPerPixelY;  // Change unit pixel to mm

                                    m_arrSamplePadExcess[intMatch[0]].fWidth = fWidth;
                                    m_arrSamplePadExcess[intMatch[0]].fHeight = fHeight;
                                    m_arrSamplePadExcess[intMatch[0]].fStartX = fStartX;
                                    m_arrSamplePadExcess[intMatch[0]].fStartY = fStartY;
                                    m_arrSamplePadExcess[intMatch[0]].fEndX = fEndX;
                                    m_arrSamplePadExcess[intMatch[0]].fEndY = fEndY;
                                }
                            }

                            if (m_arrSampleBlobPads[intMatch[0]].intFailMask == 0)
                            {
                                if (m_blnWantCheckExcessPadArea && !m_blnFailExcessLength)
                                {
                                    if (((BlobsFeatures)m_arrTemplateBlobPads[intMatch[0]]).blnEnable)
                                    {
                                        float fArea = (float)intArea / m_fMMtoPixelAreaValue;   // Change pixel to mm

                                        bool blnResult = true;
                                        if (m_blnWantUseGroupToleranceSetting)
                                        {
                                            int intGroupNo = ((BlobsFeatures)m_arrTemplateBlobPads[intMatch[0]]).intGroupID;
                                            if (fArea > ((BlobsFeatures)m_arrGroupTemplateBlobPads[intGroupNo]).fMaxExcess)
                                            {
                                                blnResult = false;
                                            }
                                        }
                                        else
                                        {
                                            if (fArea > ((BlobsFeatures)m_arrTemplateBlobPads[intMatch[0]]).fMaxExcess)
                                            {
                                                blnResult = false;
                                            }
                                        }

                                        if (!blnResult)
                                        {
                                            m_intFailResultMask |= 0x800;
                                            m_arrSampleBlobPads[intMatch[0]].intFailMask |= 0x800;
                                            m_blnFailExcessArea = true;

                                            // Collect excess pad min and max area for display error message
                                            if ((m_fResultExcessMinArea == -1) || (fArea < m_fResultExcessMinArea))
                                                m_fResultExcessMinArea = fArea;
                                            if ((m_fResultExcessMaxArea == -1) || (fArea > m_fResultExcessMaxArea))
                                                m_fResultExcessMaxArea = fArea;

                                            Defect objDefect = new Defect();
                                            objDefect.ref_strName = "Excess Pad";
                                            objDefect.ref_intFailMask |= 0x800;
                                            objDefect.ref_fArea = Convert.ToSingle(intArea);
                                            objDefect.ref_fCenterX = objContaminate.ref_ROITotalX + fGravityCenterX;
                                            objDefect.ref_fCenterY = objContaminate.ref_ROITotalY + fGravityCenterY;
                                            objDefect.ref_fStartX = fStartX;
                                            objDefect.ref_fStartY = fStartY;
                                            objDefect.ref_fEndX = fEndX;
                                            objDefect.ref_fEndY = fEndY;
                                            objDefect.ref_fWidth = fWidth;
                                            objDefect.ref_fHeight = fHeight;
                                            objDefect.ref_fWidthInMM = fWidth * m_fMMPerPixelX;
                                            objDefect.ref_fHeightInMM = fHeight * m_fMMPerPixelY;
                                            objDefect.ref_fAreaInMM2 = intArea * m_fAreaMMPerPixel;
                                            objDefect.ref_intFailCriteria |= 0x08;

                                            m_arrPadDefectList.Add(objDefect);
                                        }

                                    }
                                }
                            }
                        }
                    }
                }

                objROI.Dispose();
                objContaminate.Dispose();
            }
            catch (Exception ex)
            {
                SRMMessageBox.Show("CheckExcessPad() error. Exception = " + ex.ToString());
            }
        }
        private void CheckExcessPad2(ROI objSampleROI)
        {
            bool blnDebugImage = false;

            if (blnDebugImage)
            {
                objSampleROI.SaveImage("D:\\TS\\0.objSampleROI.bmp");
            }

            //// Get sample pad average offset value
            //float fTotalOffSetX = 0;
            //float fTotalOffSetY = 0;
            //for (int i = 0; i < m_arrSampleBlobPads.Length; i++)
            //{
            //    BlobsFeatures m_stcBlobPad = (BlobsFeatures)m_arrTemplateBlobPads[i];

            //    if (m_blnWantGaugeMeasurePkgSize)
            //    {
            //        fTotalOffSetX += m_stcBlobPad.fXDistance - (objSampleROI.ref_ROITotalX + m_arrSampleBlobPads[i].fCenterX - GetResultCenterPoint_RectGauge4L().X);
            //        fTotalOffSetY += m_stcBlobPad.fYDistance - (objSampleROI.ref_ROITotalY + m_arrSampleBlobPads[i].fCenterY - GetResultCenterPoint_RectGauge4L().Y);
            //    }
            //    else
            //    {
            //        fTotalOffSetX += m_stcBlobPad.fXDistance - (objSampleROI.ref_ROITotalX + m_arrSampleBlobPads[i].fCenterX - m_pUnitCenterPoint.X);
            //        fTotalOffSetY += m_stcBlobPad.fYDistance - (objSampleROI.ref_ROITotalY + m_arrSampleBlobPads[i].fCenterY - m_pUnitCenterPoint.Y);
            //    }


            //}
            //int intAverageOffSetX = (int)Math.Round(fTotalOffSetX / m_arrSampleBlobPads.Length, 0, MidpointRounding.AwayFromZero);
            //int intAverageOffSetY = (int)Math.Round(fTotalOffSetY / m_arrSampleBlobPads.Length, 0, MidpointRounding.AwayFromZero);

            //// Reassign sample ROI to make sure sample pads has almost zero offset with template pads before do the subtration. 
            //ROI objROI = new ROI();
            //objROI.ref_ROI.Detach();
            //objROI.ref_ROI.Attach(objSampleROI.ref_ROI.Parent);
            //objROI.LoadROISetting(objSampleROI.ref_ROIPositionX - intAverageOffSetX, objSampleROI.ref_ROIPositionY - intAverageOffSetY,
            //                    objSampleROI.ref_ROIWidth, objSampleROI.ref_ROIHeight);

            //if (blnDebugImage)
            //{
            //    objROI.SaveImage("D:\\TS\\1.objROI.bmp");
            //}
            int intTestUnitWidth = m_ImgUnitTemplateImage.Width;
            int intTestUnitHeight = m_ImgUnitTemplateImage.Height;
            // ---- Template ------
            // Get ready template ROI
            ROI objThresholdTemplateROI = new ROI();
            if ((m_ImgTUnitErodeThresImage.Width != m_ImgUnitTemplateImage.Width) || (m_ImgTUnitErodeThresImage.Height != m_ImgUnitTemplateImage.Height))
                m_ImgTUnitErodeThresImage.SetSize(m_ImgUnitTemplateImage.Width, m_ImgUnitTemplateImage.Height);
#if (Debug_2_12 || Release_2_12)
            if (m_fPadImageGain != 1f)
            {
                EasyImage.GainOffset(m_ImgUnitTemplateImage, m_ImgTUnitErodeThresImage, m_fPadImageGain);
                EasyImage.Threshold(m_ImgTUnitErodeThresImage, m_ImgTUnitErodeThresImage, (uint)m_intThresholdValue);
            }
            else
            {
                EasyImage.Threshold(m_ImgUnitTemplateImage, m_ImgTUnitErodeThresImage, (uint)m_intThresholdValue);
            }
#elif (DEBUG || RELEASE || RTXRelease || RTXDebug)
            if (m_fPadImageGain != 1f)
            {
                EasyImage.GainOffset(m_ImgUnitTemplateImage, m_ImgTUnitErodeThresImage, m_fPadImageGain);
                EasyImage.Threshold(m_ImgTUnitErodeThresImage, m_ImgTUnitErodeThresImage, m_intThresholdValue);
            }
            else
            {
                EasyImage.Threshold(m_ImgUnitTemplateImage, m_ImgTUnitErodeThresImage, m_intThresholdValue);
            }
#endif

            objThresholdTemplateROI.ref_ROI.Detach();
            objThresholdTemplateROI.ref_ROI.Attach(m_ImgTUnitErodeThresImage);
            objThresholdTemplateROI.LoadROISetting((int)Math.Round((float)m_ImgTUnitErodeThresImage.Width / 2 - (float)intTestUnitWidth / 2, 0, MidpointRounding.AwayFromZero),
                                 (int)Math.Round((float)m_ImgTUnitErodeThresImage.Height / 2 - (float)intTestUnitHeight / 2, 0, MidpointRounding.AwayFromZero),
                                 intTestUnitWidth, intTestUnitHeight);

            // ---- Black Background --------------
            m_ImgBlackUnitTemplateImage2.SetSize(m_ImgBlackUnitTemplateImage.Width, m_ImgBlackUnitTemplateImage.Height);
            m_ImgBlackUnitTemplateImage.CopyTo(m_ImgBlackUnitTemplateImage2);
            ROI objBlackBgTemplateROI = new ROI();
            objBlackBgTemplateROI.ref_ROI.Detach();
            objBlackBgTemplateROI.ref_ROI.Attach(m_ImgBlackUnitTemplateImage2);
            objBlackBgTemplateROI.LoadROISetting(0, 0, intTestUnitWidth, intTestUnitHeight);

            if (blnDebugImage)
            {
                m_ImgBlackUnitTemplateImage2.Save("D:\\TS\\05.m_ImgBlackUnitTemplateImage2.bmp");
                m_ImgTUnitErodeThresImage.Save("D:\\TS\\06.m_ImgTUnitErodeThresImage.bmp");
                objThresholdTemplateROI.SaveImage("D:\\TS\\07.objThresholdTemplateROI.bmp");
            }

            //if (intInpectMode == 0)
            {
                #region InspectMode == 0 ----------------------------------------------------------------------------------
                int[] arrTemplateStartX = new int[m_arrTemplateBlobPads.Count];
                int[] arrTemplateStartY = new int[m_arrTemplateBlobPads.Count];
                int[] arrTemplateEndX = new int[m_arrTemplateBlobPads.Count];
                int[] arrTemplateEndY = new int[m_arrTemplateBlobPads.Count];
                int[] arrSampleStartX = new int[m_arrTemplateBlobPads.Count];
                int[] arrSampleStartY = new int[m_arrTemplateBlobPads.Count];
                int[] arrSampleEndX = new int[m_arrTemplateBlobPads.Count];
                int[] arrSampleEndY = new int[m_arrTemplateBlobPads.Count];
                int[] arrTemplateSampleWidth = new int[m_arrTemplateBlobPads.Count];
                int[] arrTemplateSampleHeight = new int[m_arrTemplateBlobPads.Count];
                int[] arrDifferentSizeX = new int[m_arrTemplateBlobPads.Count]; // Template and sample different size
                int[] arrDifferentSizeY = new int[m_arrTemplateBlobPads.Count]; // Template and sample different size
                int[] arrOffsetStartX = new int[m_arrTemplateBlobPads.Count];
                int[] arrOffsetStartY = new int[m_arrTemplateBlobPads.Count];

                DefinePadSubtractOffset(objThresholdTemplateROI, m_intMPDilateHalfWidth, m_ImgBlackUnitTemplateImage2.Width - 1, m_ImgBlackUnitTemplateImage2.Height - 1,
                    ref arrTemplateStartX, ref arrTemplateStartY, ref arrTemplateEndX, ref arrTemplateEndY,
                    ref arrSampleStartX, ref arrSampleStartY, ref arrSampleEndX, ref arrSampleEndY,
                    ref arrTemplateSampleWidth, ref arrTemplateSampleHeight,
                    ref arrDifferentSizeX, ref arrDifferentSizeY,
                    ref arrOffsetStartX, ref arrOffsetStartY, false);
                
                for (int i = 0; i < m_arrTemplateBlobPads.Count; i++)
                {
                    if (m_arrSampleBlobPads[i].intFailMask != 0)
                        continue;

                    // Get template pad roi
                    ROI objTemplatePadROI = new ROI();
                    objTemplatePadROI.AttachImage(objThresholdTemplateROI);
                    //objTemplatePadROI.LoadROISetting(intStartX, intStartY, intWidth, intHeight);    
                    // 2021 03 20 - CCENG: Should not include the fPadInspectionAreaFromLeft.. parameter because this parameter is for broken pad use only.
                    //objTemplatePadROI.LoadROISetting(arrTemplateStartX[i] + (int)(((BlobsFeatures)m_arrTemplateBlobPads[i]).fPadInspectionAreaFromLeft * m_fMMToPixelXValue),
                    //arrTemplateStartY[i] + (int)(((BlobsFeatures)m_arrTemplateBlobPads[i]).fPadInspectionAreaFromTop * m_fMMToPixelYValue),
                    //    arrTemplateSampleWidth[i] - (int)(((BlobsFeatures)m_arrTemplateBlobPads[i]).fPadInspectionAreaFromLeft * m_fMMToPixelXValue) - (int)(((BlobsFeatures)m_arrTemplateBlobPads[i]).fPadInspectionAreaFromRight * m_fMMToPixelXValue),
                    //    arrTemplateSampleHeight[i] - (int)(((BlobsFeatures)m_arrTemplateBlobPads[i]).fPadInspectionAreaFromTop * m_fMMToPixelYValue) - (int)(((BlobsFeatures)m_arrTemplateBlobPads[i]).fPadInspectionAreaFromBottom * m_fMMToPixelYValue));
                    objTemplatePadROI.LoadROISetting(arrTemplateStartX[i],
                             arrTemplateStartY[i],
                             arrTemplateSampleWidth[i],
                             arrTemplateSampleHeight[i]);

                    m_ImgMPUnitTemplateImage.SetSize(objTemplatePadROI.ref_ROIWidth, objTemplatePadROI.ref_ROIHeight);

                    if ((arrDifferentSizeX[i] > 0) || (arrDifferentSizeY[i] > 0))
                    {
                        if ((arrDifferentSizeX[i] > 0 && arrDifferentSizeY[i] < 0) || (arrDifferentSizeY[i] > 0 && arrDifferentSizeX[i] < 0))
                        {
                            if (Math.Abs(arrDifferentSizeY[i]) > Math.Abs(arrDifferentSizeY[i]))
                                arrDifferentSizeY[i] = 0;
                            else
                                arrDifferentSizeX[i] = 0;
                        }
#if (Debug_2_12 || Release_2_12)
                        // Reduce template size follow the m_intMPErodeHalfWidth setting.    
                        EasyImage.DilateBox(objTemplatePadROI.ref_ROI, m_ImgMPUnitTemplateImage, (uint)Math.Abs(m_intMPDilateHalfWidth), (uint)Math.Abs(m_intMPDilateHalfWidth));
                        EasyImage.Copy(m_ImgMPUnitTemplateImage, objTemplatePadROI.ref_ROI);
#elif (DEBUG || RELEASE || RTXRelease || RTXDebug)
                        // Reduce template size follow the m_intMPErodeHalfWidth setting.    
                        EasyImage.DilateBox(objTemplatePadROI.ref_ROI, m_ImgMPUnitTemplateImage, Math.Abs(m_intMPDilateHalfWidth), Math.Abs(m_intMPDilateHalfWidth));
                        EasyImage.Copy(m_ImgMPUnitTemplateImage, objTemplatePadROI.ref_ROI);
#endif

                    }
                    else
                    {
                        // ErodeBox will make the pad size smaller.
                        if ((Math.Abs(arrDifferentSizeX[i]) + m_intMPDilateHalfWidth) > 0 || (Math.Abs(arrDifferentSizeY[i]) + m_intMPDilateHalfWidth) > 0)
                        {
#if (Debug_2_12 || Release_2_12)
                            //EasyImage.ErodeBox(objTemplatePadROI.ref_ROI, m_ImgMPUnitTemplateImage, Math.Abs(intDiffSizeWidth) + m_intMPErodeHalfWidth, Math.Abs(intDiffSizeHeight) + m_intMPErodeHalfWidth);
                            EasyImage.DilateBox(objTemplatePadROI.ref_ROI, m_ImgMPUnitTemplateImage, (uint)m_intMPDilateHalfWidth, (uint)m_intMPDilateHalfWidth);
                            EasyImage.Copy(m_ImgMPUnitTemplateImage, objTemplatePadROI.ref_ROI);
#elif (DEBUG || RELEASE || RTXRelease || RTXDebug)
                            //EasyImage.ErodeBox(objTemplatePadROI.ref_ROI, m_ImgMPUnitTemplateImage, Math.Abs(intDiffSizeWidth) + m_intMPErodeHalfWidth, Math.Abs(intDiffSizeHeight) + m_intMPErodeHalfWidth);
                            EasyImage.DilateBox(objTemplatePadROI.ref_ROI, m_ImgMPUnitTemplateImage, m_intMPDilateHalfWidth, m_intMPDilateHalfWidth);
                            EasyImage.Copy(m_ImgMPUnitTemplateImage, objTemplatePadROI.ref_ROI);
#endif

                        }
                    }


                    // Get Sample pad ROI
                    ROI objTemplate2PadROI = new ROI();
                    objTemplate2PadROI.ref_ROI.Detach();
                    objTemplate2PadROI.ref_ROI.Attach(m_ImgBlackUnitTemplateImage2);
                    // 2021 03 20 - CCENG: Should not include the fPadInspectionAreaFromLeft.. parameter because this parameter is for broken pad use only.
                    //objTemplate2PadROI.LoadROISetting(arrSampleStartX[i] + (int)(((BlobsFeatures)m_arrTemplateBlobPads[i]).fPadInspectionAreaFromLeft * m_fMMToPixelXValue) + arrOffsetStartX[i],
                    //  arrSampleStartY[i] + (int)(((BlobsFeatures)m_arrTemplateBlobPads[i]).fPadInspectionAreaFromTop * m_fMMToPixelYValue) + arrOffsetStartY[i],
                    //  arrTemplateSampleWidth[i] - (int)(((BlobsFeatures)m_arrTemplateBlobPads[i]).fPadInspectionAreaFromLeft * m_fMMToPixelXValue) - (int)(((BlobsFeatures)m_arrTemplateBlobPads[i]).fPadInspectionAreaFromRight * m_fMMToPixelXValue),
                    //  arrTemplateSampleHeight[i] - (int)(((BlobsFeatures)m_arrTemplateBlobPads[i]).fPadInspectionAreaFromTop * m_fMMToPixelYValue) - (int)(((BlobsFeatures)m_arrTemplateBlobPads[i]).fPadInspectionAreaFromBottom * m_fMMToPixelYValue));
                    objTemplate2PadROI.LoadROISetting(arrSampleStartX[i] + arrOffsetStartX[i],
                             arrSampleStartY[i] + arrOffsetStartY[i],
                             arrTemplateSampleWidth[i],
                             arrTemplateSampleHeight[i]);

                    if (blnDebugImage)
                    {
                        m_ImgMPUnitTemplateImage.Save("D:\\TS\\08_" + i.ToString() + "_BfMPTemplateImage.bmp");// debug
                        objTemplatePadROI.SaveImage("D:\\TS\\09_" + i.ToString() + "_AfMPTemplateImage.bmp");// debug
                        objTemplate2PadROI.SaveImage("D:\\TS\\10_" + i.ToString() + "_BfSBTemplate2PadImage.bmp");// debug
                    }
                    //objTemplate2PadROI.ref_ROI.SetSize(objTemplatePadROI.ref_ROI.Width, objTemplatePadROI.ref_ROI.Height);

                    if (objTemplatePadROI.ref_ROIWidth != objTemplate2PadROI.ref_ROIWidth)
                    {
                        int intSmallWidth = Math.Min(objTemplatePadROI.ref_ROIWidth, objTemplate2PadROI.ref_ROIWidth);
                        objTemplatePadROI.LoadROISetting(objTemplatePadROI.ref_ROIPositionX, objTemplatePadROI.ref_ROIPositionY, intSmallWidth, objTemplatePadROI.ref_ROIHeight);
                        objTemplate2PadROI.LoadROISetting(objTemplate2PadROI.ref_ROIPositionX, objTemplate2PadROI.ref_ROIPositionY, intSmallWidth, objTemplate2PadROI.ref_ROIHeight);
                    }

                    if (objTemplatePadROI.ref_ROIHeight != objTemplate2PadROI.ref_ROIHeight)
                    {
                        int intSmallHeight = Math.Min(objTemplatePadROI.ref_ROIHeight, objTemplate2PadROI.ref_ROIHeight);
                        objTemplatePadROI.LoadROISetting(objTemplatePadROI.ref_ROIPositionX, objTemplatePadROI.ref_ROIPositionY, objTemplatePadROI.ref_ROIWidth, intSmallHeight);
                        objTemplate2PadROI.LoadROISetting(objTemplate2PadROI.ref_ROIPositionX, objTemplate2PadROI.ref_ROIPositionY, objTemplate2PadROI.ref_ROIWidth, intSmallHeight);
                    }

                    // subtract sample pad roi - template pad roi
                    EasyImage.Oper(EArithmeticLogicOperation.Add, objTemplate2PadROI.ref_ROI, objTemplatePadROI.ref_ROI, objTemplate2PadROI.ref_ROI);

                    if (blnDebugImage)
                        objTemplate2PadROI.SaveImage("D:\\TS\\11_" + i.ToString() + "_AfSBTemplate2PadImage.bmp");// debug

                    objTemplate2PadROI.Dispose();
                    objTemplatePadROI.Dispose();
                }

                #endregion ------------------------------------------------------------------------------------------------
            }
            bool blnCheckPadUsingLengthSetting = true;
            try
            {
                // Init
                List<int> arrMultipleMatchNo = new List<int>();
                List<float> arrMultipleMatchArea = new List<float>();
                m_objContaminateImage.SetImageSize(objSampleROI.ref_ROI.TopParent.Width, objSampleROI.ref_ROI.TopParent.Height);
                m_objContaminateImage.SetImageToBlack();

                // Init destination Image
                ROI objContaminate = new ROI();
                objContaminate.LoadROISetting(objSampleROI.ref_ROIPositionX, objSampleROI.ref_ROIPositionY,
                 objSampleROI.ref_ROIWidth, objSampleROI.ref_ROIHeight);
                objContaminate.AttachImage(m_objContaminateImage);

                if (blnDebugImage)
                {
                    m_ImgBlackUnitTemplateImage2.Save("D:\\TS\\12.m_ImgBlackUnitTemplateImage2.bmp");
                    m_objContaminateImage.SaveImage("D:\\TS\\2.m_objContaminateImage.bmp");
                    objContaminate.SaveImage("D:\\TS\\3.objContaminate.bmp");
                }
#if (Debug_2_12 || Release_2_12)
                // Threshold sample image
                m_objSampleImage.SetImageSize(objSampleROI.ref_ROIWidth, objSampleROI.ref_ROIHeight);
                if (m_fPadImageGain != 1f)
                {
                    EasyImage.GainOffset(m_ImgUnitTemplateImage, m_ImgTUnitErodeThresImage, m_fPadImageGain);
                    EasyImage.Threshold(m_ImgTUnitErodeThresImage, m_ImgTUnitErodeThresImage, (uint)m_intThresholdValue);
                }
                else
                {
                    EasyImage.Threshold(objSampleROI.ref_ROI, m_objSampleImage.ref_objMainImage, (uint)m_intThresholdValue);
                }
#elif (DEBUG || RELEASE || RTXRelease || RTXDebug)
                // Threshold sample image
                m_objSampleImage.SetImageSize(objSampleROI.ref_ROIWidth, objSampleROI.ref_ROIHeight);
                if (m_fPadImageGain != 1f)
                {
                    EasyImage.GainOffset(m_ImgUnitTemplateImage, m_ImgTUnitErodeThresImage, m_fPadImageGain);
                    EasyImage.Threshold(m_ImgTUnitErodeThresImage, m_ImgTUnitErodeThresImage, m_intThresholdValue);
                }
                else
                {
                    EasyImage.Threshold(objSampleROI.ref_ROI, m_objSampleImage.ref_objMainImage, m_intThresholdValue);
                }
#endif

                if (blnDebugImage)
                {
                    m_objSampleImage.SaveImage("D:\\TS\\4.m_objSampleImage.bmp");
                    m_ImgBlackUnitTemplateImage2.Save("D:\\TS\\5.m_ImgBlackUnitTemplateImage2.bmp");
                }

                //m_ImgTUnitDilateThresImage.Save("D:\\m_ImgTUnitDilateThresImage.bmp");
                //m_objSampleImage.ref_objMainImage.Save("D:\\m_objSampleImage.bmp");
                // Template Image=m_DilateROI, Sample Image=objROI, Subtract Image=objContaminate
                if ((m_objSampleImage.ref_intImageWidth != m_ImgBlackUnitTemplateImage2.Width) ||
                    (m_objSampleImage.ref_intImageWidth != objContaminate.ref_ROI.Width) ||
                    (m_objSampleImage.ref_intImageHeight != m_ImgBlackUnitTemplateImage2.Height) ||
                    (m_objSampleImage.ref_intImageHeight != objContaminate.ref_ROI.Height))
                {
                    STTrackLog.WriteLine("CheckExcessPad > image size not same.");
                    STTrackLog.WriteLine("m_objSampleImage width = " + m_objSampleImage.ref_intImageWidth.ToString() +
                                         "m_ImgTUnitDilateThresImage width = " + m_ImgBlackUnitTemplateImage2.Width.ToString() +
                                         "objContaminate width = " + objContaminate.ref_ROI.Width.ToString() +
                                         "m_objSampleImage height = " + m_objSampleImage.ref_intImageHeight.ToString() +
                                         "m_ImgTUnitDilateThresImage height = " + m_ImgBlackUnitTemplateImage2.Height.ToString() +
                                         "objContaminate height = " + objContaminate.ref_ROI.Height.ToString());
                }

                EasyImage.Oper(EArithmeticLogicOperation.Subtract, m_objSampleImage.ref_objMainImage, m_ImgBlackUnitTemplateImage2, objContaminate.ref_ROI);

                //objContaminate.LoadROISetting(objContaminate.ref_ROIPositionX + intAverageOffSetX, objContaminate.ref_ROIPositionY + intAverageOffSetY, // Reassign back to original sample location before build blobs.
                //                objContaminate.ref_ROIWidth, objContaminate.ref_ROIHeight);
                BuildDilateObjects(objContaminate, (int)Math.Floor(m_fBlobsMinArea));


                int intNumObject = m_objDilateEBlobs.ref_intNumSelectedObject;
                int intArea, intContourX, intContourY;
                float fGravityCenterX, fGravityCenterY, fLimitCenterX, fLimitCenterY, fWidth, fHeight, fStartX, fStartY, fEndX, fEndY;
                if (blnDebugImage)
                {
                    objContaminate.SaveImage("D:\\TS\\6.objContaminate.bmp"); // debug
                }

                for (int i = 0; i < intNumObject; i++)
                {

                    // Get sample data
                    fGravityCenterX = fGravityCenterY = fLimitCenterX = fLimitCenterY = fWidth = fHeight = fStartX = fStartY = fEndX = fEndY = 0;
                    intArea = intContourX = intContourY = 0;

                    fGravityCenterX = m_objDilateEBlobs.ref_arrGravityCenterX[i];
                    fGravityCenterY = m_objDilateEBlobs.ref_arrGravityCenterY[i];
                    fLimitCenterX = m_objDilateEBlobs.ref_arrLimitCenterX[i];
                    fLimitCenterY = m_objDilateEBlobs.ref_arrLimitCenterY[i];
                    fWidth = m_objDilateEBlobs.ref_arrWidth[i];
                    fHeight = m_objDilateEBlobs.ref_arrHeight[i];
                    intArea = m_objDilateEBlobs.ref_arrArea[i];
                    intContourX = m_objDilateEBlobs.ref_arrContourX[i];
                    intContourY = m_objDilateEBlobs.ref_arrContourY[i];

                    // Get object start point and end point
                    fStartX = fLimitCenterX - (fWidth / 2);
                    fStartY = fLimitCenterY - (fHeight / 2);
                    fEndX = fLimitCenterX + (fWidth / 2);
                    fEndY = fLimitCenterY + (fHeight / 2);

                    // check is extra blob items?
                    bool blnIsExtraBlob = false;
                    for (int j = 0; j < m_arrExtraBlobCenterX.Count; j++)
                    {
                        if ((fLimitCenterX == m_arrExtraBlobCenterX[j]) &&
                            (fLimitCenterY == m_arrExtraBlobCenterY[j]) &&
                            (fWidth == m_arrExtraBlobWidth[j]) &&
                            (fHeight == m_arrExtraBlobHeight[j]))
                        {
                            blnIsExtraBlob = true;
                            break;
                        }

                    }

                    // if the blob is extra blobs, mean it is not a excess area from pad, so continue next blob checking.
                    if (blnIsExtraBlob)
                    {
                        continue;
                    }

                    List<int> intMatch2 = MatchOrdinaryBlobsFeatures(fStartX, fStartY, fEndX, fEndY, fGravityCenterX, fGravityCenterY);
                    List<int> intMatch = new List<int>();
                    for (int j = 0; j < intMatch2.Count; j++)
                    {
                        //if (m_objBlobs.ref_objContour.MatchObject(m_arrSampleBlobPads[intMatch2[j]].intContourIndex, intContourX, intContourY))
                        intMatch.Add(intMatch2[j]);
                    }

                    if (intMatch.Count >= 1)
                    {
                        if (intMatch[0] >= 0 && ((BlobsFeatures)m_arrTemplateBlobPads[intMatch[0]]).blnEnable)
                        {
                            //if (m_blnWantCheckExcessPadLength || m_blnWantCheckExcessPadArea)
                            if (m_blnWantCheckExcessPadArea)
                            {
                                if (m_arrSamplePadExcess[intMatch[0]].fAreaMM == 0)
                                {
                                    m_arrSamplePadExcess[intMatch[0]].fAreaMM = intArea * m_fAreaMMPerPixel;  // Change unit pixel to mm
                                    m_arrSamplePadExcess[intMatch[0]].fWidthMM = fWidth * m_fMMPerPixelX;  // Change unit pixel to mm
                                    m_arrSamplePadExcess[intMatch[0]].fHeightMM = fHeight * m_fMMPerPixelY;  // Change unit pixel to mm

                                    m_arrSamplePadExcess[intMatch[0]].fWidth = fWidth;
                                    m_arrSamplePadExcess[intMatch[0]].fHeight = fHeight;
                                    m_arrSamplePadExcess[intMatch[0]].fStartX = fStartX;
                                    m_arrSamplePadExcess[intMatch[0]].fStartY = fStartY;
                                    m_arrSamplePadExcess[intMatch[0]].fEndX = fEndX;
                                    m_arrSamplePadExcess[intMatch[0]].fEndY = fEndY;
                                }
                            }

                            if (m_arrSampleBlobPads[intMatch[0]].intFailMask == 0)
                            {
                                if (m_blnWantCheckExcessPadArea && !m_blnFailExcessLength)
                                {
                                    if (((BlobsFeatures)m_arrTemplateBlobPads[intMatch[0]]).blnEnable)
                                    {
                                        float fArea = (float)intArea / m_fMMtoPixelAreaValue;   // Change pixel to mm

                                        bool blnResult = true;
                                        if (m_blnWantUseGroupToleranceSetting)
                                        {
                                            int intGroupNo = ((BlobsFeatures)m_arrTemplateBlobPads[intMatch[0]]).intGroupID;
                                            if (fArea > ((BlobsFeatures)m_arrGroupTemplateBlobPads[intGroupNo]).fMaxExcess)
                                            {
                                                blnResult = false;
                                            }
                                        }
                                        else
                                        {
                                            if (fArea > ((BlobsFeatures)m_arrTemplateBlobPads[intMatch[0]]).fMaxExcess)
                                            {
                                                blnResult = false;
                                            }
                                        }

                                        if (!blnResult)
                                        {
                                            m_intFailResultMask |= 0x800;
                                            m_arrSampleBlobPads[intMatch[0]].intFailMask |= 0x800;
                                            m_blnFailExcessArea = true;

                                            // Collect excess pad min and max area for display error message
                                            if ((m_fResultExcessMinArea == -1) || (fArea < m_fResultExcessMinArea))
                                                m_fResultExcessMinArea = fArea;
                                            if ((m_fResultExcessMaxArea == -1) || (fArea > m_fResultExcessMaxArea))
                                                m_fResultExcessMaxArea = fArea;

                                            Defect objDefect = new Defect();
                                            objDefect.ref_strName = "Excess Pad";
                                            objDefect.ref_intFailMask |= 0x800;
                                            objDefect.ref_fArea = Convert.ToSingle(intArea);
                                            objDefect.ref_fCenterX = objContaminate.ref_ROITotalX + fGravityCenterX;
                                            objDefect.ref_fCenterY = objContaminate.ref_ROITotalY + fGravityCenterY;
                                            objDefect.ref_fStartX = fStartX;
                                            objDefect.ref_fStartY = fStartY;
                                            objDefect.ref_fEndX = fEndX;
                                            objDefect.ref_fEndY = fEndY;
                                            objDefect.ref_fWidth = fWidth;
                                            objDefect.ref_fHeight = fHeight;
                                            objDefect.ref_fWidthInMM = fWidth * m_fMMPerPixelX;
                                            objDefect.ref_fHeightInMM = fHeight * m_fMMPerPixelY;
                                            objDefect.ref_fAreaInMM2 = intArea * m_fAreaMMPerPixel;
                                            objDefect.ref_intFailCriteria |= 0x08;

                                            m_arrPadDefectList.Add(objDefect);
                                        }

                                    }
                                }
                            }
                        }
                    }
                }

                //objROI.Dispose();
                objContaminate.Dispose();
            }
            catch (Exception ex)
            {
                SRMMessageBox.Show("CheckExcessPad() error. Exception = " + ex.ToString());
            }
        }
        private void CheckExtraObjectOnUnitSurface2(ROI objSampleROI, ROI objUnitSurfaceROI, List<List<PointF>> arrDontCare)
        {
            // Get sample pad average offset value
            float fTotalOffSetX = 0;
            float fTotalOffSetY = 0;
            for (int i = 0; i < m_arrSampleBlobPads.Length; i++)
            {
                BlobsFeatures m_stcBlobPad = (BlobsFeatures)m_arrTemplateBlobPads[i];

                if (GetOverallWantGaugeMeasurePkgSize(false))
                {
                    if (m_stcBlobPad.fTemplateROICenterX == 0 && m_stcBlobPad.fTemplateROICenterY == 0 && m_stcBlobPad.fTemplateROITopLeftCornerX == 0 && m_stcBlobPad.fTemplateROITopLeftCornerY == 0)
                    {
                        fTotalOffSetX += m_stcBlobPad.fXDistance - (objSampleROI.ref_ROITotalX + m_arrSampleBlobPads[i].fCenterX - GetResultCenterPoint_RectGauge4L().X);
                        fTotalOffSetY += m_stcBlobPad.fYDistance - (objSampleROI.ref_ROITotalY + m_arrSampleBlobPads[i].fCenterY - GetResultCenterPoint_RectGauge4L().Y);
                    }
                    else
                    {
                        if (m_intPadOffsetReferencePoint == 0)
                        {
                            fTotalOffSetX += (m_stcBlobPad.fLimitCenterX - m_stcBlobPad.fTemplateROICenterX) - (objSampleROI.ref_ROITotalX + m_arrSampleBlobPads[i].fCenterX - GetResultCenterPoint_RectGauge4L().X);
                            fTotalOffSetY += (m_stcBlobPad.fLimitCenterY - m_stcBlobPad.fTemplateROICenterY) - (objSampleROI.ref_ROITotalY + m_arrSampleBlobPads[i].fCenterY - GetResultCenterPoint_RectGauge4L().Y);
                        }
                        else
                        {
                            fTotalOffSetX += (m_stcBlobPad.fLimitCenterX - m_stcBlobPad.fTemplateROITopLeftCornerX) - (objSampleROI.ref_ROITotalX + m_arrSampleBlobPads[i].fCenterX - GetResultTopLeftCornerPoint_RectGauge4L().X);
                            fTotalOffSetY += (m_stcBlobPad.fLimitCenterY - m_stcBlobPad.fTemplateROITopLeftCornerY) - (objSampleROI.ref_ROITotalY + m_arrSampleBlobPads[i].fCenterY - GetResultTopLeftCornerPoint_RectGauge4L().Y);
                        }
                    }
                }
                else
                {
                    if (m_stcBlobPad.fTemplateROICenterX_Pattern == 0 && m_stcBlobPad.fTemplateROICenterY_Pattern == 0 && m_stcBlobPad.fTemplateROITopLeftCornerX_Pattern == 0 && m_stcBlobPad.fTemplateROITopLeftCornerY_Pattern == 0)
                    {
                        fTotalOffSetX += m_stcBlobPad.fXDistance_Pattern - (objSampleROI.ref_ROITotalX + m_arrSampleBlobPads[i].fCenterX - m_pUnitCenterPoint.X);
                        fTotalOffSetY += m_stcBlobPad.fYDistance_Pattern - (objSampleROI.ref_ROITotalY + m_arrSampleBlobPads[i].fCenterY - m_pUnitCenterPoint.Y);
                    }
                    else
                    {
                        if (m_intPadOffsetReferencePoint == 0)
                        {
                            fTotalOffSetX += (m_stcBlobPad.fLimitCenterX - m_stcBlobPad.fTemplateROICenterX_Pattern) - (objSampleROI.ref_ROITotalX + m_arrSampleBlobPads[i].fCenterX - m_pUnitCenterPoint.X);
                            fTotalOffSetY += (m_stcBlobPad.fLimitCenterY - m_stcBlobPad.fTemplateROICenterY_Pattern) - (objSampleROI.ref_ROITotalY + m_arrSampleBlobPads[i].fCenterY - m_pUnitCenterPoint.Y);
                        }
                        else
                        {
                            fTotalOffSetX += (m_stcBlobPad.fLimitCenterX - m_stcBlobPad.fTemplateROITopLeftCornerX_Pattern) - (objSampleROI.ref_ROITotalX + m_arrSampleBlobPads[i].fCenterX - GetResultTopLeftCornerPoint_UnitMatcher().X);
                            fTotalOffSetY += (m_stcBlobPad.fLimitCenterY - m_stcBlobPad.fTemplateROITopLeftCornerY_Pattern) - (objSampleROI.ref_ROITotalY + m_arrSampleBlobPads[i].fCenterY - GetResultTopLeftCornerPoint_UnitMatcher().Y);
                        }
                    }
                }
            }

            int intAverageOffSetX, intAverageOffSetY;
            if (m_arrSampleBlobPads.Length == 0)
            {
                intAverageOffSetX = 0;
                intAverageOffSetY = 0;
            }
            else
            {
                intAverageOffSetX = (int)Math.Round(fTotalOffSetX / m_arrSampleBlobPads.Length, 0, MidpointRounding.AwayFromZero);
                intAverageOffSetY = (int)Math.Round(fTotalOffSetY / m_arrSampleBlobPads.Length, 0, MidpointRounding.AwayFromZero);
            }

            // Reassign sample ROI to make sure sample pads has almost zero offset with template pads before do the subtration. 
            ROI objROI = new ROI();
            objROI.ref_ROI.Detach();
            objROI.ref_ROI.Attach(objSampleROI.ref_ROI.Parent);
            objROI.LoadROISetting(objSampleROI.ref_ROIPositionX - intAverageOffSetX, objSampleROI.ref_ROIPositionY - intAverageOffSetY,
                                objSampleROI.ref_ROIWidth, objSampleROI.ref_ROIHeight);

            bool blnDebugImage = false;
            bool blnCheckPadUsingLengthSetting = true;
            try
            {
                // Init
                List<int> arrMultipleMatchNo = new List<int>();
                List<float> arrMultipleMatchArea = new List<float>();
                m_objContaminateImage.SetImageSize(objROI.ref_ROI.TopParent.Width, objROI.ref_ROI.TopParent.Height);

                // Init destination Image
                ROI objContaminate = new ROI();
                objContaminate.LoadROISetting(objROI.ref_ROIPositionX, objROI.ref_ROIPositionY,
                 objROI.ref_ROIWidth, objROI.ref_ROIHeight);
                objContaminate.AttachImage(m_objContaminateImage);

                // Threshold sample image
                m_objSampleImage.SetImageSize(objROI.ref_ROIWidth, objROI.ref_ROIHeight);

                /*
                   * When Setting is tight, mean unit easiy fail.
                   *  - When test run for Pass unit, set tight to true for the first time filtering. and set tight to false for the subsequence 3x test run.
                   *     - when setting is tight, minus 25 to current threshold value for white area inspection (Foreignn Material, Excess Area, dimension)
                   *     - when setting is tight, add 25 to current threshold value for black area inspection (Pad broken Area)
               */

                int intSurfaceThresholdValue;
                int intLowSurfaceThresholdValue = 0;
                bool blnUseDoubleThreshold = true;
                if (blnUseDoubleThreshold)
                {
                    if (m_blnWantTightSetting)
                    {
                        intLowSurfaceThresholdValue = m_intSurfaceLowThresholdValue - m_intTightSettingThresholdTolerance;

                        if (intLowSurfaceThresholdValue < 0)
                            intLowSurfaceThresholdValue = 0;

                        intSurfaceThresholdValue = m_intSurfaceThresholdValue - m_intTightSettingThresholdTolerance;

                        if (intSurfaceThresholdValue < 0)
                            intSurfaceThresholdValue = 0;
                    }
                    else
                    {
                        intLowSurfaceThresholdValue = m_intSurfaceLowThresholdValue;

                        if (intLowSurfaceThresholdValue < 0)
                            intLowSurfaceThresholdValue = 0;

                        intSurfaceThresholdValue = m_intSurfaceThresholdValue;

                        if (intSurfaceThresholdValue < 0)
                            intSurfaceThresholdValue = 0;

                    }
#if (Debug_2_12 || Release_2_12)
                    EasyImage.DoubleThreshold(objROI.ref_ROI, m_objSampleImage.ref_objMainImage, (uint)intLowSurfaceThresholdValue, (uint)intSurfaceThresholdValue, 255, 0, 255);
#elif (DEBUG || RELEASE || RTXRelease || RTXDebug)
                    EasyImage.DoubleThreshold(objROI.ref_ROI, m_objSampleImage.ref_objMainImage, intLowSurfaceThresholdValue, intSurfaceThresholdValue, 255, 0, 255);
#endif

                }
                else
                {
                    if (m_blnWantTightSetting)
                    {
                        if (m_intSurfaceThresholdValue < 0)
                        {
                            intSurfaceThresholdValue = ROI.GetAutoThresholdValue(objROI, 3);
                            intSurfaceThresholdValue -= m_intTightSettingThresholdTolerance;
                        }
                        else
                        {
                            intSurfaceThresholdValue = m_intSurfaceThresholdValue - m_intTightSettingThresholdTolerance;
                        }

                        if (intSurfaceThresholdValue < 0)
                            intSurfaceThresholdValue = 0;
                    }
                    else
                        intSurfaceThresholdValue = m_intSurfaceThresholdValue;
#if (Debug_2_12 || Release_2_12)
                    EasyImage.Threshold(objROI.ref_ROI, m_objSampleImage.ref_objMainImage, (uint)intSurfaceThresholdValue);
#elif (DEBUG || RELEASE || RTXRelease || RTXDebug)
                    EasyImage.Threshold(objROI.ref_ROI, m_objSampleImage.ref_objMainImage, intSurfaceThresholdValue);
#endif

                }

                if (blnDebugImage)
                {
                    m_objSampleImage.SaveImage("D:\\TS\\objSampleImage11.bmp"); // debug
                    m_ImgTUnitDilateThresImage.Save("D:\\TS\\UnitDilateThresImage11.bmp"); // debug
                }

                // Template Image=m_DilateROI, Sample Image=objROI, Subtract Image=objContaminate
                EasyImage.Oper(EArithmeticLogicOperation.Subtract, m_objSampleImage.ref_objMainImage, m_ImgTUnitDilateThresImage, objContaminate.ref_ROI);
                objContaminate.LoadROISetting(objContaminate.ref_ROIPositionX + intAverageOffSetX, objContaminate.ref_ROIPositionY + intAverageOffSetY, // Reassign back to original sample location before build blobs.
                                objContaminate.ref_ROIWidth, objContaminate.ref_ROIHeight);

                if (blnDebugImage)
                    objContaminate.SaveImage("D:\\TS\\objContaminate0.bmp"); // debug

                // Set Contaminate ROI same size with unit surface ROI and Add Pixel edge tolerance to ROI
                //2021-01-21 ZJYEOH : ForeignMaterial have own ROI Tolerance Setting
                //int intStartPixelFromEdgeX = (int)Math.Round(m_fForeignMaterialStartPixelFromLeft, 0, MidpointRounding.AwayFromZero) + m_intMPDilateHalfWidth; //m_fPkgStartPixelFromLeft
                //int intStartPixelFromEdgeY = (int)Math.Round(m_fForeignMaterialStartPixelFromEdge, 0, MidpointRounding.AwayFromZero) + m_intMPDilateHalfWidth; //m_fPkgStartPixelFromEdge
                //int intStartPixelFromEdgeX2 = (int)Math.Round(m_fForeignMaterialStartPixelFromRight, 0, MidpointRounding.AwayFromZero) + m_intMPDilateHalfWidth; //m_fPkgStartPixelFromRight
                //int intStartPixelFromEdgeY2 = (int)Math.Round(m_fForeignMaterialStartPixelFromBottom, 0, MidpointRounding.AwayFromZero) + m_intMPDilateHalfWidth; //m_fPkgStartPixelFromBottom
                int intStartPixelFromEdgeX = (int)Math.Round(m_fForeignMaterialStartPixelFromLeft_Pad, 0, MidpointRounding.AwayFromZero) + m_intMPDilateHalfWidth; //m_fPkgStartPixelFromLeft
                int intStartPixelFromEdgeY = (int)Math.Round(m_fForeignMaterialStartPixelFromEdge_Pad, 0, MidpointRounding.AwayFromZero) + m_intMPDilateHalfWidth; //m_fPkgStartPixelFromEdge
                int intStartPixelFromEdgeX2 = (int)Math.Round(m_fForeignMaterialStartPixelFromRight_Pad, 0, MidpointRounding.AwayFromZero) + m_intMPDilateHalfWidth; //m_fPkgStartPixelFromRight
                int intStartPixelFromEdgeY2 = (int)Math.Round(m_fForeignMaterialStartPixelFromBottom_Pad, 0, MidpointRounding.AwayFromZero) + m_intMPDilateHalfWidth; //m_fPkgStartPixelFromBottom
                //objContaminate.LoadROISetting(objContaminate.ref_ROIPositionX + intStartPixelFromEdgeX,
                //                              objContaminate.ref_ROIPositionY + intStartPixelFromEdgeY,
                //                              objContaminate.ref_ROIWidth - intStartPixelFromEdgeX * 2,
                //                              objContaminate.ref_ROIHeight - intStartPixelFromEdgeY * 2);
                objContaminate.LoadROISetting(objUnitSurfaceROI.ref_ROIPositionX + intStartPixelFromEdgeX,
                                              objUnitSurfaceROI.ref_ROIPositionY + intStartPixelFromEdgeY,
                                              objUnitSurfaceROI.ref_ROIWidth - intStartPixelFromEdgeX2 - intStartPixelFromEdgeX,
                                              objUnitSurfaceROI.ref_ROIHeight - intStartPixelFromEdgeY2 - intStartPixelFromEdgeY);

                if (blnDebugImage)
                    objContaminate.SaveImage("D:\\TS\\objContaminate1.bmp"); // debug

                if (blnUseDoubleThreshold)
                {
                    BuildDilateObjects(objContaminate, (int)Math.Floor(m_fBlobsMinArea), 125);
                }
                else
                {
                    BuildDilateObjects(objContaminate, (int)Math.Floor(m_fBlobsMinArea), intSurfaceThresholdValue);
                }

                if (blnDebugImage)
                {
                    objContaminate.SaveImage("D:\\TS\\objContaminate.bmp"); // debug
                    m_objSampleImage.SaveImage("D:\\TS\\m_objSampleImage.bmp"); // debug

                    EImageBW8 objImage = new EImageBW8();
                    objImage.SetSize(m_ImgUnitTemplateImage.Width, m_ImgUnitTemplateImage.Height);
#if (Debug_2_12 || Release_2_12)
                    if (m_fPadImageGain != 1f)
                    {
                        EasyImage.GainOffset(m_ImgUnitTemplateImage, objImage, m_fPadImageGain);
                        EasyImage.Threshold(objImage, objImage, (uint)m_intThresholdValue);
                    }
                    else
                    {
                        EasyImage.Threshold(m_ImgUnitTemplateImage, objImage, (uint)m_intThresholdValue);
                    }
#elif (DEBUG || RELEASE || RTXRelease || RTXDebug)
                    if (m_fPadImageGain != 1f)
                    {
                        EasyImage.GainOffset(m_ImgUnitTemplateImage, objImage, m_fPadImageGain);
                        EasyImage.Threshold(objImage, objImage, m_intThresholdValue);
                    }
                    else
                    {
                        EasyImage.Threshold(m_ImgUnitTemplateImage, objImage, m_intThresholdValue);
                    }
#endif

                    objImage.Save("D:\\TS\\m_ImgUnitTemplateImage.bmp");    // debug
                    m_ImgTUnitDilateThresImage.Save("D:\\TS\\m_ImgTUnitDilateThresImage.bmp");// debug
                    objImage.Dispose();
                }
                int intNumObject = m_objDilateEBlobs.ref_intNumSelectedObject;
                int intArea, intContourX, intContourY;
                float fGravityCenterX, fGravityCenterY, fLimitCenterX, fLimitCenterY, fWidth, fHeight, fStartX, fStartY, fEndX, fEndY;
                int intTotalExtraArea = 0;

                for (int i = 0; i < intNumObject; i++)
                {
                    // Get sample data
                    fGravityCenterX = fGravityCenterY = fLimitCenterX = fLimitCenterY = fWidth = fHeight = fStartX = fStartY = fEndX = fEndY = 0;
                    intArea = intContourX = intContourY = 0;

                    fGravityCenterX = m_objDilateEBlobs.ref_arrGravityCenterX[i];
                    fGravityCenterY = m_objDilateEBlobs.ref_arrGravityCenterY[i];
                    fLimitCenterX = m_objDilateEBlobs.ref_arrLimitCenterX[i];
                    fLimitCenterY = m_objDilateEBlobs.ref_arrLimitCenterY[i];
                    fWidth = m_objDilateEBlobs.ref_arrWidth[i];
                    fHeight = m_objDilateEBlobs.ref_arrHeight[i];
                    intArea = m_objDilateEBlobs.ref_arrArea[i];
                    intContourX = m_objDilateEBlobs.ref_arrContourX[i];
                    intContourY = m_objDilateEBlobs.ref_arrContourY[i];

                    fLimitCenterX += (objUnitSurfaceROI.ref_ROIPositionX - objSampleROI.ref_ROIPositionX) + intStartPixelFromEdgeX;
                    fLimitCenterY += (objUnitSurfaceROI.ref_ROIPositionY - objSampleROI.ref_ROIPositionY) + intStartPixelFromEdgeY;

                    // Get object start point and end point
                    fStartX = fLimitCenterX - (fWidth / 2);
                    fStartY = fLimitCenterY - (fHeight / 2);
                    fEndX = fLimitCenterX + (fWidth / 2);
                    fEndY = fLimitCenterY + (fHeight / 2);

                    // Check is object inside the ROI area
                    bool blnInsideDontCareROI = false;
                    // 14-06-2019 ZJYEOH : Remove as Inspection Image subtracted White Image
                    //for (int c = 0; c < arrDontCare.Count; c++)
                    //{
                    //    if ((fLimitCenterX > arrDontCare[c][0].X) &&
                    //        (fLimitCenterY > arrDontCare[c][0].Y) &&
                    //        (fLimitCenterX < arrDontCare[c][1].X) &&
                    //        (fLimitCenterY < arrDontCare[c][1].Y))
                    //    {
                    //        blnInsideDontCareROI = true;
                    //        break;
                    //    }
                    //}

                    //List<int> intMatch2 = MatchOrdinaryBlobsFeatures(fStartX, fStartY, fEndX, fEndY, fGravityCenterX, fGravityCenterY);
                    //List<int> intMatch2 = MatchTemplateObjects_Inspection(objSampleROI, fStartX, fStartY, fEndX, fEndY, fWidth, fHeight, fGravityCenterX, fGravityCenterY, intArea, true);
                    List<int> intMatch = new List<int>();
                    //for (int j = 0; j < intMatch2.Count; j++)
                    //{
                    //    //if (m_objBlobs.ref_objContour.MatchObject(m_arrSampleBlobPads[intMatch2[j]].intContourIndex, intContourX, intContourY))
                    //    intMatch.Add(intMatch2[j]);
                    //}

                    //2021-01-15 ZJYEOH : If Blob not within pad area then consider as foreign material
                    if (intMatch.Count == 0)
                    {
                        // 2021 07 23 - Yeoh : double check is this extra already in m_arrExtraBlobs list. If yes, then ignore here.
                        //List<int> intMatch_Prev = MatchPreviousExtraDefectList(fStartX, fStartY, fEndX, fEndY, fGravityCenterX, fGravityCenterY);

                        //if (intMatch_Prev.Count == 0)
                        {
                            float fWidthInMM = fWidth / m_fMMToPixelXValue;
                            float fHeightInMM = fHeight / m_fMMToPixelYValue;
                            float fAreaInMM = intArea / m_fMMtoPixelAreaValue;

                            SampleExtraBlobsFeatures extra = new SampleExtraBlobsFeatures();
                            extra.fStartX = fStartX;
                            extra.fEndX = fEndX;
                            extra.fStartY = fStartY;
                            extra.fEndY = fEndY;
                            extra.fWidth = fWidth;
                            extra.fHeight = fHeight;
                            extra.fCenterX = fLimitCenterX;
                            extra.fCenterY = fLimitCenterY;
                            extra.fWidthInMM = fWidthInMM;
                            extra.fHeightInMM = fHeightInMM;
                            extra.fAreaInMM2 = fAreaInMM;
                            extra.strDefectName = "Foreign Material";
                            extra.intFailMask = 0;

                            if (m_blnWantCheckExtraPadLength)
                            {
                                //////////////// Check extra pad using length limit setting ////////////////////
                                if ((fWidthInMM > m_fExtraPadSetLength) ||
                                    (fHeightInMM > m_fExtraPadSetLength))
                                {
                                    if (fWidthInMM > m_fExtraPadSetLength)
                                        extra.intFailMask |= 0x01;

                                    if (fHeightInMM > m_fExtraPadSetLength)
                                        extra.intFailMask |= 0x02;

                                    m_intFailResultMask |= 0x01;
                                    m_blnFailForeignMaterialLength = true;

                                    // Collect extra pad min and max area for display error message
                                    if ((fWidthInMM > m_fExtraPadSetLength) &&
                                    (fHeightInMM > m_fExtraPadSetLength))
                                    {
                                        float fMin = Math.Min(fWidthInMM, fHeightInMM);
                                        if ((m_fResultExtraPadMinArea == -1) || (fMin < m_fResultExtraPadMinArea))
                                            m_fResultExtraPadMinArea = fMin;

                                        float fMax = Math.Max(fWidthInMM, fHeightInMM);
                                        if ((m_fResultExtraPadMaxArea == -1) || (fMax > m_fResultExtraPadMaxArea))
                                            m_fResultExtraPadMaxArea = fMax;
                                    }
                                    else if (fWidthInMM > m_fExtraPadSetLength)
                                    {
                                        if ((m_fResultExtraPadMinArea == -1) || (fWidthInMM < m_fResultExtraPadMinArea))
                                            m_fResultExtraPadMinArea = fWidthInMM;
                                        if ((m_fResultExtraPadMaxArea == -1) || (fWidthInMM > m_fResultExtraPadMaxArea))
                                            m_fResultExtraPadMaxArea = fWidthInMM;
                                    }
                                    else if (fHeightInMM > m_fExtraPadSetLength)
                                    {
                                        if ((m_fResultExtraPadMinArea == -1) || (fHeightInMM < m_fResultExtraPadMinArea))
                                            m_fResultExtraPadMinArea = fHeightInMM;
                                        if ((m_fResultExtraPadMaxArea == -1) || (fHeightInMM > m_fResultExtraPadMaxArea))
                                            m_fResultExtraPadMaxArea = fHeightInMM;
                                    }
                                }
                            }

                            if (m_blnWantCheckExtraPadArea && !m_blnFailForeignMaterialLength)
                            {
                                //////////////// Check extra pad using area limit setting ////////////////////
                                float fTightSettingTolerance = 0;
                                if (m_blnWantTightSetting)
                                {
                                    fTightSettingTolerance = (float)(Math.Pow(intArea, 0.5) * Math.Pow(m_fTightSettingTolerance, 2) * 2);
                                }
                                float fArea = intArea * m_fAreaMMPerPixel;  // Change unit pixel to mm
                                if (fArea > (m_fExtraPadSetArea - fTightSettingTolerance))
                                {
                                    extra.intFailMask |= 0x04;
                                    m_intFailResultMask |= 0x01;
                                    m_blnFailForeignMaterialArea = true;

                                    // Collect extra pad min and max area for display error message
                                    if ((m_fResultExtraPadMinArea == -1) || (fArea < m_fResultExtraPadMinArea))
                                        m_fResultExtraPadMinArea = fArea;
                                    if ((m_fResultExtraPadMaxArea == -1) || (fArea > m_fResultExtraPadMaxArea))
                                        m_fResultExtraPadMaxArea = fArea;
                                }
                            }

                            //////////////// Get Total Extra pad unit area ///////////////////////////////
                            if ((m_intFailOptionMask & 0x1000) > 0)
                            {
                                intTotalExtraArea += intArea;
                            }

                            m_arrExtraBlobs.Add(extra);
                            m_arrExtraBlobCenterX.Add(fLimitCenterX);
                            m_arrExtraBlobCenterY.Add(fLimitCenterY);
                            m_arrExtraBlobWidth.Add(fWidth);
                            m_arrExtraBlobHeight.Add(fHeight);
                        }
                    }
                }

                if (((m_intFailOptionMask & 0x1000) > 0) && !m_blnFailForeignMaterialLength && !m_blnFailForeignMaterialArea && intTotalExtraArea > 0)
                {
                    //////////////// Check Total Extra pad unit area ///////////////////////////////
                    float fArea = intTotalExtraArea * m_fAreaMMPerPixel;  // Change unit pixel to mm
                    if (fArea > m_fTotalExtraPadSetArea)
                    {
                        for (int i = 0; i < m_arrExtraBlobs.Count; i++)
                        {
                            SampleExtraBlobsFeatures objExtraBlob = m_arrExtraBlobs[i];
                            objExtraBlob.intFailMask |= 0x04;
                            m_arrExtraBlobs[i] = objExtraBlob;
                        }

                        m_intFailResultMask |= 0x1000;

                        // Collect total extra pad for display error message
                        m_fResultTotalExtraPadArea = fArea;
                    }
                }

                objROI.Dispose();
                objContaminate.Dispose();
            }
            catch (Exception ex)
            {
                SRMMessageBox.Show("CheckExtraObjectOnUnitSurface() error. Exception = " + ex.ToString());
            }
        }
        private void CheckPadEdgeLimit(ROI objPadROI, ROI objPkgROI)
        {
            if (!m_blnWantCheckPadEdgeLimit)
                return;

            for (int i = 0; i < m_arrSampleBlobPads.Length; i++)
            {
                if (m_arrSampleBlobPads[i].intFailMask == 0)
                {
                    float fStartX = objPadROI.ref_ROITotalX + m_arrSampleBlobPads[i].fStartX;
                    float fStartY = objPadROI.ref_ROITotalY + m_arrSampleBlobPads[i].fStartY;
                    float fEndX = objPadROI.ref_ROITotalX + m_arrSampleBlobPads[i].fEndX;
                    float fEndY = objPadROI.ref_ROITotalY + m_arrSampleBlobPads[i].fEndY;

                    float fROIStartX = objPkgROI.ref_ROITotalX;
                    float fROIStartY = objPkgROI.ref_ROITotalY;
                    float fROIEndX = objPkgROI.ref_ROITotalX + objPkgROI.ref_ROIWidth;
                    float fROIEndY = objPkgROI.ref_ROITotalY + objPkgROI.ref_ROIHeight;

                    float fResultEdgeLimitTop = 0;
                    float fResultEdgeLimitRight = 0;
                    float fResultEdgeLimitBottom = 0;
                    float fResultEdgeLimitLeft = 0;

                    float fEdgeLimitTop;
                    float fEdgeLimitRight;
                    float fEdgeLimitBottom;
                    float fEdgeLimitLeft;

                    int intGroupNo = ((BlobsFeatures)m_arrTemplateBlobPads[i]).intGroupID;
                    if (m_blnWantUseGroupToleranceSetting)
                    {
                        fEdgeLimitTop = ((BlobsFeatures)m_arrGroupTemplateBlobPads[intGroupNo]).fEdgeLimitTop;
                        fEdgeLimitRight = ((BlobsFeatures)m_arrGroupTemplateBlobPads[intGroupNo]).fEdgeLimitRight;
                        fEdgeLimitBottom = ((BlobsFeatures)m_arrGroupTemplateBlobPads[intGroupNo]).fEdgeLimitBottom;
                        fEdgeLimitLeft = ((BlobsFeatures)m_arrGroupTemplateBlobPads[intGroupNo]).fEdgeLimitLeft;
                    }
                    else
                    {
                        fEdgeLimitTop = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fEdgeLimitTop;
                        fEdgeLimitRight = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fEdgeLimitRight;
                        fEdgeLimitBottom = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fEdgeLimitBottom;
                        fEdgeLimitLeft = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fEdgeLimitLeft;
                    }

                    float fDiffTop = fStartY - fROIStartY;
                    float fDiffRight = fROIEndX - fEndX;//2020-12-05 ZJYEOH : Should be fEndX instead of fStartX
                    float fDiffBottom = fROIEndY - fEndY;
                    float fDiffLeft = fStartX - fROIStartX;



                    if (((BlobsFeatures)m_arrTemplateBlobPads[i]).blnEnable)
                    {
                        if (((BlobsFeatures)m_arrTemplateBlobPads[i]).fEdgeLimitTopOffset != 0)
                        {
                            fDiffTop += ((BlobsFeatures)m_arrTemplateBlobPads[i]).fEdgeLimitTopOffset / m_fMMPerPixelY;
                        }

                        if (((BlobsFeatures)m_arrTemplateBlobPads[i]).fEdgeLimitRightOffset != 0)
                        {
                            fDiffRight += ((BlobsFeatures)m_arrTemplateBlobPads[i]).fEdgeLimitRightOffset / m_fMMPerPixelX;
                        }

                        if (((BlobsFeatures)m_arrTemplateBlobPads[i]).fEdgeLimitBottomOffset != 0)
                        {
                            fDiffBottom += ((BlobsFeatures)m_arrTemplateBlobPads[i]).fEdgeLimitBottomOffset / m_fMMPerPixelY;
                        }

                        if (((BlobsFeatures)m_arrTemplateBlobPads[i]).fEdgeLimitLeftOffset != 0)
                        {
                            fDiffLeft += ((BlobsFeatures)m_arrTemplateBlobPads[i]).fEdgeLimitLeftOffset / m_fMMPerPixelX;
                        }

                        m_arrSamplePadEdge[i].fEdgeTop = fResultEdgeLimitTop = fDiffTop * m_fMMPerPixelY;
                        m_arrSamplePadEdge[i].fEdgeRight = fResultEdgeLimitRight = fDiffRight * m_fMMPerPixelX;
                        m_arrSamplePadEdge[i].fEdgeBottom = fResultEdgeLimitBottom = fDiffBottom * m_fMMPerPixelY;
                        m_arrSamplePadEdge[i].fEdgeLeft = fResultEdgeLimitLeft = fDiffLeft * m_fMMPerPixelX;

                        //if ((fDiffTop > (fEdgeLimitTop / m_fMMPerPixelY)) ||
                        //           (fDiffRight > (fEdgeLimitRight / m_fMMPerPixelX)) ||
                        //           (fDiffBottom > (fEdgeLimitBottom / m_fMMPerPixelY)) ||
                        //           (fDiffLeft > (fEdgeLimitLeft / m_fMMPerPixelX)))
                        if (fDiffTop < (fEdgeLimitTop / m_fMMPerPixelY))
                        {
                            m_arrSampleBlobPads[i].intFailMask |= 0x200000;
                            m_intFailResultMask |= 0x200000;
                        }

                        if (fDiffRight < (fEdgeLimitRight / m_fMMPerPixelX))
                        {
                            m_arrSampleBlobPads[i].intFailMask |= 0x400000;
                            m_intFailResultMask |= 0x400000;
                        }

                        if (fDiffBottom < (fEdgeLimitBottom / m_fMMPerPixelY))
                        {
                            m_arrSampleBlobPads[i].intFailMask |= 0x800000;
                            m_intFailResultMask |= 0x800000;
                        }

                        if (fDiffLeft < (fEdgeLimitLeft / m_fMMPerPixelX))
                        {
                            m_arrSampleBlobPads[i].intFailMask |= 0x1000000;
                            m_intFailResultMask |= 0x1000000;
                        }

                    }
                }
            }

        }
        private void CheckPadEdgeLimit_WithoutRotate(ROI objPadROI)
        {
            if (!m_blnWantCheckPadEdgeLimit)
                return;

            Line objPadLine = new Line();
            Line objLineTop = m_objRectGauge4L.ref_arrLineGauge[0].ref_ObjectLine;
            Line objLineRight = m_objRectGauge4L.ref_arrLineGauge[1].ref_ObjectLine;
            Line objLineBottom = m_objRectGauge4L.ref_arrLineGauge[2].ref_ObjectLine;
            Line objLineLeft = m_objRectGauge4L.ref_arrLineGauge[3].ref_ObjectLine;
            PointF pCross;
            PointF pPad;

            for (int i = 0; i < m_arrSampleBlobPads.Length; i++)
            {
                if (m_arrSampleBlobPads[i].intFailMask == 0)
                {
                    float fStartX = objPadROI.ref_ROITotalX + m_arrSampleBlobPads[i].fStartX;
                    float fStartY = objPadROI.ref_ROITotalY + m_arrSampleBlobPads[i].fStartY;
                    float fEndX = objPadROI.ref_ROITotalX + m_arrSampleBlobPads[i].fEndX;
                    float fEndY = objPadROI.ref_ROITotalY + m_arrSampleBlobPads[i].fEndY;
                    float fCenterX = (fStartX + fEndX) / 2;
                    float fCenterY = (fStartY + fEndY) / 2;

                    //float fROIStartX = objPkgROI.ref_ROITotalX;
                    //float fROIStartY = objPkgROI.ref_ROITotalY;
                    //float fROIEndX = objPkgROI.ref_ROITotalX + objPkgROI.ref_ROIWidth;
                    //float fROIEndY = objPkgROI.ref_ROITotalY + objPkgROI.ref_ROIHeight;

                    float fResultEdgeLimitTop = 0;
                    float fResultEdgeLimitRight = 0;
                    float fResultEdgeLimitBottom = 0;
                    float fResultEdgeLimitLeft = 0;

                    float fEdgeLimitTop;
                    float fEdgeLimitRight;
                    float fEdgeLimitBottom;
                    float fEdgeLimitLeft;

                    int intGroupNo = ((BlobsFeatures)m_arrTemplateBlobPads[i]).intGroupID;
                    if (m_blnWantUseGroupToleranceSetting)
                    {
                        fEdgeLimitTop = ((BlobsFeatures)m_arrGroupTemplateBlobPads[intGroupNo]).fEdgeLimitTop;
                        fEdgeLimitRight = ((BlobsFeatures)m_arrGroupTemplateBlobPads[intGroupNo]).fEdgeLimitRight;
                        fEdgeLimitBottom = ((BlobsFeatures)m_arrGroupTemplateBlobPads[intGroupNo]).fEdgeLimitBottom;
                        fEdgeLimitLeft = ((BlobsFeatures)m_arrGroupTemplateBlobPads[intGroupNo]).fEdgeLimitLeft;
                    }
                    else
                    {
                        fEdgeLimitTop = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fEdgeLimitTop;
                        fEdgeLimitRight = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fEdgeLimitRight;
                        fEdgeLimitBottom = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fEdgeLimitBottom;
                        fEdgeLimitLeft = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fEdgeLimitLeft;
                    }

                    //float fDiffTop = fStartY - fROIStartY;
                    //float fDiffRight = fROIEndX - fEndX;//2020-12-05 ZJYEOH : Should be fEndX instead of fStartX
                    //float fDiffBottom = fROIEndY - fEndY;
                    //float fDiffLeft = fStartX - fROIStartX;

                    float fDiffTop = 0;//fStartY - fROIStartY;
                    float fDiffRight = 0;//fROIEndX - fEndX;//2020-12-05 ZJYEOH : Should be fEndX instead of fStartX
                    float fDiffBottom = 0;//fROIEndY - fEndY;
                    float fDiffLeft = 0;//fStartX - fROIStartX;

                    pPad = new PointF(fCenterX, fStartY);
                    objPadLine.CalculateLGStraightLine(pPad, objLineTop.ref_dAngle + 90);
                    pCross = Line.GetCrossPoint(objPadLine, objLineTop);
                    if (fStartY - pCross.Y > 0)
                        fDiffTop = Math2.GetDistanceBtw2Points(pCross, pPad);
                    else
                        fDiffTop = -Math2.GetDistanceBtw2Points(pCross, pPad);

                    pPad = new PointF(fEndX, fCenterY);
                    objPadLine.CalculateLGStraightLine(pPad, objLineRight.ref_dAngle + 90);
                    pCross = Line.GetCrossPoint(objPadLine, objLineRight);
                    if (pCross.X - fEndX > 0)
                        fDiffRight = Math2.GetDistanceBtw2Points(pCross, pPad);
                    else
                        fDiffRight = -Math2.GetDistanceBtw2Points(pCross, pPad);

                    pPad = new PointF(fCenterX, fEndY);
                    objPadLine.CalculateLGStraightLine(pPad, objLineBottom.ref_dAngle + 90);
                    pCross = Line.GetCrossPoint(objPadLine, objLineBottom);
                    if (pCross.Y - fEndY > 0)
                        fDiffBottom = Math2.GetDistanceBtw2Points(pCross, pPad);
                    else
                        fDiffBottom = -Math2.GetDistanceBtw2Points(pCross, pPad);

                    pPad = new PointF(fStartX, fCenterY);
                    objPadLine.CalculateLGStraightLine(pPad, objLineLeft.ref_dAngle + 90);
                    pCross = Line.GetCrossPoint(objPadLine, objLineLeft);
                    if (fStartX - pCross.X > 0)
                        fDiffLeft = Math2.GetDistanceBtw2Points(pCross, pPad);
                    else
                        fDiffLeft = -Math2.GetDistanceBtw2Points(pCross, pPad);

                    if (((BlobsFeatures)m_arrTemplateBlobPads[i]).blnEnable)
                    {
                        if (((BlobsFeatures)m_arrTemplateBlobPads[i]).fEdgeLimitTopOffset != 0)
                        {
                            fDiffTop += ((BlobsFeatures)m_arrTemplateBlobPads[i]).fEdgeLimitTopOffset / m_fMMPerPixelY;
                        }

                        if (((BlobsFeatures)m_arrTemplateBlobPads[i]).fEdgeLimitRightOffset != 0)
                        {
                            fDiffRight += ((BlobsFeatures)m_arrTemplateBlobPads[i]).fEdgeLimitRightOffset / m_fMMPerPixelX;
                        }

                        if (((BlobsFeatures)m_arrTemplateBlobPads[i]).fEdgeLimitBottomOffset != 0)
                        {
                            fDiffBottom += ((BlobsFeatures)m_arrTemplateBlobPads[i]).fEdgeLimitBottomOffset / m_fMMPerPixelY;
                        }

                        if (((BlobsFeatures)m_arrTemplateBlobPads[i]).fEdgeLimitLeftOffset != 0)
                        {
                            fDiffLeft += ((BlobsFeatures)m_arrTemplateBlobPads[i]).fEdgeLimitLeftOffset / m_fMMPerPixelX;
                        }

                        m_arrSamplePadEdge[i].fEdgeTop = fResultEdgeLimitTop = fDiffTop * m_fMMPerPixelY;
                        m_arrSamplePadEdge[i].fEdgeRight = fResultEdgeLimitRight = fDiffRight * m_fMMPerPixelX;
                        m_arrSamplePadEdge[i].fEdgeBottom = fResultEdgeLimitBottom = fDiffBottom * m_fMMPerPixelY;
                        m_arrSamplePadEdge[i].fEdgeLeft = fResultEdgeLimitLeft = fDiffLeft * m_fMMPerPixelX;

                        //if ((fDiffTop > (fEdgeLimitTop / m_fMMPerPixelY)) ||
                        //           (fDiffRight > (fEdgeLimitRight / m_fMMPerPixelX)) ||
                        //           (fDiffBottom > (fEdgeLimitBottom / m_fMMPerPixelY)) ||
                        //           (fDiffLeft > (fEdgeLimitLeft / m_fMMPerPixelX)))
                        if (fDiffTop < (fEdgeLimitTop / m_fMMPerPixelY))
                        {
                            m_arrSampleBlobPads[i].intFailMask |= 0x200000;
                            m_intFailResultMask |= 0x200000;
                        }

                        if (fDiffRight < (fEdgeLimitRight / m_fMMPerPixelX))
                        {
                            m_arrSampleBlobPads[i].intFailMask |= 0x400000;
                            m_intFailResultMask |= 0x400000;
                        }

                        if (fDiffBottom < (fEdgeLimitBottom / m_fMMPerPixelY))
                        {
                            m_arrSampleBlobPads[i].intFailMask |= 0x800000;
                            m_intFailResultMask |= 0x800000;
                        }

                        if (fDiffLeft < (fEdgeLimitLeft / m_fMMPerPixelX))
                        {
                            m_arrSampleBlobPads[i].intFailMask |= 0x1000000;
                            m_intFailResultMask |= 0x1000000;
                        }

                    }
                }
            }

        }
        private void CheckPadEdgeLimit_Rotate(ROI objPadROI, Line objLineTop, Line objLineRight, Line objLineBottom, Line objLineLeft)
        {
            if (!m_blnWantCheckPadEdgeLimit)
                return;

            Line objPadLine = new Line();
            //Line objLineTop = m_objRectGauge4L.ref_arrLineGauge[0].ref_ObjectLine;
            //Line objLineRight = m_objRectGauge4L.ref_arrLineGauge[1].ref_ObjectLine;
            //Line objLineBottom = m_objRectGauge4L.ref_arrLineGauge[2].ref_ObjectLine;
            //Line objLineLeft = m_objRectGauge4L.ref_arrLineGauge[3].ref_ObjectLine;
            PointF pCross;
            PointF pPad;

            for (int i = 0; i < m_arrSampleBlobPads.Length; i++)
            {
                if (m_arrSampleBlobPads[i].intFailMask == 0)
                {
                    float fStartX = objPadROI.ref_ROITotalX + m_arrSampleBlobPads[i].fStartX;
                    float fStartY = objPadROI.ref_ROITotalY + m_arrSampleBlobPads[i].fStartY;
                    float fEndX = objPadROI.ref_ROITotalX + m_arrSampleBlobPads[i].fEndX;
                    float fEndY = objPadROI.ref_ROITotalY + m_arrSampleBlobPads[i].fEndY;
                    float fCenterX = (fStartX + fEndX) / 2;
                    float fCenterY = (fStartY + fEndY) / 2;

                    //float fROIStartX = objPkgROI.ref_ROITotalX;
                    //float fROIStartY = objPkgROI.ref_ROITotalY;
                    //float fROIEndX = objPkgROI.ref_ROITotalX + objPkgROI.ref_ROIWidth;
                    //float fROIEndY = objPkgROI.ref_ROITotalY + objPkgROI.ref_ROIHeight;

                    float fResultEdgeLimitTop = 0;
                    float fResultEdgeLimitRight = 0;
                    float fResultEdgeLimitBottom = 0;
                    float fResultEdgeLimitLeft = 0;

                    float fEdgeLimitTop;
                    float fEdgeLimitRight;
                    float fEdgeLimitBottom;
                    float fEdgeLimitLeft;

                    int intGroupNo = ((BlobsFeatures)m_arrTemplateBlobPads[i]).intGroupID;
                    if (m_blnWantUseGroupToleranceSetting)
                    {
                        fEdgeLimitTop = ((BlobsFeatures)m_arrGroupTemplateBlobPads[intGroupNo]).fEdgeLimitTop;
                        fEdgeLimitRight = ((BlobsFeatures)m_arrGroupTemplateBlobPads[intGroupNo]).fEdgeLimitRight;
                        fEdgeLimitBottom = ((BlobsFeatures)m_arrGroupTemplateBlobPads[intGroupNo]).fEdgeLimitBottom;
                        fEdgeLimitLeft = ((BlobsFeatures)m_arrGroupTemplateBlobPads[intGroupNo]).fEdgeLimitLeft;
                    }
                    else
                    {
                        fEdgeLimitTop = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fEdgeLimitTop;
                        fEdgeLimitRight = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fEdgeLimitRight;
                        fEdgeLimitBottom = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fEdgeLimitBottom;
                        fEdgeLimitLeft = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fEdgeLimitLeft;
                    }

                    //float fDiffTop = fStartY - fROIStartY;
                    //float fDiffRight = fROIEndX - fEndX;//2020-12-05 ZJYEOH : Should be fEndX instead of fStartX
                    //float fDiffBottom = fROIEndY - fEndY;
                    //float fDiffLeft = fStartX - fROIStartX;

                    float fDiffTop = 0;//fStartY - fROIStartY;
                    float fDiffRight = 0;//fROIEndX - fEndX;//2020-12-05 ZJYEOH : Should be fEndX instead of fStartX
                    float fDiffBottom = 0;//fROIEndY - fEndY;
                    float fDiffLeft = 0;//fStartX - fROIStartX;

                    pPad = new PointF(fCenterX, fStartY);
                    objPadLine.CalculateStraightLine(pPad, objLineTop.ref_dAngle + 90);
                    pCross = Line.GetCrossPoint(objPadLine, objLineTop);
                    if (fStartY - pCross.Y > 0)
                        fDiffTop = Math2.GetDistanceBtw2Points(pCross, pPad);
                    else
                        fDiffTop = -Math2.GetDistanceBtw2Points(pCross, pPad);

                    pPad = new PointF(fEndX, fCenterY);
                    objPadLine.CalculateStraightLine(pPad, objLineRight.ref_dAngle + 90);
                    pCross = Line.GetCrossPoint(objPadLine, objLineRight);
                    if (pCross.X - fEndX > 0)
                        fDiffRight = Math2.GetDistanceBtw2Points(pCross, pPad);
                    else
                        fDiffRight = -Math2.GetDistanceBtw2Points(pCross, pPad);

                    pPad = new PointF(fCenterX, fEndY);
                    objPadLine.CalculateStraightLine(pPad, objLineBottom.ref_dAngle + 90);
                    pCross = Line.GetCrossPoint(objPadLine, objLineBottom);
                    if (pCross.Y - fEndY > 0)
                        fDiffBottom = Math2.GetDistanceBtw2Points(pCross, pPad);
                    else
                        fDiffBottom = -Math2.GetDistanceBtw2Points(pCross, pPad);

                    pPad = new PointF(fStartX, fCenterY);
                    objPadLine.CalculateStraightLine(pPad, objLineLeft.ref_dAngle + 90);
                    pCross = Line.GetCrossPoint(objPadLine, objLineLeft);
                    if (fStartX - pCross.X > 0)
                        fDiffLeft = Math2.GetDistanceBtw2Points(pCross, pPad);
                    else
                        fDiffLeft = -Math2.GetDistanceBtw2Points(pCross, pPad);

                    if (((BlobsFeatures)m_arrTemplateBlobPads[i]).blnEnable)
                    {
                        if (((BlobsFeatures)m_arrTemplateBlobPads[i]).fEdgeLimitTopOffset != 0)
                        {
                            fDiffTop += ((BlobsFeatures)m_arrTemplateBlobPads[i]).fEdgeLimitTopOffset / m_fMMPerPixelY;
                        }

                        if (((BlobsFeatures)m_arrTemplateBlobPads[i]).fEdgeLimitRightOffset != 0)
                        {
                            fDiffRight += ((BlobsFeatures)m_arrTemplateBlobPads[i]).fEdgeLimitRightOffset / m_fMMPerPixelX;
                        }

                        if (((BlobsFeatures)m_arrTemplateBlobPads[i]).fEdgeLimitBottomOffset != 0)
                        {
                            fDiffBottom += ((BlobsFeatures)m_arrTemplateBlobPads[i]).fEdgeLimitBottomOffset / m_fMMPerPixelY;
                        }

                        if (((BlobsFeatures)m_arrTemplateBlobPads[i]).fEdgeLimitLeftOffset != 0)
                        {
                            fDiffLeft += ((BlobsFeatures)m_arrTemplateBlobPads[i]).fEdgeLimitLeftOffset / m_fMMPerPixelX;
                        }

                        m_arrSamplePadEdge[i].fEdgeTop = fResultEdgeLimitTop = fDiffTop * m_fMMPerPixelY;
                        m_arrSamplePadEdge[i].fEdgeRight = fResultEdgeLimitRight = fDiffRight * m_fMMPerPixelX;
                        m_arrSamplePadEdge[i].fEdgeBottom = fResultEdgeLimitBottom = fDiffBottom * m_fMMPerPixelY;
                        m_arrSamplePadEdge[i].fEdgeLeft = fResultEdgeLimitLeft = fDiffLeft * m_fMMPerPixelX;

                        //if ((fDiffTop > (fEdgeLimitTop / m_fMMPerPixelY)) ||
                        //           (fDiffRight > (fEdgeLimitRight / m_fMMPerPixelX)) ||
                        //           (fDiffBottom > (fEdgeLimitBottom / m_fMMPerPixelY)) ||
                        //           (fDiffLeft > (fEdgeLimitLeft / m_fMMPerPixelX)))
                        if (fDiffTop < (fEdgeLimitTop / m_fMMPerPixelY))
                        {
                            m_arrSampleBlobPads[i].intFailMask |= 0x200000;
                            m_intFailResultMask |= 0x200000;
                        }

                        if (fDiffRight < (fEdgeLimitRight / m_fMMPerPixelX))
                        {
                            m_arrSampleBlobPads[i].intFailMask |= 0x400000;
                            m_intFailResultMask |= 0x400000;
                        }

                        if (fDiffBottom < (fEdgeLimitBottom / m_fMMPerPixelY))
                        {
                            m_arrSampleBlobPads[i].intFailMask |= 0x800000;
                            m_intFailResultMask |= 0x800000;
                        }

                        if (fDiffLeft < (fEdgeLimitLeft / m_fMMPerPixelX))
                        {
                            m_arrSampleBlobPads[i].intFailMask |= 0x1000000;
                            m_intFailResultMask |= 0x1000000;
                        }

                    }
                }
            }

        }
        private void CheckPadEdgeDistance(ROI objPadROI, ROI objPkgROI)
        {
            if (!m_blnWantCheckPadEdgeDistance)
                return;

            float fROIStartX = objPkgROI.ref_ROITotalX;
            float fROIStartY = objPkgROI.ref_ROITotalY;
            float fROIEndX = objPkgROI.ref_ROITotalX + objPkgROI.ref_ROIWidth;
            float fROIEndY = objPkgROI.ref_ROITotalY + objPkgROI.ref_ROIHeight;

            for (int i = 0; i < m_arrSampleBlobPads.Length; i++)
            {
                if (((BlobsFeatures)m_arrTemplateBlobPads[i]).blnEnable)
                {
                    float fStartX = objPadROI.ref_ROITotalX + m_arrSampleBlobPads[i].fStartX;
                    float fStartY = objPadROI.ref_ROITotalY + m_arrSampleBlobPads[i].fStartY;
                    float fEndX = objPadROI.ref_ROITotalX + m_arrSampleBlobPads[i].fEndX;
                    float fEndY = objPadROI.ref_ROITotalY + m_arrSampleBlobPads[i].fEndY;

                    float fDiffTop = fStartY - fROIStartY;
                    float fDiffRight = fROIEndX - fEndX;
                    float fDiffBottom = fROIEndY - fEndY;
                    float fDiffLeft = fStartX - fROIStartX;

                    if (m_fResultPadEdgeDistance_Top == 0)
                    {
                        m_fResultPadEdgeDistance_Top = fDiffTop;
                        m_intResultPadNoEdgeDistance_Top = i;
                    }
                    if (Math.Abs(m_fResultPadEdgeDistance_Top) > Math.Abs(fDiffTop))
                    {
                        m_fResultPadEdgeDistance_Top = fDiffTop;
                        m_intResultPadNoEdgeDistance_Top = i;
                    }

                    if (m_fResultPadEdgeDistance_Right == 0)
                    {
                        m_fResultPadEdgeDistance_Right = fDiffRight;
                        m_intResultPadNoEdgeDistance_Right = i;
                    }
                    if (Math.Abs(m_fResultPadEdgeDistance_Right) > Math.Abs(fDiffRight))
                    {
                        m_fResultPadEdgeDistance_Right = fDiffRight;
                        m_intResultPadNoEdgeDistance_Right = i;
                    }

                    if (m_fResultPadEdgeDistance_Bottom == 0)
                    {
                        m_fResultPadEdgeDistance_Bottom = fDiffBottom;
                        m_intResultPadNoEdgeDistance_Bottom = i;
                    }
                    if (Math.Abs(m_fResultPadEdgeDistance_Bottom) > Math.Abs(fDiffBottom))
                    {
                        m_fResultPadEdgeDistance_Bottom = fDiffBottom;
                        m_intResultPadNoEdgeDistance_Bottom = i;
                    }

                    if (m_fResultPadEdgeDistance_Left == 0)
                    {
                        m_fResultPadEdgeDistance_Left = fDiffLeft;
                        m_intResultPadNoEdgeDistance_Left = i;
                    }
                    if (Math.Abs(m_fResultPadEdgeDistance_Left) > Math.Abs(fDiffLeft))
                    {
                        m_fResultPadEdgeDistance_Left = fDiffLeft;
                        m_intResultPadNoEdgeDistance_Left = i;
                    }

                    if (((BlobsFeatures)m_arrTemplateBlobPads[i]).fEdgeDistanceTopOffset != 0)
                    {
                        m_fResultPadEdgeDistance_Top += ((BlobsFeatures)m_arrTemplateBlobPads[i]).fEdgeDistanceTopOffset / m_fMMPerPixelY;
                    }

                    if (((BlobsFeatures)m_arrTemplateBlobPads[i]).fEdgeDistanceRightOffset != 0)
                    {
                        m_fResultPadEdgeDistance_Right += ((BlobsFeatures)m_arrTemplateBlobPads[i]).fEdgeDistanceRightOffset / m_fMMPerPixelX;
                    }

                    if (((BlobsFeatures)m_arrTemplateBlobPads[i]).fEdgeDistanceBottomOffset != 0)
                    {
                        m_fResultPadEdgeDistance_Bottom += ((BlobsFeatures)m_arrTemplateBlobPads[i]).fEdgeDistanceBottomOffset / m_fMMPerPixelY;
                    }

                    if (((BlobsFeatures)m_arrTemplateBlobPads[i]).fEdgeDistanceLeftOffset != 0)
                    {
                        m_fResultPadEdgeDistance_Left += ((BlobsFeatures)m_arrTemplateBlobPads[i]).fEdgeDistanceLeftOffset / m_fMMPerPixelX;
                    }
                }
            }

            if ((m_fResultPadEdgeDistance_Top < m_fEdgeDistanceMin_Top / m_fMMPerPixelY) ||
                (m_fResultPadEdgeDistance_Top > m_fEdgeDistanceMax_Top / m_fMMPerPixelY))
            {
                m_intFailResultMask |= 0x20000000;
                m_arrSampleBlobPads[m_intResultPadNoEdgeDistance_Top].intFailMask |= 0x20000000;
            }

            if ((m_fResultPadEdgeDistance_Right < m_fEdgeDistanceMin_Right / m_fMMPerPixelX) ||
                (m_fResultPadEdgeDistance_Right > m_fEdgeDistanceMax_Right / m_fMMPerPixelX))
            {
                m_intFailResultMask |= 0x40000000;
                m_arrSampleBlobPads[m_intResultPadNoEdgeDistance_Right].intFailMask |= 0x40000000;
            }

            if ((m_fResultPadEdgeDistance_Bottom < m_fEdgeDistanceMin_Bottom / m_fMMPerPixelY) ||
                 (m_fResultPadEdgeDistance_Bottom > m_fEdgeDistanceMax_Bottom / m_fMMPerPixelY))
            {
                m_intFailResultMask |= 0x80000000;
                m_arrSampleBlobPads[m_intResultPadNoEdgeDistance_Bottom].intFailMask |= 0x80000000;
            }

            if ((m_fResultPadEdgeDistance_Left < m_fEdgeDistanceMin_Left / m_fMMPerPixelX) ||
                 (m_fResultPadEdgeDistance_Left > m_fEdgeDistanceMax_Left / m_fMMPerPixelX))
            {
                m_intFailResultMask |= 0x100000000;
                m_arrSampleBlobPads[m_intResultPadNoEdgeDistance_Left].intFailMask |= 0x100000000;
            }

            m_fResultPadEdgeDistance_Top *= m_fMMPerPixelY;
            m_fResultPadEdgeDistance_Right *= m_fMMPerPixelX;
            m_fResultPadEdgeDistance_Bottom *= m_fMMPerPixelY;
            m_fResultPadEdgeDistance_Left *= m_fMMPerPixelX;

        }
        private void CheckPadEdgeDistance_WithoutRotate(ROI objPadROI)
        {
            if (!m_blnWantCheckPadEdgeDistance)
                return;

            //float fROIStartX = objPkgROI.ref_ROITotalX;
            //float fROIStartY = objPkgROI.ref_ROITotalY;
            //float fROIEndX = objPkgROI.ref_ROITotalX + objPkgROI.ref_ROIWidth;
            //float fROIEndY = objPkgROI.ref_ROITotalY + objPkgROI.ref_ROIHeight;

            Line objPadLine = new Line();
            Line objLineTop = m_objRectGauge4L.ref_arrLineGauge[0].ref_ObjectLine;
            Line objLineRight = m_objRectGauge4L.ref_arrLineGauge[1].ref_ObjectLine;
            Line objLineBottom = m_objRectGauge4L.ref_arrLineGauge[2].ref_ObjectLine;
            Line objLineLeft = m_objRectGauge4L.ref_arrLineGauge[3].ref_ObjectLine;
            PointF pCross;
            PointF pPad;

            for (int i = 0; i < m_arrSampleBlobPads.Length; i++)
            {
                if (((BlobsFeatures)m_arrTemplateBlobPads[i]).blnEnable)
                {
                    float fStartX = objPadROI.ref_ROITotalX + m_arrSampleBlobPads[i].fStartX;
                    float fStartY = objPadROI.ref_ROITotalY + m_arrSampleBlobPads[i].fStartY;
                    float fEndX = objPadROI.ref_ROITotalX + m_arrSampleBlobPads[i].fEndX;
                    float fEndY = objPadROI.ref_ROITotalY + m_arrSampleBlobPads[i].fEndY;
                    float fCenterX = (fStartX + fEndX) / 2;
                    float fCenterY = (fStartY + fEndY) / 2;

                    float fDiffTop = 0;//fStartY - fROIStartY;
                    float fDiffRight = 0;//fROIEndX - fEndX;
                    float fDiffBottom = 0;//fROIEndY - fEndY;
                    float fDiffLeft = 0;//fStartX - fROIStartX;

                    pPad = new PointF(fCenterX, fStartY);
                    objPadLine.CalculateLGStraightLine(pPad, objLineTop.ref_dAngle + 90);
                    pCross = Line.GetCrossPoint(objPadLine, objLineTop);
                    if (fStartY - pCross.Y > 0)
                        fDiffTop = Math2.GetDistanceBtw2Points(pCross, pPad);
                    else
                        fDiffTop = -Math2.GetDistanceBtw2Points(pCross, pPad);

                    pPad = new PointF(fEndX, fCenterY);
                    objPadLine.CalculateLGStraightLine(pPad, objLineRight.ref_dAngle + 90);
                    pCross = Line.GetCrossPoint(objPadLine, objLineRight);
                    if (pCross.X - fEndX > 0)
                        fDiffRight = Math2.GetDistanceBtw2Points(pCross, pPad);
                    else
                        fDiffRight = -Math2.GetDistanceBtw2Points(pCross, pPad);

                    pPad = new PointF(fCenterX, fEndY);
                    objPadLine.CalculateLGStraightLine(pPad, objLineBottom.ref_dAngle + 90);
                    pCross = Line.GetCrossPoint(objPadLine, objLineBottom);
                    if (pCross.Y - fEndY > 0)
                        fDiffBottom = Math2.GetDistanceBtw2Points(pCross, pPad);
                    else
                        fDiffBottom = -Math2.GetDistanceBtw2Points(pCross, pPad);

                    pPad = new PointF(fStartX, fCenterY);
                    objPadLine.CalculateLGStraightLine(pPad, objLineLeft.ref_dAngle + 90);
                    pCross = Line.GetCrossPoint(objPadLine, objLineLeft);
                    if (fStartX - pCross.X > 0)
                        fDiffLeft = Math2.GetDistanceBtw2Points(pCross, pPad);
                    else
                        fDiffLeft = -Math2.GetDistanceBtw2Points(pCross, pPad);

                    if (m_fResultPadEdgeDistance_Top == 0)
                    {
                        m_fResultPadEdgeDistance_Top = fDiffTop;
                        m_intResultPadNoEdgeDistance_Top = i;
                    }
                    if (Math.Abs(m_fResultPadEdgeDistance_Top) > Math.Abs(fDiffTop))
                    {
                        m_fResultPadEdgeDistance_Top = fDiffTop;
                        m_intResultPadNoEdgeDistance_Top = i;
                    }

                    if (m_fResultPadEdgeDistance_Right == 0)
                    {
                        m_fResultPadEdgeDistance_Right = fDiffRight;
                        m_intResultPadNoEdgeDistance_Right = i;
                    }
                    if (Math.Abs(m_fResultPadEdgeDistance_Right) > Math.Abs(fDiffRight))
                    {
                        m_fResultPadEdgeDistance_Right = fDiffRight;
                        m_intResultPadNoEdgeDistance_Right = i;
                    }

                    if (m_fResultPadEdgeDistance_Bottom == 0)
                    {
                        m_fResultPadEdgeDistance_Bottom = fDiffBottom;
                        m_intResultPadNoEdgeDistance_Bottom = i;
                    }
                    if (Math.Abs(m_fResultPadEdgeDistance_Bottom) > Math.Abs(fDiffBottom))
                    {
                        m_fResultPadEdgeDistance_Bottom = fDiffBottom;
                        m_intResultPadNoEdgeDistance_Bottom = i;
                    }

                    if (m_fResultPadEdgeDistance_Left == 0)
                    {
                        m_fResultPadEdgeDistance_Left = fDiffLeft;
                        m_intResultPadNoEdgeDistance_Left = i;
                    }
                    if (Math.Abs(m_fResultPadEdgeDistance_Left) > Math.Abs(fDiffLeft))
                    {
                        m_fResultPadEdgeDistance_Left = fDiffLeft;
                        m_intResultPadNoEdgeDistance_Left = i;
                    }

                    if (((BlobsFeatures)m_arrTemplateBlobPads[i]).fEdgeDistanceTopOffset != 0)
                    {
                        m_fResultPadEdgeDistance_Top += ((BlobsFeatures)m_arrTemplateBlobPads[i]).fEdgeDistanceTopOffset / m_fMMPerPixelY;
                    }

                    if (((BlobsFeatures)m_arrTemplateBlobPads[i]).fEdgeDistanceRightOffset != 0)
                    {
                        m_fResultPadEdgeDistance_Right += ((BlobsFeatures)m_arrTemplateBlobPads[i]).fEdgeDistanceRightOffset / m_fMMPerPixelX;
                    }

                    if (((BlobsFeatures)m_arrTemplateBlobPads[i]).fEdgeDistanceBottomOffset != 0)
                    {
                        m_fResultPadEdgeDistance_Bottom += ((BlobsFeatures)m_arrTemplateBlobPads[i]).fEdgeDistanceBottomOffset / m_fMMPerPixelY;
                    }

                    if (((BlobsFeatures)m_arrTemplateBlobPads[i]).fEdgeDistanceLeftOffset != 0)
                    {
                        m_fResultPadEdgeDistance_Left += ((BlobsFeatures)m_arrTemplateBlobPads[i]).fEdgeDistanceLeftOffset / m_fMMPerPixelX;
                    }
                }
            }

            if ((m_fResultPadEdgeDistance_Top < m_fEdgeDistanceMin_Top / m_fMMPerPixelY) ||
                (m_fResultPadEdgeDistance_Top > m_fEdgeDistanceMax_Top / m_fMMPerPixelY))
            {
                m_intFailResultMask |= 0x20000000;
                m_arrSampleBlobPads[m_intResultPadNoEdgeDistance_Top].intFailMask |= 0x20000000;
            }

            if ((m_fResultPadEdgeDistance_Right < m_fEdgeDistanceMin_Right / m_fMMPerPixelX) ||
                (m_fResultPadEdgeDistance_Right > m_fEdgeDistanceMax_Right / m_fMMPerPixelX))
            {
                m_intFailResultMask |= 0x40000000;
                m_arrSampleBlobPads[m_intResultPadNoEdgeDistance_Right].intFailMask |= 0x40000000;
            }

            if ((m_fResultPadEdgeDistance_Bottom < m_fEdgeDistanceMin_Bottom / m_fMMPerPixelY) ||
                 (m_fResultPadEdgeDistance_Bottom > m_fEdgeDistanceMax_Bottom / m_fMMPerPixelY))
            {
                m_intFailResultMask |= 0x80000000;
                m_arrSampleBlobPads[m_intResultPadNoEdgeDistance_Bottom].intFailMask |= 0x80000000;
            }

            if ((m_fResultPadEdgeDistance_Left < m_fEdgeDistanceMin_Left / m_fMMPerPixelX) ||
                 (m_fResultPadEdgeDistance_Left > m_fEdgeDistanceMax_Left / m_fMMPerPixelX))
            {
                m_intFailResultMask |= 0x100000000;
                m_arrSampleBlobPads[m_intResultPadNoEdgeDistance_Left].intFailMask |= 0x100000000;
            }

            m_fResultPadEdgeDistance_Top *= m_fMMPerPixelY;
            m_fResultPadEdgeDistance_Right *= m_fMMPerPixelX;
            m_fResultPadEdgeDistance_Bottom *= m_fMMPerPixelY;
            m_fResultPadEdgeDistance_Left *= m_fMMPerPixelX;

        }
        private void CheckPadEdgeDistance_Rotate(ROI objPadROI, Line objLineTop, Line objLineRight, Line objLineBottom, Line objLineLeft)
        {
            if (!m_blnWantCheckPadEdgeDistance)
                return;

            //float fROIStartX = objPkgROI.ref_ROITotalX;
            //float fROIStartY = objPkgROI.ref_ROITotalY;
            //float fROIEndX = objPkgROI.ref_ROITotalX + objPkgROI.ref_ROIWidth;
            //float fROIEndY = objPkgROI.ref_ROITotalY + objPkgROI.ref_ROIHeight;

            Line objPadLine = new Line();
            //Line objLineTop = m_objRectGauge4L.ref_arrLineGauge[0].ref_ObjectLine;
            //Line objLineRight = m_objRectGauge4L.ref_arrLineGauge[1].ref_ObjectLine;
            //Line objLineBottom = m_objRectGauge4L.ref_arrLineGauge[2].ref_ObjectLine;
            //Line objLineLeft = m_objRectGauge4L.ref_arrLineGauge[3].ref_ObjectLine;
            PointF pCross;
            PointF pPad;

            for (int i = 0; i < m_arrSampleBlobPads.Length; i++)
            {
                if (((BlobsFeatures)m_arrTemplateBlobPads[i]).blnEnable)
                {
                    float fStartX = objPadROI.ref_ROITotalX + m_arrSampleBlobPads[i].fStartX;
                    float fStartY = objPadROI.ref_ROITotalY + m_arrSampleBlobPads[i].fStartY;
                    float fEndX = objPadROI.ref_ROITotalX + m_arrSampleBlobPads[i].fEndX;
                    float fEndY = objPadROI.ref_ROITotalY + m_arrSampleBlobPads[i].fEndY;
                    float fCenterX = (fStartX + fEndX) / 2;
                    float fCenterY = (fStartY + fEndY) / 2;

                    float fDiffTop = 0;//fStartY - fROIStartY;
                    float fDiffRight = 0;//fROIEndX - fEndX;
                    float fDiffBottom = 0;//fROIEndY - fEndY;
                    float fDiffLeft = 0;//fStartX - fROIStartX;

                    pPad = new PointF(fCenterX, fStartY);
                    objPadLine.CalculateStraightLine(pPad, objLineTop.ref_dAngle + 90);
                    pCross = Line.GetCrossPoint(objPadLine, objLineTop);
                    if (fStartY - pCross.Y > 0)
                        fDiffTop = Math2.GetDistanceBtw2Points(pCross, pPad);
                    else
                        fDiffTop = -Math2.GetDistanceBtw2Points(pCross, pPad);

                    pPad = new PointF(fEndX, fCenterY);
                    objPadLine.CalculateStraightLine(pPad, objLineRight.ref_dAngle + 90);
                    pCross = Line.GetCrossPoint(objPadLine, objLineRight);
                    if (pCross.X - fEndX > 0)
                        fDiffRight = Math2.GetDistanceBtw2Points(pCross, pPad);
                    else
                        fDiffRight = -Math2.GetDistanceBtw2Points(pCross, pPad);

                    pPad = new PointF(fCenterX, fEndY);
                    objPadLine.CalculateStraightLine(pPad, objLineBottom.ref_dAngle + 90);
                    pCross = Line.GetCrossPoint(objPadLine, objLineBottom);
                    if (pCross.Y - fEndY > 0)
                        fDiffBottom = Math2.GetDistanceBtw2Points(pCross, pPad);
                    else
                        fDiffBottom = -Math2.GetDistanceBtw2Points(pCross, pPad);

                    pPad = new PointF(fStartX, fCenterY);
                    objPadLine.CalculateStraightLine(pPad, objLineLeft.ref_dAngle + 90);
                    pCross = Line.GetCrossPoint(objPadLine, objLineLeft);
                    if (fStartX - pCross.X > 0)
                        fDiffLeft = Math2.GetDistanceBtw2Points(pCross, pPad);
                    else
                        fDiffLeft = -Math2.GetDistanceBtw2Points(pCross, pPad);

                    if (m_fResultPadEdgeDistance_Top == 0)
                    {
                        m_fResultPadEdgeDistance_Top = fDiffTop;
                        m_intResultPadNoEdgeDistance_Top = i;
                    }
                    if (Math.Abs(m_fResultPadEdgeDistance_Top) > Math.Abs(fDiffTop))
                    {
                        m_fResultPadEdgeDistance_Top = fDiffTop;
                        m_intResultPadNoEdgeDistance_Top = i;
                    }

                    if (m_fResultPadEdgeDistance_Right == 0)
                    {
                        m_fResultPadEdgeDistance_Right = fDiffRight;
                        m_intResultPadNoEdgeDistance_Right = i;
                    }
                    if (Math.Abs(m_fResultPadEdgeDistance_Right) > Math.Abs(fDiffRight))
                    {
                        m_fResultPadEdgeDistance_Right = fDiffRight;
                        m_intResultPadNoEdgeDistance_Right = i;
                    }

                    if (m_fResultPadEdgeDistance_Bottom == 0)
                    {
                        m_fResultPadEdgeDistance_Bottom = fDiffBottom;
                        m_intResultPadNoEdgeDistance_Bottom = i;
                    }
                    if (Math.Abs(m_fResultPadEdgeDistance_Bottom) > Math.Abs(fDiffBottom))
                    {
                        m_fResultPadEdgeDistance_Bottom = fDiffBottom;
                        m_intResultPadNoEdgeDistance_Bottom = i;
                    }

                    if (m_fResultPadEdgeDistance_Left == 0)
                    {
                        m_fResultPadEdgeDistance_Left = fDiffLeft;
                        m_intResultPadNoEdgeDistance_Left = i;
                    }
                    if (Math.Abs(m_fResultPadEdgeDistance_Left) > Math.Abs(fDiffLeft))
                    {
                        m_fResultPadEdgeDistance_Left = fDiffLeft;
                        m_intResultPadNoEdgeDistance_Left = i;
                    }

                    if (((BlobsFeatures)m_arrTemplateBlobPads[i]).fEdgeDistanceTopOffset != 0)
                    {
                        m_fResultPadEdgeDistance_Top += ((BlobsFeatures)m_arrTemplateBlobPads[i]).fEdgeDistanceTopOffset / m_fMMPerPixelY;
                    }

                    if (((BlobsFeatures)m_arrTemplateBlobPads[i]).fEdgeDistanceRightOffset != 0)
                    {
                        m_fResultPadEdgeDistance_Right += ((BlobsFeatures)m_arrTemplateBlobPads[i]).fEdgeDistanceRightOffset / m_fMMPerPixelX;
                    }

                    if (((BlobsFeatures)m_arrTemplateBlobPads[i]).fEdgeDistanceBottomOffset != 0)
                    {
                        m_fResultPadEdgeDistance_Bottom += ((BlobsFeatures)m_arrTemplateBlobPads[i]).fEdgeDistanceBottomOffset / m_fMMPerPixelY;
                    }

                    if (((BlobsFeatures)m_arrTemplateBlobPads[i]).fEdgeDistanceLeftOffset != 0)
                    {
                        m_fResultPadEdgeDistance_Left += ((BlobsFeatures)m_arrTemplateBlobPads[i]).fEdgeDistanceLeftOffset / m_fMMPerPixelX;
                    }
                }
            }

            if ((m_fResultPadEdgeDistance_Top < m_fEdgeDistanceMin_Top / m_fMMPerPixelY) ||
                (m_fResultPadEdgeDistance_Top > m_fEdgeDistanceMax_Top / m_fMMPerPixelY))
            {
                m_intFailResultMask |= 0x20000000;
                m_arrSampleBlobPads[m_intResultPadNoEdgeDistance_Top].intFailMask |= 0x20000000;
            }

            if ((m_fResultPadEdgeDistance_Right < m_fEdgeDistanceMin_Right / m_fMMPerPixelX) ||
                (m_fResultPadEdgeDistance_Right > m_fEdgeDistanceMax_Right / m_fMMPerPixelX))
            {
                m_intFailResultMask |= 0x40000000;
                m_arrSampleBlobPads[m_intResultPadNoEdgeDistance_Right].intFailMask |= 0x40000000;
            }

            if ((m_fResultPadEdgeDistance_Bottom < m_fEdgeDistanceMin_Bottom / m_fMMPerPixelY) ||
                 (m_fResultPadEdgeDistance_Bottom > m_fEdgeDistanceMax_Bottom / m_fMMPerPixelY))
            {
                m_intFailResultMask |= 0x80000000;
                m_arrSampleBlobPads[m_intResultPadNoEdgeDistance_Bottom].intFailMask |= 0x80000000;
            }

            if ((m_fResultPadEdgeDistance_Left < m_fEdgeDistanceMin_Left / m_fMMPerPixelX) ||
                 (m_fResultPadEdgeDistance_Left > m_fEdgeDistanceMax_Left / m_fMMPerPixelX))
            {
                m_intFailResultMask |= 0x100000000;
                m_arrSampleBlobPads[m_intResultPadNoEdgeDistance_Left].intFailMask |= 0x100000000;
            }

            m_fResultPadEdgeDistance_Top *= m_fMMPerPixelY;
            m_fResultPadEdgeDistance_Right *= m_fMMPerPixelX;
            m_fResultPadEdgeDistance_Bottom *= m_fMMPerPixelY;
            m_fResultPadEdgeDistance_Left *= m_fMMPerPixelX;

        }
        private void CheckPadStandOffLimit(ROI objPadROI, ROI objPkgROI)
        {
            if (!m_blnWantCheckPadStandOff)
                return;

            for (int i = 0; i < m_arrSampleBlobPads.Length; i++)
            {
                if (((m_arrSampleBlobPads[i].intFailMask & 0x02) == 0) && ((m_arrSampleBlobPads[i].intFailMask & 0x04) == 0))
                {
                    float fStartX = objPadROI.ref_ROITotalX + m_arrSampleBlobPads[i].fStartX;
                    float fStartY = objPadROI.ref_ROITotalY + m_arrSampleBlobPads[i].fStartY;
                    float fEndX = objPadROI.ref_ROITotalX + m_arrSampleBlobPads[i].fEndX;
                    float fEndY = objPadROI.ref_ROITotalY + m_arrSampleBlobPads[i].fEndY;

                    float fROIStartX = objPkgROI.ref_ROITotalX;
                    float fROIStartY = objPkgROI.ref_ROITotalY;
                    float fROIEndX = objPkgROI.ref_ROITotalX + objPkgROI.ref_ROIWidth;
                    float fROIEndY = objPkgROI.ref_ROITotalY + objPkgROI.ref_ROIHeight;

                    float fResultStandOffTop = 0;
                    float fResultStandOffBottom = 0;
                    float fResultStandOffLeft = 0;
                    float fResultStandOffRight = 0;
                   
                    float fMaxStandOffTop;
                    float fMaxStandOffBottom;
                    float fMaxStandOffLeft;
                    float fMaxStandOffRight;
                  
                    int intGroupNo = ((BlobsFeatures)m_arrTemplateBlobPads[i]).intGroupID;
                    if (m_blnWantUseGroupToleranceSetting)
                    {
                        fMaxStandOffTop = ((BlobsFeatures)m_arrGroupTemplateBlobPads[intGroupNo]).fMaxStandOffTop;
                        fMaxStandOffBottom = ((BlobsFeatures)m_arrGroupTemplateBlobPads[intGroupNo]).fMaxStandOffBottom;
                        fMaxStandOffLeft = ((BlobsFeatures)m_arrGroupTemplateBlobPads[intGroupNo]).fMaxStandOffLeft;
                        fMaxStandOffRight = ((BlobsFeatures)m_arrGroupTemplateBlobPads[intGroupNo]).fMaxStandOffRight;
                    }
                    else
                    {
                        fMaxStandOffTop = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fMaxStandOffTop;
                        fMaxStandOffBottom = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fMaxStandOffBottom;
                        fMaxStandOffLeft = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fMaxStandOffLeft;
                        fMaxStandOffRight = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fMaxStandOffRight;   
                    }

                    float fDiffTop = fStartY - fROIStartY;
                    float fDiffRight = fROIEndX - fStartX;
                    float fDiffBottom = fROIEndY - fEndY;
                    float fDiffLeft = fStartX - fROIStartX;

                    //Refer Top
                    if (((BlobsFeatures)m_arrTemplateBlobPads[i]).intReferTopBottom == 0)
                    {
                        switch (m_intPadROIDirection)
                        {
                            case 0:
                            case 1:
                                fDiffTop = fStartY - fROIStartY;
                                fDiffBottom = fEndY - fROIStartY;
                                break;
                            case 2:
                                fDiffTop = fROIEndX - fEndX;
                                fDiffBottom = fROIEndX - fStartX;
                                break;
                            case 3:
                                fDiffTop = fROIEndY - fEndY;
                                fDiffBottom = fROIEndY - fStartY;
                                break;
                            case 4:
                                fDiffTop = fStartX - fROIStartX;
                                fDiffBottom = fEndX - fROIStartX;
                                break;
                        }
                    }
                    else // Refer Bottom
                    {
                        switch (m_intPadROIDirection)
                        {
                            case 0:
                            case 1:
                                fDiffTop = fROIEndY - fStartY;
                                fDiffBottom = fROIEndY - fEndY;
                                break;
                            case 2:
                                fDiffTop = fEndX - fROIStartX;
                                fDiffBottom = fStartX - fROIStartX;
                                break;
                            case 3:
                                fDiffTop = fEndY - fROIStartY;
                                fDiffBottom = fStartY - fROIStartY;
                                break;
                            case 4:
                                fDiffTop = fROIEndX - fStartX;
                                fDiffBottom = fROIEndX - fEndX;
                                break;
                        }
                        
                    }

                    //Refer Left
                    if (((BlobsFeatures)m_arrTemplateBlobPads[i]).intReferLeftRight == 0)
                    {
                        switch (m_intPadROIDirection)
                        {
                            case 0:
                            case 1:
                                fDiffLeft = fStartX - fROIStartX;
                                fDiffRight = fEndX - fROIStartX;
                                break;
                            case 2:
                                fDiffLeft = fStartY - fROIStartY;
                                fDiffRight = fEndY - fROIStartY;
                                break;
                            case 3:
                                fDiffLeft = fROIEndX - fEndX;
                                fDiffRight = fROIEndX - fStartX;
                                break;
                            case 4:
                                fDiffLeft = fROIEndY - fEndY;
                                fDiffRight = fROIEndY - fStartY;
                                break;
                        }
                        
                    }
                    else // Refer Right
                    {
                        switch (m_intPadROIDirection)
                        {
                            case 0:
                            case 1:
                                fDiffLeft = fROIEndX - fStartX;
                                fDiffRight = fROIEndX - fEndX;
                                break;
                            case 2:
                                fDiffLeft = fROIEndY - fStartY;
                                fDiffRight = fROIEndY - fEndY;
                                break;
                            case 3:
                                fDiffLeft = fEndX - fROIStartX;
                                fDiffRight = fStartX - fROIStartX;
                                break;
                            case 4:
                                fDiffLeft = fEndY - fROIStartY;
                                fDiffRight = fStartY - fROIStartY;
                                break;
                        }
                        
                    }

                    if (((BlobsFeatures)m_arrTemplateBlobPads[i]).blnEnable)
                    {
                        if (((BlobsFeatures)m_arrTemplateBlobPads[i]).fStandOffTopOffset != 0)
                        {
                            fDiffTop += ((BlobsFeatures)m_arrTemplateBlobPads[i]).fStandOffTopOffset / m_fMMPerPixelY;
                        }

                        if (((BlobsFeatures)m_arrTemplateBlobPads[i]).fStandOffRightOffset != 0)
                        {
                            fDiffRight += ((BlobsFeatures)m_arrTemplateBlobPads[i]).fStandOffRightOffset / m_fMMPerPixelX;
                        }

                        if (((BlobsFeatures)m_arrTemplateBlobPads[i]).fStandOffBottomOffset != 0)
                        {
                            fDiffBottom += ((BlobsFeatures)m_arrTemplateBlobPads[i]).fStandOffBottomOffset / m_fMMPerPixelY;
                        }

                        if (((BlobsFeatures)m_arrTemplateBlobPads[i]).fStandOffLeftOffset != 0)
                        {
                            fDiffLeft += ((BlobsFeatures)m_arrTemplateBlobPads[i]).fStandOffLeftOffset / m_fMMPerPixelX;
                        }

                        if (((BlobsFeatures)m_arrTemplateBlobPads[i]).blnCheckTop)
                            m_arrSamplePadStandOff[i].fStandOffTop = fResultStandOffTop = fDiffTop * m_fMMPerPixelY;
                        else
                            m_arrSamplePadStandOff[i].fStandOffTop = -999;

                        if (((BlobsFeatures)m_arrTemplateBlobPads[i]).blnCheckBottom)
                            m_arrSamplePadStandOff[i].fStandOffBottom = fResultStandOffBottom = fDiffBottom * m_fMMPerPixelY;
                        else
                            m_arrSamplePadStandOff[i].fStandOffBottom = -999;

                        if (((BlobsFeatures)m_arrTemplateBlobPads[i]).blnCheckLeft)
                            m_arrSamplePadStandOff[i].fStandOffLeft = fResultStandOffLeft = fDiffLeft * m_fMMPerPixelX;
                        else
                            m_arrSamplePadStandOff[i].fStandOffLeft = -999;

                        if (((BlobsFeatures)m_arrTemplateBlobPads[i]).blnCheckRight)
                            m_arrSamplePadStandOff[i].fStandOffRight = fResultStandOffRight = fDiffRight * m_fMMPerPixelX;
                        else
                            m_arrSamplePadStandOff[i].fStandOffRight = -999;

                        if (((BlobsFeatures)m_arrTemplateBlobPads[i]).blnCheckTop)
                        {
                            if (((BlobsFeatures)m_arrTemplateBlobPads[i]).intReferTopBottom == 0)
                            {
                                if (fDiffTop < (fMaxStandOffTop / m_fMMPerPixelY))
                                {
                                    m_arrSampleBlobPads[i].intFailMask |= 0x2000000;
                                    m_intFailResultMask |= 0x2000000;
                                }
                            }
                            else
                            {
                                if (fDiffTop > (fMaxStandOffTop / m_fMMPerPixelY))
                                {
                                    m_arrSampleBlobPads[i].intFailMask |= 0x2000000;
                                    m_intFailResultMask |= 0x2000000;
                                }
                            }
                        }

                        if (((BlobsFeatures)m_arrTemplateBlobPads[i]).blnCheckBottom)
                        {
                            if (((BlobsFeatures)m_arrTemplateBlobPads[i]).intReferTopBottom == 0)
                            {
                                if (fDiffBottom > (fMaxStandOffBottom / m_fMMPerPixelY))
                                {
                                    m_arrSampleBlobPads[i].intFailMask |= 0x4000000;
                                    m_intFailResultMask |= 0x4000000;
                                }
                            }
                            else
                            {
                                if (fDiffBottom < (fMaxStandOffBottom / m_fMMPerPixelY))
                                {
                                    m_arrSampleBlobPads[i].intFailMask |= 0x4000000;
                                    m_intFailResultMask |= 0x4000000;
                                }
                            }
                        }

                        if (((BlobsFeatures)m_arrTemplateBlobPads[i]).blnCheckLeft)
                        {
                            if (((BlobsFeatures)m_arrTemplateBlobPads[i]).intReferLeftRight == 0)
                            {
                                if (fDiffLeft < (fMaxStandOffLeft / m_fMMPerPixelX))
                                {
                                    m_arrSampleBlobPads[i].intFailMask |= 0x8000000;
                                    m_intFailResultMask |= 0x8000000;
                                }
                            }
                            else
                            {
                                if (fDiffLeft > (fMaxStandOffLeft / m_fMMPerPixelX))
                                {
                                    m_arrSampleBlobPads[i].intFailMask |= 0x8000000;
                                    m_intFailResultMask |= 0x8000000;
                                }
                            }
                        }

                        if (((BlobsFeatures)m_arrTemplateBlobPads[i]).blnCheckRight)
                        {
                            if (((BlobsFeatures)m_arrTemplateBlobPads[i]).intReferLeftRight == 0)
                            {
                                if (fDiffRight > (fMaxStandOffRight / m_fMMPerPixelX))
                                {
                                    m_arrSampleBlobPads[i].intFailMask |= 0x10000000;
                                    m_intFailResultMask |= 0x10000000;
                                }
                            }
                            else
                            {
                                if (fDiffRight < (fMaxStandOffRight / m_fMMPerPixelX))
                                {
                                    m_arrSampleBlobPads[i].intFailMask |= 0x10000000;
                                    m_intFailResultMask |= 0x10000000;
                                }
                            }
                        }
                    }
                }
            }

        }
        private void CheckPadStandOffLimit_WithoutRotate(ROI objPadROI)
        {
            if (!m_blnWantCheckPadStandOff)
                return;

            Line objPadLine = new Line();
            Line objLineTop = m_objRectGauge4L.ref_arrLineGauge[0].ref_ObjectLine;
            Line objLineRight = m_objRectGauge4L.ref_arrLineGauge[1].ref_ObjectLine;
            Line objLineBottom = m_objRectGauge4L.ref_arrLineGauge[2].ref_ObjectLine;
            Line objLineLeft = m_objRectGauge4L.ref_arrLineGauge[3].ref_ObjectLine;
            PointF pCross;
            PointF pPad;

            for (int i = 0; i < m_arrSampleBlobPads.Length; i++)
            {
                if (((m_arrSampleBlobPads[i].intFailMask & 0x02) == 0) && ((m_arrSampleBlobPads[i].intFailMask & 0x04) == 0))
                {
                    float fStartX = objPadROI.ref_ROITotalX + m_arrSampleBlobPads[i].fStartX;
                    float fStartY = objPadROI.ref_ROITotalY + m_arrSampleBlobPads[i].fStartY;
                    float fEndX = objPadROI.ref_ROITotalX + m_arrSampleBlobPads[i].fEndX;
                    float fEndY = objPadROI.ref_ROITotalY + m_arrSampleBlobPads[i].fEndY;
                    float fCenterX = (fStartX + fEndX) / 2;
                    float fCenterY = (fStartY + fEndY) / 2;
                    //float fROIStartX = objPkgROI.ref_ROITotalX;
                    //float fROIStartY = objPkgROI.ref_ROITotalY;
                    //float fROIEndX = objPkgROI.ref_ROITotalX + objPkgROI.ref_ROIWidth;
                    //float fROIEndY = objPkgROI.ref_ROITotalY + objPkgROI.ref_ROIHeight;

                    float fResultStandOffTop = 0;
                    float fResultStandOffBottom = 0;
                    float fResultStandOffLeft = 0;
                    float fResultStandOffRight = 0;

                    float fMaxStandOffTop;
                    float fMaxStandOffBottom;
                    float fMaxStandOffLeft;
                    float fMaxStandOffRight;

                    int intGroupNo = ((BlobsFeatures)m_arrTemplateBlobPads[i]).intGroupID;
                    if (m_blnWantUseGroupToleranceSetting)
                    {
                        fMaxStandOffTop = ((BlobsFeatures)m_arrGroupTemplateBlobPads[intGroupNo]).fMaxStandOffTop;
                        fMaxStandOffBottom = ((BlobsFeatures)m_arrGroupTemplateBlobPads[intGroupNo]).fMaxStandOffBottom;
                        fMaxStandOffLeft = ((BlobsFeatures)m_arrGroupTemplateBlobPads[intGroupNo]).fMaxStandOffLeft;
                        fMaxStandOffRight = ((BlobsFeatures)m_arrGroupTemplateBlobPads[intGroupNo]).fMaxStandOffRight;
                    }
                    else
                    {
                        fMaxStandOffTop = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fMaxStandOffTop;
                        fMaxStandOffBottom = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fMaxStandOffBottom;
                        fMaxStandOffLeft = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fMaxStandOffLeft;
                        fMaxStandOffRight = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fMaxStandOffRight;
                    }

                    float fDiffTop = 0;// fStartY - fROIStartY;
                    float fDiffRight = 0;// fROIEndX - fStartX;
                    float fDiffBottom = 0;// fROIEndY - fEndY;
                    float fDiffLeft = 0;// fStartX - fROIStartX;

                    //Refer Top
                    if (((BlobsFeatures)m_arrTemplateBlobPads[i]).intReferTopBottom == 0)
                    {
                        switch (m_intPadROIDirection)
                        {
                            case 0:
                            case 1:
                                //fDiffTop = fStartY - fROIStartY;
                                //fDiffBottom = fEndY - fROIStartY;

                                pPad = new PointF(fCenterX, fStartY);
                                objPadLine.CalculateLGStraightLine(pPad, objLineTop.ref_dAngle + 90);
                                pCross = Line.GetCrossPoint(objPadLine, objLineTop);
                                if (fStartY - pCross.Y > 0)
                                    fDiffTop = Math2.GetDistanceBtw2Points(pCross, pPad);
                                else
                                    fDiffTop = -Math2.GetDistanceBtw2Points(pCross, pPad);

                                pPad = new PointF(fCenterX, fEndY);
                                objPadLine.CalculateLGStraightLine(pPad, objLineTop.ref_dAngle + 90);
                                pCross = Line.GetCrossPoint(objPadLine, objLineTop);
                                if (fEndY - pCross.Y > 0)
                                    fDiffBottom = Math2.GetDistanceBtw2Points(pCross, pPad);
                                else
                                    fDiffBottom = -Math2.GetDistanceBtw2Points(pCross, pPad);

                                break;
                            case 2:
                                //fDiffTop = fROIEndX - fEndX;
                                //fDiffBottom = fROIEndX - fStartX;

                                pPad = new PointF(fEndX, fCenterY);
                                objPadLine.CalculateLGStraightLine(pPad, objLineRight.ref_dAngle + 90);
                                pCross = Line.GetCrossPoint(objPadLine, objLineRight);
                                if (pCross.X - fEndX > 0)
                                    fDiffTop = Math2.GetDistanceBtw2Points(pCross, pPad);
                                else
                                    fDiffTop = -Math2.GetDistanceBtw2Points(pCross, pPad);

                                pPad = new PointF(fStartX, fCenterY);
                                objPadLine.CalculateLGStraightLine(pPad, objLineRight.ref_dAngle + 90);
                                pCross = Line.GetCrossPoint(objPadLine, objLineRight);
                                if (pCross.X - fStartX > 0)
                                    fDiffBottom = Math2.GetDistanceBtw2Points(pCross, pPad);
                                else
                                    fDiffBottom = -Math2.GetDistanceBtw2Points(pCross, pPad);

                                break;
                            case 3:
                                //fDiffTop = fROIEndY - fEndY;
                                //fDiffBottom = fROIEndY - fStartY;

                                pPad = new PointF(fCenterX, fEndY);
                                objPadLine.CalculateLGStraightLine(pPad, objLineBottom.ref_dAngle + 90);
                                pCross = Line.GetCrossPoint(objPadLine, objLineBottom);
                                if (pCross.Y - fEndY > 0)
                                    fDiffTop = Math2.GetDistanceBtw2Points(pCross, pPad);
                                else
                                    fDiffTop = -Math2.GetDistanceBtw2Points(pCross, pPad);

                                pPad = new PointF(fCenterX, fStartY);
                                objPadLine.CalculateLGStraightLine(pPad, objLineBottom.ref_dAngle + 90);
                                pCross = Line.GetCrossPoint(objPadLine, objLineBottom);
                                if (pCross.Y - fStartY > 0)
                                    fDiffBottom = Math2.GetDistanceBtw2Points(pCross, pPad);
                                else
                                    fDiffBottom = -Math2.GetDistanceBtw2Points(pCross, pPad);

                                break;
                            case 4:
                                //fDiffTop = fStartX - fROIStartX;
                                //fDiffBottom = fEndX - fROIStartX;

                                pPad = new PointF(fStartX, fCenterY);
                                objPadLine.CalculateLGStraightLine(pPad, objLineLeft.ref_dAngle + 90);
                                pCross = Line.GetCrossPoint(objPadLine, objLineLeft);
                                if (fStartX - pCross.X > 0)
                                    fDiffTop = Math2.GetDistanceBtw2Points(pCross, pPad);
                                else
                                    fDiffTop = -Math2.GetDistanceBtw2Points(pCross, pPad);

                                pPad = new PointF(fEndX, fCenterY);
                                objPadLine.CalculateLGStraightLine(pPad, objLineLeft.ref_dAngle + 90);
                                pCross = Line.GetCrossPoint(objPadLine, objLineLeft);
                                if (fEndX - pCross.X > 0)
                                    fDiffBottom = Math2.GetDistanceBtw2Points(pCross, pPad);
                                else
                                    fDiffBottom = -Math2.GetDistanceBtw2Points(pCross, pPad);

                                break;
                        }
                    }
                    else // Refer Bottom
                    {
                        switch (m_intPadROIDirection)
                        {
                            case 0:
                            case 1:
                                //fDiffTop = fROIEndY - fStartY;
                                //fDiffBottom = fROIEndY - fEndY;

                                pPad = new PointF(fCenterX, fStartY);
                                objPadLine.CalculateLGStraightLine(pPad, objLineBottom.ref_dAngle + 90);
                                pCross = Line.GetCrossPoint(objPadLine, objLineBottom);
                                if (pCross.Y - fStartY > 0)
                                    fDiffTop = Math2.GetDistanceBtw2Points(pCross, pPad);
                                else
                                    fDiffTop = -Math2.GetDistanceBtw2Points(pCross, pPad);

                                pPad = new PointF(fCenterX, fEndY);
                                objPadLine.CalculateLGStraightLine(pPad, objLineBottom.ref_dAngle + 90);
                                pCross = Line.GetCrossPoint(objPadLine, objLineBottom);
                                if (pCross.Y - fEndY > 0)
                                    fDiffBottom = Math2.GetDistanceBtw2Points(pCross, pPad);
                                else
                                    fDiffBottom = -Math2.GetDistanceBtw2Points(pCross, pPad);

                                break;
                            case 2:
                                //fDiffTop = fEndX - fROIStartX;
                                //fDiffBottom = fStartX - fROIStartX;

                                pPad = new PointF(fEndX, fCenterY);
                                objPadLine.CalculateLGStraightLine(pPad, objLineLeft.ref_dAngle + 90);
                                pCross = Line.GetCrossPoint(objPadLine, objLineLeft);
                                if (fEndX - pCross.X > 0)
                                    fDiffTop = Math2.GetDistanceBtw2Points(pCross, pPad);
                                else
                                    fDiffTop = -Math2.GetDistanceBtw2Points(pCross, pPad);

                                pPad = new PointF(fStartX, fCenterY);
                                objPadLine.CalculateLGStraightLine(pPad, objLineLeft.ref_dAngle + 90);
                                pCross = Line.GetCrossPoint(objPadLine, objLineLeft);
                                if (fStartX - pCross.X > 0)
                                    fDiffBottom = Math2.GetDistanceBtw2Points(pCross, pPad);
                                else
                                    fDiffBottom = -Math2.GetDistanceBtw2Points(pCross, pPad);

                                break;
                            case 3:
                                //fDiffTop = fEndY - fROIStartY;
                                //fDiffBottom = fStartY - fROIStartY;

                                pPad = new PointF(fCenterX, fEndY);
                                objPadLine.CalculateLGStraightLine(pPad, objLineTop.ref_dAngle + 90);
                                pCross = Line.GetCrossPoint(objPadLine, objLineTop);
                                if (fEndY - pCross.Y > 0)
                                    fDiffTop = Math2.GetDistanceBtw2Points(pCross, pPad);
                                else
                                    fDiffTop = -Math2.GetDistanceBtw2Points(pCross, pPad);

                                pPad = new PointF(fCenterX, fStartY);
                                objPadLine.CalculateLGStraightLine(pPad, objLineTop.ref_dAngle + 90);
                                pCross = Line.GetCrossPoint(objPadLine, objLineTop);
                                if (fStartY - pCross.Y > 0)
                                    fDiffBottom = Math2.GetDistanceBtw2Points(pCross, pPad);
                                else
                                    fDiffBottom = -Math2.GetDistanceBtw2Points(pCross, pPad);

                                break;
                            case 4:
                                //fDiffTop = fROIEndX - fStartX;
                                //fDiffBottom = fROIEndX - fEndX;

                                pPad = new PointF(fStartX, fCenterY);
                                objPadLine.CalculateLGStraightLine(pPad, objLineRight.ref_dAngle + 90);
                                pCross = Line.GetCrossPoint(objPadLine, objLineRight);
                                if (pCross.X - fStartX > 0)
                                    fDiffTop = Math2.GetDistanceBtw2Points(pCross, pPad);
                                else
                                    fDiffTop = -Math2.GetDistanceBtw2Points(pCross, pPad);

                                pPad = new PointF(fEndX, fCenterY);
                                objPadLine.CalculateLGStraightLine(pPad, objLineRight.ref_dAngle + 90);
                                pCross = Line.GetCrossPoint(objPadLine, objLineRight);
                                if (pCross.X - fEndX > 0)
                                    fDiffBottom = Math2.GetDistanceBtw2Points(pCross, pPad);
                                else
                                    fDiffBottom = -Math2.GetDistanceBtw2Points(pCross, pPad);

                                break;
                        }

                    }

                    //Refer Left
                    if (((BlobsFeatures)m_arrTemplateBlobPads[i]).intReferLeftRight == 0)
                    {
                        switch (m_intPadROIDirection)
                        {
                            case 0:
                            case 1:
                                //fDiffLeft = fStartX - fROIStartX;
                                //fDiffRight = fEndX - fROIStartX;

                                pPad = new PointF(fStartX, fCenterY);
                                objPadLine.CalculateLGStraightLine(pPad, objLineLeft.ref_dAngle + 90);
                                pCross = Line.GetCrossPoint(objPadLine, objLineLeft);
                                if (fStartX - pCross.X > 0)
                                    fDiffLeft = Math2.GetDistanceBtw2Points(pCross, pPad);
                                else
                                    fDiffLeft = -Math2.GetDistanceBtw2Points(pCross, pPad);

                                pPad = new PointF(fEndX, fCenterY);
                                objPadLine.CalculateLGStraightLine(pPad, objLineLeft.ref_dAngle + 90);
                                pCross = Line.GetCrossPoint(objPadLine, objLineLeft);
                                if (fEndX - pCross.X > 0)
                                    fDiffRight = Math2.GetDistanceBtw2Points(pCross, pPad);
                                else
                                    fDiffRight = -Math2.GetDistanceBtw2Points(pCross, pPad);

                                break;
                            case 2:
                                //fDiffLeft = fStartY - fROIStartY;
                                //fDiffRight = fEndY - fROIStartY;

                                pPad = new PointF(fCenterX, fStartY);
                                objPadLine.CalculateLGStraightLine(pPad, objLineTop.ref_dAngle + 90);
                                pCross = Line.GetCrossPoint(objPadLine, objLineTop);
                                if (fStartY - pCross.Y > 0)
                                    fDiffLeft = Math2.GetDistanceBtw2Points(pCross, pPad);
                                else
                                    fDiffLeft = -Math2.GetDistanceBtw2Points(pCross, pPad);

                                pPad = new PointF(fCenterX, fEndY);
                                objPadLine.CalculateLGStraightLine(pPad, objLineTop.ref_dAngle + 90);
                                pCross = Line.GetCrossPoint(objPadLine, objLineTop);
                                if (fEndY - pCross.Y > 0)
                                    fDiffRight = Math2.GetDistanceBtw2Points(pCross, pPad);
                                else
                                    fDiffRight = -Math2.GetDistanceBtw2Points(pCross, pPad);

                                break;
                            case 3:
                                //fDiffLeft = fROIEndX - fEndX;
                                //fDiffRight = fROIEndX - fStartX;

                                pPad = new PointF(fEndX, fCenterY);
                                objPadLine.CalculateLGStraightLine(pPad, objLineRight.ref_dAngle + 90);
                                pCross = Line.GetCrossPoint(objPadLine, objLineRight);
                                if (pCross.X - fEndX > 0)
                                    fDiffLeft = Math2.GetDistanceBtw2Points(pCross, pPad);
                                else
                                    fDiffLeft = -Math2.GetDistanceBtw2Points(pCross, pPad);

                                pPad = new PointF(fStartX, fCenterY);
                                objPadLine.CalculateLGStraightLine(pPad, objLineRight.ref_dAngle + 90);
                                pCross = Line.GetCrossPoint(objPadLine, objLineRight);
                                if (pCross.X - fStartX > 0)
                                    fDiffRight = Math2.GetDistanceBtw2Points(pCross, pPad);
                                else
                                    fDiffRight = -Math2.GetDistanceBtw2Points(pCross, pPad);

                                break;
                            case 4:
                                //fDiffLeft = fROIEndY - fEndY;
                                //fDiffRight = fROIEndY - fStartY;

                                pPad = new PointF(fCenterX, fEndY);
                                objPadLine.CalculateLGStraightLine(pPad, objLineBottom.ref_dAngle + 90);
                                pCross = Line.GetCrossPoint(objPadLine, objLineBottom);
                                if (fEndY - pCross.Y > 0)
                                    fDiffLeft = Math2.GetDistanceBtw2Points(pCross, pPad);
                                else
                                    fDiffLeft = -Math2.GetDistanceBtw2Points(pCross, pPad);

                                pPad = new PointF(fCenterX, fStartY);
                                objPadLine.CalculateLGStraightLine(pPad, objLineBottom.ref_dAngle + 90);
                                pCross = Line.GetCrossPoint(objPadLine, objLineBottom);
                                if (fStartY - pCross.Y > 0)
                                    fDiffRight = Math2.GetDistanceBtw2Points(pCross, pPad);
                                else
                                    fDiffRight = -Math2.GetDistanceBtw2Points(pCross, pPad);

                                break;
                        }

                    }
                    else // Refer Right
                    {
                        switch (m_intPadROIDirection)
                        {
                            case 0:
                            case 1:
                                //fDiffLeft = fROIEndX - fStartX;
                                //fDiffRight = fROIEndX - fEndX;

                                pPad = new PointF(fStartX, fCenterY);
                                objPadLine.CalculateLGStraightLine(pPad, objLineRight.ref_dAngle + 90);
                                pCross = Line.GetCrossPoint(objPadLine, objLineRight);
                                if (pCross.X - fStartX > 0)
                                    fDiffLeft = Math2.GetDistanceBtw2Points(pCross, pPad);
                                else
                                    fDiffLeft = -Math2.GetDistanceBtw2Points(pCross, pPad);

                                pPad = new PointF(fEndX, fCenterY);
                                objPadLine.CalculateLGStraightLine(pPad, objLineRight.ref_dAngle + 90);
                                pCross = Line.GetCrossPoint(objPadLine, objLineRight);
                                if (pCross.X - fEndX > 0)
                                    fDiffRight = Math2.GetDistanceBtw2Points(pCross, pPad);
                                else
                                    fDiffRight = -Math2.GetDistanceBtw2Points(pCross, pPad);

                                break;
                            case 2:
                                //fDiffLeft = fROIEndY - fStartY;
                                //fDiffRight = fROIEndY - fEndY;

                                pPad = new PointF(fCenterX, fStartY);
                                objPadLine.CalculateLGStraightLine(pPad, objLineBottom.ref_dAngle + 90);
                                pCross = Line.GetCrossPoint(objPadLine, objLineBottom);
                                if (pCross.Y - fStartY > 0)
                                    fDiffLeft = Math2.GetDistanceBtw2Points(pCross, pPad);
                                else
                                    fDiffLeft = -Math2.GetDistanceBtw2Points(pCross, pPad);

                                pPad = new PointF(fCenterX, fEndY);
                                objPadLine.CalculateLGStraightLine(pPad, objLineBottom.ref_dAngle + 90);
                                pCross = Line.GetCrossPoint(objPadLine, objLineBottom);
                                if (pCross.Y - fEndY > 0)
                                    fDiffRight = Math2.GetDistanceBtw2Points(pCross, pPad);
                                else
                                    fDiffRight = -Math2.GetDistanceBtw2Points(pCross, pPad);

                                break;
                            case 3:
                                //fDiffLeft = fEndX - fROIStartX;
                                //fDiffRight = fStartX - fROIStartX;

                                pPad = new PointF(fEndX, fCenterY);
                                objPadLine.CalculateLGStraightLine(pPad, objLineLeft.ref_dAngle + 90);
                                pCross = Line.GetCrossPoint(objPadLine, objLineLeft);
                                if (fEndX - pCross.X > 0)
                                    fDiffLeft = Math2.GetDistanceBtw2Points(pCross, pPad);
                                else
                                    fDiffLeft = -Math2.GetDistanceBtw2Points(pCross, pPad);

                                pPad = new PointF(fStartX, fCenterY);
                                objPadLine.CalculateLGStraightLine(pPad, objLineLeft.ref_dAngle + 90);
                                pCross = Line.GetCrossPoint(objPadLine, objLineLeft);
                                if (fStartX - pCross.X > 0)
                                    fDiffRight = Math2.GetDistanceBtw2Points(pCross, pPad);
                                else
                                    fDiffRight = -Math2.GetDistanceBtw2Points(pCross, pPad);

                                break;
                            case 4:
                                //fDiffLeft = fEndY - fROIStartY;
                                //fDiffRight = fStartY - fROIStartY;

                                pPad = new PointF(fCenterX, fEndY);
                                objPadLine.CalculateLGStraightLine(pPad, objLineTop.ref_dAngle + 90);
                                pCross = Line.GetCrossPoint(objPadLine, objLineTop);
                                if (fEndY - pCross.Y > 0)
                                    fDiffLeft = Math2.GetDistanceBtw2Points(pCross, pPad);
                                else
                                    fDiffLeft = -Math2.GetDistanceBtw2Points(pCross, pPad);

                                pPad = new PointF(fCenterX, fStartY);
                                objPadLine.CalculateLGStraightLine(pPad, objLineTop.ref_dAngle + 90);
                                pCross = Line.GetCrossPoint(objPadLine, objLineTop);
                                if (fStartY - pCross.Y > 0)
                                    fDiffRight = Math2.GetDistanceBtw2Points(pCross, pPad);
                                else
                                    fDiffRight = -Math2.GetDistanceBtw2Points(pCross, pPad);

                                break;
                        }

                    }

                    if (((BlobsFeatures)m_arrTemplateBlobPads[i]).blnEnable)
                    {
                        if (((BlobsFeatures)m_arrTemplateBlobPads[i]).fStandOffTopOffset != 0)
                        {
                            fDiffTop += ((BlobsFeatures)m_arrTemplateBlobPads[i]).fStandOffTopOffset / m_fMMPerPixelY;
                        }

                        if (((BlobsFeatures)m_arrTemplateBlobPads[i]).fStandOffRightOffset != 0)
                        {
                            fDiffRight += ((BlobsFeatures)m_arrTemplateBlobPads[i]).fStandOffRightOffset / m_fMMPerPixelX;
                        }

                        if (((BlobsFeatures)m_arrTemplateBlobPads[i]).fStandOffBottomOffset != 0)
                        {
                            fDiffBottom += ((BlobsFeatures)m_arrTemplateBlobPads[i]).fStandOffBottomOffset / m_fMMPerPixelY;
                        }

                        if (((BlobsFeatures)m_arrTemplateBlobPads[i]).fStandOffLeftOffset != 0)
                        {
                            fDiffLeft += ((BlobsFeatures)m_arrTemplateBlobPads[i]).fStandOffLeftOffset / m_fMMPerPixelX;
                        }

                        if (((BlobsFeatures)m_arrTemplateBlobPads[i]).blnCheckTop)
                            m_arrSamplePadStandOff[i].fStandOffTop = fResultStandOffTop = fDiffTop * m_fMMPerPixelY;
                        else
                            m_arrSamplePadStandOff[i].fStandOffTop = -999;

                        if (((BlobsFeatures)m_arrTemplateBlobPads[i]).blnCheckBottom)
                            m_arrSamplePadStandOff[i].fStandOffBottom = fResultStandOffBottom = fDiffBottom * m_fMMPerPixelY;
                        else
                            m_arrSamplePadStandOff[i].fStandOffBottom = -999;

                        if (((BlobsFeatures)m_arrTemplateBlobPads[i]).blnCheckLeft)
                            m_arrSamplePadStandOff[i].fStandOffLeft = fResultStandOffLeft = fDiffLeft * m_fMMPerPixelX;
                        else
                            m_arrSamplePadStandOff[i].fStandOffLeft = -999;

                        if (((BlobsFeatures)m_arrTemplateBlobPads[i]).blnCheckRight)
                            m_arrSamplePadStandOff[i].fStandOffRight = fResultStandOffRight = fDiffRight * m_fMMPerPixelX;
                        else
                            m_arrSamplePadStandOff[i].fStandOffRight = -999;

                        if (((BlobsFeatures)m_arrTemplateBlobPads[i]).blnCheckTop)
                        {
                            if (((BlobsFeatures)m_arrTemplateBlobPads[i]).intReferTopBottom == 0)
                            {
                                if (fDiffTop < (fMaxStandOffTop / m_fMMPerPixelY))
                                {
                                    m_arrSampleBlobPads[i].intFailMask |= 0x2000000;
                                    m_intFailResultMask |= 0x2000000;
                                }
                            }
                            else
                            {
                                if (fDiffTop > (fMaxStandOffTop / m_fMMPerPixelY))
                                {
                                    m_arrSampleBlobPads[i].intFailMask |= 0x2000000;
                                    m_intFailResultMask |= 0x2000000;
                                }
                            }
                        }

                        if (((BlobsFeatures)m_arrTemplateBlobPads[i]).blnCheckBottom)
                        {
                            if (((BlobsFeatures)m_arrTemplateBlobPads[i]).intReferTopBottom == 0)
                            {
                                if (fDiffBottom > (fMaxStandOffBottom / m_fMMPerPixelY))
                                {
                                    m_arrSampleBlobPads[i].intFailMask |= 0x4000000;
                                    m_intFailResultMask |= 0x4000000;
                                }
                            }
                            else
                            {
                                if (fDiffBottom < (fMaxStandOffBottom / m_fMMPerPixelY))
                                {
                                    m_arrSampleBlobPads[i].intFailMask |= 0x4000000;
                                    m_intFailResultMask |= 0x4000000;
                                }
                            }
                        }

                        if (((BlobsFeatures)m_arrTemplateBlobPads[i]).blnCheckLeft)
                        {
                            if (((BlobsFeatures)m_arrTemplateBlobPads[i]).intReferLeftRight == 0)
                            {
                                if (fDiffLeft < (fMaxStandOffLeft / m_fMMPerPixelX))
                                {
                                    m_arrSampleBlobPads[i].intFailMask |= 0x8000000;
                                    m_intFailResultMask |= 0x8000000;
                                }
                            }
                            else
                            {
                                if (fDiffLeft > (fMaxStandOffLeft / m_fMMPerPixelX))
                                {
                                    m_arrSampleBlobPads[i].intFailMask |= 0x8000000;
                                    m_intFailResultMask |= 0x8000000;
                                }
                            }
                        }

                        if (((BlobsFeatures)m_arrTemplateBlobPads[i]).blnCheckRight)
                        {
                            if (((BlobsFeatures)m_arrTemplateBlobPads[i]).intReferLeftRight == 0)
                            {
                                if (fDiffRight > (fMaxStandOffRight / m_fMMPerPixelX))
                                {
                                    m_arrSampleBlobPads[i].intFailMask |= 0x10000000;
                                    m_intFailResultMask |= 0x10000000;
                                }
                            }
                            else
                            {
                                if (fDiffRight < (fMaxStandOffRight / m_fMMPerPixelX))
                                {
                                    m_arrSampleBlobPads[i].intFailMask |= 0x10000000;
                                    m_intFailResultMask |= 0x10000000;
                                }
                            }
                        }
                    }
                }
            }

        }
        private void CheckPadStandOffLimit_Rotate(ROI objPadROI, Line objLineTop, Line objLineRight, Line objLineBottom, Line objLineLeft)
        {
            if (!m_blnWantCheckPadStandOff)
                return;

            Line objPadLine = new Line();
            //Line objLineTop = m_objRectGauge4L.ref_arrLineGauge[0].ref_ObjectLine;
            //Line objLineRight = m_objRectGauge4L.ref_arrLineGauge[1].ref_ObjectLine;
            //Line objLineBottom = m_objRectGauge4L.ref_arrLineGauge[2].ref_ObjectLine;
            //Line objLineLeft = m_objRectGauge4L.ref_arrLineGauge[3].ref_ObjectLine;
            PointF pCross;
            PointF pPad;

            for (int i = 0; i < m_arrSampleBlobPads.Length; i++)
            {
                if (((m_arrSampleBlobPads[i].intFailMask & 0x02) == 0) && ((m_arrSampleBlobPads[i].intFailMask & 0x04) == 0))
                {
                    float fStartX = objPadROI.ref_ROITotalX + m_arrSampleBlobPads[i].fStartX;
                    float fStartY = objPadROI.ref_ROITotalY + m_arrSampleBlobPads[i].fStartY;
                    float fEndX = objPadROI.ref_ROITotalX + m_arrSampleBlobPads[i].fEndX;
                    float fEndY = objPadROI.ref_ROITotalY + m_arrSampleBlobPads[i].fEndY;
                    float fCenterX = (fStartX + fEndX) / 2;
                    float fCenterY = (fStartY + fEndY) / 2;
                    //float fROIStartX = objPkgROI.ref_ROITotalX;
                    //float fROIStartY = objPkgROI.ref_ROITotalY;
                    //float fROIEndX = objPkgROI.ref_ROITotalX + objPkgROI.ref_ROIWidth;
                    //float fROIEndY = objPkgROI.ref_ROITotalY + objPkgROI.ref_ROIHeight;

                    float fResultStandOffTop = 0;
                    float fResultStandOffBottom = 0;
                    float fResultStandOffLeft = 0;
                    float fResultStandOffRight = 0;

                    float fMaxStandOffTop;
                    float fMaxStandOffBottom;
                    float fMaxStandOffLeft;
                    float fMaxStandOffRight;

                    int intGroupNo = ((BlobsFeatures)m_arrTemplateBlobPads[i]).intGroupID;
                    if (m_blnWantUseGroupToleranceSetting)
                    {
                        fMaxStandOffTop = ((BlobsFeatures)m_arrGroupTemplateBlobPads[intGroupNo]).fMaxStandOffTop;
                        fMaxStandOffBottom = ((BlobsFeatures)m_arrGroupTemplateBlobPads[intGroupNo]).fMaxStandOffBottom;
                        fMaxStandOffLeft = ((BlobsFeatures)m_arrGroupTemplateBlobPads[intGroupNo]).fMaxStandOffLeft;
                        fMaxStandOffRight = ((BlobsFeatures)m_arrGroupTemplateBlobPads[intGroupNo]).fMaxStandOffRight;
                    }
                    else
                    {
                        fMaxStandOffTop = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fMaxStandOffTop;
                        fMaxStandOffBottom = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fMaxStandOffBottom;
                        fMaxStandOffLeft = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fMaxStandOffLeft;
                        fMaxStandOffRight = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fMaxStandOffRight;
                    }

                    float fDiffTop = 0;// fStartY - fROIStartY;
                    float fDiffRight = 0;// fROIEndX - fStartX;
                    float fDiffBottom = 0;// fROIEndY - fEndY;
                    float fDiffLeft = 0;// fStartX - fROIStartX;

                    //Refer Top
                    if (((BlobsFeatures)m_arrTemplateBlobPads[i]).intReferTopBottom == 0)
                    {
                        switch (m_intPadROIDirection)
                        {
                            case 0:
                            case 1:
                                //fDiffTop = fStartY - fROIStartY;
                                //fDiffBottom = fEndY - fROIStartY;

                                pPad = new PointF(fCenterX, fStartY);
                                objPadLine.CalculateStraightLine(pPad, objLineTop.ref_dAngle + 90);
                                pCross = Line.GetCrossPoint(objPadLine, objLineTop);
                                if (fStartY - pCross.Y > 0)
                                    fDiffTop = Math2.GetDistanceBtw2Points(pCross, pPad);
                                else
                                    fDiffTop = -Math2.GetDistanceBtw2Points(pCross, pPad);

                                pPad = new PointF(fCenterX, fEndY);
                                objPadLine.CalculateStraightLine(pPad, objLineTop.ref_dAngle + 90);
                                pCross = Line.GetCrossPoint(objPadLine, objLineTop);
                                if (fEndY - pCross.Y > 0)
                                    fDiffBottom = Math2.GetDistanceBtw2Points(pCross, pPad);
                                else
                                    fDiffBottom = -Math2.GetDistanceBtw2Points(pCross, pPad);

                                break;
                            case 2:
                                //fDiffTop = fROIEndX - fEndX;
                                //fDiffBottom = fROIEndX - fStartX;

                                pPad = new PointF(fEndX, fCenterY);
                                objPadLine.CalculateStraightLine(pPad, objLineRight.ref_dAngle + 90);
                                pCross = Line.GetCrossPoint(objPadLine, objLineRight);
                                if (pCross.X - fEndX > 0)
                                    fDiffTop = Math2.GetDistanceBtw2Points(pCross, pPad);
                                else
                                    fDiffTop = -Math2.GetDistanceBtw2Points(pCross, pPad);

                                pPad = new PointF(fStartX, fCenterY);
                                objPadLine.CalculateStraightLine(pPad, objLineRight.ref_dAngle + 90);
                                pCross = Line.GetCrossPoint(objPadLine, objLineRight);
                                if (pCross.X - fStartX > 0)
                                    fDiffBottom = Math2.GetDistanceBtw2Points(pCross, pPad);
                                else
                                    fDiffBottom = -Math2.GetDistanceBtw2Points(pCross, pPad);

                                break;
                            case 3:
                                //fDiffTop = fROIEndY - fEndY;
                                //fDiffBottom = fROIEndY - fStartY;

                                pPad = new PointF(fCenterX, fEndY);
                                objPadLine.CalculateStraightLine(pPad, objLineBottom.ref_dAngle + 90);
                                pCross = Line.GetCrossPoint(objPadLine, objLineBottom);
                                if (pCross.Y - fEndY > 0)
                                    fDiffTop = Math2.GetDistanceBtw2Points(pCross, pPad);
                                else
                                    fDiffTop = -Math2.GetDistanceBtw2Points(pCross, pPad);

                                pPad = new PointF(fCenterX, fStartY);
                                objPadLine.CalculateStraightLine(pPad, objLineBottom.ref_dAngle + 90);
                                pCross = Line.GetCrossPoint(objPadLine, objLineBottom);
                                if (pCross.Y - fStartY > 0)
                                    fDiffBottom = Math2.GetDistanceBtw2Points(pCross, pPad);
                                else
                                    fDiffBottom = -Math2.GetDistanceBtw2Points(pCross, pPad);

                                break;
                            case 4:
                                //fDiffTop = fStartX - fROIStartX;
                                //fDiffBottom = fEndX - fROIStartX;

                                pPad = new PointF(fStartX, fCenterY);
                                objPadLine.CalculateStraightLine(pPad, objLineLeft.ref_dAngle + 90);
                                pCross = Line.GetCrossPoint(objPadLine, objLineLeft);
                                if (fStartX - pCross.X > 0)
                                    fDiffTop = Math2.GetDistanceBtw2Points(pCross, pPad);
                                else
                                    fDiffTop = -Math2.GetDistanceBtw2Points(pCross, pPad);

                                pPad = new PointF(fEndX, fCenterY);
                                objPadLine.CalculateStraightLine(pPad, objLineLeft.ref_dAngle + 90);
                                pCross = Line.GetCrossPoint(objPadLine, objLineLeft);
                                if (fEndX - pCross.X > 0)
                                    fDiffBottom = Math2.GetDistanceBtw2Points(pCross, pPad);
                                else
                                    fDiffBottom = -Math2.GetDistanceBtw2Points(pCross, pPad);

                                break;
                        }
                    }
                    else // Refer Bottom
                    {
                        switch (m_intPadROIDirection)
                        {
                            case 0:
                            case 1:
                                //fDiffTop = fROIEndY - fStartY;
                                //fDiffBottom = fROIEndY - fEndY;

                                pPad = new PointF(fCenterX, fStartY);
                                objPadLine.CalculateStraightLine(pPad, objLineBottom.ref_dAngle + 90);
                                pCross = Line.GetCrossPoint(objPadLine, objLineBottom);
                                if (pCross.Y - fStartY > 0)
                                    fDiffTop = Math2.GetDistanceBtw2Points(pCross, pPad);
                                else
                                    fDiffTop = -Math2.GetDistanceBtw2Points(pCross, pPad);

                                pPad = new PointF(fCenterX, fEndY);
                                objPadLine.CalculateStraightLine(pPad, objLineBottom.ref_dAngle + 90);
                                pCross = Line.GetCrossPoint(objPadLine, objLineBottom);
                                if (pCross.Y - fEndY > 0)
                                    fDiffBottom = Math2.GetDistanceBtw2Points(pCross, pPad);
                                else
                                    fDiffBottom = -Math2.GetDistanceBtw2Points(pCross, pPad);

                                break;
                            case 2:
                                //fDiffTop = fEndX - fROIStartX;
                                //fDiffBottom = fStartX - fROIStartX;

                                pPad = new PointF(fEndX, fCenterY);
                                objPadLine.CalculateStraightLine(pPad, objLineLeft.ref_dAngle + 90);
                                pCross = Line.GetCrossPoint(objPadLine, objLineLeft);
                                if (fEndX - pCross.X > 0)
                                    fDiffTop = Math2.GetDistanceBtw2Points(pCross, pPad);
                                else
                                    fDiffTop = -Math2.GetDistanceBtw2Points(pCross, pPad);

                                pPad = new PointF(fStartX, fCenterY);
                                objPadLine.CalculateStraightLine(pPad, objLineLeft.ref_dAngle + 90);
                                pCross = Line.GetCrossPoint(objPadLine, objLineLeft);
                                if (fStartX - pCross.X > 0)
                                    fDiffBottom = Math2.GetDistanceBtw2Points(pCross, pPad);
                                else
                                    fDiffBottom = -Math2.GetDistanceBtw2Points(pCross, pPad);

                                break;
                            case 3:
                                //fDiffTop = fEndY - fROIStartY;
                                //fDiffBottom = fStartY - fROIStartY;

                                pPad = new PointF(fCenterX, fEndY);
                                objPadLine.CalculateStraightLine(pPad, objLineTop.ref_dAngle + 90);
                                pCross = Line.GetCrossPoint(objPadLine, objLineTop);
                                if (fEndY - pCross.Y > 0)
                                    fDiffTop = Math2.GetDistanceBtw2Points(pCross, pPad);
                                else
                                    fDiffTop = -Math2.GetDistanceBtw2Points(pCross, pPad);

                                pPad = new PointF(fCenterX, fStartY);
                                objPadLine.CalculateStraightLine(pPad, objLineTop.ref_dAngle + 90);
                                pCross = Line.GetCrossPoint(objPadLine, objLineTop);
                                if (fStartY - pCross.Y > 0)
                                    fDiffBottom = Math2.GetDistanceBtw2Points(pCross, pPad);
                                else
                                    fDiffBottom = -Math2.GetDistanceBtw2Points(pCross, pPad);

                                break;
                            case 4:
                                //fDiffTop = fROIEndX - fStartX;
                                //fDiffBottom = fROIEndX - fEndX;

                                pPad = new PointF(fStartX, fCenterY);
                                objPadLine.CalculateStraightLine(pPad, objLineRight.ref_dAngle + 90);
                                pCross = Line.GetCrossPoint(objPadLine, objLineRight);
                                if (pCross.X - fStartX > 0)
                                    fDiffTop = Math2.GetDistanceBtw2Points(pCross, pPad);
                                else
                                    fDiffTop = -Math2.GetDistanceBtw2Points(pCross, pPad);

                                pPad = new PointF(fEndX, fCenterY);
                                objPadLine.CalculateStraightLine(pPad, objLineRight.ref_dAngle + 90);
                                pCross = Line.GetCrossPoint(objPadLine, objLineRight);
                                if (pCross.X - fEndX > 0)
                                    fDiffBottom = Math2.GetDistanceBtw2Points(pCross, pPad);
                                else
                                    fDiffBottom = -Math2.GetDistanceBtw2Points(pCross, pPad);

                                break;
                        }

                    }

                    //Refer Left
                    if (((BlobsFeatures)m_arrTemplateBlobPads[i]).intReferLeftRight == 0)
                    {
                        switch (m_intPadROIDirection)
                        {
                            case 0:
                            case 1:
                                //fDiffLeft = fStartX - fROIStartX;
                                //fDiffRight = fEndX - fROIStartX;

                                pPad = new PointF(fStartX, fCenterY);
                                objPadLine.CalculateStraightLine(pPad, objLineLeft.ref_dAngle + 90);
                                pCross = Line.GetCrossPoint(objPadLine, objLineLeft);
                                if (fStartX - pCross.X > 0)
                                    fDiffLeft = Math2.GetDistanceBtw2Points(pCross, pPad);
                                else
                                    fDiffLeft = -Math2.GetDistanceBtw2Points(pCross, pPad);

                                pPad = new PointF(fEndX, fCenterY);
                                objPadLine.CalculateStraightLine(pPad, objLineLeft.ref_dAngle + 90);
                                pCross = Line.GetCrossPoint(objPadLine, objLineLeft);
                                if (fEndX - pCross.X > 0)
                                    fDiffRight = Math2.GetDistanceBtw2Points(pCross, pPad);
                                else
                                    fDiffRight = -Math2.GetDistanceBtw2Points(pCross, pPad);

                                break;
                            case 2:
                                //fDiffLeft = fStartY - fROIStartY;
                                //fDiffRight = fEndY - fROIStartY;

                                pPad = new PointF(fCenterX, fStartY);
                                objPadLine.CalculateStraightLine(pPad, objLineTop.ref_dAngle + 90);
                                pCross = Line.GetCrossPoint(objPadLine, objLineTop);
                                if (fStartY - pCross.Y > 0)
                                    fDiffLeft = Math2.GetDistanceBtw2Points(pCross, pPad);
                                else
                                    fDiffLeft = -Math2.GetDistanceBtw2Points(pCross, pPad);

                                pPad = new PointF(fCenterX, fEndY);
                                objPadLine.CalculateStraightLine(pPad, objLineTop.ref_dAngle + 90);
                                pCross = Line.GetCrossPoint(objPadLine, objLineTop);
                                if (fEndY - pCross.Y > 0)
                                    fDiffRight = Math2.GetDistanceBtw2Points(pCross, pPad);
                                else
                                    fDiffRight = -Math2.GetDistanceBtw2Points(pCross, pPad);

                                break;
                            case 3:
                                //fDiffLeft = fROIEndX - fEndX;
                                //fDiffRight = fROIEndX - fStartX;

                                pPad = new PointF(fEndX, fCenterY);
                                objPadLine.CalculateStraightLine(pPad, objLineRight.ref_dAngle + 90);
                                pCross = Line.GetCrossPoint(objPadLine, objLineRight);
                                if (pCross.X - fEndX > 0)
                                    fDiffLeft = Math2.GetDistanceBtw2Points(pCross, pPad);
                                else
                                    fDiffLeft = -Math2.GetDistanceBtw2Points(pCross, pPad);

                                pPad = new PointF(fStartX, fCenterY);
                                objPadLine.CalculateStraightLine(pPad, objLineRight.ref_dAngle + 90);
                                pCross = Line.GetCrossPoint(objPadLine, objLineRight);
                                if (pCross.X - fStartX > 0)
                                    fDiffRight = Math2.GetDistanceBtw2Points(pCross, pPad);
                                else
                                    fDiffRight = -Math2.GetDistanceBtw2Points(pCross, pPad);

                                break;
                            case 4:
                                //fDiffLeft = fROIEndY - fEndY;
                                //fDiffRight = fROIEndY - fStartY;

                                pPad = new PointF(fCenterX, fEndY);
                                objPadLine.CalculateStraightLine(pPad, objLineBottom.ref_dAngle + 90);
                                pCross = Line.GetCrossPoint(objPadLine, objLineBottom);
                                if (fEndY - pCross.Y > 0)
                                    fDiffLeft = Math2.GetDistanceBtw2Points(pCross, pPad);
                                else
                                    fDiffLeft = -Math2.GetDistanceBtw2Points(pCross, pPad);

                                pPad = new PointF(fCenterX, fStartY);
                                objPadLine.CalculateStraightLine(pPad, objLineBottom.ref_dAngle + 90);
                                pCross = Line.GetCrossPoint(objPadLine, objLineBottom);
                                if (fStartY - pCross.Y > 0)
                                    fDiffRight = Math2.GetDistanceBtw2Points(pCross, pPad);
                                else
                                    fDiffRight = -Math2.GetDistanceBtw2Points(pCross, pPad);

                                break;
                        }

                    }
                    else // Refer Right
                    {
                        switch (m_intPadROIDirection)
                        {
                            case 0:
                            case 1:
                                //fDiffLeft = fROIEndX - fStartX;
                                //fDiffRight = fROIEndX - fEndX;

                                pPad = new PointF(fStartX, fCenterY);
                                objPadLine.CalculateStraightLine(pPad, objLineRight.ref_dAngle + 90);
                                pCross = Line.GetCrossPoint(objPadLine, objLineRight);
                                if (pCross.X - fStartX > 0)
                                    fDiffLeft = Math2.GetDistanceBtw2Points(pCross, pPad);
                                else
                                    fDiffLeft = -Math2.GetDistanceBtw2Points(pCross, pPad);

                                pPad = new PointF(fEndX, fCenterY);
                                objPadLine.CalculateStraightLine(pPad, objLineRight.ref_dAngle + 90);
                                pCross = Line.GetCrossPoint(objPadLine, objLineRight);
                                if (pCross.X - fEndX > 0)
                                    fDiffRight = Math2.GetDistanceBtw2Points(pCross, pPad);
                                else
                                    fDiffRight = -Math2.GetDistanceBtw2Points(pCross, pPad);

                                break;
                            case 2:
                                //fDiffLeft = fROIEndY - fStartY;
                                //fDiffRight = fROIEndY - fEndY;

                                pPad = new PointF(fCenterX, fStartY);
                                objPadLine.CalculateStraightLine(pPad, objLineBottom.ref_dAngle + 90);
                                pCross = Line.GetCrossPoint(objPadLine, objLineBottom);
                                if (pCross.Y - fStartY > 0)
                                    fDiffLeft = Math2.GetDistanceBtw2Points(pCross, pPad);
                                else
                                    fDiffLeft = -Math2.GetDistanceBtw2Points(pCross, pPad);

                                pPad = new PointF(fCenterX, fEndY);
                                objPadLine.CalculateStraightLine(pPad, objLineBottom.ref_dAngle + 90);
                                pCross = Line.GetCrossPoint(objPadLine, objLineBottom);
                                if (pCross.Y - fEndY > 0)
                                    fDiffRight = Math2.GetDistanceBtw2Points(pCross, pPad);
                                else
                                    fDiffRight = -Math2.GetDistanceBtw2Points(pCross, pPad);

                                break;
                            case 3:
                                //fDiffLeft = fEndX - fROIStartX;
                                //fDiffRight = fStartX - fROIStartX;

                                pPad = new PointF(fEndX, fCenterY);
                                objPadLine.CalculateStraightLine(pPad, objLineLeft.ref_dAngle + 90);
                                pCross = Line.GetCrossPoint(objPadLine, objLineLeft);
                                if (fEndX - pCross.X > 0)
                                    fDiffLeft = Math2.GetDistanceBtw2Points(pCross, pPad);
                                else
                                    fDiffLeft = -Math2.GetDistanceBtw2Points(pCross, pPad);

                                pPad = new PointF(fStartX, fCenterY);
                                objPadLine.CalculateStraightLine(pPad, objLineLeft.ref_dAngle + 90);
                                pCross = Line.GetCrossPoint(objPadLine, objLineLeft);
                                if (fStartX - pCross.X > 0)
                                    fDiffRight = Math2.GetDistanceBtw2Points(pCross, pPad);
                                else
                                    fDiffRight = -Math2.GetDistanceBtw2Points(pCross, pPad);

                                break;
                            case 4:
                                //fDiffLeft = fEndY - fROIStartY;
                                //fDiffRight = fStartY - fROIStartY;

                                pPad = new PointF(fCenterX, fEndY);
                                objPadLine.CalculateStraightLine(pPad, objLineTop.ref_dAngle + 90);
                                pCross = Line.GetCrossPoint(objPadLine, objLineTop);
                                if (fEndY - pCross.Y > 0)
                                    fDiffLeft = Math2.GetDistanceBtw2Points(pCross, pPad);
                                else
                                    fDiffLeft = -Math2.GetDistanceBtw2Points(pCross, pPad);

                                pPad = new PointF(fCenterX, fStartY);
                                objPadLine.CalculateStraightLine(pPad, objLineTop.ref_dAngle + 90);
                                pCross = Line.GetCrossPoint(objPadLine, objLineTop);
                                if (fStartY - pCross.Y > 0)
                                    fDiffRight = Math2.GetDistanceBtw2Points(pCross, pPad);
                                else
                                    fDiffRight = -Math2.GetDistanceBtw2Points(pCross, pPad);

                                break;
                        }

                    }

                    if (((BlobsFeatures)m_arrTemplateBlobPads[i]).blnEnable)
                    {
                        if (((BlobsFeatures)m_arrTemplateBlobPads[i]).fStandOffTopOffset != 0)
                        {
                            fDiffTop += ((BlobsFeatures)m_arrTemplateBlobPads[i]).fStandOffTopOffset / m_fMMPerPixelY;
                        }

                        if (((BlobsFeatures)m_arrTemplateBlobPads[i]).fStandOffRightOffset != 0)
                        {
                            fDiffRight += ((BlobsFeatures)m_arrTemplateBlobPads[i]).fStandOffRightOffset / m_fMMPerPixelX;
                        }

                        if (((BlobsFeatures)m_arrTemplateBlobPads[i]).fStandOffBottomOffset != 0)
                        {
                            fDiffBottom += ((BlobsFeatures)m_arrTemplateBlobPads[i]).fStandOffBottomOffset / m_fMMPerPixelY;
                        }

                        if (((BlobsFeatures)m_arrTemplateBlobPads[i]).fStandOffLeftOffset != 0)
                        {
                            fDiffLeft += ((BlobsFeatures)m_arrTemplateBlobPads[i]).fStandOffLeftOffset / m_fMMPerPixelX;
                        }

                        if (((BlobsFeatures)m_arrTemplateBlobPads[i]).blnCheckTop)
                            m_arrSamplePadStandOff[i].fStandOffTop = fResultStandOffTop = fDiffTop * m_fMMPerPixelY;
                        else
                            m_arrSamplePadStandOff[i].fStandOffTop = -999;

                        if (((BlobsFeatures)m_arrTemplateBlobPads[i]).blnCheckBottom)
                            m_arrSamplePadStandOff[i].fStandOffBottom = fResultStandOffBottom = fDiffBottom * m_fMMPerPixelY;
                        else
                            m_arrSamplePadStandOff[i].fStandOffBottom = -999;

                        if (((BlobsFeatures)m_arrTemplateBlobPads[i]).blnCheckLeft)
                            m_arrSamplePadStandOff[i].fStandOffLeft = fResultStandOffLeft = fDiffLeft * m_fMMPerPixelX;
                        else
                            m_arrSamplePadStandOff[i].fStandOffLeft = -999;

                        if (((BlobsFeatures)m_arrTemplateBlobPads[i]).blnCheckRight)
                            m_arrSamplePadStandOff[i].fStandOffRight = fResultStandOffRight = fDiffRight * m_fMMPerPixelX;
                        else
                            m_arrSamplePadStandOff[i].fStandOffRight = -999;

                        if (((BlobsFeatures)m_arrTemplateBlobPads[i]).blnCheckTop)
                        {
                            if (((BlobsFeatures)m_arrTemplateBlobPads[i]).intReferTopBottom == 0)
                            {
                                if (fDiffTop < (fMaxStandOffTop / m_fMMPerPixelY))
                                {
                                    m_arrSampleBlobPads[i].intFailMask |= 0x2000000;
                                    m_intFailResultMask |= 0x2000000;
                                }
                            }
                            else
                            {
                                if (fDiffTop > (fMaxStandOffTop / m_fMMPerPixelY))
                                {
                                    m_arrSampleBlobPads[i].intFailMask |= 0x2000000;
                                    m_intFailResultMask |= 0x2000000;
                                }
                            }
                        }

                        if (((BlobsFeatures)m_arrTemplateBlobPads[i]).blnCheckBottom)
                        {
                            if (((BlobsFeatures)m_arrTemplateBlobPads[i]).intReferTopBottom == 0)
                            {
                                if (fDiffBottom > (fMaxStandOffBottom / m_fMMPerPixelY))
                                {
                                    m_arrSampleBlobPads[i].intFailMask |= 0x4000000;
                                    m_intFailResultMask |= 0x4000000;
                                }
                            }
                            else
                            {
                                if (fDiffBottom < (fMaxStandOffBottom / m_fMMPerPixelY))
                                {
                                    m_arrSampleBlobPads[i].intFailMask |= 0x4000000;
                                    m_intFailResultMask |= 0x4000000;
                                }
                            }
                        }

                        if (((BlobsFeatures)m_arrTemplateBlobPads[i]).blnCheckLeft)
                        {
                            if (((BlobsFeatures)m_arrTemplateBlobPads[i]).intReferLeftRight == 0)
                            {
                                if (fDiffLeft < (fMaxStandOffLeft / m_fMMPerPixelX))
                                {
                                    m_arrSampleBlobPads[i].intFailMask |= 0x8000000;
                                    m_intFailResultMask |= 0x8000000;
                                }
                            }
                            else
                            {
                                if (fDiffLeft > (fMaxStandOffLeft / m_fMMPerPixelX))
                                {
                                    m_arrSampleBlobPads[i].intFailMask |= 0x8000000;
                                    m_intFailResultMask |= 0x8000000;
                                }
                            }
                        }

                        if (((BlobsFeatures)m_arrTemplateBlobPads[i]).blnCheckRight)
                        {
                            if (((BlobsFeatures)m_arrTemplateBlobPads[i]).intReferLeftRight == 0)
                            {
                                if (fDiffRight > (fMaxStandOffRight / m_fMMPerPixelX))
                                {
                                    m_arrSampleBlobPads[i].intFailMask |= 0x10000000;
                                    m_intFailResultMask |= 0x10000000;
                                }
                            }
                            else
                            {
                                if (fDiffRight < (fMaxStandOffRight / m_fMMPerPixelX))
                                {
                                    m_arrSampleBlobPads[i].intFailMask |= 0x10000000;
                                    m_intFailResultMask |= 0x10000000;
                                }
                            }
                        }
                    }
                }
            }

        }
        private void CheckSmear(ROI objROI)
        {
            if (!m_blnWantUseGaugeMeasureDimension && !m_blnWantCheckSmearPadLength)
                return;



            for (int i = 0; i < m_arrSampleBlobPads.Length; i++)
            {
                // intSmearSide == 1 == Left
                // intSmearSide == 2 == Right
                // intSmearSide == 4 == Top
                // intSmearSide == 8 == Bottom

                if (m_arrSampleBlobPads[i].intFailMask == 0)// && ((BlobsFeatures)m_arrTemplateBlobPads[i]).intSmearSide > 0)
                {
                    //int intStartX = (int)Math.Ceiling(m_arrSampleBlobPads[i].fStartX);
                    //int intStartY = (int)Math.Ceiling(m_arrSampleBlobPads[i].fStartY);
                    //int intEndX = (int)Math.Ceiling(m_arrSampleBlobPads[i].fEndX);
                    //int intEndY = (int)Math.Ceiling(m_arrSampleBlobPads[i].fEndY);
                    float fStartX = m_arrSampleBlobPads[i].fStartX;
                    float fStartY = m_arrSampleBlobPads[i].fStartY;
                    float fEndX = m_arrSampleBlobPads[i].fEndX;
                    float fEndY = m_arrSampleBlobPads[i].fEndY;
                    int intBlobStartX = (int)Math.Ceiling(m_arrBackupBlobPads[i].fStartX);
                    int intBlobStartY = (int)Math.Ceiling(m_arrBackupBlobPads[i].fStartY);
                    int intBlobEndX = (int)Math.Ceiling(m_arrBackupBlobPads[i].fEndX);
                    int intBlobEndY = (int)Math.Ceiling(m_arrBackupBlobPads[i].fEndY);

                    float fResultSmearLength = -1f;
                    bool blnResult = true;
                    float fSmearLength;
                    int intGroupNo = ((BlobsFeatures)m_arrTemplateBlobPads[i]).intGroupID;
                    if (m_blnWantUseGroupToleranceSetting)
                        fSmearLength = ((BlobsFeatures)m_arrGroupTemplateBlobPads[intGroupNo]).fMaxSmearLength;
                    else
                        fSmearLength = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fMaxSmearLength;

                    int intRealPosition = 0;

                    //04-09-2019 ZJYEOH : No need to consider which side anymore, direct check all sides
                    //if (((BlobsFeatures)m_arrTemplateBlobPads[i]).intSmearSide == 5) // Top Left
                    //{
                    //    if (((BlobsFeatures)m_arrTemplateBlobPads[i]).intLengthMode == 2)
                    //        intRealPosition = 1;
                    //    else
                    //        intRealPosition = 4;
                    //}
                    //else if (((BlobsFeatures)m_arrTemplateBlobPads[i]).intSmearSide == 6) // Top Right
                    //{
                    //    if (((BlobsFeatures)m_arrTemplateBlobPads[i]).intLengthMode == 2)
                    //        intRealPosition = 2;
                    //    else
                    //        intRealPosition = 4;
                    //}
                    //else if (((BlobsFeatures)m_arrTemplateBlobPads[i]).intSmearSide == 7) // Top Left Right
                    //{
                    //        intRealPosition = 4;
                    //}
                    //else if (((BlobsFeatures)m_arrTemplateBlobPads[i]).intSmearSide == 9) // Bottom Left
                    //{
                    //    if (((BlobsFeatures)m_arrTemplateBlobPads[i]).intLengthMode == 2)
                    //        intRealPosition = 1;
                    //    else
                    //        intRealPosition = 8;
                    //}
                    //else if (((BlobsFeatures)m_arrTemplateBlobPads[i]).intSmearSide == 10) // Bottom Right
                    //{
                    //    if (((BlobsFeatures)m_arrTemplateBlobPads[i]).intLengthMode == 2)
                    //        intRealPosition = 2;
                    //    else
                    //        intRealPosition = 8;
                    //}
                    //else if (((BlobsFeatures)m_arrTemplateBlobPads[i]).intSmearSide == 11) // Bottom Left Right
                    //{
                    //    intRealPosition = 8;
                    //}
                    //else if (((BlobsFeatures)m_arrTemplateBlobPads[i]).intSmearSide == 13) // Left Top Bottom
                    //{
                    //    intRealPosition = 1;
                    //}
                    //else if (((BlobsFeatures)m_arrTemplateBlobPads[i]).intSmearSide == 14) // Right Top Bottom
                    //{
                    //    intRealPosition = 2;
                    //}
                    //else if (((BlobsFeatures)m_arrTemplateBlobPads[i]).intSmearSide == 1 || ((BlobsFeatures)m_arrTemplateBlobPads[i]).intSmearSide == 2)
                    //{
                    //    intRealPosition = ((BlobsFeatures)m_arrTemplateBlobPads[i]).intSmearSide;
                    //}
                    //else if (((BlobsFeatures)m_arrTemplateBlobPads[i]).intSmearSide == 4 || ((BlobsFeatures)m_arrTemplateBlobPads[i]).intSmearSide == 8)
                    //{
                    //    intRealPosition = ((BlobsFeatures)m_arrTemplateBlobPads[i]).intSmearSide;
                    //}

                    float DiffStartX = Math.Abs(fStartX - intBlobStartX);
                    float DiffStartY = Math.Abs(fStartY - intBlobStartY);
                    float DiffEndX = Math.Abs(fEndX - intBlobEndX);
                    float DiffEndY = Math.Abs(fEndY - intBlobEndY);

                    if (intRealPosition > 0)
                    {
                        if (intRealPosition == 1) // Left
                        {
                            if (((BlobsFeatures)m_arrTemplateBlobPads[i]).blnEnable)
                            {
                                if ((DiffStartY > fSmearLength / m_fMMPerPixelY) || (DiffEndY > fSmearLength / m_fMMPerPixelY) || (DiffEndX > fSmearLength / m_fMMPerPixelX))
                                {
                                    if (Math.Max(DiffStartY, DiffEndY) > DiffEndX)
                                        fResultSmearLength = Math.Max(DiffStartY, DiffEndY) * m_fMMPerPixelY;
                                    else
                                        fResultSmearLength = DiffEndX * m_fMMPerPixelX;

                                    blnResult = false;


                                }
                                else
                                {
                                    if (Math.Max(DiffStartY, DiffEndY) > DiffEndX)
                                        fResultSmearLength = Math.Max(DiffStartY, DiffEndY) * m_fMMPerPixelY;
                                    else
                                        fResultSmearLength = DiffEndX * m_fMMPerPixelX;

                                    blnResult = true;
                                }

                            }
                        }

                        if (intRealPosition == 2) // Right
                        {
                            if (((BlobsFeatures)m_arrTemplateBlobPads[i]).blnEnable)
                            {
                                if ((DiffStartY > fSmearLength / m_fMMPerPixelY) || (DiffEndY > fSmearLength / m_fMMPerPixelY) || (DiffStartX > fSmearLength / m_fMMPerPixelX))
                                {
                                    if (Math.Max(DiffStartY, DiffEndY) > DiffStartX)
                                        fResultSmearLength = Math.Max(DiffStartY, DiffEndY) * m_fMMPerPixelY;
                                    else
                                        fResultSmearLength = DiffStartX * m_fMMPerPixelX;

                                    blnResult = false;


                                }
                                else
                                {
                                    if (Math.Max(DiffStartY, DiffEndY) > DiffStartX)
                                        fResultSmearLength = Math.Max(DiffStartY, DiffEndY) * m_fMMPerPixelY;
                                    else
                                        fResultSmearLength = DiffStartX * m_fMMPerPixelX;

                                    blnResult = true;
                                }

                            }
                        }

                        if (intRealPosition == 4) //Top
                        {
                            if (((BlobsFeatures)m_arrTemplateBlobPads[i]).blnEnable)
                            {
                                if ((DiffStartX > fSmearLength / m_fMMPerPixelX) || (DiffEndX > fSmearLength / m_fMMPerPixelX) || (DiffEndY > fSmearLength / m_fMMPerPixelY))
                                {
                                    if (Math.Max(DiffStartX, DiffEndX) > DiffEndY)
                                        fResultSmearLength = Math.Max(DiffStartX, DiffEndX) * m_fMMPerPixelX;
                                    else
                                        fResultSmearLength = DiffEndY * m_fMMPerPixelY;

                                    blnResult = false;


                                }
                                else
                                {
                                    if (Math.Max(DiffStartX, DiffEndX) > DiffEndY)
                                        fResultSmearLength = Math.Max(DiffStartX, DiffEndX) * m_fMMPerPixelX;
                                    else
                                        fResultSmearLength = DiffEndY * m_fMMPerPixelY;

                                    blnResult = true;


                                }
                            }
                        }

                        if (intRealPosition == 8) // Bottom
                        {
                            if (((BlobsFeatures)m_arrTemplateBlobPads[i]).blnEnable)
                            {
                                if ((DiffStartX > fSmearLength / m_fMMPerPixelX) || (DiffEndX > fSmearLength / m_fMMPerPixelX) || (DiffStartY > fSmearLength / m_fMMPerPixelY))
                                {
                                    if (Math.Max(DiffStartX, DiffEndX) > DiffStartY)
                                        fResultSmearLength = Math.Max(DiffStartX, DiffEndX) * m_fMMPerPixelX;
                                    else
                                        fResultSmearLength = DiffStartY * m_fMMPerPixelY;

                                    blnResult = false;


                                }
                                else
                                {
                                    if (Math.Max(DiffStartX, DiffEndX) > DiffStartY)
                                        fResultSmearLength = Math.Max(DiffStartX, DiffEndX) * m_fMMPerPixelX;
                                    else
                                        fResultSmearLength = DiffStartY * m_fMMPerPixelY;

                                    blnResult = true;


                                }
                            }
                        }
                    }
                    else
                    {
                        if (((BlobsFeatures)m_arrTemplateBlobPads[i]).blnEnable)
                        {
                            if ((DiffStartX > fSmearLength / m_fMMPerPixelX) || (DiffEndX > fSmearLength / m_fMMPerPixelX) || (DiffEndY > fSmearLength / m_fMMPerPixelY) || (DiffStartY > fSmearLength / m_fMMPerPixelY))
                            {
                                if (Math.Max(DiffStartX, DiffEndX) > Math.Max(DiffStartY, DiffEndY))
                                    fResultSmearLength = Math.Max(DiffStartX, DiffEndX) * m_fMMPerPixelX;
                                else
                                    fResultSmearLength = Math.Max(DiffStartY, DiffEndY) * m_fMMPerPixelY;

                                blnResult = false;


                            }
                            else
                            {
                                if (Math.Max(DiffStartX, DiffEndX) > Math.Max(DiffStartY, DiffEndY))
                                    fResultSmearLength = Math.Max(DiffStartX, DiffEndX) * m_fMMPerPixelX;
                                else
                                    fResultSmearLength = Math.Max(DiffStartY, DiffEndY) * m_fMMPerPixelY;

                                blnResult = true;


                            }
                        }
                    }

                    if (!blnResult)
                    {
                        m_arrSampleBlobPads[i].intFailMask |= 0x2000;
                        m_intFailResultMask |= 0x2000;
                        m_arrSamplePadSmear[i].fSmearLength = fResultSmearLength;

                        //Defect objDefect = new Defect();
                        //objDefect.ref_strName = "Smear Pad";
                        //objDefect.ref_intFailMask |= 0x08;
                        //if ((((BlobsFeatures)m_arrTemplateBlobPads[i]).intSide == 1) || (((BlobsFeatures)m_arrTemplateBlobPads[i]).intSide == 2))
                        //{
                        //    objDefect.ref_fCenterX = objImage1SampleUnitROI.ref_ROITotalX + fCenterX;  // objThresholdSampleROI.ref_ROITotalX + fCenterX;
                        //    objDefect.ref_fCenterY = objImage1SampleUnitROI.ref_ROITotalY + fCenterY;  // objThresholdSampleROI.ref_ROITotalY + fCenterY;
                        //    objDefect.ref_fStartX = fStartX;
                        //    objDefect.ref_fStartY = fStartY;
                        //    objDefect.ref_fEndX = fEndX;
                        //    objDefect.ref_fEndY = fEndY;
                        //    objDefect.ref_fWidth = fWidth;
                        //    objDefect.ref_fHeight = fHeight;
                        //    objDefect.ref_fWidthInMM = fWidthMM;
                        //    objDefect.ref_fHeightInMM = fHeightMM;

                        //}



                        //m_arrPadDefectList.Add(objDefect);
                    }
                    else
                        m_arrSamplePadSmear[i].fSmearLength = fResultSmearLength;


                }
            }

        }

        /// <summary>
        /// Check smear within ROI
        /// </summary>
        /// <param name="objROI">ROI</param>
        private void CheckSmear_old(ROI objROI)
        {
            for (int i = 0; i < m_arrSampleBlobPads.Length; i++)
            {
                if (m_arrSampleBlobPads[i].intFailMask == 0 && ((BlobsFeatures)m_arrTemplateBlobPads[i]).intSide > 0)
                {
                    ROI objPadROI = new ROI();
                    int intStartX = (int)Math.Ceiling(m_arrSampleBlobPads[i].fStartX);
                    int intStartY = (int)Math.Ceiling(m_arrSampleBlobPads[i].fStartY);
                    int intEndX = (int)Math.Ceiling(m_arrSampleBlobPads[i].fEndX);
                    int intEndY = (int)Math.Ceiling(m_arrSampleBlobPads[i].fEndY);
                    objPadROI.LoadROISetting(intStartX, intStartY, intEndX - intStartX, intEndY - intStartY);
                    objPadROI.AttachImage(objROI);

                    EBW8Vector objVectorSideTop = new EBW8Vector();
                    EBW8Vector objVectorSideBottom = new EBW8Vector();
                    EBW8Vector objVectorQuarter = new EBW8Vector();
                    int intPositionChange, intPadPostitionChange, intRealPosition;
                    int intPositionStartSmear, intPositionEndSmear, intPositionStartBody, intPositionEndBody;
                    intPositionStartSmear = intPositionEndSmear = intPositionStartBody = intPositionEndBody = 0;
                    intPositionChange = intPadPostitionChange = intRealPosition = 0;

                    if (((BlobsFeatures)m_arrTemplateBlobPads[i]).intSide == 5)
                    {
                        if (((BlobsFeatures)m_arrTemplateBlobPads[i]).intLengthMode == 2)
                            intRealPosition = 1;
                        else
                            intRealPosition = 2;

                    }
                    else if (((BlobsFeatures)m_arrTemplateBlobPads[i]).intSide == 6)
                    {
                        if (((BlobsFeatures)m_arrTemplateBlobPads[i]).intLengthMode == 2)
                            intRealPosition = 2;
                        else
                            intRealPosition = 4;
                    }
                    else if (((BlobsFeatures)m_arrTemplateBlobPads[i]).intSide == 9)
                    {
                        if (((BlobsFeatures)m_arrTemplateBlobPads[i]).intLengthMode == 2)
                            intRealPosition = 1;
                        else
                            intRealPosition = 8;
                    }
                    else if (((BlobsFeatures)m_arrTemplateBlobPads[i]).intSide == 10)
                    {
                        if (((BlobsFeatures)m_arrTemplateBlobPads[i]).intLengthMode == 2)
                            intRealPosition = 2;
                        else
                            intRealPosition = 8;
                    }
                    else if (((BlobsFeatures)m_arrTemplateBlobPads[i]).intSide == 1 || ((BlobsFeatures)m_arrTemplateBlobPads[i]).intSide == 2)
                    {
                        intRealPosition = ((BlobsFeatures)m_arrTemplateBlobPads[i]).intSide;
                    }
                    else if (((BlobsFeatures)m_arrTemplateBlobPads[i]).intSide == 4 || ((BlobsFeatures)m_arrTemplateBlobPads[i]).intSide == 8)
                    {
                        intRealPosition = ((BlobsFeatures)m_arrTemplateBlobPads[i]).intSide;
                    }

                    if (intRealPosition == 1 || intRealPosition == 2)
                        intPadPostitionChange = objPadROI.ref_ROIWidth;
                    else
                        intPadPostitionChange = objPadROI.ref_ROIHeight;

                    if (intRealPosition == 1 || intRealPosition == 4)
                        intPositionChange = intPadPostitionChange * 1 / 3;
                    else
                        intPositionChange = intPadPostitionChange * 2 / 3;

                    if (intRealPosition == 4)
                    {
                        //First row/col line segment
                        EasyImage.ImageToLineSegment(objPadROI.ref_ROI, objVectorSideTop, 0, 0, objPadROI.ref_ROIWidth - 1, 0);

                        //Second row/col line segment
                        EasyImage.ImageToLineSegment(objPadROI.ref_ROI, objVectorSideBottom, 0, 1, objPadROI.ref_ROIWidth - 1, 1);

                        //Quarter row/col line segment
                        EasyImage.ImageToLineSegment(objPadROI.ref_ROI, objVectorQuarter, 0, intPositionChange, objPadROI.ref_ROIWidth - 1, intPositionChange);
                    }
                    else if (intRealPosition == 1)
                    {
                        EasyImage.ImageToLineSegment(objPadROI.ref_ROI, objVectorSideTop, 0, 0, 0, objPadROI.ref_ROIHeight - 1);
                        EasyImage.ImageToLineSegment(objPadROI.ref_ROI, objVectorSideBottom, 1, 0, 1, objPadROI.ref_ROIHeight - 1);
                        EasyImage.ImageToLineSegment(objPadROI.ref_ROI, objVectorQuarter, intPositionChange, 0, intPositionChange, objPadROI.ref_ROIHeight - 1);
                    }
                    else if (intRealPosition == 2)
                    {
                        EasyImage.ImageToLineSegment(objPadROI.ref_ROI, objVectorSideTop, objPadROI.ref_ROIWidth - 1, 0, objPadROI.ref_ROIWidth - 1, objPadROI.ref_ROIHeight - 1);
                        EasyImage.ImageToLineSegment(objPadROI.ref_ROI, objVectorSideBottom, objPadROI.ref_ROIWidth - 2, 0, objPadROI.ref_ROIWidth - 2, objPadROI.ref_ROIHeight - 1);
                        EasyImage.ImageToLineSegment(objPadROI.ref_ROI, objVectorQuarter, intPositionChange, 0, intPositionChange, objPadROI.ref_ROIHeight - 1);
                    }
                    else if (intRealPosition == 8)
                    {
                        EasyImage.ImageToLineSegment(objPadROI.ref_ROI, objVectorSideTop, 0, objPadROI.ref_ROIHeight - 1, objPadROI.ref_ROIWidth - 1, objPadROI.ref_ROIHeight - 1);
                        EasyImage.ImageToLineSegment(objPadROI.ref_ROI, objVectorSideBottom, 0, objPadROI.ref_ROIHeight - 2, objPadROI.ref_ROIWidth - 1, objPadROI.ref_ROIHeight - 2);
                        EasyImage.ImageToLineSegment(objPadROI.ref_ROI, objVectorQuarter, 0, intPositionChange, objPadROI.ref_ROIWidth - 1, intPositionChange);
                    }

                    //Get smear start pixel by checking first and second row/col line segment
                    for (int p = 0; p < objVectorSideTop.NumElements; p++)
                    {
                        if (objVectorSideTop.GetElement(p).Value > m_intThresholdValue)
                        {
                            intPositionStartSmear = p;
                            break;
                        }
                        else if (objVectorSideBottom.GetElement(p).Value > m_intThresholdValue)
                        {
                            intPositionStartSmear = p;
                            break;
                        }
                    }

                    //Get smear end pixel by checking first and second row/col line segment
                    for (int q = (int)objVectorSideTop.NumElements - 1; q > 0; q--)
                    {
                        if (objVectorSideTop.GetElement(q).Value > m_intThresholdValue)
                        {
                            intPositionEndSmear = q;
                            break;
                        }
                        else if (objVectorSideBottom.GetElement(q).Value > m_intThresholdValue)
                        {
                            intPositionEndSmear = q;
                            break;
                        }
                    }

                    //Get smear body start pixel
                    for (int x = 0; x < objVectorQuarter.NumElements; x++)
                    {
                        if (objVectorQuarter.GetElement(x).Value > m_intThresholdValue)
                        {
                            intPositionStartBody = x;
                            break;
                        }
                    }

                    //Get smear body end pixel
                    for (int y = (int)objVectorQuarter.NumElements - 1; y > 0; y--)
                    {
                        if (objVectorQuarter.GetElement(y).Value > m_intThresholdValue)
                        {
                            intPositionEndBody = y;
                            break;
                        }
                    }

                    //Calculate actual smear length
                    float fStartDiff, fEndDiff;
                    fStartDiff = fEndDiff = -999;

                    if (intPositionStartBody >= intPositionStartSmear)
                        fStartDiff = Math.Abs(intPositionStartSmear - intPositionStartBody);

                    if (intPositionEndSmear >= intPositionEndBody)
                        fEndDiff = Math.Abs(intPositionEndSmear - intPositionEndBody);

                    if ((fStartDiff != -999) && (fStartDiff >= m_fSmearLength))
                    {
                        if (((BlobsFeatures)m_arrTemplateBlobPads[i]).blnEnable)
                        {
                            m_arrSampleBlobPads[i].intFailMask |= 0x2000;
                            m_intFailResultMask |= 0x2000;

                            // Collect smear min and max area for display error message
                            if ((m_fResultSmearMinLength == -1) || (fStartDiff < m_fResultSmearMinLength))
                            {
                                m_fResultSmearMinLength = fStartDiff;
                            }

                            if ((m_fResultSmearMaxLength == -1) || (fStartDiff > m_fResultSmearMaxLength))
                            {
                                m_fResultSmearMaxLength = fStartDiff;
                            }
                        }
                    }

                    else if ((fEndDiff != -999) && (fEndDiff >= m_fSmearLength))
                    {
                        if (((BlobsFeatures)m_arrTemplateBlobPads[i]).blnEnable)
                        {
                            m_arrSampleBlobPads[i].intFailMask |= 0x2000;
                            m_intFailResultMask |= 0x2000;

                            // Collect smear min and max area for display error message
                            if ((m_fResultSmearMinLength == -1) || (fEndDiff < m_fResultSmearMinLength))
                            {
                                m_fResultSmearMinLength = fEndDiff;
                            }

                            if ((m_fResultSmearMaxLength == -1) || (fEndDiff > m_fResultSmearMaxLength))
                            {
                                m_fResultSmearMaxLength = fEndDiff;
                            }
                        }
                    }

                    objPadROI.Dispose();
                }
            }

        }

        /// <summary>
        /// Check the direction of the pad (left column, right column, high row, low row)
        /// </summary>
        /// <param name="intPadPosition">pad position</param>
        private void ClassifyObjectsToDirectionGroup(int intPadPosition)
        {
            BlobsFeatures stcBlobsFeatures = new BlobsFeatures();
            int intDirectionMask;

            for (int i = 0; i < m_arrTemplateBlobPads.Count; i++)
            {
                BlobsFeatures m_stcBlobPad = (BlobsFeatures)m_arrTemplateBlobPads[i];

                if (!m_stcBlobPad.blnSelected)
                    continue;

                intDirectionMask = 0x0F;

                for (int j = 0; j < m_arrTemplateBlobPads.Count; j++)
                {
                    if (i == j)
                        continue;

                    stcBlobsFeatures = (BlobsFeatures)m_arrTemplateBlobPads[j];

                    if (!stcBlobsFeatures.blnSelected)
                        continue;

                    if (intPadPosition != 2 && intPadPosition != 4)
                    {
                        // Check is left column
                        if ((m_stcBlobPad.intStartX + (int)m_fDefineSizePixel) > (stcBlobsFeatures.intEndX - (int)m_fDefineSizePixel))
                        {
                            intDirectionMask &= ~0x01;
                        }

                        // Check is right column
                        if ((m_stcBlobPad.intEndX - (int)m_fDefineSizePixel) < (stcBlobsFeatures.intStartX + (int)m_fDefineSizePixel))
                        {
                            intDirectionMask &= ~0x02;
                        }
                    }

                    if (intPadPosition != 1 && intPadPosition != 3)
                    {

                        // Check is high row
                        if ((m_stcBlobPad.intStartY + (int)m_fDefineSizePixel) > (stcBlobsFeatures.intEndY - (int)m_fDefineSizePixel))
                        {
                            intDirectionMask &= ~0x04;
                        }

                        // Check is low row
                        if ((m_stcBlobPad.intEndY - (int)m_fDefineSizePixel) < (stcBlobsFeatures.intStartY + (int)m_fDefineSizePixel))
                        {
                            intDirectionMask &= ~0x08;
                        }
                    }
                }

                if (intDirectionMask == 3 && intPadPosition == 0)  // E.g big pad at center and link to left and right edge
                    intDirectionMask = 0;

                if (intDirectionMask == 0x0C && intPadPosition == 0)  // E.g big pad at center and link to left and right edge
                    intDirectionMask = 0;


                if ((intDirectionMask == 3) && (intPadPosition == 2 || intPadPosition == 4))
                {
                    //if (intPadPosition == 2)
                    //    intDirectionMask = 0x01;
                    //else
                    intDirectionMask = 0x02;
                }
                if ((intDirectionMask == 11) && (intPadPosition == 2 || intPadPosition == 4))
                {
                    //if (intPadPosition == 2)
                    //    intDirectionMask = 0x09;
                    //else
                    intDirectionMask = 0x0A;
                }
                if ((intDirectionMask == 7) && (intPadPosition == 2 || intPadPosition == 4))
                {
                    //if (intPadPosition == 2)
                    //    intDirectionMask = 0x05;
                    //else
                    intDirectionMask = 0x06;
                }

                if (intDirectionMask == 0x0C && (intPadPosition == 1 || intPadPosition == 3))
                {
                    //if (intPadPosition == 1)
                    //    intDirectionMask = 0x08;
                    //else
                    intDirectionMask = 0x04;
                }
                if (intDirectionMask == 0x0E && (intPadPosition == 1 || intPadPosition == 3))
                {
                    //if (intPadPosition == 1)
                    //    intDirectionMask = 0x0A;
                    //else
                    intDirectionMask = 0x06;
                }
                if (intDirectionMask == 0x0D && (intPadPosition == 1 || intPadPosition == 3))
                {
                    //if (intPadPosition == 1)
                    //    intDirectionMask = 0x09;
                    //else
                    intDirectionMask = 0x05;
                }
                m_stcBlobPad.intDirection = intDirectionMask;
                m_arrTemplateBlobPads.RemoveAt(i);
                m_arrTemplateBlobPads.Insert(i, m_stcBlobPad);
            }
        }

        /// <summary>
        /// Define default pitch gap tolerance
        /// </summary>
        private void DefinePitchGapTolerance()
        {
            //m_stcPitchGap.fMinGap = (m_stcPitchGap.fGap - m_fDefaultPixelTolerance) / m_fMMToPixelXValue;
            //m_stcPitchGap.fMaxGap = (m_stcPitchGap.fGap + m_fDefaultPixelTolerance) / m_fMMToPixelXValue;
            //m_stcPitchGap.fMinPitch = (m_stcPitchGap.fPitch - m_fDefaultPixelTolerance) / m_fMMToPixelXValue;
            //m_stcPitchGap.fMaxPitch = (m_stcPitchGap.fPitch + m_fDefaultPixelTolerance) / m_fMMToPixelXValue;

            // 2019-10-24 ZJYEOH : when convert unit, need to consider direction to decide whether want use calibration data X or Y
            if (m_stcPitchGap.intDirection == 0 || m_stcPitchGap.intDirection == 180)
            {
                m_stcPitchGap.fMinGap = (m_stcPitchGap.fGap - m_fDefaultPixelTolerance) / m_fMMToPixelYValue;
                m_stcPitchGap.fMaxGap = (m_stcPitchGap.fGap + m_fDefaultPixelTolerance) / m_fMMToPixelYValue;
                m_stcPitchGap.fMinPitch = (m_stcPitchGap.fPitch - m_fDefaultPixelTolerance) / m_fMMToPixelYValue;
                m_stcPitchGap.fMaxPitch = (m_stcPitchGap.fPitch + m_fDefaultPixelTolerance) / m_fMMToPixelYValue;
            }
            else
            {
                m_stcPitchGap.fMinGap = (m_stcPitchGap.fGap - m_fDefaultPixelTolerance) / m_fMMToPixelXValue;
                m_stcPitchGap.fMaxGap = (m_stcPitchGap.fGap + m_fDefaultPixelTolerance) / m_fMMToPixelXValue;
                m_stcPitchGap.fMinPitch = (m_stcPitchGap.fPitch - m_fDefaultPixelTolerance) / m_fMMToPixelXValue;
                m_stcPitchGap.fMaxPitch = (m_stcPitchGap.fPitch + m_fDefaultPixelTolerance) / m_fMMToPixelXValue;
            }

        }

        public bool IsGaugeMeasureOK(int intPadIndex)
        {
            return m_objRectGauge4L.IsGaugeMeasureOK(intPadIndex);
        }

        private void InitPadInspectionData(ROI objROI, int intNumSelectedObject)
        {
            m_intTemplateMatchStatus = new int[m_arrTemplateBlobPads.Count];
            m_intSampleMatchNumber = new int[intNumSelectedObject];
            m_fSamplePadRangeStartX = -999;// objROI.ref_ROIWidth;
            m_fSamplePadRangeStartY = -999;// objROI.ref_ROIHeight;
            m_fSamplePadRangeEndX = -999;// 0;
            m_fSamplePadRangeEndY = -999;// 0;

            for (int k = 0; k < intNumSelectedObject; k++)
            {
                m_intSampleMatchNumber[k] = -1;
            }

            for (int i = 0; i < m_arrSampleBlobPads.Length; i++)
            {
                m_arrSampleBlobPads[i].fOffSet = -999;
                m_arrSampleBlobPads[i].fArea = -999;
                m_arrSampleBlobPads[i].fWidth = -999;
                m_arrSampleBlobPads[i].fHeight = -999;
                m_arrSampleBlobPads[i].fPitch = -999;
                m_arrSampleBlobPads[i].fGap = -999;
                m_arrSampleBlobPads[i].intFailMask = 0;
                m_arrSampleBlobPads[i].fStartX = -999;
                m_arrSampleBlobPads[i].fStartY = -999;
                m_arrSampleBlobPads[i].fEndX = -999;
                m_arrSampleBlobPads[i].fEndY = -999;
                m_arrSampleBlobPads[i].fCenterX = -999;
                m_arrSampleBlobPads[i].fCenterY = -999;
                m_arrSampleBlobPads[i].intContourIndex = -1;

                m_arrSampleBlobPads[i].fOffSetMM = -999;
                m_arrSampleBlobPads[i].fAreaMM = -999;
                m_arrSampleBlobPads[i].fWidthMM = -999;
                m_arrSampleBlobPads[i].fHeightMM = -999;
                m_arrSampleBlobPads[i].fLine3MM = -999;
                m_arrSampleBlobPads[i].fLine4MM = -999;
                m_arrSampleBlobPads[i].fLine5MM = -999;
                m_arrSampleBlobPads[i].fLine6MM = -999;
                m_arrSampleBlobPads[i].fLine7MM = -999;
                m_arrSampleBlobPads[i].fLine8MM = -999;
                m_arrSampleBlobPads[i].fLine9MM = -999;
                m_arrSampleBlobPads[i].fLine10MM = -999;
                m_arrSampleBlobPads[i].fLine11MM = -999;
                m_arrSampleBlobPads[i].fLine12MM = -999;
                m_arrSampleBlobPads[i].fPitchMM = -999;
                m_arrSampleBlobPads[i].fGapMM = -999;
                m_arrSampleBlobPads[i].fSmearLength = -999;
                m_arrSampleBlobPads[i].fEdgeTop = -999;
                m_arrSampleBlobPads[i].fEdgeRight = -999;
                m_arrSampleBlobPads[i].fEdgeBottom = -999;
                m_arrSampleBlobPads[i].fEdgeLeft = -999;

                m_arrSampleBlobPads[i].fStandOffTop = -999;
                m_arrSampleBlobPads[i].fStandOffBottom = -999;
                m_arrSampleBlobPads[i].fStandOffLeft = -999;
                m_arrSampleBlobPads[i].fStandOffRight = -999;
                
            }

            m_arrFailPitchGapList = new List<PitchGap>();   // 2020 01 28 - CCENG: Due to Sensitivity Auto Feature, this m_arrFailPitchGapList array need to be reseted each repeat loop.
        }

        private void PadTestStage1_Eblob(ROI objROI, ROI objUnitSurfaceROI, List<List<PointF>> arrDontCare, bool blnCheckContamination)
        {
            // Testing Type:
            // 1. Match Blobs Object to Template Pad
            // 2. Check Extra Pad
            // 3. Check Joint/Bridge Pad
            // 4. Check Valid Pad

            m_arrExtraBlobCenterX.Clear();
            m_arrExtraBlobCenterY.Clear();
            m_arrExtraBlobWidth.Clear();
            m_arrExtraBlobHeight.Clear();
            float fGravityCenterX, fGravityCenterY, fLimitCenterX, fLimitCenterY, fWidth, fHeight;
            float fFeretCenterX, fFeretCenterY, fFeretWidth, fFeretHeight, fFeretAngle;
            float fStartX, fStartY, fEndX, fEndY;
            int intArea;
            int intTotalExtraArea = 0;

            int intStartPixelFromEdgeX = (int)Math.Round(m_fPkgStartPixelFromLeft, 0, MidpointRounding.AwayFromZero);
            int intStartPixelFromEdgeY = (int)Math.Round(m_fPkgStartPixelFromEdge, 0, MidpointRounding.AwayFromZero);
            int intStartPixelFromEdgeX2 = (int)Math.Round(m_fPkgStartPixelFromRight, 0, MidpointRounding.AwayFromZero);
            int intStartPixelFromEdgeY2 = (int)Math.Round(m_fPkgStartPixelFromBottom, 0, MidpointRounding.AwayFromZero);
            float fUnitAreaWidth = objUnitSurfaceROI.ref_ROIWidth;
            float fUnitAreaHeight = objUnitSurfaceROI.ref_ROIHeight;
            //2021-01-21 ZJYEOH : ForeignMaterial have own ROI Tolerance Setting
            //float fUnitAreaStartX = objROI.ref_ROITotalCenterX - fUnitAreaWidth / 2 - objROI.ref_ROITotalX + m_fForeignMaterialStartPixelFromLeft;//m_fPkgStartPixelFromLeft
            //float fUnitAreaStartY = objROI.ref_ROITotalCenterY - fUnitAreaHeight / 2 - objROI.ref_ROITotalY + m_fForeignMaterialStartPixelFromEdge;//m_fPkgStartPixelFromEdge
            //float fUnitAreaEndX = objROI.ref_ROITotalCenterX + fUnitAreaWidth / 2 - objROI.ref_ROITotalX - m_fForeignMaterialStartPixelFromRight;//m_fPkgStartPixelFromRight
            //float fUnitAreaEndY = objROI.ref_ROITotalCenterY + fUnitAreaHeight / 2 - objROI.ref_ROITotalY - m_fForeignMaterialStartPixelFromBottom;//m_fPkgStartPixelFromBottom
            float fUnitAreaStartX = objROI.ref_ROITotalCenterX - fUnitAreaWidth / 2 - objROI.ref_ROITotalX + m_fForeignMaterialStartPixelFromLeft_Pad;//m_fPkgStartPixelFromLeft
            float fUnitAreaStartY = objROI.ref_ROITotalCenterY - fUnitAreaHeight / 2 - objROI.ref_ROITotalY + m_fForeignMaterialStartPixelFromEdge_Pad;//m_fPkgStartPixelFromEdge
            float fUnitAreaEndX = objROI.ref_ROITotalCenterX + fUnitAreaWidth / 2 - objROI.ref_ROITotalX - m_fForeignMaterialStartPixelFromRight_Pad;//m_fPkgStartPixelFromRight
            float fUnitAreaEndY = objROI.ref_ROITotalCenterY + fUnitAreaHeight / 2 - objROI.ref_ROITotalY - m_fForeignMaterialStartPixelFromBottom_Pad;//m_fPkgStartPixelFromBottom

            for (int i = 0; i < m_objEBlobs.ref_intNumSelectedObject; i++)
            {
                // Skip if is hole
                ////if (m_objBlobs.IsHole())
                ////{
                ////    m_objBlobs.SetListBlobsToNext();
                ////    continue;
                ////}

                // Get sample data
                fGravityCenterX = fGravityCenterY = fLimitCenterX = fLimitCenterY = fWidth = fHeight = 0;
                intArea = 0;
                fGravityCenterX = m_objEBlobs.ref_arrGravityCenterX[i];
                fGravityCenterY = m_objEBlobs.ref_arrGravityCenterY[i];
                fLimitCenterX = m_objEBlobs.ref_arrLimitCenterX[i];
                fLimitCenterY = m_objEBlobs.ref_arrLimitCenterY[i];

                fWidth = m_objEBlobs.ref_arrWidth[i];
                fHeight = m_objEBlobs.ref_arrHeight[i];
                intArea = m_objEBlobs.ref_arrArea[i];

                // Get object start point and end point
                fStartX = fLimitCenterX - (fWidth / 2);
                fStartY = fLimitCenterY - (fHeight / 2);
                fEndX = fLimitCenterX + (fWidth / 2);
                fEndY = fLimitCenterY + (fHeight / 2);

                //14-06-2019 ZJYEOH : Remove as Inspection image subtracted white image
                //if (IsInDontCareArea(fGravityCenterX, fGravityCenterY, arrDontCare))
                //{
                //    continue;
                //}

                // Get template number which match with sample
                List<int> arrMatch = MatchTemplateObjects_Inspection(objROI, fStartX, fStartY,
                                                        fEndX, fEndY,
                                                        fWidth, fHeight,
                                                        fGravityCenterX, fGravityCenterY,
                                                        intArea, false);

                for (int j = 0; j < arrMatch.Count; j++)
                    m_intTemplateMatchStatus[arrMatch[j]]++;

                if (arrMatch.Count == 0)        // Set to -1 if match nothing with any template pads
                    m_intSampleMatchNumber[i] = -1;
                else if (arrMatch.Count > 1)    // Set to -2 if match more than 1 template pads
                    m_intSampleMatchNumber[i] = -2;
                else
                    m_intSampleMatchNumber[i] = arrMatch[0];

                // Only check extra pad if no template match with sample, by using Pad threshold
                if (m_intSampleMatchNumber[i] == -1)
                {
                    // Extra Pad
                    if ((m_intFailOptionMask & 0x1001) > 0 && blnCheckContamination) // 0x01 for extra pad area and length, 0x1000 for total extra pad.
                    {
                        float fOutWidth = Math.Max(fUnitAreaStartX - fStartX, 0) + Math.Max(fEndX - fUnitAreaEndX, 0);
                        float fOutHeight = Math.Max(fUnitAreaStartY - fStartY, 0) + Math.Max(fEndY - fUnitAreaEndY, 0);

                        // check is sample under unit area range
                        if (((fWidth - fOutWidth) > 0) && ((fHeight - fOutHeight) > 0)) // both value are > 0 when it is in check area range
                        {
                            //if (m_blnWantCheckExtraPadLength || m_blnWantCheckExtraPadArea)
                            {
                                // Create small ROI for the extra area
                                ROI objExtraAreaROI = new ROI();
                                objExtraAreaROI.AttachImage(objROI);
                                objExtraAreaROI.LoadROISetting((int)Math.Ceiling(fStartX + Math.Max(fUnitAreaStartX - fStartX, 0)),
                                                               (int)Math.Ceiling(fStartY + Math.Max(fUnitAreaStartY - fStartY, 0)),
                                                               (int)Math.Floor(fWidth - Math.Max(fUnitAreaStartX - fStartX, 0) - Math.Max(fEndX - fUnitAreaEndX, 0)),
                                                               (int)Math.Floor(fHeight - Math.Max(fUnitAreaStartY - fStartY, 0) - Math.Max(fEndY - fUnitAreaEndY, 0)));

                                if (objExtraAreaROI.ref_ROIWidth > 0 && objExtraAreaROI.ref_ROIHeight > 0)
                                {

                                    //m_objExtraPadEBlobs.BuildObjects_Filter_GetElement(objExtraAreaROI, false, true, 0, m_objEBlobs.ref_intAbsoluteThreshold,
                                    //    m_objEBlobs.ref_intMinAreaLimit, m_objExtraPadEBlobs.ref_intMaxAreaLimit, false, 0x0F);

                                    //2021-01-16 ZJYEOH : Use Foreign Material own threshold value
                                    int intSurfaceThresholdValue;
                                    int intLowSurfaceThresholdValue = 0;
                                    if (m_blnWantTightSetting)
                                    {
                                        intLowSurfaceThresholdValue = m_intSurfaceLowThresholdValue - m_intTightSettingThresholdTolerance;

                                        if (intLowSurfaceThresholdValue < 0)
                                            intLowSurfaceThresholdValue = 0;

                                        intSurfaceThresholdValue = m_intSurfaceThresholdValue - m_intTightSettingThresholdTolerance;

                                        if (intSurfaceThresholdValue < 0)
                                            intSurfaceThresholdValue = 0;
                                    }
                                    else
                                    {
                                        intLowSurfaceThresholdValue = m_intSurfaceLowThresholdValue;

                                        if (intLowSurfaceThresholdValue < 0)
                                            intLowSurfaceThresholdValue = 0;

                                        intSurfaceThresholdValue = m_intSurfaceThresholdValue;

                                        if (intSurfaceThresholdValue < 0)
                                            intSurfaceThresholdValue = 0;

                                    }

                                    m_objExtraPadEBlobs.BuildObjects_Filter_GetElement_DoubleThreshold(
                                        objExtraAreaROI, true, false, true, true, intLowSurfaceThresholdValue, intSurfaceThresholdValue,
                                        (int)Math.Floor(m_fBlobsMinArea), objExtraAreaROI.ref_ROIWidth * objExtraAreaROI.ref_ROIHeight + 1, false, 0x1F);
                                    //objExtraAreaROI.SaveImage("D:\\objExtraAreaROI.bmp");
                                    if (m_objExtraPadEBlobs.ref_intNumSelectedObject > 0)
                                    {
                                        double dClosest = double.MaxValue;
                                        float fLimitCenterX2 = 0, fLimitCenterY2 = 0;
                                        float fFinalLimitCenterX = 0, fFinalLimitCenterY = 0;
                                        for (int k = 0; k < m_objExtraPadEBlobs.ref_intNumSelectedObject; k++)
                                        {
                                            fLimitCenterX2 = m_objExtraPadEBlobs.ref_arrLimitCenterX[k];
                                            fLimitCenterY2 = m_objExtraPadEBlobs.ref_arrLimitCenterY[k];

                                            double dDistance = Math.Pow(Math.Pow(fLimitCenterX - (objExtraAreaROI.ref_ROIPositionX + fLimitCenterX2), 2) + Math.Pow(fLimitCenterY - (objExtraAreaROI.ref_ROIPositionY + fLimitCenterY2), 2), 0.5);

                                            if (dClosest > dDistance)
                                            {
                                                dClosest = dDistance;
                                                fFinalLimitCenterX = fLimitCenterX2;
                                                fFinalLimitCenterY = fLimitCenterY2;
                                                fWidth = m_objExtraPadEBlobs.ref_arrWidth[k];
                                                fHeight = m_objExtraPadEBlobs.ref_arrHeight[k];
                                                intArea = m_objExtraPadEBlobs.ref_arrArea[k];
                                            }
                                        }

                                        // get the object dimension from small ROI and reset this new dimension to the extra area dimension
                                        //m_objExtraPadBlobs.SetFirstListBlobs();
                                        //m_objExtraPadBlobs.GetSelectedListBlobsLimitCenterX(ref fLimitCenterX);
                                        //m_objExtraPadBlobs.GetSelectedListBlobsLimitCenterY(ref fLimitCenterY);
                                        //m_objExtraPadBlobs.GetSelectedListBlobsWidth(ref fWidth);
                                        //m_objExtraPadBlobs.GetSelectedListBlobsHeight(ref fHeight);
                                        //m_objExtraPadBlobs.GetSelectedListBlobsArea(ref intArea);

                                        // Reposition so that it offset to objROI
                                        fFinalLimitCenterX += objExtraAreaROI.ref_ROIPositionX;
                                        fFinalLimitCenterY += objExtraAreaROI.ref_ROIPositionY;

                                        // Get object start point and end point
                                        fStartX = fFinalLimitCenterX - (fWidth / 2);
                                        fStartY = fFinalLimitCenterY - (fHeight / 2);
                                        fEndX = fFinalLimitCenterX + (fWidth / 2);
                                        fEndY = fFinalLimitCenterY + (fHeight / 2);
                                    }
                                    else
                                    {
                                        // Set extra area as empty if cannot find object in small ROI
                                        fWidth = 0;
                                        fHeight = 0;
                                        intArea = 0;
                                    }
                                }
                                else
                                {
                                    fWidth = 0;
                                    fHeight = 0;
                                    intArea = 0;
                                }

                                objExtraAreaROI.Dispose();
                            }

                            // 2018 09 12 - JBTAN: Dont check contamination here, will check later at CheckExtraObjectOnUnitSurface()
                            //if (m_blnWantCheckExtraPadLength)
                            //{
                            //    //////////////// Check extra pad using length limit setting ////////////////////

                            //    float fWidthInMM = fWidth / m_fMMToPixelXValue;
                            //    float fHeightInMM = fHeight / m_fMMToPixelXValue;

                            //    if ((fWidthInMM > m_fExtraPadSetLength) ||
                            //        (fHeightInMM > m_fExtraPadSetLength))
                            //    {
                            //        SampleExtraBlobsFeatures extra = new SampleExtraBlobsFeatures();
                            //        extra.fStartX = fStartX;
                            //        extra.fEndX = fEndX;
                            //        extra.fStartY = fStartY;
                            //        extra.fEndY = fEndY;
                            //        extra.fWidth = fWidth;
                            //        extra.fHeight = fHeight;
                            //        extra.fCenterX = fLimitCenterX;
                            //        extra.fCenterY = fLimitCenterY;

                            //        m_arrExtraBlobs.Add(extra);

                            //        m_intFailResultMask |= 0x01;
                            //        m_blnFailForeignMaterialLength = true;

                            //        // Collect extra pad min and max area for display error message
                            //        if ((fWidthInMM > m_fExtraPadSetLength) &&
                            //        (fHeightInMM > m_fExtraPadSetLength))
                            //        {
                            //            float fMin = Math.Min(fWidthInMM, fHeightInMM);
                            //            if ((m_fResultExtraPadMinArea == -1) || (fMin < m_fResultExtraPadMinArea))
                            //                m_fResultExtraPadMinArea = fMin;

                            //            float fMax = Math.Max(fWidthInMM, fHeightInMM);
                            //            if ((m_fResultExtraPadMaxArea == -1) || (fMax > m_fResultExtraPadMaxArea))
                            //                m_fResultExtraPadMaxArea = fMax;
                            //        }
                            //        else if (fWidthInMM > m_fExtraPadSetLength)
                            //        {
                            //            if ((m_fResultExtraPadMinArea == -1) || (fWidthInMM < m_fResultExtraPadMinArea))
                            //                m_fResultExtraPadMinArea = fWidthInMM;
                            //            if ((m_fResultExtraPadMaxArea == -1) || (fWidthInMM > m_fResultExtraPadMaxArea))
                            //                m_fResultExtraPadMaxArea = fWidthInMM;
                            //        }
                            //        else if (fHeightInMM > m_fExtraPadSetLength)
                            //        {
                            //            if ((m_fResultExtraPadMinArea == -1) || (fHeightInMM < m_fResultExtraPadMinArea))
                            //                m_fResultExtraPadMinArea = fHeightInMM;
                            //            if ((m_fResultExtraPadMaxArea == -1) || (fHeightInMM > m_fResultExtraPadMaxArea))
                            //                m_fResultExtraPadMaxArea = fHeightInMM;
                            //        }
                            //    }
                            //}

                            //// 2018 09 12 - JBTAN: Dont check Extra Pad here, will check later at CheckExtraObjectOnUnitSurface()
                            //if (m_blnWantCheckExtraPadArea && !m_blnFailForeignMaterialLength)
                            //{
                            //    //////////////// Check extra pad using area limit setting ////////////////////
                            //    float fArea = intArea * m_fAreaMMPerPixel;  // Change unit pixel to mm
                            //    if (fArea >= m_fExtraPadSetArea)
                            //    {
                            //        SampleExtraBlobsFeatures extra = new SampleExtraBlobsFeatures();
                            //        extra.fStartX = fStartX;
                            //        extra.fEndX = fEndX;
                            //        extra.fStartY = fStartY;
                            //        extra.fEndY = fEndY;
                            //        extra.fWidth = fWidth;
                            //        extra.fHeight = fHeight;
                            //        extra.fCenterX = fLimitCenterX;
                            //        extra.fCenterY = fLimitCenterY;

                            //        m_arrExtraBlobs.Add(extra);

                            //        m_intFailResultMask |= 0x01;
                            //        m_blnFailForeignMaterialArea = true;

                            //        // Collect extra pad min and max area for display error message
                            //        if ((m_fResultExtraPadMinArea == -1) || (fArea < m_fResultExtraPadMinArea))
                            //            m_fResultExtraPadMinArea = fArea;
                            //        if ((m_fResultExtraPadMaxArea == -1) || (fArea > m_fResultExtraPadMaxArea))
                            //            m_fResultExtraPadMaxArea = fArea;
                            //    }

                            //    //////////////////////////////////////////////////////////////////////
                            //}

                            float fWidthInMM = fWidth / m_fMMToPixelXValue;
                            float fHeightInMM = fHeight / m_fMMToPixelYValue;
                            float fAreaInMM = intArea / m_fMMtoPixelAreaValue;

                            SampleExtraBlobsFeatures extra = new SampleExtraBlobsFeatures();
                            extra.fStartX = fStartX;
                            extra.fEndX = fEndX;
                            extra.fStartY = fStartY;
                            extra.fEndY = fEndY;
                            extra.fWidth = fWidth;
                            extra.fHeight = fHeight;
                            extra.fCenterX = fLimitCenterX;
                            extra.fCenterY = fLimitCenterY;
                            extra.fWidthInMM = fWidthInMM;
                            extra.fHeightInMM = fHeightInMM;
                            extra.fAreaInMM2 = fAreaInMM;
                            extra.strDefectName = "Foreign Material";
                            extra.intFailMask = 0;

                            if (m_blnWantCheckExtraPadLength)
                            {
                                //////////////// Check extra pad using length limit setting ////////////////////


                                if ((fWidthInMM > m_fExtraPadSetLength) ||
                                    (fHeightInMM > m_fExtraPadSetLength))
                                {
                                    if (fWidthInMM > m_fExtraPadSetLength)
                                        extra.intFailMask |= 0x01;

                                    if (fHeightInMM > m_fExtraPadSetLength)
                                        extra.intFailMask |= 0x02;

                                    m_intFailResultMask |= 0x01;
                                    m_blnFailForeignMaterialLength = true;

                                    // Collect extra pad min and max area for display error message
                                    if ((fWidthInMM > m_fExtraPadSetLength) &&
                                    (fHeightInMM > m_fExtraPadSetLength))
                                    {
                                        float fMin = Math.Min(fWidthInMM, fHeightInMM);
                                        if ((m_fResultExtraPadMinArea == -1) || (fMin < m_fResultExtraPadMinArea))
                                            m_fResultExtraPadMinArea = fMin;

                                        float fMax = Math.Max(fWidthInMM, fHeightInMM);
                                        if ((m_fResultExtraPadMaxArea == -1) || (fMax > m_fResultExtraPadMaxArea))
                                            m_fResultExtraPadMaxArea = fMax;
                                    }
                                    else if (fWidthInMM > m_fExtraPadSetLength)
                                    {
                                        if ((m_fResultExtraPadMinArea == -1) || (fWidthInMM < m_fResultExtraPadMinArea))
                                            m_fResultExtraPadMinArea = fWidthInMM;
                                        if ((m_fResultExtraPadMaxArea == -1) || (fWidthInMM > m_fResultExtraPadMaxArea))
                                            m_fResultExtraPadMaxArea = fWidthInMM;
                                    }
                                    else if (fHeightInMM > m_fExtraPadSetLength)
                                    {
                                        if ((m_fResultExtraPadMinArea == -1) || (fHeightInMM < m_fResultExtraPadMinArea))
                                            m_fResultExtraPadMinArea = fHeightInMM;
                                        if ((m_fResultExtraPadMaxArea == -1) || (fHeightInMM > m_fResultExtraPadMaxArea))
                                            m_fResultExtraPadMaxArea = fHeightInMM;
                                    }
                                }
                            }

                            if (m_blnWantCheckExtraPadArea && !m_blnFailForeignMaterialLength)
                            {
                                //////////////// Check extra pad using area limit setting ////////////////////
                                float fArea = intArea * m_fAreaMMPerPixel;  // Change unit pixel to mm
                                if (fArea > m_fExtraPadSetArea)
                                {
                                    extra.intFailMask |= 0x04;

                                    m_intFailResultMask |= 0x01;
                                    m_blnFailForeignMaterialArea = true;

                                    // Collect extra pad min and max area for display error message
                                    if ((m_fResultExtraPadMinArea == -1) || (fArea < m_fResultExtraPadMinArea))
                                        m_fResultExtraPadMinArea = fArea;
                                    if ((m_fResultExtraPadMaxArea == -1) || (fArea > m_fResultExtraPadMaxArea))
                                        m_fResultExtraPadMaxArea = fArea;
                                }
                            }

                            //////////////// Get Total Extra pad unit area ///////////////////////////////
                            if (intArea > 0)
                            {
                                if ((m_intFailOptionMask & 0x1000) > 0)
                                {
                                    intTotalExtraArea += intArea;
                                }


                                m_arrExtraBlobs.Add(extra);

                                m_arrExtraBlobCenterX.Add(fLimitCenterX);
                                m_arrExtraBlobCenterY.Add(fLimitCenterY);
                                m_arrExtraBlobWidth.Add(fWidth);
                                m_arrExtraBlobHeight.Add(fHeight);
                            }
                        }
                    }
                }
                //More than 1 templates match with sample
                if (m_intSampleMatchNumber[i] == -2)  // Temporary close bridging
                {
                    //Join/Bridge Pad
                    bool blnIsAnyEnable = false;
                    for (int b = 0; b < arrMatch.Count; b++)
                    {
                        if (((BlobsFeatures)m_arrTemplateBlobPads[arrMatch[b]]).blnEnable)
                        {
                            m_arrSampleBlobPads[arrMatch[b]].intFailMask |= 0x02;
                            blnIsAnyEnable = true;
                        }
                    }

                    if (blnIsAnyEnable)
                    {
                        float fWidthInMM = fWidth / m_fMMToPixelXValue;
                        float fHeightInMM = fHeight / m_fMMToPixelYValue;
                        float fAreaInMM = intArea / m_fMMToPixelXValue / m_fMMToPixelYValue;

                        //Join/Bridge Pad
                        SampleExtraBlobsFeatures extra = new SampleExtraBlobsFeatures();
                        extra.fStartX = fStartX;
                        extra.fEndX = fEndX;
                        extra.fStartY = fStartY;
                        extra.fEndY = fEndY;
                        extra.fWidth = fWidth;
                        extra.fHeight = fHeight;
                        extra.fCenterX = fLimitCenterX;
                        extra.fCenterY = fLimitCenterY;
                        extra.fWidthInMM = fWidthInMM;
                        extra.fHeightInMM = fHeightInMM;
                        extra.fAreaInMM2 = fAreaInMM;
                        extra.strDefectName = "Join/Bridge Pad";
                        extra.intFailMask |= 0x07;

                        m_arrExtraBlobs.Add(extra);

                        m_intFailResultMask |= 0x02;
                    }
                }
                //Sample fall in Don't Care ROI area
                else if (m_intSampleMatchNumber[i] == -3)
                {
                    continue;
                }
                // Found only 1 templates match with sample
                else if (m_intSampleMatchNumber[i] >= 0)
                {
                    if (m_arrSampleBlobPads[m_intSampleMatchNumber[i]].fArea == -999)
                    {
                        //Collect ordinary blob data
                        m_arrSampleBlobPads[m_intSampleMatchNumber[i]].intFailMask |= 0;
                        m_arrSampleBlobPads[m_intSampleMatchNumber[i]].fStartX = fStartX;
                        m_arrSampleBlobPads[m_intSampleMatchNumber[i]].fStartY = fStartY;
                        m_arrSampleBlobPads[m_intSampleMatchNumber[i]].fEndX = fEndX;
                        m_arrSampleBlobPads[m_intSampleMatchNumber[i]].fEndY = fEndY;
                        m_arrSampleBlobPads[m_intSampleMatchNumber[i]].fCenterX = m_arrSampleBlobPads[m_intSampleMatchNumber[i]].fBlobCenterX = fLimitCenterX;
                        m_arrSampleBlobPads[m_intSampleMatchNumber[i]].fCenterY = m_arrSampleBlobPads[m_intSampleMatchNumber[i]].fBlobCenterY = fLimitCenterY;
                        m_arrSampleBlobPads[m_intSampleMatchNumber[i]].fGravityCenterX = fGravityCenterX;
                        m_arrSampleBlobPads[m_intSampleMatchNumber[i]].fGravityCenterY = fGravityCenterY;
                        m_arrSampleBlobPads[m_intSampleMatchNumber[i]].fWidth = m_arrSampleBlobPads[m_intSampleMatchNumber[i]].fBlobWidth = fWidth;
                        m_arrSampleBlobPads[m_intSampleMatchNumber[i]].fHeight = m_arrSampleBlobPads[m_intSampleMatchNumber[i]].fBlobHeight = fHeight;
                        m_arrSampleBlobPads[m_intSampleMatchNumber[i]].fArea = (float)intArea;
                        m_arrSampleBlobPads[m_intSampleMatchNumber[i]].intContourIndex = i;

                        //collect feret information
                        BlobsFeatures m_stcBlobPad = (BlobsFeatures)m_arrTemplateBlobPads[m_intSampleMatchNumber[i]];
                        float fTemplateAngle = m_stcBlobPad.fFeretAngle;
                        float fAngle = m_objEBlobs.ref_arrRectAngle[i];

                        if (m_objEBlobs.ref_arrRectHeight[i] < m_objEBlobs.ref_arrRectWidth[i] && (Math.Abs(fAngle - fTemplateAngle) > 10))
                        {
                            if (fAngle >= 10)//&& fAngle <= 80)
                                fAngle = m_objEBlobs.ref_arrRectAngle[i] - 90;
                            else
                                fAngle = 90 + m_objEBlobs.ref_arrRectAngle[i];



                            fFeretWidth = m_objEBlobs.ref_arrRectHeight[i];
                            fFeretHeight = m_objEBlobs.ref_arrRectWidth[i];
                        }
                        else
                        {
                            fFeretWidth = m_objEBlobs.ref_arrRectWidth[i];
                            fFeretHeight = m_objEBlobs.ref_arrRectHeight[i];
                        }
                        fFeretCenterX = m_objEBlobs.ref_arrRectLimitCenterX[i] /*+ Math.Abs(OffsetX)*/;
                        fFeretCenterY = m_objEBlobs.ref_arrRectLimitCenterY[i] /*+ Math.Abs(OffsetY)*/;

                        fFeretAngle = fTemplateAngle;// fAngle;
                        
                        m_arrSampleBlobPads[m_intSampleMatchNumber[i]].fFeretCenterX = fFeretCenterX;
                        m_arrSampleBlobPads[m_intSampleMatchNumber[i]].fFeretCenterY = fFeretCenterY;
                        m_arrSampleBlobPads[m_intSampleMatchNumber[i]].fFeretWidth = fFeretWidth;
                        m_arrSampleBlobPads[m_intSampleMatchNumber[i]].fFeretHeight = fFeretHeight;
                        m_arrSampleBlobPads[m_intSampleMatchNumber[i]].fFeretAngle = fFeretAngle;

                        // Copy to backup blob
                        m_arrBackupBlobPads[m_intSampleMatchNumber[i]].intFailMask |= 0;
                        m_arrBackupBlobPads[m_intSampleMatchNumber[i]].fStartX = fStartX;
                        m_arrBackupBlobPads[m_intSampleMatchNumber[i]].fStartY = fStartY;
                        m_arrBackupBlobPads[m_intSampleMatchNumber[i]].fEndX = fEndX;
                        m_arrBackupBlobPads[m_intSampleMatchNumber[i]].fEndY = fEndY;
                        m_arrBackupBlobPads[m_intSampleMatchNumber[i]].fCenterX = fLimitCenterX;
                        m_arrBackupBlobPads[m_intSampleMatchNumber[i]].fCenterY = fLimitCenterY;
                        m_arrBackupBlobPads[m_intSampleMatchNumber[i]].fGravityCenterX = fGravityCenterX;
                        m_arrBackupBlobPads[m_intSampleMatchNumber[i]].fGravityCenterY = fGravityCenterY;
                        m_arrBackupBlobPads[m_intSampleMatchNumber[i]].fWidth = fWidth;
                        m_arrBackupBlobPads[m_intSampleMatchNumber[i]].fHeight = fHeight;
                        m_arrBackupBlobPads[m_intSampleMatchNumber[i]].fArea = (float)intArea;
                        m_arrBackupBlobPads[m_intSampleMatchNumber[i]].intContourIndex = i;

                        m_arrBackupBlobPads[m_intSampleMatchNumber[i]].fFeretCenterX = fFeretCenterX;
                        m_arrBackupBlobPads[m_intSampleMatchNumber[i]].fFeretCenterY = fFeretCenterY;
                        m_arrBackupBlobPads[m_intSampleMatchNumber[i]].fFeretWidth = fFeretWidth;
                        m_arrBackupBlobPads[m_intSampleMatchNumber[i]].fFeretHeight = fFeretHeight;
                        m_arrBackupBlobPads[m_intSampleMatchNumber[i]].fFeretAngle = fFeretAngle;

                        // Collect Pad range data
                        if (m_fSamplePadRangeStartX == -999 || fStartX < m_fSamplePadRangeStartX)
                            m_fSamplePadRangeStartX = fStartX;
                        if (m_fSamplePadRangeStartY == -999 || fStartY < m_fSamplePadRangeStartY)
                            m_fSamplePadRangeStartY = fStartY;
                        if (m_fSamplePadRangeEndX == -999 || fEndX > m_fSamplePadRangeEndX)
                            m_fSamplePadRangeEndX = fEndX;
                        if (m_fSamplePadRangeEndY == -999 || fEndY > m_fSamplePadRangeEndY)
                            m_fSamplePadRangeEndY = fEndY;

                        // Collect sample blobs data in MM
                        m_arrSampleBlobPads[m_intSampleMatchNumber[i]].fWidthMM = fWidth / m_fMMToPixelXValue;
                        m_arrSampleBlobPads[m_intSampleMatchNumber[i]].fHeightMM = fHeight / m_fMMToPixelYValue; // 11-04-2019 ZJYEOH : Changed m_fMMToPixelXValue to m_fMMToPixelYValue
                        m_arrSampleBlobPads[m_intSampleMatchNumber[i]].fAreaMM = (float)intArea / m_fMMtoPixelAreaValue;
                    }

                }
            }

            if ((((m_intFailOptionMask & 0x1000) > 0) && blnCheckContamination) && !m_blnFailForeignMaterialLength && !m_blnFailForeignMaterialArea)
            {
                //////////////// Check Total Extra pad unit area ///////////////////////////////
                float fArea = intTotalExtraArea * m_fAreaMMPerPixel;  // Change unit pixel to mm
                if (fArea > m_fTotalExtraPadSetArea)
                {
                    for (int i = 0; i < m_arrExtraBlobs.Count; i++)
                    {
                        SampleExtraBlobsFeatures objExtraBlob = m_arrExtraBlobs[i];
                        objExtraBlob.intFailMask |= 0x04;
                        m_arrExtraBlobs[i] = objExtraBlob;
                    }

                    m_intFailResultMask |= 0x1000;

                    // Collect total extra pad for display error message
                    m_fResultTotalExtraPadArea = fArea;
                }
            }
        }

        /// <summary>
        /// Sort object number
        /// </summary>
        private void SortObjectNumber()
        {
            int intNoID = 1;
            BlobsFeatures stcBlobsFeatures = new BlobsFeatures();
            int[] intDirectionOrder = { -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 };

            #region Set Direction Sequence
            bool blnTopFound = false;
            bool blnBottomFound = false;
            bool blnLeftFound = false;
            bool blnRightFound = false;
            int intOneColumn = 0;
            int intOneRow = 0;
            for (int i = 0; i < m_arrTemplateBlobPads.Count; i++)
            {
                BlobsFeatures m_stcBlobPad = (BlobsFeatures)m_arrTemplateBlobPads[i];
                if (!m_stcBlobPad.blnSelected)
                    continue;

                if (m_stcBlobPad.intDirection == 1)
                    blnLeftFound = true;

                if (m_stcBlobPad.intDirection == 2)
                    blnRightFound = true;

                if (m_stcBlobPad.intDirection == 4)
                    blnTopFound = true;

                if (m_stcBlobPad.intDirection == 8)
                    blnBottomFound = true;

                if (m_stcBlobPad.intDirection == 7)
                    intOneColumn |= 0x01;

                if (m_stcBlobPad.intDirection == 3)
                    intOneColumn |= 0x02;

                if (m_stcBlobPad.intDirection == 11)
                    intOneColumn |= 0x04;

                if (m_stcBlobPad.intDirection == 13)
                    intOneRow |= 0x01;

                if (m_stcBlobPad.intDirection == 12)
                    intOneRow |= 0x02;

                if (m_stcBlobPad.intDirection == 14)
                    intOneRow |= 0x04;
            }

            int intIndex = 0;
            //if (intOneColumn == 0x07)
            if (intOneColumn > 0)
            {
                if (m_intPadLabelRefCorner == 0 || m_intPadLabelRefCorner == 1) // Top Left or Top Right
                {
                    intDirectionOrder[intIndex++] = 7;
                    intDirectionOrder[intIndex++] = 3;
                    intDirectionOrder[intIndex++] = 11;
                }
                else
                {
                    intDirectionOrder[intIndex++] = 11;
                    intDirectionOrder[intIndex++] = 3;
                    intDirectionOrder[intIndex++] = 7;
                }
            }
            //else if (intOneRow == 0x07)
            else if (intOneRow > 0)
            {
                if (m_intPadLabelRefCorner == 0 || m_intPadLabelRefCorner == 2) // Top Left or Bottom Left
                {
                    intDirectionOrder[intIndex++] = 13;
                    intDirectionOrder[intIndex++] = 12;
                    intDirectionOrder[intIndex++] = 14;
                }
                else
                {
                    intDirectionOrder[intIndex++] = 14;
                    intDirectionOrder[intIndex++] = 12;
                    intDirectionOrder[intIndex++] = 13;
                }
            }
            //else  // 2020 07 08 - some time there are other small pad after big pad occupy one row or one column.
            {
                switch (m_intPadLabelRefCorner)
                {
                    case 0:
                        {
                            if (m_intPadLabelDirection == 0)
                            {
                                if (blnTopFound || !blnLeftFound && !blnRightFound)
                                {
                                    intDirectionOrder[intIndex++] = 5;

                                }

                                intDirectionOrder[intIndex++] = 4;
                                intDirectionOrder[intIndex++] = 6;
                                intDirectionOrder[intIndex++] = 2;
                                intDirectionOrder[intIndex++] = 10;
                                intDirectionOrder[intIndex++] = 8;
                                intDirectionOrder[intIndex++] = 9;
                                intDirectionOrder[intIndex++] = 1;

                                if (!blnTopFound && (blnLeftFound || blnRightFound))
                                    intDirectionOrder[intIndex++] = 5;

                                intDirectionOrder[intIndex] = 0;
                            }
                            else
                            {
                                if (blnLeftFound || !blnTopFound && !blnBottomFound)
                                {
                                    intDirectionOrder[intIndex++] = 5;
                                }

                                intDirectionOrder[intIndex++] = 1;
                                intDirectionOrder[intIndex++] = 9;
                                intDirectionOrder[intIndex++] = 8;
                                intDirectionOrder[intIndex++] = 10;
                                intDirectionOrder[intIndex++] = 2;
                                intDirectionOrder[intIndex++] = 6;
                                intDirectionOrder[intIndex++] = 4;

                                if (!blnLeftFound && (blnTopFound || blnBottomFound))
                                    intDirectionOrder[intIndex++] = 5;

                                intDirectionOrder[intIndex] = 0;
                            }
                        }
                        break;
                    case 1:
                        {
                            if (m_intPadLabelDirection == 0)
                            {
                                if (blnRightFound || !blnTopFound && !blnBottomFound)
                                {
                                    intDirectionOrder[intIndex++] = 6;

                                }

                                intDirectionOrder[intIndex++] = 2;
                                intDirectionOrder[intIndex++] = 10;
                                intDirectionOrder[intIndex++] = 8;
                                intDirectionOrder[intIndex++] = 9;
                                intDirectionOrder[intIndex++] = 1;
                                intDirectionOrder[intIndex++] = 5;
                                intDirectionOrder[intIndex++] = 4;

                                if (!blnRightFound && (blnTopFound || blnBottomFound))
                                    intDirectionOrder[intIndex++] = 6;

                                intDirectionOrder[intIndex] = 0;
                            }
                            else
                            {
                                if (blnTopFound || !blnLeftFound && !blnRightFound)
                                {
                                    intDirectionOrder[intIndex++] = 6;

                                }

                                intDirectionOrder[intIndex++] = 4;
                                intDirectionOrder[intIndex++] = 5;
                                intDirectionOrder[intIndex++] = 1;
                                intDirectionOrder[intIndex++] = 9;
                                intDirectionOrder[intIndex++] = 8;
                                intDirectionOrder[intIndex++] = 10;
                                intDirectionOrder[intIndex++] = 2;

                                if (!blnTopFound && (blnLeftFound || blnRightFound))
                                    intDirectionOrder[intIndex++] = 6;

                                intDirectionOrder[intIndex] = 0;
                            }
                        }
                        break;
                    case 2: // Bottom Left
                        {
                            if (m_intPadLabelDirection == 0)
                            {
                                if (blnLeftFound || !blnTopFound && !blnBottomFound)
                                {
                                    intDirectionOrder[intIndex++] = 9;

                                }

                                intDirectionOrder[intIndex++] = 1;
                                intDirectionOrder[intIndex++] = 5;
                                intDirectionOrder[intIndex++] = 4;
                                intDirectionOrder[intIndex++] = 6;
                                intDirectionOrder[intIndex++] = 2;
                                intDirectionOrder[intIndex++] = 10;
                                intDirectionOrder[intIndex++] = 8;

                                if (!blnLeftFound && (blnTopFound || blnBottomFound))
                                    intDirectionOrder[intIndex++] = 9;

                                intDirectionOrder[intIndex] = 0;
                            }
                            else
                            {
                                if (blnBottomFound || !blnLeftFound && !blnRightFound)
                                {
                                    intDirectionOrder[intIndex++] = 9;

                                }

                                intDirectionOrder[intIndex++] = 8;
                                intDirectionOrder[intIndex++] = 10;
                                intDirectionOrder[intIndex++] = 2;
                                intDirectionOrder[intIndex++] = 6;
                                intDirectionOrder[intIndex++] = 4;
                                intDirectionOrder[intIndex++] = 5;
                                intDirectionOrder[intIndex++] = 1;

                                if (!blnBottomFound && (blnLeftFound || blnRightFound))
                                    intDirectionOrder[intIndex++] = 9;

                                intDirectionOrder[intIndex] = 0;
                            }
                        }
                        break;
                    case 3: // Bottom Right
                        {
                            if (m_intPadLabelDirection == 0)
                            {
                                if (blnBottomFound || !blnLeftFound && !blnRightFound)
                                {
                                    intDirectionOrder[intIndex++] = 10;

                                }

                                intDirectionOrder[intIndex++] = 8;
                                intDirectionOrder[intIndex++] = 9;
                                intDirectionOrder[intIndex++] = 1;
                                intDirectionOrder[intIndex++] = 5;
                                intDirectionOrder[intIndex++] = 4;
                                intDirectionOrder[intIndex++] = 6;
                                intDirectionOrder[intIndex++] = 2;

                                if (!blnBottomFound && (blnLeftFound || blnRightFound))
                                    intDirectionOrder[intIndex++] = 10;

                                intDirectionOrder[intIndex] = 0;
                            }
                            else
                            {
                                if (blnRightFound || !blnTopFound && !blnBottomFound)
                                {
                                    intDirectionOrder[intIndex++] = 10;

                                }

                                intDirectionOrder[intIndex++] = 2;
                                intDirectionOrder[intIndex++] = 6;
                                intDirectionOrder[intIndex++] = 4;
                                intDirectionOrder[intIndex++] = 5;
                                intDirectionOrder[intIndex++] = 1;
                                intDirectionOrder[intIndex++] = 9;
                                intDirectionOrder[intIndex++] = 8;

                                if (!blnRightFound && (blnTopFound || blnBottomFound))
                                    intDirectionOrder[intIndex++] = 10;

                                intDirectionOrder[intIndex] = 0;
                            }
                        }
                        break;
                }
            }

            #endregion

            #region Known Direction
            for (int d = 0; d < intDirectionOrder.Length; d++)
            {
                if (intDirectionOrder[d] == -1)
                    continue;

                for (int i = 0; i < m_arrTemplateBlobPads.Count; i++)
                {
                    BlobsFeatures m_stcBlobPad = (BlobsFeatures)m_arrTemplateBlobPads[i];

                    if (!m_stcBlobPad.blnSelected)
                        continue;

                    if (m_stcBlobPad.intDirection == intDirectionOrder[d])
                    {
                        m_stcBlobPad.intNoID = intNoID;

                        for (int j = 0; j < i; j++)
                        {
                            stcBlobsFeatures = (BlobsFeatures)m_arrTemplateBlobPads[j];

                            if (!stcBlobsFeatures.blnSelected)
                                continue;

                            if (stcBlobsFeatures.intDirection == intDirectionOrder[d])
                            {
                                if ((intDirectionOrder[d] == 5) || (intDirectionOrder[d] == 4) || (intDirectionOrder[d] == 6) || (intDirectionOrder[d] == 12) || (intDirectionOrder[d] == 13) || (intDirectionOrder[d] == 14))
                                {
                                    if (m_intPadLabelDirection == 0)
                                    {
                                        if (m_stcBlobPad.intStartX < stcBlobsFeatures.intStartX)
                                        {
                                            if (m_stcBlobPad.intNoID > stcBlobsFeatures.intNoID)
                                                m_stcBlobPad.intNoID = stcBlobsFeatures.intNoID;
                                        }
                                    }
                                    else
                                    {
                                        if (m_stcBlobPad.intStartX > stcBlobsFeatures.intStartX)
                                        {
                                            if (m_stcBlobPad.intNoID > stcBlobsFeatures.intNoID)
                                                m_stcBlobPad.intNoID = stcBlobsFeatures.intNoID;
                                        }
                                    }
                                }
                                else if ((intDirectionOrder[d] == 2) || (intDirectionOrder[d] == 0) || (intDirectionOrder[d] == 7) || (intDirectionOrder[d] == 3) || (intDirectionOrder[d] == 11))
                                {
                                    if (m_intPadLabelDirection == 0)
                                    {
                                        if (m_stcBlobPad.intStartY < stcBlobsFeatures.intStartY)
                                        {
                                            if (m_stcBlobPad.intNoID > stcBlobsFeatures.intNoID)
                                                m_stcBlobPad.intNoID = stcBlobsFeatures.intNoID;
                                        }
                                    }
                                    else
                                    {
                                        if (m_stcBlobPad.intStartY > stcBlobsFeatures.intStartY)
                                        {
                                            if (m_stcBlobPad.intNoID > stcBlobsFeatures.intNoID)
                                                m_stcBlobPad.intNoID = stcBlobsFeatures.intNoID;
                                        }
                                    }
                                }
                                else if ((intDirectionOrder[d] == 10) || (intDirectionOrder[d] == 8) || (intDirectionOrder[d] == 9))
                                {
                                    if (m_intPadLabelDirection == 0)
                                    {
                                        if (m_stcBlobPad.intStartX > stcBlobsFeatures.intStartX)
                                        {
                                            if (m_stcBlobPad.intNoID > stcBlobsFeatures.intNoID)
                                                m_stcBlobPad.intNoID = stcBlobsFeatures.intNoID;
                                        }
                                    }
                                    else
                                    {
                                        if (m_stcBlobPad.intStartX < stcBlobsFeatures.intStartX)
                                        {
                                            if (m_stcBlobPad.intNoID > stcBlobsFeatures.intNoID)
                                                m_stcBlobPad.intNoID = stcBlobsFeatures.intNoID;
                                        }
                                    }
                                }
                                else
                                {
                                    if (m_intPadLabelDirection == 0)
                                    {
                                        if (m_stcBlobPad.intStartY > stcBlobsFeatures.intStartY)
                                        {
                                            if (m_stcBlobPad.intNoID > stcBlobsFeatures.intNoID)
                                                m_stcBlobPad.intNoID = stcBlobsFeatures.intNoID;
                                        }
                                    }
                                    else
                                    {
                                        if (m_stcBlobPad.intStartY < stcBlobsFeatures.intStartY)
                                        {
                                            if (m_stcBlobPad.intNoID > stcBlobsFeatures.intNoID)
                                                m_stcBlobPad.intNoID = stcBlobsFeatures.intNoID;
                                        }
                                    }
                                }
                            }
                        }

                        for (int j = 0; j < i; j++)
                        {
                            stcBlobsFeatures = (BlobsFeatures)m_arrTemplateBlobPads[j];
                            if (stcBlobsFeatures.intDirection == intDirectionOrder[d])
                            {
                                if (m_stcBlobPad.intNoID <= stcBlobsFeatures.intNoID)
                                {
                                    stcBlobsFeatures.intNoID++;
                                    m_arrTemplateBlobPads.RemoveAt(j);
                                    m_arrTemplateBlobPads.Insert(j, stcBlobsFeatures);
                                }
                            }
                        }
                        intNoID++;
                    }
                    m_arrTemplateBlobPads.RemoveAt(i);
                    m_arrTemplateBlobPads.Insert(i, m_stcBlobPad);
                }
            }
            #endregion

            #region Unknown Direction

            for (int i = 0; i < m_arrTemplateBlobPads.Count; i++)
            {
                BlobsFeatures m_stcBlobPad = (BlobsFeatures)m_arrTemplateBlobPads[i];

                if (!m_stcBlobPad.blnSelected)
                    continue;

                if (m_stcBlobPad.intNoID == 0)
                {
                    m_stcBlobPad.intNoID = intNoID;
                    m_arrTemplateBlobPads.RemoveAt(i);
                    m_arrTemplateBlobPads.Insert(i, m_stcBlobPad);
                    intNoID++;
                }
            }

            #endregion
        }

        private void SortObjectNumber(int intPadPosition)
        {
            int intNoID = 1;
            BlobsFeatures stcBlobsFeatures = new BlobsFeatures();
            int[] intDirectionOrder = { -1, -1, -1, -1, -1, -1, -1, -1, -1 };

            #region Set Direction Sequence
            bool blnTopFound = false;
            bool blnBottomFound = false;
            bool blnLeftFound = false;
            bool blnRightFound = false;
            int intOneColumn = 0;
            int intOneRow = 0;
            for (int i = 0; i < m_arrTemplateBlobPads.Count; i++)
            {
                BlobsFeatures m_stcBlobPad = (BlobsFeatures)m_arrTemplateBlobPads[i];
                if (!m_stcBlobPad.blnSelected)
                    continue;

                if (m_stcBlobPad.intDirection == 1)
                    blnLeftFound = true;

                if (m_stcBlobPad.intDirection == 2)
                    blnRightFound = true;

                if (m_stcBlobPad.intDirection == 4)
                    blnTopFound = true;

                if (m_stcBlobPad.intDirection == 8)
                    blnBottomFound = true;

                if (m_stcBlobPad.intDirection == 7)
                    intOneColumn |= 0x01;

                if (m_stcBlobPad.intDirection == 3)
                    intOneColumn |= 0x02;

                if (m_stcBlobPad.intDirection == 11)
                    intOneColumn |= 0x04;

                if (m_stcBlobPad.intDirection == 13)
                    intOneRow |= 0x01;

                if (m_stcBlobPad.intDirection == 12)
                    intOneRow |= 0x02;

                if (m_stcBlobPad.intDirection == 14)
                    intOneRow |= 0x04;
            }

            int intIndex = 0;
            if ((intPadPosition == 0 && (intOneColumn == 0x05 || intOneColumn == 0x07)) ||
                (intPadPosition > 0 && (intOneColumn > 0)))
            {
                intDirectionOrder[intIndex++] = 7;
                intDirectionOrder[intIndex++] = 3;
                intDirectionOrder[intIndex++] = 11;
            }
            else if ((intPadPosition == 0 && (intOneRow == 0x05 || intOneRow == 0x07)) ||
                (intPadPosition > 0 && (intOneRow > 0)))
            {
                intDirectionOrder[intIndex++] = 13;
                intDirectionOrder[intIndex++] = 12;
                intDirectionOrder[intIndex++] = 14;
            }
            else
            {
                if (blnTopFound)
                {
                    intDirectionOrder[intIndex++] = 5;

                }

                intDirectionOrder[intIndex++] = 4;
                intDirectionOrder[intIndex++] = 6;
                intDirectionOrder[intIndex++] = 2;
                intDirectionOrder[intIndex++] = 10;
                intDirectionOrder[intIndex++] = 8;
                intDirectionOrder[intIndex++] = 9;
                intDirectionOrder[intIndex++] = 1;

                if (!blnTopFound)
                    intDirectionOrder[intIndex++] = 5;

                intDirectionOrder[intIndex] = 0;
            }

            #endregion

            #region Known Direction
            for (int d = 0; d < intDirectionOrder.Length; d++)
            {
                if (intDirectionOrder[d] == -1)
                    continue;

                for (int i = 0; i < m_arrTemplateBlobPads.Count; i++)
                {
                    BlobsFeatures m_stcBlobPad = (BlobsFeatures)m_arrTemplateBlobPads[i];

                    if (!m_stcBlobPad.blnSelected)
                        continue;

                    if (m_stcBlobPad.intDirection == intDirectionOrder[d])
                    {
                        m_stcBlobPad.intNoID = intNoID;

                        for (int j = 0; j < i; j++)
                        {
                            stcBlobsFeatures = (BlobsFeatures)m_arrTemplateBlobPads[j];

                            if (!stcBlobsFeatures.blnSelected)
                                continue;

                            if (stcBlobsFeatures.intDirection == intDirectionOrder[d])
                            {
                                if ((intDirectionOrder[d] == 5) || (intDirectionOrder[d] == 4) || (intDirectionOrder[d] == 6) || (intDirectionOrder[d] == 12) || (intDirectionOrder[d] == 13) || (intDirectionOrder[d] == 14))
                                {
                                    if (m_stcBlobPad.intStartX < stcBlobsFeatures.intStartX)
                                    {
                                        if (m_stcBlobPad.intNoID > stcBlobsFeatures.intNoID)
                                            m_stcBlobPad.intNoID = stcBlobsFeatures.intNoID;
                                    }
                                }
                                else if ((intDirectionOrder[d] == 2) || (intDirectionOrder[d] == 0) || (intDirectionOrder[d] == 7) || (intDirectionOrder[d] == 3) || (intDirectionOrder[d] == 11))
                                {
                                    if (m_stcBlobPad.intStartY < stcBlobsFeatures.intStartY)
                                    {
                                        if (m_stcBlobPad.intNoID > stcBlobsFeatures.intNoID)
                                            m_stcBlobPad.intNoID = stcBlobsFeatures.intNoID;
                                    }
                                }
                                else if ((intDirectionOrder[d] == 10) || (intDirectionOrder[d] == 8) || (intDirectionOrder[d] == 9))
                                {
                                    if (m_stcBlobPad.intStartX > stcBlobsFeatures.intStartX)
                                    {
                                        if (m_stcBlobPad.intNoID > stcBlobsFeatures.intNoID)
                                            m_stcBlobPad.intNoID = stcBlobsFeatures.intNoID;
                                    }
                                }
                                else
                                {
                                    if (m_stcBlobPad.intStartY > stcBlobsFeatures.intStartY)
                                    {
                                        if (m_stcBlobPad.intNoID > stcBlobsFeatures.intNoID)
                                            m_stcBlobPad.intNoID = stcBlobsFeatures.intNoID;
                                    }
                                }
                            }
                        }

                        for (int j = 0; j < i; j++)
                        {
                            stcBlobsFeatures = (BlobsFeatures)m_arrTemplateBlobPads[j];
                            if (stcBlobsFeatures.intDirection == intDirectionOrder[d])
                            {
                                if (m_stcBlobPad.intNoID <= stcBlobsFeatures.intNoID)
                                {
                                    stcBlobsFeatures.intNoID++;
                                    m_arrTemplateBlobPads.RemoveAt(j);
                                    m_arrTemplateBlobPads.Insert(j, stcBlobsFeatures);
                                }
                            }
                        }
                        intNoID++;
                    }
                    m_arrTemplateBlobPads.RemoveAt(i);
                    m_arrTemplateBlobPads.Insert(i, m_stcBlobPad);
                }
            }
            #endregion

            #region Unknown Direction

            for (int i = 0; i < m_arrTemplateBlobPads.Count; i++)
            {
                BlobsFeatures m_stcBlobPad = (BlobsFeatures)m_arrTemplateBlobPads[i];

                if (!m_stcBlobPad.blnSelected)
                    continue;

                if (m_stcBlobPad.intNoID == 0)
                {
                    m_stcBlobPad.intNoID = intNoID;
                    m_arrTemplateBlobPads.RemoveAt(i);
                    m_arrTemplateBlobPads.Insert(i, m_stcBlobPad);
                    intNoID++;
                }
            }

            #endregion
        }

        /// <summary>
        /// Update previous pitch gap tolerance into current template
        /// </summary>
        private void UpdatePreviousPitchToleranceToTemplate()
        {
            PitchGap stcBackupPitchGap = new PitchGap();

            int intSelectedIndex = -1;
            float fDiffSmallestArea = float.MaxValue;
            for (int i = 0; i < m_arrBackupPitchGap.Count; i++)
            {
                stcBackupPitchGap = (PitchGap)m_arrBackupPitchGap[i];

                // Get smallest different pitch size between current and previous learn pitch size.
                if (Math.Abs(m_stcPitchGap.fPitch - ((PitchGap)stcBackupPitchGap).fPitch) < fDiffSmallestArea)
                {
                    fDiffSmallestArea = Math.Abs(m_stcPitchGap.fPitch - ((PitchGap)stcBackupPitchGap).fPitch);
                    intSelectedIndex = i;
                }

            }
            if (intSelectedIndex >= 0)
            {
                m_stcTolePitchGap = (TolerancePitchGap)m_arrTolePitchGap[intSelectedIndex];

                m_stcPitchGap.fMinGap = m_stcTolePitchGap.fMinGap;
                m_stcPitchGap.fMaxGap = m_stcTolePitchGap.fMaxGap;
                m_stcPitchGap.fMinPitch = m_stcTolePitchGap.fMinPitch;
                m_stcPitchGap.fMaxPitch = m_stcTolePitchGap.fMaxPitch;
            }
        }

        //private void UpdatePreviousPitchToleranceToTemplate(int intFromPadIndex)
        //{
        //    PitchGap stcBackupPitchGap = new PitchGap();

        //    int intSelectedIndex = -1;
        //    // 2020 12 17 - since we need to get back pitch gap tolerance setting base on previous template. so just direct get the same FromPadIndex value.
        //    for (int i = 0; i < m_arrBackupPitchGap.Count; i++)
        //    {
        //        if ((m_arrBackupPitchGap[i].intFromPadNo) == intFromPadIndex)
        //        {
        //            intSelectedIndex = i;
        //        }
        //    }

        //    if (intSelectedIndex == -1)
        //    {
        //        float fDiffSmallestArea = float.MaxValue;
        //        for (int i = 0; i < m_arrBackupPitchGap.Count; i++)
        //        {
        //            stcBackupPitchGap = (PitchGap)m_arrBackupPitchGap[i];

        //            // Get smallest different pitch size between current and previous learn pitch size.
        //            if (Math.Abs(m_stcPitchGap.fPitch - ((PitchGap)stcBackupPitchGap).fPitch) < fDiffSmallestArea)
        //            {
        //                fDiffSmallestArea = Math.Abs(m_stcPitchGap.fPitch - ((PitchGap)stcBackupPitchGap).fPitch);
        //                intSelectedIndex = i;
        //            }

        //        }
        //    }

        //    if (intSelectedIndex >= 0)
        //    {
        //        m_stcTolePitchGap = (TolerancePitchGap)m_arrTolePitchGap[intSelectedIndex];

        //        m_stcPitchGap.fMinGap = m_stcTolePitchGap.fMinGap;
        //        m_stcPitchGap.fMaxGap = m_stcTolePitchGap.fMaxGap;
        //        m_stcPitchGap.fMinPitch = m_stcTolePitchGap.fMinPitch;
        //        m_stcPitchGap.fMaxPitch = m_stcTolePitchGap.fMaxPitch;
        //    }
        //}

        private void UpdatePreviousPitchToleranceToTemplate(int intSelectedIndex)
        {
            if (intSelectedIndex >= 0 && intSelectedIndex < m_arrTolePitchGap.Count)
            {
                m_stcTolePitchGap = (TolerancePitchGap)m_arrTolePitchGap[intSelectedIndex];

                m_stcPitchGap.fMinGap = m_stcTolePitchGap.fMinGap;
                m_stcPitchGap.fMaxGap = m_stcTolePitchGap.fMaxGap;
                m_stcPitchGap.fMinPitch = m_stcTolePitchGap.fMinPitch;
                m_stcPitchGap.fMaxPitch = m_stcTolePitchGap.fMaxPitch;
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="objImage1SampleUnitROI">Sample Pad ROI</param>
        /// <returns></returns>
        private bool CheckImage1PadDefect_PadUse(ROI objImage1SampleUnitROI)
        {
            /*
             * 1. objImage1SampleUnitROI = Sample Pad ROI == Sampel Package Size + Pad ROI Tolerance
             * 
             * 
             * 
             * 
             */

            int intInpectMode = 0; //0=Flexi template size, 1= use sample size, 2: Fix template size
            bool blnResult = true;
            bool blnDebugImage = false;

            // Find a suitable Unit Size for both template and sample ROI (Solution: Use Learn Package ROI size)
            int intTestUnitWidth = m_ImgUnitTemplateImage.Width;
            int intTestUnitHeight = m_ImgUnitTemplateImage.Height;
            // Get threshold value
            int intThresholdValue = m_intDarkThresholdValue;
            //if (m_blnWantSeparateBrokenPadThresholdSetting)
            //{
            //    if (m_intImageMerge2ThresholdValue < 0)
            //    {
            //        EBW8 objBW8 = EasyImage.AutoThreshold(objImage1SampleUnitROI.ref_ROI, EThresholdMode.MinResidue);
            //        intThresholdValue = objBW8.Value;
            //    }
            //    else
            //        intThresholdValue = m_intImageMerge2ThresholdValue;
            //}
            //else
            //{
            //    if (m_intDarkThresholdValue < 0)
            //    {
            //        EBW8 objBW8 = EasyImage.AutoThreshold(objImage1SampleUnitROI.ref_ROI, EThresholdMode.MinResidue);
            //        intThresholdValue = objBW8.Value;
            //    }
            //    else
            //        intThresholdValue = m_intDarkThresholdValue;
            //}
            if (!m_blnWantSeparateBrokenPadThresholdSetting)
            {
                if (m_intDarkThresholdValue < 0)
                {
                    EBW8 objBW8 = EasyImage.AutoThreshold(objImage1SampleUnitROI.ref_ROI, EThresholdMode.MinResidue);
                    intThresholdValue = objBW8.Value;
                }
                else
                    intThresholdValue = m_intDarkThresholdValue;
            }
            // ---- Sample -------
            // Get ready sample ROI,
            ROI objThresholdSampleROI = new ROI();
            objThresholdSampleROI.AttachImage(m_objInsPadPkgImage1); // Attach sample ROI to ori size image. m_objInsPadPkgImage1 is a ori size image used to keep the sample image temporary for modification such as double threshold
            objThresholdSampleROI.LoadROISetting(0, 0,
                                                 intTestUnitWidth, intTestUnitHeight);
#if (Debug_2_12 || Release_2_12)
            // Threshold sample unit using Pad Threshold
            if (m_blnWantSeparateBrokenPadThresholdSetting)
                EasyImage.DoubleThreshold(objImage1SampleUnitROI.ref_ROI, objThresholdSampleROI.ref_ROI, (uint)m_intImageMerge2ThresholdLowValue, (uint)m_intImageMerge2ThresholdHighValue, 0, 255, 0);
            else
                EasyImage.Threshold(objImage1SampleUnitROI.ref_ROI, objThresholdSampleROI.ref_ROI, (uint)intThresholdValue);   // error happen when set 255, 0);
            EasyImage.Oper(EArithmeticLogicOperation.Invert, objThresholdSampleROI.ref_ROI, objThresholdSampleROI.ref_ROI);

#elif (DEBUG || RELEASE || RTXRelease || RTXDebug)
            // Threshold sample unit using Pad Threshold
             if (m_blnWantSeparateBrokenPadThresholdSetting)
                EasyImage.DoubleThreshold(objImage1SampleUnitROI.ref_ROI, objThresholdSampleROI.ref_ROI, m_intImageMerge2ThresholdLowValue, m_intImageMerge2ThresholdHighValue, 0, 255, 0);
            else
                EasyImage.Threshold(objImage1SampleUnitROI.ref_ROI, objThresholdSampleROI.ref_ROI, intThresholdValue);   // error happen when set 255, 0);
            EasyImage.Oper(EArithmeticLogicOperation.Invert, objThresholdSampleROI.ref_ROI, objThresholdSampleROI.ref_ROI);

#endif

            if (blnDebugImage)
            {
                objImage1SampleUnitROI.SaveImage("D:\\TS\\01_objImage1SampleUnitROI.bmp"); // debug
                objThresholdSampleROI.SaveImage("D:\\TS\\02_objThresholdSampleROI.bmp");   // debug
            }

            // ---- Template ------
            // Get ready template ROI
            ROI objThresholdTemplateROI = new ROI();
            if ((m_ImgTUnitErodeThresImage.Width != m_ImgUnitTemplateImage.Width) || (m_ImgTUnitErodeThresImage.Height != m_ImgUnitTemplateImage.Height))
                m_ImgTUnitErodeThresImage.SetSize(m_ImgUnitTemplateImage.Width, m_ImgUnitTemplateImage.Height);
#if (Debug_2_12 || Release_2_12)
            if (m_blnWantSeparateBrokenPadThresholdSetting)
                EasyImage.DoubleThreshold(m_ImgUnitTemplateImage, m_ImgTUnitErodeThresImage, (uint)m_intImageMerge2ThresholdLowValue, (uint)m_intImageMerge2ThresholdHighValue, 0, 255, 0);
            else
                EasyImage.Threshold(m_ImgUnitTemplateImage, m_ImgTUnitErodeThresImage, (uint)intThresholdValue);
#elif (DEBUG || RELEASE || RTXRelease || RTXDebug)
            if (m_blnWantSeparateBrokenPadThresholdSetting)
                EasyImage.DoubleThreshold(m_ImgUnitTemplateImage, m_ImgTUnitErodeThresImage, m_intImageMerge2ThresholdLowValue, m_intImageMerge2ThresholdHighValue, 0, 255, 0);
            else
                EasyImage.Threshold(m_ImgUnitTemplateImage, m_ImgTUnitErodeThresImage, intThresholdValue);
#endif

            objThresholdTemplateROI.ref_ROI.Detach();
            objThresholdTemplateROI.ref_ROI.Attach(m_ImgTUnitErodeThresImage);
            objThresholdTemplateROI.LoadROISetting((int)Math.Round((float)m_ImgTUnitErodeThresImage.Width / 2 - (float)intTestUnitWidth / 2, 0, MidpointRounding.AwayFromZero),
                                 (int)Math.Round((float)m_ImgTUnitErodeThresImage.Height / 2 - (float)intTestUnitHeight / 2, 0, MidpointRounding.AwayFromZero),
                                 intTestUnitWidth, intTestUnitHeight);

            if (blnDebugImage)
            {
                m_ImgUnitTemplateImage.Save("D:\\TS\\03_ImgUnitTemplateImage.bmp");                   // debug
                m_ImgTUnitErodeThresImage.Save("D:\\TS\\04_ImgTUnitErodeThresImage.bmp");        // debug
                objThresholdTemplateROI.SaveImage("D:\\TS\\05_objThresholdTemplateROI.bmp");     // debug
            }

            // ---- White Background --------------
            m_ImgWhiteUnitTemplateImage2.SetSize(m_ImgWhiteUnitTemplateImage.Width, m_ImgWhiteUnitTemplateImage.Height);
            m_ImgWhiteUnitTemplateImage.CopyTo(m_ImgWhiteUnitTemplateImage2);
            ROI objWhiteBgTemplateROI = new ROI();
            objWhiteBgTemplateROI.ref_ROI.Detach();
            objWhiteBgTemplateROI.ref_ROI.Attach(m_ImgWhiteUnitTemplateImage2);
            objWhiteBgTemplateROI.LoadROISetting(0, 0, intTestUnitWidth, intTestUnitHeight);

            if (blnDebugImage)
            {
                objWhiteBgTemplateROI.SaveImage("D:\\TS\\06_objWhiteBgTemplateROI.bmp");     // debug
            }

            if (intInpectMode == 0)
            {
                #region InspectMode == 0 ----------------------------------------------------------------------------------
                int[] arrTemplateStartX = new int[m_arrTemplateBlobPads.Count];
                int[] arrTemplateStartY = new int[m_arrTemplateBlobPads.Count];
                int[] arrTemplateEndX = new int[m_arrTemplateBlobPads.Count];
                int[] arrTemplateEndY = new int[m_arrTemplateBlobPads.Count];
                int[] arrSampleStartX = new int[m_arrTemplateBlobPads.Count];
                int[] arrSampleStartY = new int[m_arrTemplateBlobPads.Count];
                int[] arrSampleEndX = new int[m_arrTemplateBlobPads.Count];
                int[] arrSampleEndY = new int[m_arrTemplateBlobPads.Count];
                int[] arrTemplateSampleWidth = new int[m_arrTemplateBlobPads.Count];
                int[] arrTemplateSampleHeight = new int[m_arrTemplateBlobPads.Count];
                int[] arrDifferentSizeX = new int[m_arrTemplateBlobPads.Count]; // Template and sample different size
                int[] arrDifferentSizeY = new int[m_arrTemplateBlobPads.Count]; // Template and sample different size
                int[] arrOffsetStartX = new int[m_arrTemplateBlobPads.Count];
                int[] arrOffsetStartY = new int[m_arrTemplateBlobPads.Count];

                DefinePadSubtractOffset(objThresholdTemplateROI, m_intMPDilateHalfWidth, m_ImgWhiteUnitTemplateImage2.Width -1, m_ImgWhiteUnitTemplateImage2.Height -1,
                    ref arrTemplateStartX, ref arrTemplateStartY, ref arrTemplateEndX, ref arrTemplateEndY,
                    ref arrSampleStartX, ref arrSampleStartY, ref arrSampleEndX, ref arrSampleEndY,
                    ref arrTemplateSampleWidth, ref arrTemplateSampleHeight,
                    ref arrDifferentSizeX, ref arrDifferentSizeY,
                    ref arrOffsetStartX, ref arrOffsetStartY, false);
                
                for (int i = 0; i < m_arrTemplateBlobPads.Count; i++)
                {
                    if (m_arrSampleBlobPads[i].intFailMask != 0)
                        continue;

                    // Get template pad roi
                    ROI objTemplatePadROI = new ROI();
                    objTemplatePadROI.AttachImage(objThresholdTemplateROI);
                    //objTemplatePadROI.LoadROISetting(intStartX, intStartY, intWidth, intHeight);    
                    objTemplatePadROI.LoadROISetting(arrTemplateStartX[i] + (int)(((BlobsFeatures)m_arrTemplateBlobPads[i]).fPadInspectionAreaFromLeft * m_fMMToPixelXValue),
                    arrTemplateStartY[i] + (int)(((BlobsFeatures)m_arrTemplateBlobPads[i]).fPadInspectionAreaFromTop * m_fMMToPixelYValue),
                        arrTemplateSampleWidth[i] - (int)(((BlobsFeatures)m_arrTemplateBlobPads[i]).fPadInspectionAreaFromLeft * m_fMMToPixelXValue) - (int)(((BlobsFeatures)m_arrTemplateBlobPads[i]).fPadInspectionAreaFromRight * m_fMMToPixelXValue),
                        arrTemplateSampleHeight[i] - (int)(((BlobsFeatures)m_arrTemplateBlobPads[i]).fPadInspectionAreaFromTop * m_fMMToPixelYValue) - (int)(((BlobsFeatures)m_arrTemplateBlobPads[i]).fPadInspectionAreaFromBottom * m_fMMToPixelYValue));
                    m_ImgMPUnitTemplateImage.SetSize(objTemplatePadROI.ref_ROIWidth, objTemplatePadROI.ref_ROIHeight);

                    if ((arrDifferentSizeX[i]> 0) || (arrDifferentSizeY[i] > 0))
                    {
                        if ((arrDifferentSizeX[i] > 0 && arrDifferentSizeY[i] < 0) || (arrDifferentSizeY[i] > 0 && arrDifferentSizeX[i] < 0))
                        {
                            if (Math.Abs(arrDifferentSizeY[i]) > Math.Abs(arrDifferentSizeY[i]))
                                arrDifferentSizeY[i] = 0;
                            else
                                arrDifferentSizeX[i] = 0;
                        }
#if (Debug_2_12 || Release_2_12)
                        // Reduce template size follow the m_intMPErodeHalfWidth setting.    
                        EasyImage.ErodeBox(objTemplatePadROI.ref_ROI, m_ImgMPUnitTemplateImage, (uint)Math.Abs(m_intMPErodeHalfWidth), (uint)Math.Abs(m_intMPErodeHalfWidth));
                        EasyImage.Copy(m_ImgMPUnitTemplateImage, objTemplatePadROI.ref_ROI);
#elif (DEBUG || RELEASE || RTXRelease || RTXDebug)
                        // Reduce template size follow the m_intMPErodeHalfWidth setting.    
                        EasyImage.ErodeBox(objTemplatePadROI.ref_ROI, m_ImgMPUnitTemplateImage, Math.Abs(m_intMPErodeHalfWidth), Math.Abs(m_intMPErodeHalfWidth));
                        EasyImage.Copy(m_ImgMPUnitTemplateImage, objTemplatePadROI.ref_ROI);
#endif

                    }
                    else
                    {
                        // ErodeBox will make the pad size smaller.
                        if ((Math.Abs(arrDifferentSizeX[i]) + m_intMPErodeHalfWidth) > 0 || (Math.Abs(arrDifferentSizeY[i]) + m_intMPErodeHalfWidth) > 0)
                        {
#if (Debug_2_12 || Release_2_12)
                            //EasyImage.ErodeBox(objTemplatePadROI.ref_ROI, m_ImgMPUnitTemplateImage, Math.Abs(intDiffSizeWidth) + m_intMPErodeHalfWidth, Math.Abs(intDiffSizeHeight) + m_intMPErodeHalfWidth);
                            EasyImage.ErodeBox(objTemplatePadROI.ref_ROI, m_ImgMPUnitTemplateImage, (uint)m_intMPErodeHalfWidth, (uint)m_intMPErodeHalfWidth);
                            EasyImage.Copy(m_ImgMPUnitTemplateImage, objTemplatePadROI.ref_ROI);
#elif (DEBUG || RELEASE || RTXRelease || RTXDebug)
                            //EasyImage.ErodeBox(objTemplatePadROI.ref_ROI, m_ImgMPUnitTemplateImage, Math.Abs(intDiffSizeWidth) + m_intMPErodeHalfWidth, Math.Abs(intDiffSizeHeight) + m_intMPErodeHalfWidth);
                            EasyImage.ErodeBox(objTemplatePadROI.ref_ROI, m_ImgMPUnitTemplateImage, m_intMPErodeHalfWidth, m_intMPErodeHalfWidth);
                            EasyImage.Copy(m_ImgMPUnitTemplateImage, objTemplatePadROI.ref_ROI);
#endif

                        }
                    }


                    // Get Sample pad ROI
                    ROI objTemplate2PadROI = new ROI();
                    objTemplate2PadROI.ref_ROI.Detach();
                    objTemplate2PadROI.ref_ROI.Attach(m_ImgWhiteUnitTemplateImage2);
                    objTemplate2PadROI.LoadROISetting(arrSampleStartX[i] + (int)(((BlobsFeatures)m_arrTemplateBlobPads[i]).fPadInspectionAreaFromLeft * m_fMMToPixelXValue) + arrOffsetStartX[i],
                      arrSampleStartY[i] + (int)(((BlobsFeatures)m_arrTemplateBlobPads[i]).fPadInspectionAreaFromTop * m_fMMToPixelYValue) + arrOffsetStartY[i],
                      arrTemplateSampleWidth[i] - (int)(((BlobsFeatures)m_arrTemplateBlobPads[i]).fPadInspectionAreaFromLeft * m_fMMToPixelXValue) - (int)(((BlobsFeatures)m_arrTemplateBlobPads[i]).fPadInspectionAreaFromRight * m_fMMToPixelXValue),
                      arrTemplateSampleHeight[i] - (int)(((BlobsFeatures)m_arrTemplateBlobPads[i]).fPadInspectionAreaFromTop * m_fMMToPixelYValue) - (int)(((BlobsFeatures)m_arrTemplateBlobPads[i]).fPadInspectionAreaFromBottom * m_fMMToPixelYValue));
                    if (blnDebugImage)
                    {
                        m_ImgMPUnitTemplateImage.Save("D:\\TS\\08_" + i.ToString() + "_BfMPTemplateImage.bmp");// debug
                        objTemplatePadROI.SaveImage("D:\\TS\\09_" + i.ToString() + "_AfMPTemplateImage.bmp");// debug
                        objTemplate2PadROI.SaveImage("D:\\TS\\10_" + i.ToString() + "_BfSBTemplate2PadImage.bmp");// debug
                    }
                    //objTemplate2PadROI.ref_ROI.SetSize(objTemplatePadROI.ref_ROI.Width, objTemplatePadROI.ref_ROI.Height);

                    if (objTemplatePadROI.ref_ROIWidth != objTemplate2PadROI.ref_ROIWidth)
                    {
                        int intSmallWidth = Math.Min(objTemplatePadROI.ref_ROIWidth, objTemplate2PadROI.ref_ROIWidth);
                        objTemplatePadROI.LoadROISetting(objTemplatePadROI.ref_ROIPositionX, objTemplatePadROI.ref_ROIPositionY, intSmallWidth, objTemplatePadROI.ref_ROIHeight);
                        objTemplate2PadROI.LoadROISetting(objTemplate2PadROI.ref_ROIPositionX, objTemplate2PadROI.ref_ROIPositionY, intSmallWidth, objTemplate2PadROI.ref_ROIHeight);
                    }

                    if (objTemplatePadROI.ref_ROIHeight != objTemplate2PadROI.ref_ROIHeight)
                    {
                        int intSmallHeight = Math.Min(objTemplatePadROI.ref_ROIHeight, objTemplate2PadROI.ref_ROIHeight);
                        objTemplatePadROI.LoadROISetting(objTemplatePadROI.ref_ROIPositionX, objTemplatePadROI.ref_ROIPositionY, objTemplatePadROI.ref_ROIWidth, intSmallHeight);
                        objTemplate2PadROI.LoadROISetting(objTemplate2PadROI.ref_ROIPositionX, objTemplate2PadROI.ref_ROIPositionY, objTemplate2PadROI.ref_ROIWidth, intSmallHeight);
                    }

                    // subtract sample pad roi - template pad roi
                    EasyImage.Oper(EArithmeticLogicOperation.Subtract, objTemplate2PadROI.ref_ROI, objTemplatePadROI.ref_ROI, objTemplate2PadROI.ref_ROI);

                    if (blnDebugImage)
                        objTemplate2PadROI.SaveImage("D:\\TS\\11_" + i.ToString() + "_AfSBTemplate2PadImage.bmp");// debug

                    objTemplate2PadROI.Dispose();
                    objTemplatePadROI.Dispose();
                }

                #endregion ------------------------------------------------------------------------------------------------
            }

            // Subtract sample ROI - template ROI
            if (blnDebugImage)
            {
                objThresholdSampleROI.SaveImage("D:\\TS\\12_BfSBSampleROI.bmp");// debug   // sample: Background white color, pad black color, defect on pad is white color
                objWhiteBgTemplateROI.SaveImage("D:\\TS\\13_objTemplate2ROI.bmp");// debug // template: Background white color, pad black color.
            }

            //objWhiteBgTemplateROI.ref_ROI.SetSize(objThresholdSampleROI.ref_ROI.Width, objThresholdSampleROI.ref_ROI.Height);

            if (objThresholdSampleROI.ref_ROIWidth != objWhiteBgTemplateROI.ref_ROIWidth)
            {
                int intSmallWidth = Math.Min(objThresholdSampleROI.ref_ROIWidth, objWhiteBgTemplateROI.ref_ROIWidth);
                objThresholdSampleROI.LoadROISetting(objThresholdSampleROI.ref_ROIPositionX, objThresholdSampleROI.ref_ROIPositionY, intSmallWidth, objThresholdSampleROI.ref_ROIHeight);
                objWhiteBgTemplateROI.LoadROISetting(objWhiteBgTemplateROI.ref_ROIPositionX, objWhiteBgTemplateROI.ref_ROIPositionY, intSmallWidth, objWhiteBgTemplateROI.ref_ROIHeight);
            }

            if (objThresholdSampleROI.ref_ROIHeight != objWhiteBgTemplateROI.ref_ROIHeight)
            {
                int intSmallHeight = Math.Min(objThresholdSampleROI.ref_ROIHeight, objWhiteBgTemplateROI.ref_ROIHeight);
                objThresholdSampleROI.LoadROISetting(objThresholdSampleROI.ref_ROIPositionX, objThresholdSampleROI.ref_ROIPositionY, objThresholdSampleROI.ref_ROIWidth, intSmallHeight);
                objWhiteBgTemplateROI.LoadROISetting(objWhiteBgTemplateROI.ref_ROIPositionX, objWhiteBgTemplateROI.ref_ROIPositionY, objWhiteBgTemplateROI.ref_ROIWidth, intSmallHeight);
            }

            EasyImage.Oper(EArithmeticLogicOperation.Subtract, objThresholdSampleROI.ref_ROI, objWhiteBgTemplateROI.ref_ROI, objThresholdSampleROI.ref_ROI);

            if (blnDebugImage)
                objThresholdSampleROI.SaveImage("D:\\TS\\14_AfSBSampleROI.bmp");// debug

            // Build blobs object for subtract image
            m_objImage1PadEBlobs.BuildObjects_Filter_GetElement(objThresholdSampleROI, false, true, 0, 125, (int)m_fBlobsMinArea, 999999, false, 0x0F);

            if (m_objImage1PadEBlobs.ref_intNumSelectedObject > 0)
            {
                float fGravityCenterX = 0, fGravityCenterY = 0, fCenterX = 0, fCenterY = 0, fWidth = 0, fHeight = 0;
                float fStartX = 0, fStartY = 0, fEndX = 0, fEndY = 0;
                int intArea = 0;

                for (int i = 0; i < m_objImage1PadEBlobs.ref_intNumSelectedObject; i++)
                {
                    fGravityCenterX = m_objImage1PadEBlobs.ref_arrGravityCenterX[i];
                    fGravityCenterY = m_objImage1PadEBlobs.ref_arrGravityCenterY[i];
                    fCenterX = m_objImage1PadEBlobs.ref_arrLimitCenterX[i];
                    fCenterY = m_objImage1PadEBlobs.ref_arrLimitCenterY[i];
                    fWidth = m_objImage1PadEBlobs.ref_arrWidth[i];
                    fHeight = m_objImage1PadEBlobs.ref_arrHeight[i];
                    intArea = m_objImage1PadEBlobs.ref_arrArea[i];

                    // Get object start point and end point
                    fStartX = fCenterX - (fWidth / 2);
                    fStartY = fCenterY - (fHeight / 2);
                    fEndX = fCenterX + (fWidth / 2);
                    fEndY = fCenterY + (fHeight / 2);

                    int intMatch = Match1TemplateObjects(fStartX, fStartY, fEndX, fEndY, fGravityCenterX, fGravityCenterY);

                    if (intMatch >= 0)
                    {
                        if (m_blnWantCheckBrokenPadLength || m_blnWantCheckBrokenPadArea)
                        {
                            if (m_arrSamplePadBroken[intMatch].fAreaMM == 0)
                            {
                                m_arrSamplePadBroken[intMatch].fAreaMM = intArea * m_fAreaMMPerPixel;  // Change unit pixel to mm
                                m_arrSamplePadBroken[intMatch].fWidthMM = fWidth * m_fMMPerPixelX;  // Change unit pixel to mm
                                m_arrSamplePadBroken[intMatch].fHeightMM = fHeight * m_fMMPerPixelY;  // Change unit pixel to mm

                                m_arrSamplePadBroken[intMatch].fWidth = fWidth;
                                m_arrSamplePadBroken[intMatch].fHeight = fHeight;
                                m_arrSamplePadBroken[intMatch].fStartX = fStartX;
                                m_arrSamplePadBroken[intMatch].fStartY = fStartY;
                                m_arrSamplePadBroken[intMatch].fEndX = fEndX;
                                m_arrSamplePadBroken[intMatch].fEndY = fEndY;
                            }
                        }

                        if (m_blnWantCheckBrokenPadLength)
                        {
                            if ((m_arrSampleBlobPads[intMatch].intFailMask & ~0x08) == 0) // Make sure the sample pad has not other failure.
                            {
                                if (((BlobsFeatures)m_arrTemplateBlobPads[intMatch]).blnEnable)
                                {
                                    float fWidthMM = fWidth / m_fMMToPixelXValue;
                                    float fHeightMM = fHeight / m_fMMToPixelYValue; // 11-04-2019 ZJYEOH : Changed m_fMMToPixelXValue to m_fMMToPixelYValue
                                    float fBrokenAreaMM2 = (float)intArea / m_fMMtoPixelAreaValue;

                                    bool blnResult1 = true;
                                    if (m_blnWantUseGroupToleranceSetting)
                                    {
                                        int intGroupNo = ((BlobsFeatures)m_arrTemplateBlobPads[intMatch]).intGroupID;
                                        if ((fWidthMM > ((BlobsFeatures)m_arrGroupTemplateBlobPads[intGroupNo]).fMaxBrokenLength) ||
                                            (fHeightMM > ((BlobsFeatures)m_arrGroupTemplateBlobPads[intGroupNo]).fMaxBrokenLength))
                                        {
                                            blnResult1 = false;
                                        }
                                    }
                                    else
                                    {
                                        if ((fWidthMM > ((BlobsFeatures)m_arrTemplateBlobPads[intMatch]).fMaxBrokenLength) ||
                                            (fHeightMM > ((BlobsFeatures)m_arrTemplateBlobPads[intMatch]).fMaxBrokenLength))
                                        {
                                            blnResult1 = false;
                                        }
                                    }

                                    if (!blnResult1)
                                    {
                                        if (Math.Max(m_arrSamplePadBroken[intMatch].fWidthMM, m_arrSamplePadBroken[intMatch].fHeightMM) <= Math.Max(fWidthMM, fHeightMM))
                                        {
                                            m_arrSamplePadBroken[intMatch].fAreaMM = intArea * m_fAreaMMPerPixel;  // Change unit pixel to mm
                                            m_arrSamplePadBroken[intMatch].fWidthMM = fWidth * m_fMMPerPixelX;  // Change unit pixel to mm
                                            m_arrSamplePadBroken[intMatch].fHeightMM = fHeight * m_fMMPerPixelY;  // Change unit pixel to mm

                                            m_arrSamplePadBroken[intMatch].fWidth = fWidth;
                                            m_arrSamplePadBroken[intMatch].fHeight = fHeight;
                                            m_arrSamplePadBroken[intMatch].fStartX = fStartX;
                                            m_arrSamplePadBroken[intMatch].fStartY = fStartY;
                                            m_arrSamplePadBroken[intMatch].fEndX = fEndX;
                                            m_arrSamplePadBroken[intMatch].fEndY = fEndY;
                                        }

                                        m_blnFailBrokenLength = true;
                                        m_arrSampleBlobPads[intMatch].intFailMask |= 0x08;
                                        m_intFailResultMask |= 0x08;

                                        float fMaxLength = Math.Max(fWidthMM, fHeightMM);

                                        // Collect scratch min and max area for display error message
                                        if ((m_fResultBrokenMinArea == -1) || (fMaxLength < m_fResultBrokenMinArea))
                                        {
                                            m_fResultBrokenMinArea = fMaxLength;
                                        }

                                        if ((m_fResultBrokenMaxArea == -1) || (fMaxLength > m_fResultBrokenMaxArea))
                                        {
                                            m_fResultBrokenMaxArea = fMaxLength;
                                        }

                                        Defect objDefect = new Defect();
                                        objDefect.ref_strName = "Broken Pad";
                                        objDefect.ref_intFailMask |= 0x08;
                                        objDefect.ref_fArea = Convert.ToSingle(intArea);
                                        objDefect.ref_fCenterX = objImage1SampleUnitROI.ref_ROITotalX + fCenterX;  // objThresholdSampleROI.ref_ROITotalX + fCenterX;
                                        objDefect.ref_fCenterY = objImage1SampleUnitROI.ref_ROITotalY + fCenterY;  // objThresholdSampleROI.ref_ROITotalY + fCenterY;
                                        objDefect.ref_fStartX = fStartX;
                                        objDefect.ref_fStartY = fStartY;
                                        objDefect.ref_fEndX = fEndX;
                                        objDefect.ref_fEndY = fEndY;
                                        objDefect.ref_fWidth = fWidth;
                                        objDefect.ref_fHeight = fHeight;
                                        objDefect.ref_fWidthInMM = fWidthMM;
                                        objDefect.ref_fHeightInMM = fHeightMM;
                                        objDefect.ref_fAreaInMM2 = fBrokenAreaMM2;

                                        if (fWidthMM > ((BlobsFeatures)m_arrTemplateBlobPads[intMatch]).fMaxBrokenLength)
                                            objDefect.ref_intFailCriteria |= 0x01;

                                        if (fHeightMM > ((BlobsFeatures)m_arrTemplateBlobPads[intMatch]).fMaxBrokenLength)
                                            objDefect.ref_intFailCriteria |= 0x02;

                                        m_arrPadDefectList.Add(objDefect);

                                        if (blnResult)
                                            blnResult = false;
                                    }
                                }
                            }
                        }

                        if (m_blnWantCheckBrokenPadArea && !m_blnFailBrokenLength)
                        {
                            if ((m_arrSampleBlobPads[intMatch].intFailMask & ~0x08) == 0) // Make sure the sample pad has not other failure.
                            {
                                if (((BlobsFeatures)m_arrTemplateBlobPads[intMatch]).blnEnable)
                                {
                                    float fWidthMM = fWidth / m_fMMToPixelXValue;
                                    float fHeightMM = fHeight / m_fMMToPixelYValue; // 11-04-2019 ZJYEOH : Changed m_fMMToPixelXValue to m_fMMToPixelYValue
                                    float fBrokenAreaMM2 = (float)intArea / m_fMMtoPixelAreaValue;

                                    bool blnResult1 = true;
                                    if (m_blnWantUseGroupToleranceSetting)
                                    {
                                        int intGroupNo = ((BlobsFeatures)m_arrTemplateBlobPads[intMatch]).intGroupID;
                                        if (fBrokenAreaMM2 > ((BlobsFeatures)m_arrGroupTemplateBlobPads[intGroupNo]).fMaxBroken)
                                        {
                                            blnResult1 = false;
                                        }

                                    }
                                    else
                                    {
                                        if (fBrokenAreaMM2 > ((BlobsFeatures)m_arrTemplateBlobPads[intMatch]).fMaxBroken)
                                        {
                                            blnResult1 = false;
                                        }
                                    }

                                    if (!blnResult1)
                                    {
                                        m_blnFailBrokenArea = true;
                                        m_arrSampleBlobPads[intMatch].intFailMask |= 0x08;
                                        m_intFailResultMask |= 0x08;

                                        // Collect scratch min and max area for display error message
                                        if ((m_fResultBrokenMinArea == -1) || (fBrokenAreaMM2 < m_fResultBrokenMinArea))
                                        {
                                            m_fResultBrokenMinArea = fBrokenAreaMM2;
                                        }

                                        if ((m_fResultBrokenMaxArea == -1) || (fBrokenAreaMM2 > m_fResultBrokenMaxArea))
                                        {
                                            m_fResultBrokenMaxArea = fBrokenAreaMM2;
                                        }

                                        Defect objDefect = new Defect();
                                        objDefect.ref_strName = "Broken Pad";
                                        objDefect.ref_intFailMask |= 0x08;
                                        objDefect.ref_fArea = Convert.ToSingle(intArea);
                                        objDefect.ref_fCenterX = objImage1SampleUnitROI.ref_ROITotalX + fCenterX;  // objThresholdSampleROI.ref_ROITotalX + fCenterX;
                                        objDefect.ref_fCenterY = objImage1SampleUnitROI.ref_ROITotalY + fCenterY;  // objThresholdSampleROI.ref_ROITotalY + fCenterY;
                                        objDefect.ref_fStartX = fStartX;
                                        objDefect.ref_fStartY = fStartY;
                                        objDefect.ref_fEndX = fEndX;
                                        objDefect.ref_fEndY = fEndY;
                                        objDefect.ref_fWidth = fWidth;
                                        objDefect.ref_fHeight = fHeight;
                                        objDefect.ref_fWidthInMM = fWidthMM;
                                        objDefect.ref_fHeightInMM = fHeightMM;
                                        objDefect.ref_fAreaInMM2 = fBrokenAreaMM2;
                                        objDefect.ref_intFailCriteria |= 0x04;

                                        m_arrPadDefectList.Add(objDefect);

                                        if (blnResult)
                                            blnResult = false;

                                    }
                                }
                            }
                        }
                    }
                }
            }

            objThresholdSampleROI.Dispose();
            objThresholdTemplateROI.Dispose();
            objWhiteBgTemplateROI.Dispose();
            return blnResult;
        }
        private bool CheckColorDefect(CROI objSampleUnitROI, List<CImageDrawing> arrColorImages, ROI objSampleROI)
        {
            if (m_arrDefectColorThresName.Count == 0)
                return true;

            if ((((m_intFailColorOptionMask & 0x03) == 0) && m_arrDefectColorThresName.Count == 1) &&
                (((m_intFailColorOptionMask & 0x0C) == 0) && m_arrDefectColorThresName.Count == 2) &&
                (((m_intFailColorOptionMask & 0x30) == 0) && m_arrDefectColorThresName.Count == 3) &&
                (((m_intFailColorOptionMask & 0xC0) == 0) && m_arrDefectColorThresName.Count == 4) &&
                (((m_intFailColorOptionMask & 0x300) == 0) && m_arrDefectColorThresName.Count == 5))
                return true;

            bool blnResult = true;
            bool blnDebugImage = false;

            //float fPkgOffsetX = (objSampleUnitROI.ref_ROIWidth - Math.Max(GetResultUpWidth_RectGauge4L(0), GetResultDownWidth_RectGauge4L(0))) / 2;
            //float fPkgOffsetY = (objSampleUnitROI.ref_ROIHeight - Math.Max(GetResultLeftHeight_RectGauge4L(0), GetResultRightHeight_RectGauge4L(0))) / 2;

            int intStartPixelFromEdgeX = 0;// (int)Math.Round(fPkgOffsetX - m_intPadROIStartPixelFromLeft, 0, MidpointRounding.AwayFromZero); //m_fPkgStartPixelFromLeft
            int intStartPixelFromEdgeY = 0;// (int)Math.Round(fPkgOffsetY - m_intPadROIStartPixelFromTop, 0, MidpointRounding.AwayFromZero); //m_fPkgStartPixelFromEdge
            //int intStartPixelFromEdgeX2 = (int)Math.Round(fPkgOffsetX + m_intPadROIStartPixelFromRight, 0, MidpointRounding.AwayFromZero); //m_fPkgStartPixelFromRight
            //int intStartPixelFromEdgeY2 = (int)Math.Round(fPkgOffsetY + m_intPadROIStartPixelFromBottom, 0, MidpointRounding.AwayFromZero); //m_fPkgStartPixelFromBottom

            ROI objThresholdSampleROI = new ROI();
            objThresholdSampleROI.AttachImage(m_objInsPadPkgImage1); // Attach sample ROI to ori size image. m_objInsPadPkgImage1 is a ori size image used to keep the sample image temporary for modification such as double threshold
            objThresholdSampleROI.LoadROISetting(objSampleUnitROI.ref_ROIPositionX, objSampleUnitROI.ref_ROIPositionY, objSampleUnitROI.ref_ROIWidth, objSampleUnitROI.ref_ROIHeight);

            if (blnDebugImage)
            {
                objSampleUnitROI.SaveImage("D:\\TS\\1.objSampleUnitROI.bmp");
            }
          
            for (int intColorThresIndex = 0; intColorThresIndex < m_arrDefectColor.Count; intColorThresIndex++)
            {
                if (intColorThresIndex == 0 && ((m_intFailColorOptionMask & 0x03) == 0))
                    continue;
                else if (intColorThresIndex == 1 && ((m_intFailColorOptionMask & 0x0C) == 0))
                    continue;
                else if (intColorThresIndex == 2 && ((m_intFailColorOptionMask & 0x30) == 0))
                    continue;
                else if (intColorThresIndex == 3 && ((m_intFailColorOptionMask & 0xC0) == 0))
                    continue;
                else if (intColorThresIndex == 4 && ((m_intFailColorOptionMask & 0x300) == 0))
                    continue;

                if (!blnResult)
                    break;

                objSampleUnitROI.AttachImage(arrColorImages[CImageDrawing.GetArrayImageIndex(m_arrDefectImageNo[intColorThresIndex], m_intVisionIndex)]);

                if (blnDebugImage)
                {
                    objSampleUnitROI.SaveImage("D:\\TS\\1_1.objSampleUnitROI2.bmp");
                }

                bool blnCheckLength = false;
                bool blnCheckArea = false;
                int intFailMask = 0;
                if (intColorThresIndex == 0)
                {
                    intFailMask = 0x01;
                    if ((m_intFailColorOptionMask & 0x01) > 0)
                        blnCheckLength = true;
                    if ((m_intFailColorOptionMask & 0x02) > 0)
                        blnCheckArea = true;
                }
                else if (intColorThresIndex == 1)
                {
                    intFailMask = 0x02;
                    if ((m_intFailColorOptionMask & 0x04) > 0)
                        blnCheckLength = true;
                    if ((m_intFailColorOptionMask & 0x08) > 0)
                        blnCheckArea = true;
                }
                else if (intColorThresIndex == 2)
                {
                    intFailMask = 0x04;
                    if ((m_intFailColorOptionMask & 0x10) > 0)
                        blnCheckLength = true;
                    if ((m_intFailColorOptionMask & 0x20) > 0)
                        blnCheckArea = true;
                }
                else if (intColorThresIndex == 3)
                {
                    intFailMask = 0x08;
                    if ((m_intFailColorOptionMask & 0x40) > 0)
                        blnCheckLength = true;
                    if ((m_intFailColorOptionMask & 0x80) > 0)
                        blnCheckArea = true;
                }
                else if (intColorThresIndex == 4)
                {
                    intFailMask = 0x10;
                    if ((m_intFailColorOptionMask & 0x100) > 0)
                        blnCheckLength = true;
                    if ((m_intFailColorOptionMask & 0x200) > 0)
                        blnCheckArea = true;
                }

                int intSelectedObjectNum = 0;
                // Get color threshold min max value
                m_objColorBlobs.ref_C24LowColorThreshold = ColorProcessing.CalculateMinColor(m_arrDefectColor[intColorThresIndex], m_arrDefectColorTolerance[intColorThresIndex]).ref_Color24;
                m_objColorBlobs.ref_C24HighColorThreshold = ColorProcessing.CalculateMaxColor(m_arrDefectColor[intColorThresIndex], m_arrDefectColorTolerance[intColorThresIndex]).ref_Color24;

                // Threshold color image 
                if (m_arrDefectColorSystem[intColorThresIndex] == 0)
                    EasyImage.Threshold(objSampleUnitROI.ref_CROI, objThresholdSampleROI.ref_ROI, m_objColorBlobs.ref_C24LowColorThreshold, m_objColorBlobs.ref_C24HighColorThreshold, m_objColorLookupLSH);
                else if (m_arrDefectColorSystem[intColorThresIndex] == 1)
                    EasyImage.Threshold(objSampleUnitROI.ref_CROI, objThresholdSampleROI.ref_ROI, m_objColorBlobs.ref_C24LowColorThreshold, m_objColorBlobs.ref_C24HighColorThreshold, m_objColorLookupRGB);
                else
                {
                    EasyColor.GetComponent(objSampleUnitROI.ref_CROI, objThresholdSampleROI.ref_ROI, 1, m_objColorLookupYSH);
                    if (blnDebugImage)
                        objThresholdSampleROI.SaveImage("D:\\TS\\1_2.SaturationImg" + intColorThresIndex + ".bmp");
#if (Debug_2_12 || Release_2_12)
                    EasyImage.Threshold(objThresholdSampleROI.ref_ROI, objThresholdSampleROI.ref_ROI, (uint)m_arrDefectColor[intColorThresIndex][0]);
#elif (DEBUG || RELEASE || RTXRelease || RTXDebug)
                    EasyImage.Threshold(objThresholdSampleROI.ref_ROI, objThresholdSampleROI.ref_ROI, m_arrDefectColor[intColorThresIndex][0]);
#endif
                }

                if (blnDebugImage)
                    objThresholdSampleROI.SaveImage("D:\\TS\\2.objThresholdSampleROI" + intColorThresIndex + ".bmp");

                SubtractColorDontCareImage(objSampleROI, objThresholdSampleROI, m_arrDefectDontCareMode[intColorThresIndex], m_arrPadColorDontCareImage[intColorThresIndex]);

                objThresholdSampleROI.LoadROISetting(objSampleUnitROI.ref_ROITotalX + GetColorDefectInspection_Left(intColorThresIndex),
                    objSampleUnitROI.ref_ROITotalY + GetColorDefectInspection_Top(intColorThresIndex),
                    objSampleUnitROI.ref_ROIWidth - GetColorDefectInspection_Left(intColorThresIndex) - GetColorDefectInspection_Right(intColorThresIndex),
                    objSampleUnitROI.ref_ROIHeight - GetColorDefectInspection_Top(intColorThresIndex) - GetColorDefectInspection_Bottom(intColorThresIndex));

                if (blnDebugImage)
                    objThresholdSampleROI.SaveImage("D:\\TS\\3.objThresholdSampleROI" + intColorThresIndex + ".bmp");

                intSelectedObjectNum = m_objColorBlobs.BuildObjects_Filter_GetElement(objThresholdSampleROI, !m_blnWhiteOnBlack, true, 0, -4,
                m_arrDefectColorMinArea[intColorThresIndex], objSampleUnitROI.ref_ROIWidth * objSampleUnitROI.ref_ROIHeight, false, 0xFF);

                if (intSelectedObjectNum == 0 && m_arrDefectType[intColorThresIndex] == 1)
                {
                    ColorDefect objDefect = new ColorDefect();

                    objDefect.ref_strName = m_arrDefectColorThresName[intColorThresIndex];
                    objDefect.ref_intFailMask = intFailMask;
                    objDefect.ref_fCenterX = -1;
                    objDefect.ref_fCenterY = -1;
                    objDefect.ref_fStartX = -1;
                    objDefect.ref_fStartY = -1;
                    objDefect.ref_fEndX = -1;
                    objDefect.ref_fEndY = -1;
                    objDefect.ref_fWidth = -1;
                    objDefect.ref_fHeight = -1;
                    objDefect.ref_fArea = -1;
                    objDefect.ref_fWidthInMM = -1;
                    objDefect.ref_fHeightInMM = -1;
                    objDefect.ref_fAreaInMM2 = -1;
                    objDefect.ref_intImageNo = m_arrDefectImageNo[intColorThresIndex] + 1;

                    objDefect.ref_fAreaFailValue = -1;
                    objDefect.ref_intFailCriteria |= 0x10;

                    m_arrColorDefectList.Add(objDefect);

                    m_intFailColorResultMask |= intFailMask;

                    blnResult = false;
                }

                bool blnOverallResult = true;
                if (intSelectedObjectNum > 0)
                {
                    float fCenterX = 0, fCenterY = 0, fWidth = 0, fHeight = 0;
                    float fStartX, fStartY, fEndX, fEndY, fAngle = 0;
                    int intArea = 0;
                    float fWidthMM, fHeightMM, fAreaInMM;
                    int intFailCount = 0;

                    int intTotalArea = 0;
                    for (int i = 0; i < intSelectedObjectNum; i++)
                    {
                        intArea = m_objColorBlobs.ref_arrArea[i];

                        if (m_objColorBlobs.ref_arrRectWidth[i] < m_objColorBlobs.ref_arrRectHeight[i])
                        {
                            fWidth = m_objColorBlobs.ref_arrRectWidth[i];
                            fHeight = m_objColorBlobs.ref_arrRectHeight[i];

                            fAngle = m_objColorBlobs.ref_arrRectAngle[i];


                            if (fAngle < 0)
                                fAngle = -Math.Abs(fAngle);
                            else
                                fAngle = -fAngle;
                        }
                        else
                        {
                            fWidth = m_objColorBlobs.ref_arrRectHeight[i];
                            fHeight = m_objColorBlobs.ref_arrRectWidth[i];

                            fAngle = m_objColorBlobs.ref_arrRectAngle[i];


                            if (fAngle < 0)
                                fAngle = Math.Abs(fAngle);
                            else
                                fAngle = 90 - (fAngle);
                        }
                        fCenterX = m_objColorBlobs.ref_arrRectLimitCenterX[i];
                        fCenterY = m_objColorBlobs.ref_arrRectLimitCenterY[i];

                        intTotalArea += intArea;
                        fCenterX += intStartPixelFromEdgeX;
                        fCenterY += intStartPixelFromEdgeY;
                        fStartX = (float)Math.Floor(fCenterX - (fWidth / 2));
                        fStartY = (float)Math.Floor(fCenterY - (fHeight / 2));
                        fEndX = (float)Math.Ceiling(fCenterX + (fWidth / 2));
                        fEndY = (float)Math.Ceiling(fCenterY + (fHeight / 2));

                        // convert width and height to mm
                        fWidthMM = fWidth / m_fMMToPixelXValue;
                        fHeightMM = fHeight / m_fMMToPixelYValue; // 11-04-2019 ZJYEOH : Changed m_fMMToPixelXValue to m_fMMToPixelYValue
                        fAreaInMM = intArea / m_fMMToPixelXValue / m_fMMToPixelYValue;

                        {
                            intFailCount++;

                            ColorDefect objDefect = new ColorDefect();

                            objDefect.ref_strName = m_arrDefectColorThresName[intColorThresIndex];
                            objDefect.ref_intFailMask = intFailMask;
                            objDefect.ref_fCenterX = objThresholdSampleROI.ref_ROITotalX + fCenterX;
                            objDefect.ref_fCenterY = objThresholdSampleROI.ref_ROITotalY + fCenterY;
                            objDefect.ref_fStartX = objThresholdSampleROI.ref_ROITotalX + fStartX;
                            objDefect.ref_fStartY = objThresholdSampleROI.ref_ROITotalY + fStartY;
                            objDefect.ref_fEndX = objThresholdSampleROI.ref_ROITotalX + fEndX;
                            objDefect.ref_fEndY = objThresholdSampleROI.ref_ROITotalY + fEndY;
                            objDefect.ref_fWidth = fWidth;
                            objDefect.ref_fHeight = fHeight;
                            objDefect.ref_fArea = intArea;
                            objDefect.ref_fAngle = fAngle;
                            objDefect.ref_fWidthInMM = fWidthMM;
                            objDefect.ref_fHeightInMM = fHeightMM;
                            objDefect.ref_fAreaInMM2 = fAreaInMM;
                            objDefect.ref_intImageNo = m_arrDefectImageNo[intColorThresIndex] + 1;

                            if (blnCheckLength)
                            {
                                if (m_arrDefectColorInspectionFailCondition[intColorThresIndex] == 0)
                                {
                                    if (fWidthMM > m_arrDefectColorInspectionWidth[intColorThresIndex])
                                    {
                                        m_intFailColorResultMask |= intFailMask;

                                        blnOverallResult = false;
                                        objDefect.ref_fWidthFailValue = fWidthMM;
                                        objDefect.ref_intFailCriteria |= 0x01;
                                        blnResult = false;
                                    }
                                    if (fHeightMM > m_arrDefectColorInspectionLength[intColorThresIndex])
                                    {
                                        m_intFailColorResultMask |= intFailMask;

                                        blnOverallResult = false;
                                        objDefect.ref_fHeightFailValue = fHeightMM;
                                        objDefect.ref_intFailCriteria |= 0x02;
                                        blnResult = false;
                                    }
                                }
                                else
                                {
                                    if ((fWidthMM > m_arrDefectColorInspectionWidth[intColorThresIndex]) && (fHeightMM > m_arrDefectColorInspectionLength[intColorThresIndex]))
                                    {
                                        m_intFailColorResultMask |= intFailMask;

                                        blnOverallResult = false;
                                        objDefect.ref_fWidthFailValue = fWidthMM;
                                        objDefect.ref_fHeightFailValue = fHeightMM;
                                        objDefect.ref_intFailCriteria |= 0x01;
                                        objDefect.ref_intFailCriteria |= 0x02;
                                        blnResult = false;
                                    }
                                }
                            }

                            if (blnCheckArea)
                            {
                                if (/*fAreaInMM < m_arrDefectColorInspectionMinArea[intColorThresIndex] ||*/ fAreaInMM > m_arrDefectColorInspectionMaxArea[intColorThresIndex])
                                {
                                    m_intFailColorResultMask |= intFailMask;

                                    blnOverallResult = false;
                                    objDefect.ref_fAreaFailValue = fAreaInMM;
                                    objDefect.ref_intFailCriteria |= 0x04;
                                    blnResult = false;
                                }
                            }

                            m_arrColorDefectList.Add(objDefect);
                        }

                    }

                    if (blnCheckArea)
                    {
                        fAreaInMM = intTotalArea / m_fMMToPixelXValue / m_fMMToPixelYValue;

                        if (fAreaInMM > m_arrDefectColorInspectionTotalArea[intColorThresIndex])
                        {
                            ColorDefect objDefect = new ColorDefect();

                            objDefect.ref_strName = m_arrDefectColorThresName[intColorThresIndex];
                            objDefect.ref_intFailMask = intFailMask;
                            objDefect.ref_fCenterX = -1;
                            objDefect.ref_fCenterY = -1;
                            objDefect.ref_fStartX = -1;
                            objDefect.ref_fStartY = -1;
                            objDefect.ref_fEndX = -1;
                            objDefect.ref_fEndY = -1;
                            objDefect.ref_fWidth = -1;
                            objDefect.ref_fHeight = -1;
                            objDefect.ref_fArea = intTotalArea;
                            objDefect.ref_fWidthInMM = -1;
                            objDefect.ref_fHeightInMM = -1;
                            objDefect.ref_fAreaInMM2 = fAreaInMM;
                            objDefect.ref_intImageNo = m_arrDefectImageNo[intColorThresIndex] + 1;
                            objDefect.ref_blnFailTotalArea = true;
                            blnOverallResult = false;
                            objDefect.ref_fAreaFailValue = fAreaInMM;
                            objDefect.ref_intFailCriteria |= 0x08;

                            m_arrColorDefectList.Add(objDefect);

                            m_intFailColorResultMask |= intFailMask;

                            //for (int b = 0; b < m_arrColorDefectList.Count; b++)
                            //{
                            //    if (((ColorDefect)m_arrColorDefectList[b]).ref_strName == m_arrDefectColorThresName[intColorThresIndex])
                            //    {
                            //        if (!((ColorDefect)m_arrColorDefectList[b]).ref_blnFailTotalArea)
                            //        {
                            //            ColorDefect objDefect2 = m_arrColorDefectList[b];
                            //            objDefect2.ref_blnFailTotalArea = true;
                            //            m_arrColorDefectList.RemoveAt(b);
                            //            m_arrColorDefectList.Insert(b, objDefect2);
                            //        }
                            //    }
                            //}

                            blnResult = false;
                        }
                        
                    }
                }
            }
            objThresholdSampleROI.Dispose();
            return blnResult;
        }
        private bool CheckColorDefect_CombineSameName(CROI objSampleUnitROI, List<CImageDrawing> arrColorImages, ROI objSampleROI, ImageDrawing objBlackImage)
        {
            if (m_arrDefectColorThresName.Count == 0)
                return true;

            if ((((m_intFailColorOptionMask & 0x03) == 0) && m_arrDefectColorThresName.Count == 1) &&
                (((m_intFailColorOptionMask & 0x0C) == 0) && m_arrDefectColorThresName.Count == 2) &&
                (((m_intFailColorOptionMask & 0x30) == 0) && m_arrDefectColorThresName.Count == 3) &&
                (((m_intFailColorOptionMask & 0xC0) == 0) && m_arrDefectColorThresName.Count == 4) &&
                (((m_intFailColorOptionMask & 0x300) == 0) && m_arrDefectColorThresName.Count == 5))
                return true;

            bool blnResult = true;
            bool blnDebugImage = false;

            //float fPkgOffsetX = (objSampleUnitROI.ref_ROIWidth - Math.Max(GetResultUpWidth_RectGauge4L(0), GetResultDownWidth_RectGauge4L(0))) / 2;
            //float fPkgOffsetY = (objSampleUnitROI.ref_ROIHeight - Math.Max(GetResultLeftHeight_RectGauge4L(0), GetResultRightHeight_RectGauge4L(0))) / 2;

            int intStartPixelFromEdgeX = 0;// (int)Math.Round(fPkgOffsetX - m_intPadROIStartPixelFromLeft, 0, MidpointRounding.AwayFromZero); //m_fPkgStartPixelFromLeft
            int intStartPixelFromEdgeY = 0;// (int)Math.Round(fPkgOffsetY - m_intPadROIStartPixelFromTop, 0, MidpointRounding.AwayFromZero); //m_fPkgStartPixelFromEdge
            //int intStartPixelFromEdgeX2 = (int)Math.Round(fPkgOffsetX + m_intPadROIStartPixelFromRight, 0, MidpointRounding.AwayFromZero); //m_fPkgStartPixelFromRight
            //int intStartPixelFromEdgeY2 = (int)Math.Round(fPkgOffsetY + m_intPadROIStartPixelFromBottom, 0, MidpointRounding.AwayFromZero); //m_fPkgStartPixelFromBottom
            
            ROI objThresholdSampleROI = new ROI();
            objThresholdSampleROI.AttachImage(m_objInsPadPkgImage1); // Attach sample ROI to ori size image. m_objInsPadPkgImage1 is a ori size image used to keep the sample image temporary for modification such as double threshold
            objThresholdSampleROI.LoadROISetting(objSampleUnitROI.ref_ROIPositionX, objSampleUnitROI.ref_ROIPositionY, objSampleUnitROI.ref_ROIWidth, objSampleUnitROI.ref_ROIHeight);

            ROI objThresholdSampleROI_Temp = new ROI();
            objThresholdSampleROI_Temp.AttachImage(m_objInsSurfacePkgImage1); // Attach sample ROI to ori size image. m_objInsSurfacePkgImage1 is a ori size image used to keep the sample image temporary for modification such as double threshold
            objThresholdSampleROI_Temp.LoadROISetting(objSampleUnitROI.ref_ROIPositionX, objSampleUnitROI.ref_ROIPositionY, objSampleUnitROI.ref_ROIWidth, objSampleUnitROI.ref_ROIHeight);

            if (blnDebugImage)
            {
                objSampleUnitROI.SaveImage("D:\\TS\\1.objSampleUnitROI.bmp");
            }
            List<int> arrSkip = new List<int>();
            for (int intColorThresIndex = 0; intColorThresIndex < m_arrDefectColor.Count; intColorThresIndex++)
            {
                if (intColorThresIndex == 0 && ((m_intFailColorOptionMask & 0x03) == 0))
                    continue;
                else if (intColorThresIndex == 1 && ((m_intFailColorOptionMask & 0x0C) == 0))
                    continue;
                else if (intColorThresIndex == 2 && ((m_intFailColorOptionMask & 0x30) == 0))
                    continue;
                else if (intColorThresIndex == 3 && ((m_intFailColorOptionMask & 0xC0) == 0))
                    continue;
                else if (intColorThresIndex == 4 && ((m_intFailColorOptionMask & 0x300) == 0))
                    continue;

                if (!blnResult)
                    break;

                objBlackImage.CopyTo(ref m_objInsPadPkgImage1);

                string strThresName = m_arrDefectColorThresName[intColorThresIndex];
                if (!arrSkip.Contains(intColorThresIndex))
                {
                    bool blnFirstTime = true;
                    for (int i = 0; i < m_arrDefectColor.Count; i++)
                    {
                        if (!arrSkip.Contains(i) && strThresName == m_arrDefectColorThresName[i])
                        {
                            arrSkip.Add(i);
                        }
                        else
                            continue;

                        objSampleUnitROI.AttachImage(arrColorImages[CImageDrawing.GetArrayImageIndex(m_arrDefectImageNo[i], m_intVisionIndex)]);

                        if (blnDebugImage)
                        {
                            objSampleUnitROI.SaveImage("D:\\TS\\1_1.objSampleUnitROI2.bmp");
                        }
                        objBlackImage.CopyTo(ref m_objInsSurfacePkgImage1);

                        // Get color threshold min max value
                        m_objColorBlobs.ref_C24LowColorThreshold = ColorProcessing.CalculateMinColor(m_arrDefectColor[i], m_arrDefectColorTolerance[i]).ref_Color24;
                        m_objColorBlobs.ref_C24HighColorThreshold = ColorProcessing.CalculateMaxColor(m_arrDefectColor[i], m_arrDefectColorTolerance[i]).ref_Color24;

                        objThresholdSampleROI_Temp.LoadROISetting(objSampleUnitROI.ref_ROITotalX,
                            objSampleUnitROI.ref_ROITotalY,
                            objSampleUnitROI.ref_ROIWidth,
                            objSampleUnitROI.ref_ROIHeight);

                        // Threshold color image 
                        if (m_arrDefectColorSystem[i] == 0)
                            EasyImage.Threshold(objSampleUnitROI.ref_CROI, objThresholdSampleROI_Temp.ref_ROI, m_objColorBlobs.ref_C24LowColorThreshold, m_objColorBlobs.ref_C24HighColorThreshold, m_objColorLookupLSH);
                        else if (m_arrDefectColorSystem[i] == 1)
                            EasyImage.Threshold(objSampleUnitROI.ref_CROI, objThresholdSampleROI_Temp.ref_ROI, m_objColorBlobs.ref_C24LowColorThreshold, m_objColorBlobs.ref_C24HighColorThreshold, m_objColorLookupRGB);
                        else
                        {
                            EasyColor.GetComponent(objSampleUnitROI.ref_CROI, objThresholdSampleROI_Temp.ref_ROI, 1, m_objColorLookupYSH);
                            if (blnDebugImage)
                            {
                                objThresholdSampleROI_Temp.SaveImage("D:\\TS\\1_2.SaturationImg" + i + ".bmp");
                                m_objInsSurfacePkgImage1.SaveImage("D:\\TS\\1_2.m_objInsSurfacePkgImage1" + i + ".bmp");
                            }
#if (Debug_2_12 || Release_2_12)
                            EasyImage.Threshold(objThresholdSampleROI_Temp.ref_ROI, objThresholdSampleROI_Temp.ref_ROI, (uint)m_arrDefectColor[i][0]);
#elif (DEBUG || RELEASE || RTXRelease || RTXDebug)
                            EasyImage.Threshold(objThresholdSampleROI_Temp.ref_ROI, objThresholdSampleROI_Temp.ref_ROI, m_arrDefectColor[i][0]);
#endif
                        }

                        if (blnDebugImage)
                        {
                            objThresholdSampleROI_Temp.SaveImage("D:\\TS\\2.objThresholdSampleROI_Temp" + i + ".bmp");
                            m_objInsSurfacePkgImage1.SaveImage("D:\\TS\\2.m_objInsSurfacePkgImage1" + i + ".bmp");
                        }

                        if (m_arrDefectCloseIteration[i] > 0)
                        {
#if (Debug_2_12 || Release_2_12)
                            EasyImage.CloseBox(objThresholdSampleROI_Temp.ref_ROI, objThresholdSampleROI_Temp.ref_ROI, (uint)Math.Abs(m_arrDefectCloseIteration[i]), (uint)Math.Abs(m_arrDefectCloseIteration[i]));
#elif (DEBUG || RELEASE || RTXRelease || RTXDebug)
                            EasyImage.CloseBox(objThresholdSampleROI_Temp.ref_ROI, objThresholdSampleROI_Temp.ref_ROI, Math.Abs(m_intColorDefectCloseIteration), Math.Abs(m_intColorDefectCloseIteration));
#endif
                        }

                        if (blnDebugImage)
                        {
                            objThresholdSampleROI_Temp.SaveImage("D:\\TS\\3.objThresholdSampleROI_Temp" + i + ".bmp");
                            m_objInsSurfacePkgImage1.SaveImage("D:\\TS\\3.m_objInsSurfacePkgImage1" + i + ".bmp");
                        }

                        if (m_arrDefectInvertBlackWhite[i])
                        {
                            EasyImage.Oper(EArithmeticLogicOperation.Invert, objThresholdSampleROI_Temp.ref_ROI, objThresholdSampleROI_Temp.ref_ROI);
                        }

                        if (blnDebugImage)
                        {
                            objThresholdSampleROI_Temp.SaveImage("D:\\TS\\4.objThresholdSampleROI_Temp" + i + ".bmp");
                            m_objInsSurfacePkgImage1.SaveImage("D:\\TS\\4.m_objInsSurfacePkgImage1" + i + ".bmp");
                        }

                        SubtractColorDontCareImage(objSampleROI, objThresholdSampleROI_Temp, m_arrDefectDontCareMode[i], m_arrPadColorDontCareImage[i]);

                        objThresholdSampleROI_Temp.LoadROISetting(objSampleUnitROI.ref_ROITotalX + GetColorDefectInspection_Left(i),
                            objSampleUnitROI.ref_ROITotalY + GetColorDefectInspection_Top(i),
                            objSampleUnitROI.ref_ROIWidth - GetColorDefectInspection_Left(i) - GetColorDefectInspection_Right(i),
                            objSampleUnitROI.ref_ROIHeight - GetColorDefectInspection_Top(i) - GetColorDefectInspection_Bottom(i));

                        objThresholdSampleROI.LoadROISetting(objSampleUnitROI.ref_ROITotalX + GetColorDefectInspection_Left(i),
                         objSampleUnitROI.ref_ROITotalY + GetColorDefectInspection_Top(i),
                         objSampleUnitROI.ref_ROIWidth - GetColorDefectInspection_Left(i) - GetColorDefectInspection_Right(i),
                         objSampleUnitROI.ref_ROIHeight - GetColorDefectInspection_Top(i) - GetColorDefectInspection_Bottom(i));

                        if (blnDebugImage)
                        {
                            objThresholdSampleROI_Temp.SaveImage("D:\\TS\\5.objThresholdSampleROI_Temp" + i + ".bmp");
                            m_objInsSurfacePkgImage1.SaveImage("D:\\TS\\5.m_objInsSurfacePkgImage1" + i + ".bmp");
                        }

                        if (!blnFirstTime)
                        {
                            ROI.LogicOperationAddROI(objThresholdSampleROI, objThresholdSampleROI_Temp);
                        }
                        else
                        {
                            objThresholdSampleROI_Temp.CopyImage(ref objThresholdSampleROI);
                        }

                        if (blnDebugImage)
                        {
                            objThresholdSampleROI.SaveImage("D:\\TS\\6.objThresholdSampleROI" + i + ".bmp");
                            m_objInsPadPkgImage1.SaveImage("D:\\TS\\6.m_objInsPadPkgImage1" + i + ".bmp");
                        }
                        blnFirstTime = false;
                    }
                }
                else
                    continue;

                objThresholdSampleROI.LoadROISetting(objSampleUnitROI.ref_ROITotalX,
                 objSampleUnitROI.ref_ROITotalY,
                 objSampleUnitROI.ref_ROIWidth,
                 objSampleUnitROI.ref_ROIHeight);

                if (blnDebugImage)
                {
                    objThresholdSampleROI.SaveImage("D:\\TS\\7.objThresholdSampleROI" + intColorThresIndex + ".bmp");
                    m_objInsPadPkgImage1.SaveImage("D:\\TS\\7.m_objInsPadPkgImage1" + intColorThresIndex + ".bmp");
                }
                
                bool blnCheckLength = false;
                bool blnCheckArea = false;
                int intFailMask = 0;
                if (intColorThresIndex == 0)
                {
                    intFailMask = 0x01;
                    if ((m_intFailColorOptionMask & 0x01) > 0)
                        blnCheckLength = true;
                    if ((m_intFailColorOptionMask & 0x02) > 0)
                        blnCheckArea = true;
                }
                else if (intColorThresIndex == 1)
                {
                    intFailMask = 0x02;
                    if ((m_intFailColorOptionMask & 0x04) > 0)
                        blnCheckLength = true;
                    if ((m_intFailColorOptionMask & 0x08) > 0)
                        blnCheckArea = true;
                }
                else if (intColorThresIndex == 2)
                {
                    intFailMask = 0x04;
                    if ((m_intFailColorOptionMask & 0x10) > 0)
                        blnCheckLength = true;
                    if ((m_intFailColorOptionMask & 0x20) > 0)
                        blnCheckArea = true;
                }
                else if (intColorThresIndex == 3)
                {
                    intFailMask = 0x08;
                    if ((m_intFailColorOptionMask & 0x40) > 0)
                        blnCheckLength = true;
                    if ((m_intFailColorOptionMask & 0x80) > 0)
                        blnCheckArea = true;
                }
                else if (intColorThresIndex == 4)
                {
                    intFailMask = 0x10;
                    if ((m_intFailColorOptionMask & 0x100) > 0)
                        blnCheckLength = true;
                    if ((m_intFailColorOptionMask & 0x200) > 0)
                        blnCheckArea = true;
                }

                int intSelectedObjectNum = 0;
                intSelectedObjectNum = m_objColorBlobs.BuildObjects_Filter_GetElement(objThresholdSampleROI, !m_blnWhiteOnBlack, true, 0, -4,
                m_arrDefectColorMinArea[intColorThresIndex], objSampleUnitROI.ref_ROIWidth * objSampleUnitROI.ref_ROIHeight, false, 0xFF);

                //if (intSelectedObjectNum == 0 && m_arrDefectType[intColorThresIndex] == 1)
                //{
                //    ColorDefect objDefect = new ColorDefect();

                //    objDefect.ref_strName = m_arrDefectColorThresName[intColorThresIndex];
                //    objDefect.ref_intFailMask = intFailMask;
                //    objDefect.ref_fCenterX = -1;
                //    objDefect.ref_fCenterY = -1;
                //    objDefect.ref_fStartX = -1;
                //    objDefect.ref_fStartY = -1;
                //    objDefect.ref_fEndX = -1;
                //    objDefect.ref_fEndY = -1;
                //    objDefect.ref_fWidth = -1;
                //    objDefect.ref_fHeight = -1;
                //    objDefect.ref_fArea = -1;
                //    objDefect.ref_fWidthInMM = -1;
                //    objDefect.ref_fHeightInMM = -1;
                //    objDefect.ref_fAreaInMM2 = -1;
                //    objDefect.ref_intImageNo = m_arrDefectImageNo[intColorThresIndex] + 1;

                //    objDefect.ref_fAreaFailValue = -1;
                //    objDefect.ref_intFailCriteria |= 0x10;

                //    m_arrColorDefectList.Add(objDefect);

                //    m_intFailColorResultMask |= intFailMask;

                //    blnResult = false;
                //}

                bool blnOverallResult = true;
                if (intSelectedObjectNum > 0)
                {
                    float fCenterX = 0, fCenterY = 0, fWidth = 0, fHeight = 0;
                    float fStartX, fStartY, fEndX, fEndY, fAngle = 0;
                    int intArea = 0;
                    float fWidthMM, fHeightMM, fAreaInMM;
                    int intFailCount = 0;

                    int intTotalArea = 0;
                    for (int i = 0; i < intSelectedObjectNum; i++)
                    {
                        intArea = m_objColorBlobs.ref_arrArea[i];

                        if (m_objColorBlobs.ref_arrRectWidth[i] < m_objColorBlobs.ref_arrRectHeight[i])
                        {
                            fWidth = m_objColorBlobs.ref_arrRectWidth[i];
                            fHeight = m_objColorBlobs.ref_arrRectHeight[i];

                            fAngle = m_objColorBlobs.ref_arrRectAngle[i];


                            if (fAngle < 0)
                                fAngle = -Math.Abs(fAngle);
                            else
                                fAngle = -fAngle;
                        }
                        else
                        {
                            fWidth = m_objColorBlobs.ref_arrRectHeight[i];
                            fHeight = m_objColorBlobs.ref_arrRectWidth[i];

                            fAngle = m_objColorBlobs.ref_arrRectAngle[i];


                            if (fAngle < 0)
                                fAngle = Math.Abs(fAngle);
                            else
                                fAngle = 90 - (fAngle);
                        }
                        fCenterX = m_objColorBlobs.ref_arrRectLimitCenterX[i];
                        fCenterY = m_objColorBlobs.ref_arrRectLimitCenterY[i];

                        intTotalArea += intArea;
                        fCenterX += intStartPixelFromEdgeX;
                        fCenterY += intStartPixelFromEdgeY;
                        fStartX = (float)Math.Floor(fCenterX - (fWidth / 2));
                        fStartY = (float)Math.Floor(fCenterY - (fHeight / 2));
                        fEndX = (float)Math.Ceiling(fCenterX + (fWidth / 2));
                        fEndY = (float)Math.Ceiling(fCenterY + (fHeight / 2));

                        // convert width and height to mm
                        fWidthMM = fWidth / m_fMMToPixelXValue;
                        fHeightMM = fHeight / m_fMMToPixelYValue; // 11-04-2019 ZJYEOH : Changed m_fMMToPixelXValue to m_fMMToPixelYValue
                        fAreaInMM = intArea / m_fMMToPixelXValue / m_fMMToPixelYValue;

                        {
                            intFailCount++;

                            ColorDefect objDefect = new ColorDefect();

                            objDefect.ref_strName = m_arrDefectColorThresName[intColorThresIndex];
                            objDefect.ref_intFailMask = intFailMask;
                            objDefect.ref_fCenterX = objThresholdSampleROI.ref_ROITotalX + fCenterX;
                            objDefect.ref_fCenterY = objThresholdSampleROI.ref_ROITotalY + fCenterY;
                            objDefect.ref_fStartX = objThresholdSampleROI.ref_ROITotalX + fStartX;
                            objDefect.ref_fStartY = objThresholdSampleROI.ref_ROITotalY + fStartY;
                            objDefect.ref_fEndX = objThresholdSampleROI.ref_ROITotalX + fEndX;
                            objDefect.ref_fEndY = objThresholdSampleROI.ref_ROITotalY + fEndY;
                            objDefect.ref_fWidth = fWidth;
                            objDefect.ref_fHeight = fHeight;
                            objDefect.ref_fArea = intArea;
                            objDefect.ref_fAngle = fAngle;
                            objDefect.ref_fWidthInMM = fWidthMM;
                            objDefect.ref_fHeightInMM = fHeightMM;
                            objDefect.ref_fAreaInMM2 = fAreaInMM;
                            objDefect.ref_intImageNo = m_arrDefectImageNo[intColorThresIndex] + 1;

                            if (blnCheckLength)
                            {
                                if (m_arrDefectColorInspectionFailCondition[intColorThresIndex] == 0)
                                {
                                    if (fWidthMM > m_arrDefectColorInspectionWidth[intColorThresIndex])
                                    {
                                        m_intFailColorResultMask |= intFailMask;

                                        blnOverallResult = false;
                                        objDefect.ref_fWidthFailValue = fWidthMM;
                                        objDefect.ref_intFailCriteria |= 0x01;
                                        blnResult = false;
                                    }
                                    if (fHeightMM > m_arrDefectColorInspectionLength[intColorThresIndex])
                                    {
                                        m_intFailColorResultMask |= intFailMask;

                                        blnOverallResult = false;
                                        objDefect.ref_fHeightFailValue = fHeightMM;
                                        objDefect.ref_intFailCriteria |= 0x02;
                                        blnResult = false;
                                    }
                                }
                                else
                                {
                                    if ((fWidthMM > m_arrDefectColorInspectionWidth[intColorThresIndex]) && (fHeightMM > m_arrDefectColorInspectionLength[intColorThresIndex]))
                                    {
                                        m_intFailColorResultMask |= intFailMask;

                                        blnOverallResult = false;
                                        objDefect.ref_fWidthFailValue = fWidthMM;
                                        objDefect.ref_fHeightFailValue = fHeightMM;
                                        objDefect.ref_intFailCriteria |= 0x01;
                                        objDefect.ref_intFailCriteria |= 0x02;
                                        blnResult = false;
                                    }
                                }
                            }

                            if (blnCheckArea)
                            {
                                if (/*fAreaInMM < m_arrDefectColorInspectionMinArea[intColorThresIndex] ||*/ fAreaInMM > m_arrDefectColorInspectionMaxArea[intColorThresIndex])
                                {
                                    m_intFailColorResultMask |= intFailMask;

                                    blnOverallResult = false;
                                    objDefect.ref_fAreaFailValue = fAreaInMM;
                                    objDefect.ref_intFailCriteria |= 0x04;
                                    blnResult = false;
                                }
                            }

                            m_arrColorDefectList.Add(objDefect);
                        }

                    }

                    if (blnCheckArea)
                    {
                        fAreaInMM = intTotalArea / m_fMMToPixelXValue / m_fMMToPixelYValue;

                        if (fAreaInMM > m_arrDefectColorInspectionTotalArea[intColorThresIndex])
                        {
                            ColorDefect objDefect = new ColorDefect();

                            objDefect.ref_strName = m_arrDefectColorThresName[intColorThresIndex];
                            objDefect.ref_intFailMask = intFailMask;
                            objDefect.ref_fCenterX = -1;
                            objDefect.ref_fCenterY = -1;
                            objDefect.ref_fStartX = -1;
                            objDefect.ref_fStartY = -1;
                            objDefect.ref_fEndX = -1;
                            objDefect.ref_fEndY = -1;
                            objDefect.ref_fWidth = -1;
                            objDefect.ref_fHeight = -1;
                            objDefect.ref_fArea = intTotalArea;
                            objDefect.ref_fWidthInMM = -1;
                            objDefect.ref_fHeightInMM = -1;
                            objDefect.ref_fAreaInMM2 = fAreaInMM;
                            objDefect.ref_intImageNo = m_arrDefectImageNo[intColorThresIndex] + 1;
                            objDefect.ref_blnFailTotalArea = true;
                            blnOverallResult = false;
                            objDefect.ref_fAreaFailValue = fAreaInMM;
                            objDefect.ref_intFailCriteria |= 0x08;

                            m_arrColorDefectList.Add(objDefect);

                            m_intFailColorResultMask |= intFailMask;

                            for (int b = 0; b < m_arrColorDefectList.Count; b++)
                            {
                                if (((ColorDefect)m_arrColorDefectList[b]).ref_strName == m_arrDefectColorThresName[intColorThresIndex])
                                {
                                    if (!((ColorDefect)m_arrColorDefectList[b]).ref_blnFailTotalArea)
                                    {
                                        ColorDefect objDefect2 = m_arrColorDefectList[b];
                                        objDefect2.ref_blnFailTotalArea = true;
                                        m_arrColorDefectList.RemoveAt(b);
                                        m_arrColorDefectList.Insert(b, objDefect2);
                                    }
                                }
                            }

                            blnResult = false;
                        }

                    }
                }
            }
            objThresholdSampleROI.Dispose();
            objThresholdSampleROI_Temp.Dispose();
            return blnResult;
        }
        private bool CheckColorDefect_CombineSameName_LinkNearest(CROI objSampleUnitROI, List<CImageDrawing> arrColorImages, ROI objSampleROI, ImageDrawing objBlackImage)
        {
            if (m_arrDefectColorThresName.Count == 0)
                return true;

            if ((((m_intFailColorOptionMask & 0x03) == 0) && m_arrDefectColorThresName.Count == 1) &&
                (((m_intFailColorOptionMask & 0x0C) == 0) && m_arrDefectColorThresName.Count == 2) &&
                (((m_intFailColorOptionMask & 0x30) == 0) && m_arrDefectColorThresName.Count == 3) &&
                (((m_intFailColorOptionMask & 0xC0) == 0) && m_arrDefectColorThresName.Count == 4) &&
                (((m_intFailColorOptionMask & 0x300) == 0) && m_arrDefectColorThresName.Count == 5))
                return true;

            bool blnResult = true;
            bool blnDebugImage = false;

            //float fPkgOffsetX = (objSampleUnitROI.ref_ROIWidth - Math.Max(GetResultUpWidth_RectGauge4L(0), GetResultDownWidth_RectGauge4L(0))) / 2;
            //float fPkgOffsetY = (objSampleUnitROI.ref_ROIHeight - Math.Max(GetResultLeftHeight_RectGauge4L(0), GetResultRightHeight_RectGauge4L(0))) / 2;

            int intStartPixelFromEdgeX = 0;// (int)Math.Round(fPkgOffsetX - m_intPadROIStartPixelFromLeft, 0, MidpointRounding.AwayFromZero); //m_fPkgStartPixelFromLeft
            int intStartPixelFromEdgeY = 0;// (int)Math.Round(fPkgOffsetY - m_intPadROIStartPixelFromTop, 0, MidpointRounding.AwayFromZero); //m_fPkgStartPixelFromEdge
                                           //int intStartPixelFromEdgeX2 = (int)Math.Round(fPkgOffsetX + m_intPadROIStartPixelFromRight, 0, MidpointRounding.AwayFromZero); //m_fPkgStartPixelFromRight
                                           //int intStartPixelFromEdgeY2 = (int)Math.Round(fPkgOffsetY + m_intPadROIStartPixelFromBottom, 0, MidpointRounding.AwayFromZero); //m_fPkgStartPixelFromBottom

            ROI objThresholdSampleROI = new ROI();
            objThresholdSampleROI.AttachImage(m_objInsPadPkgImage1); // Attach sample ROI to ori size image. m_objInsPadPkgImage1 is a ori size image used to keep the sample image temporary for modification such as double threshold
            objThresholdSampleROI.LoadROISetting(objSampleUnitROI.ref_ROIPositionX, objSampleUnitROI.ref_ROIPositionY, objSampleUnitROI.ref_ROIWidth, objSampleUnitROI.ref_ROIHeight);

            ROI objThresholdSampleROI_Temp = new ROI();
            objThresholdSampleROI_Temp.AttachImage(m_objInsSurfacePkgImage1); // Attach sample ROI to ori size image. m_objInsSurfacePkgImage1 is a ori size image used to keep the sample image temporary for modification such as double threshold
            objThresholdSampleROI_Temp.LoadROISetting(objSampleUnitROI.ref_ROIPositionX, objSampleUnitROI.ref_ROIPositionY, objSampleUnitROI.ref_ROIWidth, objSampleUnitROI.ref_ROIHeight);

            if (blnDebugImage)
            {
                objSampleUnitROI.SaveImage("D:\\TS\\1.objSampleUnitROI.bmp");
            }
            List<int> arrSkip = new List<int>();
            for (int intColorThresIndex = 0; intColorThresIndex < m_arrDefectColor.Count; intColorThresIndex++)
            {
                if (intColorThresIndex == 0 && ((m_intFailColorOptionMask & 0x03) == 0))
                    continue;
                else if (intColorThresIndex == 1 && ((m_intFailColorOptionMask & 0x0C) == 0))
                    continue;
                else if (intColorThresIndex == 2 && ((m_intFailColorOptionMask & 0x30) == 0))
                    continue;
                else if (intColorThresIndex == 3 && ((m_intFailColorOptionMask & 0xC0) == 0))
                    continue;
                else if (intColorThresIndex == 4 && ((m_intFailColorOptionMask & 0x300) == 0))
                    continue;

                if (!blnResult)
                    break;

                objBlackImage.CopyTo(ref m_objInsPadPkgImage1);

                string strThresName = m_arrDefectColorThresName[intColorThresIndex];
                if (!arrSkip.Contains(intColorThresIndex))
                {
                    bool blnFirstTime = true;
                    for (int i = 0; i < m_arrDefectColor.Count; i++)
                    {
                        if (!arrSkip.Contains(i) && strThresName == m_arrDefectColorThresName[i])
                        {
                            arrSkip.Add(i);
                        }
                        else
                            continue;

                        objSampleUnitROI.AttachImage(arrColorImages[CImageDrawing.GetArrayImageIndex(m_arrDefectImageNo[i], m_intVisionIndex)]);

                        if (blnDebugImage)
                        {
                            objSampleUnitROI.SaveImage("D:\\TS\\1_1.objSampleUnitROI2.bmp");
                        }
                        objBlackImage.CopyTo(ref m_objInsSurfacePkgImage1);

                        // Get color threshold min max value
                        m_objColorBlobs.ref_C24LowColorThreshold = ColorProcessing.CalculateMinColor(m_arrDefectColor[i], m_arrDefectColorTolerance[i]).ref_Color24;
                        m_objColorBlobs.ref_C24HighColorThreshold = ColorProcessing.CalculateMaxColor(m_arrDefectColor[i], m_arrDefectColorTolerance[i]).ref_Color24;

                        objThresholdSampleROI_Temp.LoadROISetting(objSampleUnitROI.ref_ROITotalX,
                            objSampleUnitROI.ref_ROITotalY,
                            objSampleUnitROI.ref_ROIWidth,
                            objSampleUnitROI.ref_ROIHeight);

                        // Threshold color image 
                        if (m_arrDefectColorSystem[i] == 0)
                            EasyImage.Threshold(objSampleUnitROI.ref_CROI, objThresholdSampleROI_Temp.ref_ROI, m_objColorBlobs.ref_C24LowColorThreshold, m_objColorBlobs.ref_C24HighColorThreshold, m_objColorLookupLSH);
                        else if (m_arrDefectColorSystem[i] == 1)
                            EasyImage.Threshold(objSampleUnitROI.ref_CROI, objThresholdSampleROI_Temp.ref_ROI, m_objColorBlobs.ref_C24LowColorThreshold, m_objColorBlobs.ref_C24HighColorThreshold, m_objColorLookupRGB);
                        else
                        {
                            EasyColor.GetComponent(objSampleUnitROI.ref_CROI, objThresholdSampleROI_Temp.ref_ROI, 1, m_objColorLookupYSH);
                            if (blnDebugImage)
                            {
                                objThresholdSampleROI_Temp.SaveImage("D:\\TS\\1_2.SaturationImg" + i + ".bmp");
                                m_objInsSurfacePkgImage1.SaveImage("D:\\TS\\1_2.m_objInsSurfacePkgImage1" + i + ".bmp");
                            }
#if (Debug_2_12 || Release_2_12)
                            EasyImage.Threshold(objThresholdSampleROI_Temp.ref_ROI, objThresholdSampleROI_Temp.ref_ROI, (uint)m_arrDefectColor[i][0]);
#elif (DEBUG || RELEASE || RTXRelease || RTXDebug)
                            EasyImage.Threshold(objThresholdSampleROI_Temp.ref_ROI, objThresholdSampleROI_Temp.ref_ROI, m_arrDefectColor[i][0]);
#endif
                        }

                        if (blnDebugImage)
                        {
                            objThresholdSampleROI_Temp.SaveImage("D:\\TS\\2.objThresholdSampleROI_Temp" + i + ".bmp");
                            m_objInsSurfacePkgImage1.SaveImage("D:\\TS\\2.m_objInsSurfacePkgImage1" + i + ".bmp");
                        }

                        if (m_arrDefectCloseIteration[i] > 0)
                        {
#if (Debug_2_12 || Release_2_12)
                            EasyImage.CloseBox(objThresholdSampleROI_Temp.ref_ROI, objThresholdSampleROI_Temp.ref_ROI, (uint)Math.Abs(m_arrDefectCloseIteration[i]), (uint)Math.Abs(m_arrDefectCloseIteration[i]));
#elif (DEBUG || RELEASE || RTXRelease || RTXDebug)
                            EasyImage.CloseBox(objThresholdSampleROI_Temp.ref_ROI, objThresholdSampleROI_Temp.ref_ROI, Math.Abs(m_arrDefectCloseIteration[i]), Math.Abs(m_arrDefectCloseIteration[i]));
#endif
                        }

                        if (blnDebugImage)
                        {
                            objThresholdSampleROI_Temp.SaveImage("D:\\TS\\3.objThresholdSampleROI_Temp" + i + ".bmp");
                            m_objInsSurfacePkgImage1.SaveImage("D:\\TS\\3.m_objInsSurfacePkgImage1" + i + ".bmp");
                        }

                        if (m_arrDefectInvertBlackWhite[i])
                        {
                            EasyImage.Oper(EArithmeticLogicOperation.Invert, objThresholdSampleROI_Temp.ref_ROI, objThresholdSampleROI_Temp.ref_ROI);
                        }

                        if (blnDebugImage)
                        {
                            objThresholdSampleROI_Temp.SaveImage("D:\\TS\\4.objThresholdSampleROI_Temp" + i + ".bmp");
                            m_objInsSurfacePkgImage1.SaveImage("D:\\TS\\4.m_objInsSurfacePkgImage1" + i + ".bmp");
                        }

                        SubtractColorDontCareImage(objSampleROI, objThresholdSampleROI_Temp, m_arrDefectDontCareMode[i], m_arrPadColorDontCareImage[i]);

                        objThresholdSampleROI_Temp.LoadROISetting(objSampleUnitROI.ref_ROITotalX + GetColorDefectInspection_Left(i),
                            objSampleUnitROI.ref_ROITotalY + GetColorDefectInspection_Top(i),
                            objSampleUnitROI.ref_ROIWidth - GetColorDefectInspection_Left(i) - GetColorDefectInspection_Right(i),
                            objSampleUnitROI.ref_ROIHeight - GetColorDefectInspection_Top(i) - GetColorDefectInspection_Bottom(i));

                        objThresholdSampleROI.LoadROISetting(objSampleUnitROI.ref_ROITotalX + GetColorDefectInspection_Left(i),
                         objSampleUnitROI.ref_ROITotalY + GetColorDefectInspection_Top(i),
                         objSampleUnitROI.ref_ROIWidth - GetColorDefectInspection_Left(i) - GetColorDefectInspection_Right(i),
                         objSampleUnitROI.ref_ROIHeight - GetColorDefectInspection_Top(i) - GetColorDefectInspection_Bottom(i));

                        if (blnDebugImage)
                        {
                            objThresholdSampleROI_Temp.SaveImage("D:\\TS\\5.objThresholdSampleROI_Temp" + i + ".bmp");
                            m_objInsSurfacePkgImage1.SaveImage("D:\\TS\\5.m_objInsSurfacePkgImage1" + i + ".bmp");
                        }

                        if (!blnFirstTime)
                        {
                            ROI.LogicOperationAddROI(objThresholdSampleROI, objThresholdSampleROI_Temp);
                        }
                        else
                        {
                            objThresholdSampleROI_Temp.CopyImage(ref objThresholdSampleROI);
                        }

                        if (blnDebugImage)
                        {
                            objThresholdSampleROI.SaveImage("D:\\TS\\6.objThresholdSampleROI" + i + ".bmp");
                            m_objInsPadPkgImage1.SaveImage("D:\\TS\\6.m_objInsPadPkgImage1" + i + ".bmp");
                        }
                        blnFirstTime = false;
                    }
                }
                else
                    continue;

                objThresholdSampleROI.LoadROISetting(objSampleUnitROI.ref_ROITotalX,
                 objSampleUnitROI.ref_ROITotalY,
                 objSampleUnitROI.ref_ROIWidth,
                 objSampleUnitROI.ref_ROIHeight);

                if (blnDebugImage)
                {
                    objThresholdSampleROI.SaveImage("D:\\TS\\7.objThresholdSampleROI" + intColorThresIndex + ".bmp");
                    m_objInsPadPkgImage1.SaveImage("D:\\TS\\7.m_objInsPadPkgImage1" + intColorThresIndex + ".bmp");
                }
                
                bool blnCheckLength = false;
                bool blnCheckArea = false;
                int intFailMask = 0;
                if (intColorThresIndex == 0)
                {
                    intFailMask = 0x01;
                    if ((m_intFailColorOptionMask & 0x01) > 0)
                        blnCheckLength = true;
                    if ((m_intFailColorOptionMask & 0x02) > 0)
                        blnCheckArea = true;
                }
                else if (intColorThresIndex == 1)
                {
                    intFailMask = 0x02;
                    if ((m_intFailColorOptionMask & 0x04) > 0)
                        blnCheckLength = true;
                    if ((m_intFailColorOptionMask & 0x08) > 0)
                        blnCheckArea = true;
                }
                else if (intColorThresIndex == 2)
                {
                    intFailMask = 0x04;
                    if ((m_intFailColorOptionMask & 0x10) > 0)
                        blnCheckLength = true;
                    if ((m_intFailColorOptionMask & 0x20) > 0)
                        blnCheckArea = true;
                }
                else if (intColorThresIndex == 3)
                {
                    intFailMask = 0x08;
                    if ((m_intFailColorOptionMask & 0x40) > 0)
                        blnCheckLength = true;
                    if ((m_intFailColorOptionMask & 0x80) > 0)
                        blnCheckArea = true;
                }
                else if (intColorThresIndex == 4)
                {
                    intFailMask = 0x10;
                    if ((m_intFailColorOptionMask & 0x100) > 0)
                        blnCheckLength = true;
                    if ((m_intFailColorOptionMask & 0x200) > 0)
                        blnCheckArea = true;
                }

                int intSelectedObjectNum = 0;
                intSelectedObjectNum = m_objColorBlobs.BuildObjects_Filter_GetElement(objThresholdSampleROI, !m_blnWhiteOnBlack, true, 0, -4,
                m_arrDefectColorMinArea[intColorThresIndex], objSampleUnitROI.ref_ROIWidth * objSampleUnitROI.ref_ROIHeight, false, 0xFF);

                //if (intSelectedObjectNum == 0 && m_arrDefectType[intColorThresIndex] == 1)
                //{
                //    ColorDefect objDefect = new ColorDefect();

                //    objDefect.ref_strName = m_arrDefectColorThresName[intColorThresIndex];
                //    objDefect.ref_intFailMask = intFailMask;
                //    objDefect.ref_fCenterX = -1;
                //    objDefect.ref_fCenterY = -1;
                //    objDefect.ref_fStartX = -1;
                //    objDefect.ref_fStartY = -1;
                //    objDefect.ref_fEndX = -1;
                //    objDefect.ref_fEndY = -1;
                //    objDefect.ref_fWidth = -1;
                //    objDefect.ref_fHeight = -1;
                //    objDefect.ref_fArea = -1;
                //    objDefect.ref_fWidthInMM = -1;
                //    objDefect.ref_fHeightInMM = -1;
                //    objDefect.ref_fAreaInMM2 = -1;
                //    objDefect.ref_intImageNo = m_arrDefectImageNo[intColorThresIndex] + 1;

                //    objDefect.ref_fAreaFailValue = -1;
                //    objDefect.ref_intFailCriteria |= 0x10;

                //    m_arrColorDefectList.Add(objDefect);

                //    m_intFailColorResultMask |= intFailMask;

                //    blnResult = false;
                //}

                bool blnOverallResult = true;
                if (intSelectedObjectNum > 0)
                {
                    List<List<System.Windows.Point>> arr2DPoints = new List<List<System.Windows.Point>>();
                    List<List<PointF>> arrRotatedPoints = new List<List<PointF>>();
                    List<float> fObjectHeightList = new List<float>(), fObjectWidthList = new List<float>(), fObjectCenterXList = new List<float>(), fObjectCenterYList = new List<float>(), fObjectAngleList = new List<float>();
                    List<float> fObjectLimitHeightList = new List<float>(), fObjectLimitWidthList = new List<float>(), fObjectLimitCenterXList = new List<float>(), fObjectLimitCenterYList = new List<float>();
                    List<int> fObjectAreaList = new List<int>(), fObjectAreaList2 = new List<int>();
                    int intObjectTotalArea = 0;
                    int intObjectArea = 0;
                    int intLengthMode = 0;
                    float fObjectHeight = 0, fObjectWidth = 0, fObjectCenterX = 0, fObjectCenterY = 0, fObjectAngle = 0;
                    float fObjectLimitHeight = 0, fObjectLimitWidth = 0, fObjectLimitCenterX = 0, fObjectLimitCenterY = 0;
                    bool blnOverAllFail = false;
                    for (int i = 0; i < intSelectedObjectNum; i++)
                    {
                        arrRotatedPoints.Add(new List<PointF>());
                        arr2DPoints.Add(new List<System.Windows.Point>());
                        intObjectArea = m_objColorBlobs.ref_arrArea[i];

                        if (m_objColorBlobs.ref_arrRectHeight[i] < m_objColorBlobs.ref_arrRectWidth[i])
                        {
                            fObjectWidth = m_objColorBlobs.ref_arrRectHeight[i];
                            fObjectHeight = m_objColorBlobs.ref_arrRectWidth[i];
                            intLengthMode = 0;
                            fObjectAngle = m_objColorBlobs.ref_arrRectAngle[i];

                            if (fObjectAngle >= 10)//&& fAngle <= 80)
                                fObjectAngle = m_objColorBlobs.ref_arrRectAngle[i] - 90;
                            else
                                fObjectAngle = 90 + m_objColorBlobs.ref_arrRectAngle[i];

                        }
                        else
                        {
                            fObjectHeight = m_objColorBlobs.ref_arrRectHeight[i];
                            fObjectWidth = m_objColorBlobs.ref_arrRectWidth[i];
                            intLengthMode = 0;

                            fObjectAngle = m_objColorBlobs.ref_arrRectAngle[i];

                        }
                        fObjectCenterX = m_objColorBlobs.ref_arrRectLimitCenterX[i];
                        fObjectCenterY = m_objColorBlobs.ref_arrRectLimitCenterY[i];

                        fObjectLimitCenterX = m_objColorBlobs.ref_arrLimitCenterX[i];
                        fObjectLimitCenterY = m_objColorBlobs.ref_arrLimitCenterY[i];
                        fObjectLimitWidth = m_objColorBlobs.ref_arrWidth[i];
                        fObjectLimitHeight = m_objColorBlobs.ref_arrHeight[i];

                        intObjectTotalArea += intObjectArea;
                        //float MaxX = 0, MaxY = 0, MinX = 0, MinY = 0;
                        float newX1 = 0, newY1 = 0;  // new point 1
                        float newX2 = 0, newY2 = 0; // new point 2
                        float newX3 = 0, newY3 = 0; // new point 3
                        float newX4 = 0, newY4 = 0; // new point 4
                        
                        //2020-12-18 ZJYEOH : Change to this format
                        //  Point 1 *-------------* Point 2
                        //          |             |
                        //          |             |
                        //          |             |
                        //  Point 4 *-------------* Point 3

                        Math2.RotateWithAngleAccordingToReferencePoint(fObjectCenterX, fObjectCenterY, (fObjectCenterX - (fObjectWidth / 2)), (fObjectCenterY - (fObjectHeight / 2)), fObjectAngle, ref newX1, ref newY1);
                        Math2.RotateWithAngleAccordingToReferencePoint(fObjectCenterX, fObjectCenterY, (fObjectCenterX + (fObjectWidth / 2)), (fObjectCenterY - (fObjectHeight / 2)), fObjectAngle, ref newX2, ref newY2);
                        Math2.RotateWithAngleAccordingToReferencePoint(fObjectCenterX, fObjectCenterY, (fObjectCenterX + (fObjectWidth / 2)), (fObjectCenterY + (fObjectHeight / 2)), fObjectAngle, ref newX3, ref newY3);
                        Math2.RotateWithAngleAccordingToReferencePoint(fObjectCenterX, fObjectCenterY, (fObjectCenterX - (fObjectWidth / 2)), (fObjectCenterY + (fObjectHeight / 2)), fObjectAngle, ref newX4, ref newY4);


                        arrRotatedPoints[i].Add(new PointF(newX1, newY1));
                        arrRotatedPoints[i].Add(new PointF(newX2, newY2));
                        arrRotatedPoints[i].Add(new PointF(newX3, newY3));
                        arrRotatedPoints[i].Add(new PointF(newX4, newY4));

                        Math2.RotateWithAngleAccordingToReferencePoint(fObjectCenterX, fObjectCenterY, (fObjectCenterX - (fObjectWidth / 2)) - m_intColorDefectLinkTolerance, (fObjectCenterY - (fObjectHeight / 2)) - m_intColorDefectLinkTolerance, fObjectAngle, ref newX1, ref newY1);
                        Math2.RotateWithAngleAccordingToReferencePoint(fObjectCenterX, fObjectCenterY, (fObjectCenterX + (fObjectWidth / 2)) + m_intColorDefectLinkTolerance, (fObjectCenterY - (fObjectHeight / 2)) - m_intColorDefectLinkTolerance, fObjectAngle, ref newX2, ref newY2);
                        Math2.RotateWithAngleAccordingToReferencePoint(fObjectCenterX, fObjectCenterY, (fObjectCenterX + (fObjectWidth / 2)) + m_intColorDefectLinkTolerance, (fObjectCenterY + (fObjectHeight / 2)) + m_intColorDefectLinkTolerance, fObjectAngle, ref newX3, ref newY3);
                        Math2.RotateWithAngleAccordingToReferencePoint(fObjectCenterX, fObjectCenterY, (fObjectCenterX - (fObjectWidth / 2)) - m_intColorDefectLinkTolerance, (fObjectCenterY + (fObjectHeight / 2)) + m_intColorDefectLinkTolerance, fObjectAngle, ref newX4, ref newY4);

                        arr2DPoints[i].Add(new System.Windows.Point(newX1, newY1));
                        arr2DPoints[i].Add(new System.Windows.Point(newX2, newY2));
                        arr2DPoints[i].Add(new System.Windows.Point(newX3, newY3));
                        arr2DPoints[i].Add(new System.Windows.Point(newX4, newY4));
                        
                        fObjectHeightList.Add(fObjectHeight);
                        fObjectWidthList.Add(fObjectWidth);
                        fObjectCenterXList.Add(fObjectCenterX);
                        fObjectCenterYList.Add(fObjectCenterY);
                        fObjectAngleList.Add(fObjectAngle);
                        fObjectAreaList.Add(intObjectArea);
                        fObjectAreaList2.Add(intObjectArea);
                    }
                    int intTolerance = m_intColorDefectLinkTolerance;
                    int intAngleTolerance = 10;
                    bool blnDecrement = false;
                    if (intTolerance >= 0)
                    {
                        for (int i = 0; i < fObjectHeightList.Count; i++)
                        {
                            if (blnDecrement)
                            {
                                blnDecrement = false;
                                if (i > 0)
                                    i--;
                            }
                            for (int j = 0; j < fObjectHeightList.Count; j++)
                            {
                                if (i != j && i < fObjectHeightList.Count && j < fObjectHeightList.Count)
                                {
                                    if (Intersection.CheckRectRectIntersection(arr2DPoints[i].ToArray(), arr2DPoints[j].ToArray(), intTolerance))
                                    {
                                        PointF[] arrPoints = new PointF[8];

                                        arrPoints[0] = arrRotatedPoints[i][0];
                                        arrPoints[1] = arrRotatedPoints[i][1];
                                        arrPoints[2] = arrRotatedPoints[i][2];
                                        arrPoints[3] = arrRotatedPoints[i][3];
                                        arrPoints[4] = arrRotatedPoints[j][0];
                                        arrPoints[5] = arrRotatedPoints[j][1];
                                        arrPoints[6] = arrRotatedPoints[j][2];
                                        arrPoints[7] = arrRotatedPoints[j][3];

                                        float fMinAngle = 0;
                                        List<PointF> arrMinRect = new List<PointF>();
                                        arrMinRect = MinimumBoundingBox.CalculateMinimumBoundingBox(arrPoints, ref fMinAngle);

                                        if (fMinAngle < 0)
                                            fObjectAngleList[i] = -(90 + fMinAngle);
                                        else
                                            fObjectAngleList[i] = 90 - fMinAngle;

                                        Line onjLine1 = new Line();
                                        Line onjLine2 = new Line();
                                        onjLine1.CalculateStraightLine(arrMinRect[0], arrMinRect[2]);
                                        onjLine2.CalculateStraightLine(arrMinRect[1], arrMinRect[3]);
                                        PointF pCenter = Line.GetCrossPoint(onjLine1, onjLine2);
                                        float p1X = 0, p1Y = 0;
                                        float p2X = 0, p2Y = 0;
                                        float p3X = 0, p3Y = 0;
                                        float p4X = 0, p4Y = 0;
                                        Math2.RotateWithAngleAccordingToReferencePoint(pCenter.X, pCenter.Y, arrMinRect[0].X, arrMinRect[0].Y, -fObjectAngleList[i], ref p1X, ref p1Y);
                                        Math2.RotateWithAngleAccordingToReferencePoint(pCenter.X, pCenter.Y, arrMinRect[1].X, arrMinRect[1].Y, -fObjectAngleList[i], ref p2X, ref p2Y);
                                        Math2.RotateWithAngleAccordingToReferencePoint(pCenter.X, pCenter.Y, arrMinRect[2].X, arrMinRect[2].Y, -fObjectAngleList[i], ref p3X, ref p3Y);
                                        Math2.RotateWithAngleAccordingToReferencePoint(pCenter.X, pCenter.Y, arrMinRect[3].X, arrMinRect[3].Y, -fObjectAngleList[i], ref p4X, ref p4Y);

                                        float pR1X = 0, pR1Y = 0;
                                        float pR2X = 0, pR2Y = 0;
                                        float pR3X = 0, pR3Y = 0;
                                        float pR4X = 0, pR4Y = 0;
                                        Math2.RotateWithAngleAccordingToReferencePoint(pCenter.X, pCenter.Y, Math.Min(Math.Min(p1X, p2X), Math.Min(p3X, p4X)), Math.Min(Math.Min(p1Y, p2Y), Math.Min(p3Y, p4Y)), fObjectAngleList[i], ref pR1X, ref pR1Y); // Top Left
                                        Math2.RotateWithAngleAccordingToReferencePoint(pCenter.X, pCenter.Y, Math.Max(Math.Max(p1X, p2X), Math.Max(p3X, p4X)), Math.Min(Math.Min(p1Y, p2Y), Math.Min(p3Y, p4Y)), fObjectAngleList[i], ref pR2X, ref pR2Y); // Top Right
                                        Math2.RotateWithAngleAccordingToReferencePoint(pCenter.X, pCenter.Y, Math.Max(Math.Max(p1X, p2X), Math.Max(p3X, p4X)), Math.Max(Math.Max(p1Y, p2Y), Math.Max(p3Y, p4Y)), fObjectAngleList[i], ref pR3X, ref pR3Y); // Bottom Right
                                        Math2.RotateWithAngleAccordingToReferencePoint(pCenter.X, pCenter.Y, Math.Min(Math.Min(p1X, p2X), Math.Min(p3X, p4X)), Math.Max(Math.Max(p1Y, p2Y), Math.Max(p3Y, p4Y)), fObjectAngleList[i], ref pR4X, ref pR4Y); // Bottom Left
                                        arrMinRect[0] = new PointF(pR1X, pR1Y);
                                        arrMinRect[1] = new PointF(pR2X, pR2Y);
                                        arrMinRect[2] = new PointF(pR3X, pR3Y);
                                        arrMinRect[3] = new PointF(pR4X, pR4Y);
                                        
                                        arrRotatedPoints[i][0] = arrMinRect[0];
                                        arrRotatedPoints[i][1] = arrMinRect[1];
                                        arrRotatedPoints[i][2] = arrMinRect[2];
                                        arrRotatedPoints[i][3] = arrMinRect[3];

                                        Math2.RotateWithAngleAccordingToReferencePoint(pCenter.X, pCenter.Y, Math.Min(Math.Min(p1X, p2X), Math.Min(p3X, p4X)) - m_intColorDefectLinkTolerance, Math.Min(Math.Min(p1Y, p2Y), Math.Min(p3Y, p4Y)) - m_intColorDefectLinkTolerance, fObjectAngleList[i], ref pR1X, ref pR1Y); // Top Left
                                        Math2.RotateWithAngleAccordingToReferencePoint(pCenter.X, pCenter.Y, Math.Max(Math.Max(p1X, p2X), Math.Max(p3X, p4X)) + m_intColorDefectLinkTolerance, Math.Min(Math.Min(p1Y, p2Y), Math.Min(p3Y, p4Y)) - m_intColorDefectLinkTolerance, fObjectAngleList[i], ref pR2X, ref pR2Y); // Top Right
                                        Math2.RotateWithAngleAccordingToReferencePoint(pCenter.X, pCenter.Y, Math.Max(Math.Max(p1X, p2X), Math.Max(p3X, p4X)) + m_intColorDefectLinkTolerance, Math.Max(Math.Max(p1Y, p2Y), Math.Max(p3Y, p4Y)) + m_intColorDefectLinkTolerance, fObjectAngleList[i], ref pR3X, ref pR3Y); // Bottom Right
                                        Math2.RotateWithAngleAccordingToReferencePoint(pCenter.X, pCenter.Y, Math.Min(Math.Min(p1X, p2X), Math.Min(p3X, p4X)) - m_intColorDefectLinkTolerance, Math.Max(Math.Max(p1Y, p2Y), Math.Max(p3Y, p4Y)) + m_intColorDefectLinkTolerance, fObjectAngleList[i], ref pR4X, ref pR4Y); // Bottom Left

                                        arr2DPoints[i][0] = new System.Windows.Point(pR1X, pR1Y);
                                        arr2DPoints[i][1] = new System.Windows.Point(pR2X, pR2Y);
                                        arr2DPoints[i][2] = new System.Windows.Point(pR3X, pR3Y);
                                        arr2DPoints[i][3] = new System.Windows.Point(pR4X, pR4Y);

                                        arrRotatedPoints.RemoveAt(j);
                                        arr2DPoints.RemoveAt(j);

                                        float fDiffX = Math.Max(Math.Abs(p1X - p4X), Math.Abs(p2X - p3X));
                                        float fDiffY = Math.Max(Math.Abs(p3Y - p4Y), Math.Abs(p2Y - p1Y));

                                        fObjectWidthList[i] = fDiffX;
                                        fObjectHeightList[i] = fDiffY;

                                        fObjectCenterXList[i] = pCenter.X;
                                        fObjectCenterYList[i] = pCenter.Y;

                                        fObjectAreaList2.RemoveAt(j);
                                        fObjectAreaList[i] = fObjectAreaList[i] + fObjectAreaList[j];

                                        fObjectHeightList.RemoveAt(j);
                                        fObjectWidthList.RemoveAt(j);
                                        fObjectCenterXList.RemoveAt(j);
                                        fObjectCenterYList.RemoveAt(j);
                                        fObjectAngleList.RemoveAt(j);
                                        fObjectAreaList.RemoveAt(j);

                                        if (j > 0)
                                            j = -1;
                                        if (i > 0)
                                        {
                                            i = 0;
                                        }
                                        else
                                            blnDecrement = true;

                                    }
                                }
                            }
                        }
                    }
                    float fStartX, fStartY, fEndX, fEndY, fWidthMM, fHeightMM, fAreaInMM;
                    for (int i = 0; i < fObjectHeightList.Count; i++)
                    {
                        if (fObjectHeightList[i] < fObjectWidthList[i])
                        {
                            fObjectWidth = fObjectHeightList[i];
                            fObjectHeight = fObjectWidthList[i];

                            fObjectAngle = fObjectAngleList[i];

                            if (fObjectAngle >= 10)//&& fAngle <= 80)
                                fObjectAngle = fObjectAngleList[i] - 90;
                            else
                                fObjectAngle = 90 + fObjectAngleList[i];

                            fObjectWidthList[i] = fObjectWidth;
                            fObjectHeightList[i] = fObjectHeight;
                            fObjectAngleList[i] = fObjectAngle;
                        }
                        else
                        {
                            fObjectHeight = fObjectHeightList[i];
                            fObjectWidth = fObjectWidthList[i];

                            fObjectAngle = fObjectAngleList[i];

                            fObjectWidthList[i] = fObjectWidth;
                            fObjectHeightList[i] = fObjectHeight;
                            fObjectAngleList[i] = fObjectAngle;
                        }

                        fObjectCenterXList[i] += intStartPixelFromEdgeX;
                        fObjectCenterYList[i] += intStartPixelFromEdgeY;
                        fStartX = (float)Math.Floor(fObjectCenterXList[i] - (fObjectWidthList[i] / 2));
                        fStartY = (float)Math.Floor(fObjectCenterYList[i] - (fObjectHeightList[i] / 2));
                        fEndX = (float)Math.Ceiling(fObjectCenterXList[i] + (fObjectWidthList[i] / 2));
                        fEndY = (float)Math.Ceiling(fObjectCenterYList[i] + (fObjectHeightList[i] / 2));

                        // convert width and height to mm
                        fWidthMM = fObjectWidthList[i] / m_fMMToPixelXValue;
                        fHeightMM = fObjectHeightList[i] / m_fMMToPixelYValue;
                        fAreaInMM = fObjectAreaList[i] / m_fMMToPixelXValue / m_fMMToPixelYValue;
                        
                        ColorDefect objDefect = new ColorDefect();

                        objDefect.ref_strName = m_arrDefectColorThresName[intColorThresIndex];
                        objDefect.ref_intFailMask = intFailMask;
                        objDefect.ref_fCenterX = objThresholdSampleROI.ref_ROITotalX + fObjectCenterXList[i];
                        objDefect.ref_fCenterY = objThresholdSampleROI.ref_ROITotalY + fObjectCenterYList[i];
                        objDefect.ref_fStartX = objThresholdSampleROI.ref_ROITotalX + fStartX;
                        objDefect.ref_fStartY = objThresholdSampleROI.ref_ROITotalY + fStartY;
                        objDefect.ref_fEndX = objThresholdSampleROI.ref_ROITotalX + fEndX;
                        objDefect.ref_fEndY = objThresholdSampleROI.ref_ROITotalY + fEndY;
                        objDefect.ref_fWidth = fObjectWidthList[i];
                        objDefect.ref_fHeight = fObjectHeightList[i];
                        objDefect.ref_fArea = fObjectAreaList[i];
                        objDefect.ref_fAngle = fObjectAngleList[i];
                        objDefect.ref_fWidthInMM = fWidthMM;
                        objDefect.ref_fHeightInMM = fHeightMM;
                        objDefect.ref_fAreaInMM2 = fAreaInMM;
                        objDefect.ref_intImageNo = m_arrDefectImageNo[intColorThresIndex] + 1;

                        if (blnCheckLength)
                        {
                            if (m_arrDefectColorInspectionFailCondition[intColorThresIndex] == 0)
                            {
                                if (fWidthMM > m_arrDefectColorInspectionWidth[intColorThresIndex])
                                {
                                    m_intFailColorResultMask |= intFailMask;

                                    blnOverallResult = false;
                                    objDefect.ref_fWidthFailValue = fWidthMM;
                                    objDefect.ref_intFailCriteria |= 0x01;
                                    blnResult = false;
                                }
                                if (fHeightMM > m_arrDefectColorInspectionLength[intColorThresIndex])
                                {
                                    m_intFailColorResultMask |= intFailMask;

                                    blnOverallResult = false;
                                    objDefect.ref_fHeightFailValue = fHeightMM;
                                    objDefect.ref_intFailCriteria |= 0x02;
                                    blnResult = false;
                                }
                            }
                            else
                            {
                                if ((fWidthMM > m_arrDefectColorInspectionWidth[intColorThresIndex]) && (fHeightMM > m_arrDefectColorInspectionLength[intColorThresIndex]))
                                {
                                    m_intFailColorResultMask |= intFailMask;

                                    blnOverallResult = false;
                                    objDefect.ref_fWidthFailValue = fWidthMM;
                                    objDefect.ref_fHeightFailValue = fHeightMM;
                                    objDefect.ref_intFailCriteria |= 0x01;
                                    objDefect.ref_intFailCriteria |= 0x02;
                                    blnResult = false;
                                }
                            }
                        }

                        if (blnCheckArea)
                        {
                            if (/*fAreaInMM < m_arrDefectColorInspectionMinArea[intColorThresIndex] ||*/ fAreaInMM > m_arrDefectColorInspectionMaxArea[intColorThresIndex])
                            {
                                m_intFailColorResultMask |= intFailMask;

                                blnOverallResult = false;
                                objDefect.ref_fAreaFailValue = fAreaInMM;
                                objDefect.ref_intFailCriteria |= 0x04;
                                blnResult = false;
                            }
                        }

                        m_arrColorDefectList.Add(objDefect);
                    }

                    if (blnCheckArea)
                    {
                        fAreaInMM = intObjectTotalArea / m_fMMToPixelXValue / m_fMMToPixelYValue;

                        if (fAreaInMM > m_arrDefectColorInspectionTotalArea[intColorThresIndex])
                        {
                            ColorDefect objDefect = new ColorDefect();

                            objDefect.ref_strName = m_arrDefectColorThresName[intColorThresIndex];
                            objDefect.ref_intFailMask = intFailMask;
                            objDefect.ref_fCenterX = -1;
                            objDefect.ref_fCenterY = -1;
                            objDefect.ref_fStartX = -1;
                            objDefect.ref_fStartY = -1;
                            objDefect.ref_fEndX = -1;
                            objDefect.ref_fEndY = -1;
                            objDefect.ref_fWidth = -1;
                            objDefect.ref_fHeight = -1;
                            objDefect.ref_fArea = intObjectTotalArea;
                            objDefect.ref_fWidthInMM = -1;
                            objDefect.ref_fHeightInMM = -1;
                            objDefect.ref_fAreaInMM2 = fAreaInMM;
                            objDefect.ref_intImageNo = m_arrDefectImageNo[intColorThresIndex] + 1;
                            objDefect.ref_blnFailTotalArea = true;
                            blnOverallResult = false;
                            objDefect.ref_fAreaFailValue = fAreaInMM;
                            objDefect.ref_intFailCriteria |= 0x08;

                            m_arrColorDefectList.Add(objDefect);

                            m_intFailColorResultMask |= intFailMask;

                            for (int b = 0; b < m_arrColorDefectList.Count; b++)
                            {
                                if (((ColorDefect)m_arrColorDefectList[b]).ref_strName == m_arrDefectColorThresName[intColorThresIndex])
                                {
                                    if (!((ColorDefect)m_arrColorDefectList[b]).ref_blnFailTotalArea)
                                    {
                                        ColorDefect objDefect2 = m_arrColorDefectList[b];
                                        objDefect2.ref_blnFailTotalArea = true;
                                        m_arrColorDefectList.RemoveAt(b);
                                        m_arrColorDefectList.Insert(b, objDefect2);
                                    }
                                }
                            }

                            blnResult = false;
                        }

                    }
                }
            }
            objThresholdSampleROI.Dispose();
            objThresholdSampleROI_Temp.Dispose();
            return blnResult;
        }
        private bool CheckColorDefect_TiltAngle(CROI objSampleUnitROI, List<CImageDrawing> arrColorImages, ROI objSampleROI)
        {
            if (m_arrDefectColorThresName.Count == 0)
                return true;

            if ((((m_intFailColorOptionMask & 0x03) == 0) && m_arrDefectColorThresName.Count == 1) &&
                (((m_intFailColorOptionMask & 0x0C) == 0) && m_arrDefectColorThresName.Count == 2) &&
                (((m_intFailColorOptionMask & 0x30) == 0) && m_arrDefectColorThresName.Count == 3) &&
                (((m_intFailColorOptionMask & 0xC0) == 0) && m_arrDefectColorThresName.Count == 4) &&
                (((m_intFailColorOptionMask & 0x300) == 0) && m_arrDefectColorThresName.Count == 5))
                return true;

            bool blnResult = true;
            bool blnDebugImage = false;

            //float fPkgOffsetX = (objSampleUnitROI.ref_ROIWidth - Math.Max(GetResultUpWidth_RectGauge4L(0), GetResultDownWidth_RectGauge4L(0))) / 2;
            //float fPkgOffsetY = (objSampleUnitROI.ref_ROIHeight - Math.Max(GetResultLeftHeight_RectGauge4L(0), GetResultRightHeight_RectGauge4L(0))) / 2;

            int intStartPixelFromEdgeX = 0;// (int)Math.Round(fPkgOffsetX - m_intPadROIStartPixelFromLeft, 0, MidpointRounding.AwayFromZero); //m_fPkgStartPixelFromLeft
            int intStartPixelFromEdgeY = 0;// (int)Math.Round(fPkgOffsetY - m_intPadROIStartPixelFromTop, 0, MidpointRounding.AwayFromZero); //m_fPkgStartPixelFromEdge
            //int intStartPixelFromEdgeX2 = (int)Math.Round(fPkgOffsetX + m_intPadROIStartPixelFromRight, 0, MidpointRounding.AwayFromZero); //m_fPkgStartPixelFromRight
            //int intStartPixelFromEdgeY2 = (int)Math.Round(fPkgOffsetY + m_intPadROIStartPixelFromBottom, 0, MidpointRounding.AwayFromZero); //m_fPkgStartPixelFromBottom

            ROI objThresholdSampleROI = new ROI();
            objThresholdSampleROI.AttachImage(m_objInsPadPkgImage1); // Attach sample ROI to ori size image. m_objInsPadPkgImage1 is a ori size image used to keep the sample image temporary for modification such as double threshold
            objThresholdSampleROI.LoadROISetting(objSampleUnitROI.ref_ROIPositionX, objSampleUnitROI.ref_ROIPositionY, objSampleUnitROI.ref_ROIWidth, objSampleUnitROI.ref_ROIHeight);

            if (blnDebugImage)
            {
                objSampleUnitROI.SaveImage("D:\\TS\\1.objSampleUnitROI" + m_intPadROIDirection + ".bmp");
            }

            for (int intColorThresIndex = 0; intColorThresIndex < m_arrDefectColor.Count; intColorThresIndex++)
            {
                if (intColorThresIndex == 0 && ((m_intFailColorOptionMask & 0x03) == 0))
                    continue;
                else if (intColorThresIndex == 1 && ((m_intFailColorOptionMask & 0x0C) == 0))
                    continue;
                else if (intColorThresIndex == 2 && ((m_intFailColorOptionMask & 0x30) == 0))
                    continue;
                else if (intColorThresIndex == 3 && ((m_intFailColorOptionMask & 0xC0) == 0))
                    continue;
                else if (intColorThresIndex == 4 && ((m_intFailColorOptionMask & 0x300) == 0))
                    continue;

                if (!blnResult)
                    break;

                objSampleUnitROI.AttachImage(arrColorImages[CImageDrawing.GetArrayImageIndex(m_arrDefectImageNo[intColorThresIndex], m_intVisionIndex)]);

                if (blnDebugImage)
                {
                    arrColorImages[CImageDrawing.GetArrayImageIndex(m_arrDefectImageNo[intColorThresIndex], m_intVisionIndex)].SaveImage("D:\\TS\\arrColorImage" + CImageDrawing.GetArrayImageIndex(m_arrDefectImageNo[intColorThresIndex], m_intVisionIndex) + m_intPadROIDirection + ".bmp");
                    objSampleUnitROI.SaveImage("D:\\TS\\1_1.objSampleUnitROI2" + m_intPadROIDirection + ".bmp");
                }

                bool blnCheckLength = false;
                bool blnCheckArea = false;
                int intFailMask = 0;
                if (intColorThresIndex == 0)
                {
                    intFailMask = 0x01;
                    if ((m_intFailColorOptionMask & 0x01) > 0)
                        blnCheckLength = true;
                    if ((m_intFailColorOptionMask & 0x02) > 0)
                        blnCheckArea = true;
                }
                else if (intColorThresIndex == 1)
                {
                    intFailMask = 0x02;
                    if ((m_intFailColorOptionMask & 0x04) > 0)
                        blnCheckLength = true;
                    if ((m_intFailColorOptionMask & 0x08) > 0)
                        blnCheckArea = true;
                }
                else if (intColorThresIndex == 2)
                {
                    intFailMask = 0x04;
                    if ((m_intFailColorOptionMask & 0x10) > 0)
                        blnCheckLength = true;
                    if ((m_intFailColorOptionMask & 0x20) > 0)
                        blnCheckArea = true;
                }
                else if (intColorThresIndex == 3)
                {
                    intFailMask = 0x08;
                    if ((m_intFailColorOptionMask & 0x40) > 0)
                        blnCheckLength = true;
                    if ((m_intFailColorOptionMask & 0x80) > 0)
                        blnCheckArea = true;
                }
                else if (intColorThresIndex == 4)
                {
                    intFailMask = 0x10;
                    if ((m_intFailColorOptionMask & 0x100) > 0)
                        blnCheckLength = true;
                    if ((m_intFailColorOptionMask & 0x200) > 0)
                        blnCheckArea = true;
                }

                int intSelectedObjectNum = 0;
                // Get color threshold min max value
                m_objColorBlobs.ref_C24LowColorThreshold = ColorProcessing.CalculateMinColor(m_arrDefectColor[intColorThresIndex], m_arrDefectColorTolerance[intColorThresIndex]).ref_Color24;
                m_objColorBlobs.ref_C24HighColorThreshold = ColorProcessing.CalculateMaxColor(m_arrDefectColor[intColorThresIndex], m_arrDefectColorTolerance[intColorThresIndex]).ref_Color24;

                // Threshold color image 
                if (m_arrDefectColorSystem[intColorThresIndex] == 0)
                    EasyImage.Threshold(objSampleUnitROI.ref_CROI, objThresholdSampleROI.ref_ROI, m_objColorBlobs.ref_C24LowColorThreshold, m_objColorBlobs.ref_C24HighColorThreshold, m_objColorLookupLSH);
                else if (m_arrDefectColorSystem[intColorThresIndex] == 1)
                    EasyImage.Threshold(objSampleUnitROI.ref_CROI, objThresholdSampleROI.ref_ROI, m_objColorBlobs.ref_C24LowColorThreshold, m_objColorBlobs.ref_C24HighColorThreshold, m_objColorLookupRGB);
                else
                {
                    EasyColor.GetComponent(objSampleUnitROI.ref_CROI, objThresholdSampleROI.ref_ROI, 1, m_objColorLookupYSH);
                    if (blnDebugImage)
                        objThresholdSampleROI.SaveImage("D:\\TS\\1_2.SaturationImg" + m_intPadROIDirection + intColorThresIndex + ".bmp");
#if (Debug_2_12 || Release_2_12)
                    EasyImage.Threshold(objThresholdSampleROI.ref_ROI, objThresholdSampleROI.ref_ROI, (uint)m_arrDefectColor[intColorThresIndex][0]);
#elif (DEBUG || RELEASE || RTXRelease || RTXDebug)
                    EasyImage.Threshold(objThresholdSampleROI.ref_ROI, objThresholdSampleROI.ref_ROI, m_arrDefectColor[intColorThresIndex][0]);
#endif
                }

                if (blnDebugImage)
                    objThresholdSampleROI.SaveImage("D:\\TS\\2.objThresholdSampleROI" + m_intPadROIDirection + intColorThresIndex + ".bmp");

                //2019-09-23 ZJYEOH : Subtract tilt dont care area 
                if (m_intPadROIDirection == 1) // Top
                {
                    ROI DontCareTop = new ROI();

                    DontCareTop.LoadROISetting(0, 0, objThresholdSampleROI.ref_ROIWidth, objThresholdSampleROI.ref_ROIHeight);
                    DontCareTop.AttachImage(m_ImgTilt_Top_L);
                    EasyImage.Oper(EArithmeticLogicOperation.Subtract, objThresholdSampleROI.ref_ROI, DontCareTop.ref_ROI, objThresholdSampleROI.ref_ROI);
                    DontCareTop.LoadROISetting(m_ImgTilt_Top_R.ref_intImageWidth - objThresholdSampleROI.ref_ROIWidth, 0, objThresholdSampleROI.ref_ROIWidth, objThresholdSampleROI.ref_ROIHeight);
                    DontCareTop.AttachImage(m_ImgTilt_Top_R);
                    EasyImage.Oper(EArithmeticLogicOperation.Subtract, objThresholdSampleROI.ref_ROI, DontCareTop.ref_ROI, objThresholdSampleROI.ref_ROI);
                    if (blnDebugImage)
                        objThresholdSampleROI.SaveImage("D:\\TS\\objThresholdSampleROI_Top" + m_intPadROIDirection + intColorThresIndex + ".bmp");
                    DontCareTop.Dispose();
                }
                if (m_intPadROIDirection == 2) // Right
                {
                    ROI DontCareRight = new ROI();
                    DontCareRight.LoadROISetting(m_ImgTilt_Top_R.ref_intImageWidth - objThresholdSampleROI.ref_ROIWidth, 0, objThresholdSampleROI.ref_ROIWidth, objThresholdSampleROI.ref_ROIHeight);
                    DontCareRight.AttachImage(m_ImgTilt_Right_T);
                    EasyImage.Oper(EArithmeticLogicOperation.Subtract, objThresholdSampleROI.ref_ROI, DontCareRight.ref_ROI, objThresholdSampleROI.ref_ROI);
                    DontCareRight.LoadROISetting(m_ImgTilt_Top_R.ref_intImageWidth - objThresholdSampleROI.ref_ROIWidth, m_ImgTilt_Top_R.ref_intImageHeight - objThresholdSampleROI.ref_ROIHeight, objThresholdSampleROI.ref_ROIWidth, objThresholdSampleROI.ref_ROIHeight);
                    DontCareRight.AttachImage(m_ImgTilt_Right_B);
                    EasyImage.Oper(EArithmeticLogicOperation.Subtract, objThresholdSampleROI.ref_ROI, DontCareRight.ref_ROI, objThresholdSampleROI.ref_ROI);
                    if (blnDebugImage)
                        objThresholdSampleROI.SaveImage("D:\\TS\\objThresholdSampleROI_Right" + m_intPadROIDirection + intColorThresIndex + ".bmp");
                    DontCareRight.Dispose();
                }
                if (m_intPadROIDirection == 3) // Bottom
                {
                    ROI DontCareBottom = new ROI();

                    DontCareBottom.LoadROISetting(0, m_ImgTilt_Top_R.ref_intImageHeight - objThresholdSampleROI.ref_ROIHeight, objThresholdSampleROI.ref_ROIWidth, objThresholdSampleROI.ref_ROIHeight);
                    DontCareBottom.AttachImage(m_ImgTilt_Bottom_L);
                    EasyImage.Oper(EArithmeticLogicOperation.Subtract, objThresholdSampleROI.ref_ROI, DontCareBottom.ref_ROI, objThresholdSampleROI.ref_ROI);
                    DontCareBottom.LoadROISetting(m_ImgTilt_Top_R.ref_intImageWidth - objThresholdSampleROI.ref_ROIWidth, m_ImgTilt_Top_R.ref_intImageHeight - objThresholdSampleROI.ref_ROIHeight, objThresholdSampleROI.ref_ROIWidth, objThresholdSampleROI.ref_ROIHeight);
                    DontCareBottom.AttachImage(m_ImgTilt_Bottom_R);
                    EasyImage.Oper(EArithmeticLogicOperation.Subtract, objThresholdSampleROI.ref_ROI, DontCareBottom.ref_ROI, objThresholdSampleROI.ref_ROI);
                    if (blnDebugImage)
                        objThresholdSampleROI.SaveImage("D:\\TS\\objThresholdSampleROI_Bottom" + m_intPadROIDirection + intColorThresIndex + ".bmp");
                    DontCareBottom.Dispose();
                }
                if (m_intPadROIDirection == 4) // Left
                {
                    ROI DontCareLeft = new ROI();

                    DontCareLeft.LoadROISetting(0, 0, objThresholdSampleROI.ref_ROIWidth, objThresholdSampleROI.ref_ROIHeight);
                    DontCareLeft.AttachImage(m_ImgTilt_Left_T);
                    EasyImage.Oper(EArithmeticLogicOperation.Subtract, objThresholdSampleROI.ref_ROI, DontCareLeft.ref_ROI, objThresholdSampleROI.ref_ROI);
                    DontCareLeft.LoadROISetting(0, m_ImgTilt_Top_R.ref_intImageHeight - objThresholdSampleROI.ref_ROIHeight, objThresholdSampleROI.ref_ROIWidth, objThresholdSampleROI.ref_ROIHeight);
                    DontCareLeft.AttachImage(m_ImgTilt_Left_B);
                    EasyImage.Oper(EArithmeticLogicOperation.Subtract, objThresholdSampleROI.ref_ROI, DontCareLeft.ref_ROI, objThresholdSampleROI.ref_ROI);
                    if (blnDebugImage)
                        objThresholdSampleROI.SaveImage("D:\\TS\\objThresholdSampleROI_Left" + m_intPadROIDirection + intColorThresIndex + ".bmp");
                    DontCareLeft.Dispose();
                }

                if (blnDebugImage)
                    objThresholdSampleROI.SaveImage("D:\\TS\\3.objThresholdSampleROI_AfterTiltAngle" + m_intPadROIDirection + intColorThresIndex + ".bmp");

                SubtractColorDontCareImage(objSampleROI, objThresholdSampleROI, m_arrDefectDontCareMode[intColorThresIndex], m_arrPadColorDontCareImage[intColorThresIndex]);

                objThresholdSampleROI.LoadROISetting(objSampleUnitROI.ref_ROITotalX + GetColorDefectInspection_Left(intColorThresIndex),
                    objSampleUnitROI.ref_ROITotalY + GetColorDefectInspection_Top(intColorThresIndex),
                    objSampleUnitROI.ref_ROIWidth - GetColorDefectInspection_Left(intColorThresIndex) - GetColorDefectInspection_Right(intColorThresIndex),
                    objSampleUnitROI.ref_ROIHeight - GetColorDefectInspection_Top(intColorThresIndex) - GetColorDefectInspection_Bottom(intColorThresIndex));

                if (blnDebugImage)
                    objThresholdSampleROI.SaveImage("D:\\TS\\4.objThresholdSampleROI" + m_intPadROIDirection + intColorThresIndex + ".bmp");

                intSelectedObjectNum = m_objColorBlobs.BuildObjects_Filter_GetElement(objThresholdSampleROI, !m_blnWhiteOnBlack, true, 0, -4,
                m_arrDefectColorMinArea[intColorThresIndex], objSampleUnitROI.ref_ROIWidth * objSampleUnitROI.ref_ROIHeight, false, 0xFF);

                if (intSelectedObjectNum == 0 && m_arrDefectType[intColorThresIndex] == 1)
                {
                    ColorDefect objDefect = new ColorDefect();

                    objDefect.ref_strName = m_arrDefectColorThresName[intColorThresIndex];
                    objDefect.ref_intFailMask = intFailMask;
                    objDefect.ref_fCenterX = -1;
                    objDefect.ref_fCenterY = -1;
                    objDefect.ref_fStartX = -1;
                    objDefect.ref_fStartY = -1;
                    objDefect.ref_fEndX = -1;
                    objDefect.ref_fEndY = -1;
                    objDefect.ref_fWidth = -1;
                    objDefect.ref_fHeight = -1;
                    objDefect.ref_fArea = -1;
                    objDefect.ref_fWidthInMM = -1;
                    objDefect.ref_fHeightInMM = -1;
                    objDefect.ref_fAreaInMM2 = -1;
                    objDefect.ref_intImageNo = m_arrDefectImageNo[intColorThresIndex] + 1;

                    objDefect.ref_fAreaFailValue = -1;
                    objDefect.ref_intFailCriteria |= 0x10;

                    m_arrColorDefectList.Add(objDefect);

                    m_intFailColorResultMask |= intFailMask;

                    blnResult = false;
                }

                bool blnOverallResult = true;
                if (intSelectedObjectNum > 0)
                {
                    float fCenterX = 0, fCenterY = 0, fWidth = 0, fHeight = 0;
                    float fStartX, fStartY, fEndX, fEndY, fAngle = 0;
                    int intArea = 0;
                    float fWidthMM, fHeightMM, fAreaInMM;
                    int intFailCount = 0;

                    int intTotalArea = 0;
                    for (int i = 0; i < intSelectedObjectNum; i++)
                    {
                        intArea = m_objColorBlobs.ref_arrArea[i];

                        if (m_objColorBlobs.ref_arrRectWidth[i] < m_objColorBlobs.ref_arrRectHeight[i])
                        {
                            fWidth = m_objColorBlobs.ref_arrRectWidth[i];
                            fHeight = m_objColorBlobs.ref_arrRectHeight[i];

                            fAngle = m_objColorBlobs.ref_arrRectAngle[i];


                            if (fAngle < 0)
                                fAngle = -Math.Abs(fAngle);
                            else
                                fAngle = -fAngle;
                        }
                        else
                        {
                            fWidth = m_objColorBlobs.ref_arrRectHeight[i];
                            fHeight = m_objColorBlobs.ref_arrRectWidth[i];

                            fAngle = m_objColorBlobs.ref_arrRectAngle[i];


                            if (fAngle < 0)
                                fAngle = Math.Abs(fAngle);
                            else
                                fAngle = 90 - (fAngle);
                        }
                        fCenterX = m_objColorBlobs.ref_arrRectLimitCenterX[i];
                        fCenterY = m_objColorBlobs.ref_arrRectLimitCenterY[i];

                        intTotalArea += intArea;
                        fCenterX += intStartPixelFromEdgeX;
                        fCenterY += intStartPixelFromEdgeY;
                        fStartX = (float)Math.Floor(fCenterX - (fWidth / 2));
                        fStartY = (float)Math.Floor(fCenterY - (fHeight / 2));
                        fEndX = (float)Math.Ceiling(fCenterX + (fWidth / 2));
                        fEndY = (float)Math.Ceiling(fCenterY + (fHeight / 2));

                        // convert width and height to mm
                        fWidthMM = fWidth / m_fMMToPixelXValue;
                        fHeightMM = fHeight / m_fMMToPixelYValue; // 11-04-2019 ZJYEOH : Changed m_fMMToPixelXValue to m_fMMToPixelYValue
                        fAreaInMM = intArea / m_fMMToPixelXValue / m_fMMToPixelYValue;

                        {
                            intFailCount++;

                            ColorDefect objDefect = new ColorDefect();

                            objDefect.ref_strName = m_arrDefectColorThresName[intColorThresIndex];
                            objDefect.ref_intFailMask = intFailMask;
                            objDefect.ref_fCenterX = objThresholdSampleROI.ref_ROITotalX + fCenterX;
                            objDefect.ref_fCenterY = objThresholdSampleROI.ref_ROITotalY + fCenterY;
                            objDefect.ref_fStartX = objThresholdSampleROI.ref_ROITotalX + fStartX;
                            objDefect.ref_fStartY = objThresholdSampleROI.ref_ROITotalY + fStartY;
                            objDefect.ref_fEndX = objThresholdSampleROI.ref_ROITotalX + fEndX;
                            objDefect.ref_fEndY = objThresholdSampleROI.ref_ROITotalY + fEndY;
                            objDefect.ref_fWidth = fWidth;
                            objDefect.ref_fHeight = fHeight;
                            objDefect.ref_fArea = intArea;
                            objDefect.ref_fAngle = fAngle;
                            objDefect.ref_fWidthInMM = fWidthMM;
                            objDefect.ref_fHeightInMM = fHeightMM;
                            objDefect.ref_fAreaInMM2 = fAreaInMM;
                            objDefect.ref_intImageNo = m_arrDefectImageNo[intColorThresIndex] + 1;

                            if (blnCheckLength)
                            {
                                if (m_arrDefectColorInspectionFailCondition[intColorThresIndex] == 0)
                                {
                                    if (fWidthMM > m_arrDefectColorInspectionWidth[intColorThresIndex])
                                    {
                                        m_intFailColorResultMask |= intFailMask;

                                        blnOverallResult = false;
                                        objDefect.ref_fWidthFailValue = fWidthMM;
                                        objDefect.ref_intFailCriteria |= 0x01;
                                        blnResult = false;
                                    }
                                    if (fHeightMM > m_arrDefectColorInspectionLength[intColorThresIndex])
                                    {
                                        m_intFailColorResultMask |= intFailMask;

                                        blnOverallResult = false;
                                        objDefect.ref_fHeightFailValue = fHeightMM;
                                        objDefect.ref_intFailCriteria |= 0x02;
                                        blnResult = false;
                                    }
                                }
                                else
                                {
                                    if ((fWidthMM > m_arrDefectColorInspectionWidth[intColorThresIndex]) && (fHeightMM > m_arrDefectColorInspectionLength[intColorThresIndex]))
                                    {
                                        m_intFailColorResultMask |= intFailMask;

                                        blnOverallResult = false;
                                        objDefect.ref_fWidthFailValue = fWidthMM;
                                        objDefect.ref_fHeightFailValue = fHeightMM;
                                        objDefect.ref_intFailCriteria |= 0x01;
                                        objDefect.ref_intFailCriteria |= 0x02;
                                        blnResult = false;
                                    }
                                }
                            }

                            if (blnCheckArea)
                            {
                                if (/*fAreaInMM < m_arrDefectColorInspectionMinArea[intColorThresIndex] ||*/ fAreaInMM > m_arrDefectColorInspectionMaxArea[intColorThresIndex])
                                {
                                    m_intFailColorResultMask |= intFailMask;

                                    blnOverallResult = false;
                                    objDefect.ref_fAreaFailValue = fAreaInMM;
                                    objDefect.ref_intFailCriteria |= 0x04;
                                    blnResult = false;
                                }
                            }

                            m_arrColorDefectList.Add(objDefect);
                        }

                    }

                    if (blnCheckArea)
                    {
                        fAreaInMM = intTotalArea / m_fMMToPixelXValue / m_fMMToPixelYValue;

                        if (fAreaInMM > m_arrDefectColorInspectionTotalArea[intColorThresIndex])
                        {
                            ColorDefect objDefect = new ColorDefect();

                            objDefect.ref_strName = m_arrDefectColorThresName[intColorThresIndex];
                            objDefect.ref_intFailMask = intFailMask;
                            objDefect.ref_fCenterX = -1;
                            objDefect.ref_fCenterY = -1;
                            objDefect.ref_fStartX = -1;
                            objDefect.ref_fStartY = -1;
                            objDefect.ref_fEndX = -1;
                            objDefect.ref_fEndY = -1;
                            objDefect.ref_fWidth = -1;
                            objDefect.ref_fHeight = -1;
                            objDefect.ref_fArea = intTotalArea;
                            objDefect.ref_fWidthInMM = -1;
                            objDefect.ref_fHeightInMM = -1;
                            objDefect.ref_fAreaInMM2 = fAreaInMM;
                            objDefect.ref_intImageNo = m_arrDefectImageNo[intColorThresIndex] + 1;
                            objDefect.ref_blnFailTotalArea = true;

                            blnOverallResult = false;
                            objDefect.ref_fAreaFailValue = fAreaInMM;
                            objDefect.ref_intFailCriteria |= 0x08;

                            m_arrColorDefectList.Add(objDefect);

                            m_intFailColorResultMask |= intFailMask;

                            //for (int b = 0; b < m_arrColorDefectList.Count; b++)
                            //{
                            //    if (((ColorDefect)m_arrColorDefectList[b]).ref_strName == m_arrDefectColorThresName[intColorThresIndex])
                            //    {
                            //        if (!((ColorDefect)m_arrColorDefectList[b]).ref_blnFailTotalArea)
                            //        {
                            //            ColorDefect objDefect2 = m_arrColorDefectList[b];
                            //            objDefect2.ref_blnFailTotalArea = true;
                            //            m_arrColorDefectList.RemoveAt(b);
                            //            m_arrColorDefectList.Insert(b, objDefect2);
                            //        }
                            //    }
                            //}

                            blnResult = false;
                        }
                        
                    }
                }
            }
            objThresholdSampleROI.Dispose();
            return blnResult;
        }
        private bool CheckColorDefect_TiltAngle_CombineSameName(CROI objSampleUnitROI, List<CImageDrawing> arrColorImages, ROI objSampleROI, ImageDrawing objBlackImage)
        {
            if (m_arrDefectColorThresName.Count == 0)
                return true;

            if ((((m_intFailColorOptionMask & 0x03) == 0) && m_arrDefectColorThresName.Count == 1) &&
                (((m_intFailColorOptionMask & 0x0C) == 0) && m_arrDefectColorThresName.Count == 2) &&
                (((m_intFailColorOptionMask & 0x30) == 0) && m_arrDefectColorThresName.Count == 3) &&
                (((m_intFailColorOptionMask & 0xC0) == 0) && m_arrDefectColorThresName.Count == 4) &&
                (((m_intFailColorOptionMask & 0x300) == 0) && m_arrDefectColorThresName.Count == 5))
                return true;

            bool blnResult = true;
            bool blnDebugImage = false;

            //float fPkgOffsetX = (objSampleUnitROI.ref_ROIWidth - Math.Max(GetResultUpWidth_RectGauge4L(0), GetResultDownWidth_RectGauge4L(0))) / 2;
            //float fPkgOffsetY = (objSampleUnitROI.ref_ROIHeight - Math.Max(GetResultLeftHeight_RectGauge4L(0), GetResultRightHeight_RectGauge4L(0))) / 2;

            int intStartPixelFromEdgeX = 0;// (int)Math.Round(fPkgOffsetX - m_intPadROIStartPixelFromLeft, 0, MidpointRounding.AwayFromZero); //m_fPkgStartPixelFromLeft
            int intStartPixelFromEdgeY = 0;// (int)Math.Round(fPkgOffsetY - m_intPadROIStartPixelFromTop, 0, MidpointRounding.AwayFromZero); //m_fPkgStartPixelFromEdge
            //int intStartPixelFromEdgeX2 = (int)Math.Round(fPkgOffsetX + m_intPadROIStartPixelFromRight, 0, MidpointRounding.AwayFromZero); //m_fPkgStartPixelFromRight
            //int intStartPixelFromEdgeY2 = (int)Math.Round(fPkgOffsetY + m_intPadROIStartPixelFromBottom, 0, MidpointRounding.AwayFromZero); //m_fPkgStartPixelFromBottom

            ROI objThresholdSampleROI = new ROI();
            objThresholdSampleROI.AttachImage(m_objInsPadPkgImage1); // Attach sample ROI to ori size image. m_objInsPadPkgImage1 is a ori size image used to keep the sample image temporary for modification such as double threshold
            objThresholdSampleROI.LoadROISetting(objSampleUnitROI.ref_ROIPositionX, objSampleUnitROI.ref_ROIPositionY, objSampleUnitROI.ref_ROIWidth, objSampleUnitROI.ref_ROIHeight);

            ROI objThresholdSampleROI_Temp = new ROI();
            objThresholdSampleROI_Temp.AttachImage(m_objInsSurfacePkgImage1); // Attach sample ROI to ori size image. m_objInsSurfacePkgImage1 is a ori size image used to keep the sample image temporary for modification such as double threshold
            objThresholdSampleROI_Temp.LoadROISetting(objSampleUnitROI.ref_ROIPositionX, objSampleUnitROI.ref_ROIPositionY, objSampleUnitROI.ref_ROIWidth, objSampleUnitROI.ref_ROIHeight);

            if (blnDebugImage)
            {
                objSampleUnitROI.SaveImage("D:\\TS\\1.objSampleUnitROI" + m_intPadROIDirection + ".bmp");
            }
            List<int> arrSkip = new List<int>();
            for (int intColorThresIndex = 0; intColorThresIndex < m_arrDefectColor.Count; intColorThresIndex++)
            {
                if (intColorThresIndex == 0 && ((m_intFailColorOptionMask & 0x03) == 0))
                    continue;
                else if (intColorThresIndex == 1 && ((m_intFailColorOptionMask & 0x0C) == 0))
                    continue;
                else if (intColorThresIndex == 2 && ((m_intFailColorOptionMask & 0x30) == 0))
                    continue;
                else if (intColorThresIndex == 3 && ((m_intFailColorOptionMask & 0xC0) == 0))
                    continue;
                else if (intColorThresIndex == 4 && ((m_intFailColorOptionMask & 0x300) == 0))
                    continue;

                if (!blnResult)
                    break;

                objBlackImage.CopyTo(ref m_objInsPadPkgImage1);
                string strThresName = m_arrDefectColorThresName[intColorThresIndex];
                if (!arrSkip.Contains(intColorThresIndex))
                {
                    bool blnFirstTime = true;
                    for (int i = 0; i < m_arrDefectColor.Count; i++)
                    {
                        if (!arrSkip.Contains(i) && strThresName == m_arrDefectColorThresName[i])
                        {
                            arrSkip.Add(i);
                        }
                        else
                            continue;

                        objSampleUnitROI.AttachImage(arrColorImages[CImageDrawing.GetArrayImageIndex(m_arrDefectImageNo[i], m_intVisionIndex)]);

                        if (blnDebugImage)
                        {
                            arrColorImages[CImageDrawing.GetArrayImageIndex(m_arrDefectImageNo[i], m_intVisionIndex)].SaveImage("D:\\TS\\arrColorImage" + CImageDrawing.GetArrayImageIndex(m_arrDefectImageNo[i], m_intVisionIndex) + m_intPadROIDirection + ".bmp");
                            objSampleUnitROI.SaveImage("D:\\TS\\1_1.objSampleUnitROI2" + m_intPadROIDirection + ".bmp");
                        }
                        objBlackImage.CopyTo(ref m_objInsSurfacePkgImage1);
                        // Get color threshold min max value
                        m_objColorBlobs.ref_C24LowColorThreshold = ColorProcessing.CalculateMinColor(m_arrDefectColor[i], m_arrDefectColorTolerance[i]).ref_Color24;
                        m_objColorBlobs.ref_C24HighColorThreshold = ColorProcessing.CalculateMaxColor(m_arrDefectColor[i], m_arrDefectColorTolerance[i]).ref_Color24;

                        objThresholdSampleROI_Temp.LoadROISetting(objSampleUnitROI.ref_ROITotalX,
                            objSampleUnitROI.ref_ROITotalY,
                            objSampleUnitROI.ref_ROIWidth,
                            objSampleUnitROI.ref_ROIHeight);

                        // Threshold color image 
                        if (m_arrDefectColorSystem[i] == 0)
                            EasyImage.Threshold(objSampleUnitROI.ref_CROI, objThresholdSampleROI_Temp.ref_ROI, m_objColorBlobs.ref_C24LowColorThreshold, m_objColorBlobs.ref_C24HighColorThreshold, m_objColorLookupLSH);
                        else if (m_arrDefectColorSystem[i] == 1)
                            EasyImage.Threshold(objSampleUnitROI.ref_CROI, objThresholdSampleROI_Temp.ref_ROI, m_objColorBlobs.ref_C24LowColorThreshold, m_objColorBlobs.ref_C24HighColorThreshold, m_objColorLookupRGB);
                        else
                        {
                            EasyColor.GetComponent(objSampleUnitROI.ref_CROI, objThresholdSampleROI_Temp.ref_ROI, 1, m_objColorLookupYSH);
                            if (blnDebugImage)
                                objThresholdSampleROI_Temp.SaveImage("D:\\TS\\1_2.SaturationImg" + m_intPadROIDirection + i + ".bmp");
#if (Debug_2_12 || Release_2_12)
                            EasyImage.Threshold(objThresholdSampleROI_Temp.ref_ROI, objThresholdSampleROI_Temp.ref_ROI, (uint)m_arrDefectColor[i][0]);
#elif (DEBUG || RELEASE || RTXRelease || RTXDebug)
                    EasyImage.Threshold(objThresholdSampleROI_Temp.ref_ROI, objThresholdSampleROI_Temp.ref_ROI, m_arrDefectColor[i][0]);
#endif
                        }

                        if (blnDebugImage)
                            objThresholdSampleROI_Temp.SaveImage("D:\\TS\\2.objThresholdSampleROI" + m_intPadROIDirection + i + ".bmp");

                        if (m_arrDefectCloseIteration[i] > 0)
                        {
#if (Debug_2_12 || Release_2_12)
                            EasyImage.CloseBox(objThresholdSampleROI_Temp.ref_ROI, objThresholdSampleROI_Temp.ref_ROI, (uint)Math.Abs(m_arrDefectCloseIteration[i]), (uint)Math.Abs(m_arrDefectCloseIteration[i]));
#elif (DEBUG || RELEASE || RTXRelease || RTXDebug)
                            EasyImage.CloseBox(objThresholdSampleROI_Temp.ref_ROI, objThresholdSampleROI_Temp.ref_ROI, Math.Abs(m_arrDefectCloseIteration[i]), Math.Abs(m_arrDefectCloseIteration[i]));
#endif
                        }

                        if (blnDebugImage)
                            objThresholdSampleROI_Temp.SaveImage("D:\\TS\\3.objThresholdSampleROI" + m_intPadROIDirection + i + ".bmp");

                        if (m_arrDefectInvertBlackWhite[i])
                        {
                            EasyImage.Oper(EArithmeticLogicOperation.Invert, objThresholdSampleROI_Temp.ref_ROI, objThresholdSampleROI_Temp.ref_ROI);
                        }

                        if (blnDebugImage)
                            objThresholdSampleROI_Temp.SaveImage("D:\\TS\\4.objThresholdSampleROI" + m_intPadROIDirection + i + ".bmp");

                        //2019-09-23 ZJYEOH : Subtract tilt dont care area 
                        if (m_intPadROIDirection == 1) // Top
                        {
                            ROI DontCareTop = new ROI();

                            DontCareTop.LoadROISetting(0, 0, objThresholdSampleROI_Temp.ref_ROIWidth, objThresholdSampleROI_Temp.ref_ROIHeight);
                            DontCareTop.AttachImage(m_ImgTilt_Top_L);
                            EasyImage.Oper(EArithmeticLogicOperation.Subtract, objThresholdSampleROI_Temp.ref_ROI, DontCareTop.ref_ROI, objThresholdSampleROI_Temp.ref_ROI);
                            DontCareTop.LoadROISetting(m_ImgTilt_Top_R.ref_intImageWidth - objThresholdSampleROI_Temp.ref_ROIWidth, 0, objThresholdSampleROI_Temp.ref_ROIWidth, objThresholdSampleROI_Temp.ref_ROIHeight);
                            DontCareTop.AttachImage(m_ImgTilt_Top_R);
                            EasyImage.Oper(EArithmeticLogicOperation.Subtract, objThresholdSampleROI_Temp.ref_ROI, DontCareTop.ref_ROI, objThresholdSampleROI_Temp.ref_ROI);
                            if (blnDebugImage)
                                objThresholdSampleROI_Temp.SaveImage("D:\\TS\\objThresholdSampleROI_Top" + m_intPadROIDirection + i + ".bmp");
                            DontCareTop.Dispose();
                        }
                        if (m_intPadROIDirection == 2) // Right
                        {
                            ROI DontCareRight = new ROI();
                            DontCareRight.LoadROISetting(m_ImgTilt_Top_R.ref_intImageWidth - objThresholdSampleROI_Temp.ref_ROIWidth, 0, objThresholdSampleROI_Temp.ref_ROIWidth, objThresholdSampleROI_Temp.ref_ROIHeight);
                            DontCareRight.AttachImage(m_ImgTilt_Right_T);
                            EasyImage.Oper(EArithmeticLogicOperation.Subtract, objThresholdSampleROI_Temp.ref_ROI, DontCareRight.ref_ROI, objThresholdSampleROI_Temp.ref_ROI);
                            DontCareRight.LoadROISetting(m_ImgTilt_Top_R.ref_intImageWidth - objThresholdSampleROI_Temp.ref_ROIWidth, m_ImgTilt_Top_R.ref_intImageHeight - objThresholdSampleROI_Temp.ref_ROIHeight, objThresholdSampleROI_Temp.ref_ROIWidth, objThresholdSampleROI_Temp.ref_ROIHeight);
                            DontCareRight.AttachImage(m_ImgTilt_Right_B);
                            EasyImage.Oper(EArithmeticLogicOperation.Subtract, objThresholdSampleROI_Temp.ref_ROI, DontCareRight.ref_ROI, objThresholdSampleROI_Temp.ref_ROI);
                            if (blnDebugImage)
                                objThresholdSampleROI_Temp.SaveImage("D:\\TS\\objThresholdSampleROI_Right" + m_intPadROIDirection + i + ".bmp");
                            DontCareRight.Dispose();
                        }
                        if (m_intPadROIDirection == 3) // Bottom
                        {
                            ROI DontCareBottom = new ROI();

                            DontCareBottom.LoadROISetting(0, m_ImgTilt_Top_R.ref_intImageHeight - objThresholdSampleROI_Temp.ref_ROIHeight, objThresholdSampleROI_Temp.ref_ROIWidth, objThresholdSampleROI_Temp.ref_ROIHeight);
                            DontCareBottom.AttachImage(m_ImgTilt_Bottom_L);
                            EasyImage.Oper(EArithmeticLogicOperation.Subtract, objThresholdSampleROI_Temp.ref_ROI, DontCareBottom.ref_ROI, objThresholdSampleROI_Temp.ref_ROI);
                            DontCareBottom.LoadROISetting(m_ImgTilt_Top_R.ref_intImageWidth - objThresholdSampleROI_Temp.ref_ROIWidth, m_ImgTilt_Top_R.ref_intImageHeight - objThresholdSampleROI_Temp.ref_ROIHeight, objThresholdSampleROI_Temp.ref_ROIWidth, objThresholdSampleROI_Temp.ref_ROIHeight);
                            DontCareBottom.AttachImage(m_ImgTilt_Bottom_R);
                            EasyImage.Oper(EArithmeticLogicOperation.Subtract, objThresholdSampleROI_Temp.ref_ROI, DontCareBottom.ref_ROI, objThresholdSampleROI_Temp.ref_ROI);
                            if (blnDebugImage)
                                objThresholdSampleROI_Temp.SaveImage("D:\\TS\\objThresholdSampleROI_Bottom" + m_intPadROIDirection + i + ".bmp");
                            DontCareBottom.Dispose();
                        }
                        if (m_intPadROIDirection == 4) // Left
                        {
                            ROI DontCareLeft = new ROI();

                            DontCareLeft.LoadROISetting(0, 0, objThresholdSampleROI_Temp.ref_ROIWidth, objThresholdSampleROI_Temp.ref_ROIHeight);
                            DontCareLeft.AttachImage(m_ImgTilt_Left_T);
                            EasyImage.Oper(EArithmeticLogicOperation.Subtract, objThresholdSampleROI_Temp.ref_ROI, DontCareLeft.ref_ROI, objThresholdSampleROI_Temp.ref_ROI);
                            DontCareLeft.LoadROISetting(0, m_ImgTilt_Top_R.ref_intImageHeight - objThresholdSampleROI_Temp.ref_ROIHeight, objThresholdSampleROI_Temp.ref_ROIWidth, objThresholdSampleROI_Temp.ref_ROIHeight);
                            DontCareLeft.AttachImage(m_ImgTilt_Left_B);
                            EasyImage.Oper(EArithmeticLogicOperation.Subtract, objThresholdSampleROI_Temp.ref_ROI, DontCareLeft.ref_ROI, objThresholdSampleROI_Temp.ref_ROI);
                            if (blnDebugImage)
                                objThresholdSampleROI_Temp.SaveImage("D:\\TS\\objThresholdSampleROI_Left" + m_intPadROIDirection + i + ".bmp");
                            DontCareLeft.Dispose();
                        }

                        if (blnDebugImage)
                            objThresholdSampleROI_Temp.SaveImage("D:\\TS\\5.objThresholdSampleROI_AfterTiltAngle" + m_intPadROIDirection + i + ".bmp");

                        SubtractColorDontCareImage(objSampleROI, objThresholdSampleROI_Temp, m_arrDefectDontCareMode[i], m_arrPadColorDontCareImage[i]);

                        objThresholdSampleROI_Temp.LoadROISetting(objSampleUnitROI.ref_ROITotalX + GetColorDefectInspection_Left(i),
                            objSampleUnitROI.ref_ROITotalY + GetColorDefectInspection_Top(i),
                            objSampleUnitROI.ref_ROIWidth - GetColorDefectInspection_Left(i) - GetColorDefectInspection_Right(i),
                            objSampleUnitROI.ref_ROIHeight - GetColorDefectInspection_Top(i) - GetColorDefectInspection_Bottom(i));

                        objThresholdSampleROI.LoadROISetting(objSampleUnitROI.ref_ROITotalX + GetColorDefectInspection_Left(i),
                            objSampleUnitROI.ref_ROITotalY + GetColorDefectInspection_Top(i),
                            objSampleUnitROI.ref_ROIWidth - GetColorDefectInspection_Left(i) - GetColorDefectInspection_Right(i),
                            objSampleUnitROI.ref_ROIHeight - GetColorDefectInspection_Top(i) - GetColorDefectInspection_Bottom(i));

                        if (blnDebugImage)
                            objThresholdSampleROI_Temp.SaveImage("D:\\TS\\6.objThresholdSampleROI" + m_intPadROIDirection + i + ".bmp");

                        if (!blnFirstTime)
                        {
                            ROI.LogicOperationAddROI(objThresholdSampleROI, objThresholdSampleROI_Temp);
                        }
                        else
                        {
                            objThresholdSampleROI_Temp.CopyImage(ref objThresholdSampleROI);
                        }

                        if (blnDebugImage)
                        {
                            objThresholdSampleROI.SaveImage("D:\\TS\\7.objThresholdSampleROI" + i + ".bmp");
                            m_objInsPadPkgImage1.SaveImage("D:\\TS\\7.m_objInsPadPkgImage1" + i + ".bmp");
                        }
                        blnFirstTime = false;
                    }
                }
                else
                    continue;

                objThresholdSampleROI.LoadROISetting(objSampleUnitROI.ref_ROITotalX,
                 objSampleUnitROI.ref_ROITotalY,
                 objSampleUnitROI.ref_ROIWidth,
                 objSampleUnitROI.ref_ROIHeight);

                if (blnDebugImage)
                {
                    objThresholdSampleROI.SaveImage("D:\\TS\\8.objThresholdSampleROI" + intColorThresIndex + ".bmp");
                    m_objInsPadPkgImage1.SaveImage("D:\\TS\\8.m_objInsPadPkgImage1" + intColorThresIndex + ".bmp");
                }
                
                bool blnCheckLength = false;
                bool blnCheckArea = false;
                int intFailMask = 0;
                if (intColorThresIndex == 0)
                {
                    intFailMask = 0x01;
                    if ((m_intFailColorOptionMask & 0x01) > 0)
                        blnCheckLength = true;
                    if ((m_intFailColorOptionMask & 0x02) > 0)
                        blnCheckArea = true;
                }
                else if (intColorThresIndex == 1)
                {
                    intFailMask = 0x02;
                    if ((m_intFailColorOptionMask & 0x04) > 0)
                        blnCheckLength = true;
                    if ((m_intFailColorOptionMask & 0x08) > 0)
                        blnCheckArea = true;
                }
                else if (intColorThresIndex == 2)
                {
                    intFailMask = 0x04;
                    if ((m_intFailColorOptionMask & 0x10) > 0)
                        blnCheckLength = true;
                    if ((m_intFailColorOptionMask & 0x20) > 0)
                        blnCheckArea = true;
                }
                else if (intColorThresIndex == 3)
                {
                    intFailMask = 0x08;
                    if ((m_intFailColorOptionMask & 0x40) > 0)
                        blnCheckLength = true;
                    if ((m_intFailColorOptionMask & 0x80) > 0)
                        blnCheckArea = true;
                }
                else if (intColorThresIndex == 4)
                {
                    intFailMask = 0x10;
                    if ((m_intFailColorOptionMask & 0x100) > 0)
                        blnCheckLength = true;
                    if ((m_intFailColorOptionMask & 0x200) > 0)
                        blnCheckArea = true;
                }

                int intSelectedObjectNum = 0;
                intSelectedObjectNum = m_objColorBlobs.BuildObjects_Filter_GetElement(objThresholdSampleROI, !m_blnWhiteOnBlack, true, 0, -4,
                m_arrDefectColorMinArea[intColorThresIndex], objSampleUnitROI.ref_ROIWidth * objSampleUnitROI.ref_ROIHeight, false, 0xFF);

                //if (intSelectedObjectNum == 0 && m_arrDefectType[intColorThresIndex] == 1)
                //{
                //    ColorDefect objDefect = new ColorDefect();

                //    objDefect.ref_strName = m_arrDefectColorThresName[intColorThresIndex];
                //    objDefect.ref_intFailMask = intFailMask;
                //    objDefect.ref_fCenterX = -1;
                //    objDefect.ref_fCenterY = -1;
                //    objDefect.ref_fStartX = -1;
                //    objDefect.ref_fStartY = -1;
                //    objDefect.ref_fEndX = -1;
                //    objDefect.ref_fEndY = -1;
                //    objDefect.ref_fWidth = -1;
                //    objDefect.ref_fHeight = -1;
                //    objDefect.ref_fArea = -1;
                //    objDefect.ref_fWidthInMM = -1;
                //    objDefect.ref_fHeightInMM = -1;
                //    objDefect.ref_fAreaInMM2 = -1;
                //    objDefect.ref_intImageNo = m_arrDefectImageNo[intColorThresIndex] + 1;

                //    objDefect.ref_fAreaFailValue = -1;
                //    objDefect.ref_intFailCriteria |= 0x10;

                //    m_arrColorDefectList.Add(objDefect);

                //    m_intFailColorResultMask |= intFailMask;

                //    blnResult = false;
                //}

                bool blnOverallResult = true;
                if (intSelectedObjectNum > 0)
                {
                    float fCenterX = 0, fCenterY = 0, fWidth = 0, fHeight = 0;
                    float fStartX, fStartY, fEndX, fEndY, fAngle = 0;
                    int intArea = 0;
                    float fWidthMM, fHeightMM, fAreaInMM;
                    int intFailCount = 0;

                    int intTotalArea = 0;
                    for (int i = 0; i < intSelectedObjectNum; i++)
                    {
                        intArea = m_objColorBlobs.ref_arrArea[i];

                        if (m_objColorBlobs.ref_arrRectWidth[i] < m_objColorBlobs.ref_arrRectHeight[i])
                        {
                            fWidth = m_objColorBlobs.ref_arrRectWidth[i];
                            fHeight = m_objColorBlobs.ref_arrRectHeight[i];

                            fAngle = m_objColorBlobs.ref_arrRectAngle[i];


                            if (fAngle < 0)
                                fAngle = -Math.Abs(fAngle);
                            else
                                fAngle = -fAngle;
                        }
                        else
                        {
                            fWidth = m_objColorBlobs.ref_arrRectHeight[i];
                            fHeight = m_objColorBlobs.ref_arrRectWidth[i];

                            fAngle = m_objColorBlobs.ref_arrRectAngle[i];


                            if (fAngle < 0)
                                fAngle = Math.Abs(fAngle);
                            else
                                fAngle = 90 - (fAngle);
                        }
                        fCenterX = m_objColorBlobs.ref_arrRectLimitCenterX[i];
                        fCenterY = m_objColorBlobs.ref_arrRectLimitCenterY[i];

                        intTotalArea += intArea;
                        fCenterX += intStartPixelFromEdgeX;
                        fCenterY += intStartPixelFromEdgeY;
                        fStartX = (float)Math.Floor(fCenterX - (fWidth / 2));
                        fStartY = (float)Math.Floor(fCenterY - (fHeight / 2));
                        fEndX = (float)Math.Ceiling(fCenterX + (fWidth / 2));
                        fEndY = (float)Math.Ceiling(fCenterY + (fHeight / 2));

                        // convert width and height to mm
                        fWidthMM = fWidth / m_fMMToPixelXValue;
                        fHeightMM = fHeight / m_fMMToPixelYValue; // 11-04-2019 ZJYEOH : Changed m_fMMToPixelXValue to m_fMMToPixelYValue
                        fAreaInMM = intArea / m_fMMToPixelXValue / m_fMMToPixelYValue;

                        {
                            intFailCount++;

                            ColorDefect objDefect = new ColorDefect();

                            objDefect.ref_strName = m_arrDefectColorThresName[intColorThresIndex];
                            objDefect.ref_intFailMask = intFailMask;
                            objDefect.ref_fCenterX = objThresholdSampleROI.ref_ROITotalX + fCenterX;
                            objDefect.ref_fCenterY = objThresholdSampleROI.ref_ROITotalY + fCenterY;
                            objDefect.ref_fStartX = objThresholdSampleROI.ref_ROITotalX + fStartX;
                            objDefect.ref_fStartY = objThresholdSampleROI.ref_ROITotalY + fStartY;
                            objDefect.ref_fEndX = objThresholdSampleROI.ref_ROITotalX + fEndX;
                            objDefect.ref_fEndY = objThresholdSampleROI.ref_ROITotalY + fEndY;
                            objDefect.ref_fWidth = fWidth;
                            objDefect.ref_fHeight = fHeight;
                            objDefect.ref_fArea = intArea;
                            objDefect.ref_fAngle = fAngle;
                            objDefect.ref_fWidthInMM = fWidthMM;
                            objDefect.ref_fHeightInMM = fHeightMM;
                            objDefect.ref_fAreaInMM2 = fAreaInMM;
                            objDefect.ref_intImageNo = m_arrDefectImageNo[intColorThresIndex] + 1;

                            if (blnCheckLength)
                            {
                                if (m_arrDefectColorInspectionFailCondition[intColorThresIndex] == 0)
                                {
                                    if (fWidthMM > m_arrDefectColorInspectionWidth[intColorThresIndex])
                                    {
                                        m_intFailColorResultMask |= intFailMask;

                                        blnOverallResult = false;
                                        objDefect.ref_fWidthFailValue = fWidthMM;
                                        objDefect.ref_intFailCriteria |= 0x01;
                                        blnResult = false;
                                    }
                                    if (fHeightMM > m_arrDefectColorInspectionLength[intColorThresIndex])
                                    {
                                        m_intFailColorResultMask |= intFailMask;

                                        blnOverallResult = false;
                                        objDefect.ref_fHeightFailValue = fHeightMM;
                                        objDefect.ref_intFailCriteria |= 0x02;
                                        blnResult = false;
                                    }
                                }
                                else
                                {
                                    if ((fWidthMM > m_arrDefectColorInspectionWidth[intColorThresIndex]) && (fHeightMM > m_arrDefectColorInspectionLength[intColorThresIndex]))
                                    {
                                        m_intFailColorResultMask |= intFailMask;

                                        blnOverallResult = false;
                                        objDefect.ref_fWidthFailValue = fWidthMM;
                                        objDefect.ref_fHeightFailValue = fHeightMM;
                                        objDefect.ref_intFailCriteria |= 0x01;
                                        objDefect.ref_intFailCriteria |= 0x02;
                                        blnResult = false;
                                    }
                                }
                            }

                            if (blnCheckArea)
                            {
                                if (/*fAreaInMM < m_arrDefectColorInspectionMinArea[intColorThresIndex] ||*/ fAreaInMM > m_arrDefectColorInspectionMaxArea[intColorThresIndex])
                                {
                                    m_intFailColorResultMask |= intFailMask;

                                    blnOverallResult = false;
                                    objDefect.ref_fAreaFailValue = fAreaInMM;
                                    objDefect.ref_intFailCriteria |= 0x04;
                                    blnResult = false;
                                }
                            }

                            m_arrColorDefectList.Add(objDefect);
                        }

                    }

                    if (blnCheckArea)
                    {
                        fAreaInMM = intTotalArea / m_fMMToPixelXValue / m_fMMToPixelYValue;

                        if (fAreaInMM > m_arrDefectColorInspectionTotalArea[intColorThresIndex])
                        {
                            ColorDefect objDefect = new ColorDefect();

                            objDefect.ref_strName = m_arrDefectColorThresName[intColorThresIndex];
                            objDefect.ref_intFailMask = intFailMask;
                            objDefect.ref_fCenterX = -1;
                            objDefect.ref_fCenterY = -1;
                            objDefect.ref_fStartX = -1;
                            objDefect.ref_fStartY = -1;
                            objDefect.ref_fEndX = -1;
                            objDefect.ref_fEndY = -1;
                            objDefect.ref_fWidth = -1;
                            objDefect.ref_fHeight = -1;
                            objDefect.ref_fArea = intTotalArea;
                            objDefect.ref_fWidthInMM = -1;
                            objDefect.ref_fHeightInMM = -1;
                            objDefect.ref_fAreaInMM2 = fAreaInMM;
                            objDefect.ref_intImageNo = m_arrDefectImageNo[intColorThresIndex] + 1;
                            objDefect.ref_blnFailTotalArea = true;

                            blnOverallResult = false;
                            objDefect.ref_fAreaFailValue = fAreaInMM;
                            objDefect.ref_intFailCriteria |= 0x08;

                            m_arrColorDefectList.Add(objDefect);

                            m_intFailColorResultMask |= intFailMask;

                            for (int b = 0; b < m_arrColorDefectList.Count; b++)
                            {
                                if (((ColorDefect)m_arrColorDefectList[b]).ref_strName == m_arrDefectColorThresName[intColorThresIndex])
                                {
                                    if (!((ColorDefect)m_arrColorDefectList[b]).ref_blnFailTotalArea)
                                    {
                                        ColorDefect objDefect2 = m_arrColorDefectList[b];
                                        objDefect2.ref_blnFailTotalArea = true;
                                        m_arrColorDefectList.RemoveAt(b);
                                        m_arrColorDefectList.Insert(b, objDefect2);
                                    }
                                }
                            }

                            blnResult = false;
                        }

                    }
                }
            }
            objThresholdSampleROI.Dispose();
            objThresholdSampleROI_Temp.Dispose();
            return blnResult;
        }
        private bool CheckColorDefect_TiltAngle_CombineSameName_LinkNearest(CROI objSampleUnitROI, List<CImageDrawing> arrColorImages, ROI objSampleROI, ImageDrawing objBlackImage)
        {
            if (m_arrDefectColorThresName.Count == 0)
                return true;

            if ((((m_intFailColorOptionMask & 0x03) == 0) && m_arrDefectColorThresName.Count == 1) &&
                (((m_intFailColorOptionMask & 0x0C) == 0) && m_arrDefectColorThresName.Count == 2) &&
                (((m_intFailColorOptionMask & 0x30) == 0) && m_arrDefectColorThresName.Count == 3) &&
                (((m_intFailColorOptionMask & 0xC0) == 0) && m_arrDefectColorThresName.Count == 4) &&
                (((m_intFailColorOptionMask & 0x300) == 0) && m_arrDefectColorThresName.Count == 5))
                return true;

            bool blnResult = true;
            bool blnDebugImage = false;

            //float fPkgOffsetX = (objSampleUnitROI.ref_ROIWidth - Math.Max(GetResultUpWidth_RectGauge4L(0), GetResultDownWidth_RectGauge4L(0))) / 2;
            //float fPkgOffsetY = (objSampleUnitROI.ref_ROIHeight - Math.Max(GetResultLeftHeight_RectGauge4L(0), GetResultRightHeight_RectGauge4L(0))) / 2;

            int intStartPixelFromEdgeX = 0;// (int)Math.Round(fPkgOffsetX - m_intPadROIStartPixelFromLeft, 0, MidpointRounding.AwayFromZero); //m_fPkgStartPixelFromLeft
            int intStartPixelFromEdgeY = 0;// (int)Math.Round(fPkgOffsetY - m_intPadROIStartPixelFromTop, 0, MidpointRounding.AwayFromZero); //m_fPkgStartPixelFromEdge
            //int intStartPixelFromEdgeX2 = (int)Math.Round(fPkgOffsetX + m_intPadROIStartPixelFromRight, 0, MidpointRounding.AwayFromZero); //m_fPkgStartPixelFromRight
            //int intStartPixelFromEdgeY2 = (int)Math.Round(fPkgOffsetY + m_intPadROIStartPixelFromBottom, 0, MidpointRounding.AwayFromZero); //m_fPkgStartPixelFromBottom

            ROI objThresholdSampleROI = new ROI();
            objThresholdSampleROI.AttachImage(m_objInsPadPkgImage1); // Attach sample ROI to ori size image. m_objInsPadPkgImage1 is a ori size image used to keep the sample image temporary for modification such as double threshold
            objThresholdSampleROI.LoadROISetting(objSampleUnitROI.ref_ROIPositionX, objSampleUnitROI.ref_ROIPositionY, objSampleUnitROI.ref_ROIWidth, objSampleUnitROI.ref_ROIHeight);

            ROI objThresholdSampleROI_Temp = new ROI();
            objThresholdSampleROI_Temp.AttachImage(m_objInsSurfacePkgImage1); // Attach sample ROI to ori size image. m_objInsSurfacePkgImage1 is a ori size image used to keep the sample image temporary for modification such as double threshold
            objThresholdSampleROI_Temp.LoadROISetting(objSampleUnitROI.ref_ROIPositionX, objSampleUnitROI.ref_ROIPositionY, objSampleUnitROI.ref_ROIWidth, objSampleUnitROI.ref_ROIHeight);

            if (blnDebugImage)
            {
                objSampleUnitROI.SaveImage("D:\\TS\\1.objSampleUnitROI" + m_intPadROIDirection + ".bmp");
            }
            List<int> arrSkip = new List<int>();
            for (int intColorThresIndex = 0; intColorThresIndex < m_arrDefectColor.Count; intColorThresIndex++)
            {
                if (intColorThresIndex == 0 && ((m_intFailColorOptionMask & 0x03) == 0))
                    continue;
                else if (intColorThresIndex == 1 && ((m_intFailColorOptionMask & 0x0C) == 0))
                    continue;
                else if (intColorThresIndex == 2 && ((m_intFailColorOptionMask & 0x30) == 0))
                    continue;
                else if (intColorThresIndex == 3 && ((m_intFailColorOptionMask & 0xC0) == 0))
                    continue;
                else if (intColorThresIndex == 4 && ((m_intFailColorOptionMask & 0x300) == 0))
                    continue;

                if (!blnResult)
                    break;

                objBlackImage.CopyTo(ref m_objInsPadPkgImage1);
                string strThresName = m_arrDefectColorThresName[intColorThresIndex];
                if (!arrSkip.Contains(intColorThresIndex))
                {
                    bool blnFirstTime = true;
                    for (int i = 0; i < m_arrDefectColor.Count; i++)
                    {
                        if (!arrSkip.Contains(i) && strThresName == m_arrDefectColorThresName[i])
                        {
                            arrSkip.Add(i);
                        }
                        else
                            continue;

                        objSampleUnitROI.AttachImage(arrColorImages[CImageDrawing.GetArrayImageIndex(m_arrDefectImageNo[i], m_intVisionIndex)]);

                        if (blnDebugImage)
                        {
                            arrColorImages[CImageDrawing.GetArrayImageIndex(m_arrDefectImageNo[i], m_intVisionIndex)].SaveImage("D:\\TS\\arrColorImage" + CImageDrawing.GetArrayImageIndex(m_arrDefectImageNo[i], m_intVisionIndex) + m_intPadROIDirection + ".bmp");
                            objSampleUnitROI.SaveImage("D:\\TS\\1_1.objSampleUnitROI2" + m_intPadROIDirection + ".bmp");
                        }
                        objBlackImage.CopyTo(ref m_objInsSurfacePkgImage1);
                        // Get color threshold min max value
                        m_objColorBlobs.ref_C24LowColorThreshold = ColorProcessing.CalculateMinColor(m_arrDefectColor[i], m_arrDefectColorTolerance[i]).ref_Color24;
                        m_objColorBlobs.ref_C24HighColorThreshold = ColorProcessing.CalculateMaxColor(m_arrDefectColor[i], m_arrDefectColorTolerance[i]).ref_Color24;

                        objThresholdSampleROI_Temp.LoadROISetting(objSampleUnitROI.ref_ROITotalX,
                            objSampleUnitROI.ref_ROITotalY,
                            objSampleUnitROI.ref_ROIWidth,
                            objSampleUnitROI.ref_ROIHeight);

                        // Threshold color image 
                        if (m_arrDefectColorSystem[i] == 0)
                            EasyImage.Threshold(objSampleUnitROI.ref_CROI, objThresholdSampleROI_Temp.ref_ROI, m_objColorBlobs.ref_C24LowColorThreshold, m_objColorBlobs.ref_C24HighColorThreshold, m_objColorLookupLSH);
                        else if (m_arrDefectColorSystem[i] == 1)
                            EasyImage.Threshold(objSampleUnitROI.ref_CROI, objThresholdSampleROI_Temp.ref_ROI, m_objColorBlobs.ref_C24LowColorThreshold, m_objColorBlobs.ref_C24HighColorThreshold, m_objColorLookupRGB);
                        else
                        {
                            EasyColor.GetComponent(objSampleUnitROI.ref_CROI, objThresholdSampleROI_Temp.ref_ROI, 1, m_objColorLookupYSH);
                            if (blnDebugImage)
                                objThresholdSampleROI_Temp.SaveImage("D:\\TS\\1_2.SaturationImg" + m_intPadROIDirection + i + ".bmp");
#if (Debug_2_12 || Release_2_12)
                            EasyImage.Threshold(objThresholdSampleROI_Temp.ref_ROI, objThresholdSampleROI_Temp.ref_ROI, (uint)m_arrDefectColor[i][0]);
#elif (DEBUG || RELEASE || RTXRelease || RTXDebug)
                    EasyImage.Threshold(objThresholdSampleROI_Temp.ref_ROI, objThresholdSampleROI_Temp.ref_ROI, m_arrDefectColor[i][0]);
#endif
                        }

                        if (blnDebugImage)
                            objThresholdSampleROI_Temp.SaveImage("D:\\TS\\2.objThresholdSampleROI" + m_intPadROIDirection + i + ".bmp");

                        if (m_arrDefectCloseIteration[i] > 0)
                        {
#if (Debug_2_12 || Release_2_12)
                            EasyImage.CloseBox(objThresholdSampleROI_Temp.ref_ROI, objThresholdSampleROI_Temp.ref_ROI, (uint)Math.Abs(m_arrDefectCloseIteration[i]), (uint)Math.Abs(m_arrDefectCloseIteration[i]));
#elif (DEBUG || RELEASE || RTXRelease || RTXDebug)
                            EasyImage.CloseBox(objThresholdSampleROI_Temp.ref_ROI, objThresholdSampleROI_Temp.ref_ROI, Math.Abs(m_arrDefectCloseIteration[i]), Math.Abs(m_arrDefectCloseIteration[i]));
#endif
                        }

                        if (blnDebugImage)
                            objThresholdSampleROI_Temp.SaveImage("D:\\TS\\3.objThresholdSampleROI" + m_intPadROIDirection + i + ".bmp");

                        if (m_arrDefectInvertBlackWhite[i])
                        {
                            EasyImage.Oper(EArithmeticLogicOperation.Invert, objThresholdSampleROI_Temp.ref_ROI, objThresholdSampleROI_Temp.ref_ROI);
                        }

                        if (blnDebugImage)
                            objThresholdSampleROI_Temp.SaveImage("D:\\TS\\4.objThresholdSampleROI" + m_intPadROIDirection + i + ".bmp");

                        //2019-09-23 ZJYEOH : Subtract tilt dont care area 
                        if (m_intPadROIDirection == 1) // Top
                        {
                            ROI DontCareTop = new ROI();

                            DontCareTop.LoadROISetting(0, 0, objThresholdSampleROI_Temp.ref_ROIWidth, objThresholdSampleROI_Temp.ref_ROIHeight);
                            DontCareTop.AttachImage(m_ImgTilt_Top_L);
                            EasyImage.Oper(EArithmeticLogicOperation.Subtract, objThresholdSampleROI_Temp.ref_ROI, DontCareTop.ref_ROI, objThresholdSampleROI_Temp.ref_ROI);
                            DontCareTop.LoadROISetting(m_ImgTilt_Top_R.ref_intImageWidth - objThresholdSampleROI_Temp.ref_ROIWidth, 0, objThresholdSampleROI_Temp.ref_ROIWidth, objThresholdSampleROI_Temp.ref_ROIHeight);
                            DontCareTop.AttachImage(m_ImgTilt_Top_R);
                            EasyImage.Oper(EArithmeticLogicOperation.Subtract, objThresholdSampleROI_Temp.ref_ROI, DontCareTop.ref_ROI, objThresholdSampleROI_Temp.ref_ROI);
                            if (blnDebugImage)
                                objThresholdSampleROI_Temp.SaveImage("D:\\TS\\objThresholdSampleROI_Top" + m_intPadROIDirection + i + ".bmp");
                            DontCareTop.Dispose();
                        }
                        if (m_intPadROIDirection == 2) // Right
                        {
                            ROI DontCareRight = new ROI();
                            DontCareRight.LoadROISetting(m_ImgTilt_Top_R.ref_intImageWidth - objThresholdSampleROI_Temp.ref_ROIWidth, 0, objThresholdSampleROI_Temp.ref_ROIWidth, objThresholdSampleROI_Temp.ref_ROIHeight);
                            DontCareRight.AttachImage(m_ImgTilt_Right_T);
                            EasyImage.Oper(EArithmeticLogicOperation.Subtract, objThresholdSampleROI_Temp.ref_ROI, DontCareRight.ref_ROI, objThresholdSampleROI_Temp.ref_ROI);
                            DontCareRight.LoadROISetting(m_ImgTilt_Top_R.ref_intImageWidth - objThresholdSampleROI_Temp.ref_ROIWidth, m_ImgTilt_Top_R.ref_intImageHeight - objThresholdSampleROI_Temp.ref_ROIHeight, objThresholdSampleROI_Temp.ref_ROIWidth, objThresholdSampleROI_Temp.ref_ROIHeight);
                            DontCareRight.AttachImage(m_ImgTilt_Right_B);
                            EasyImage.Oper(EArithmeticLogicOperation.Subtract, objThresholdSampleROI_Temp.ref_ROI, DontCareRight.ref_ROI, objThresholdSampleROI_Temp.ref_ROI);
                            if (blnDebugImage)
                                objThresholdSampleROI_Temp.SaveImage("D:\\TS\\objThresholdSampleROI_Right" + m_intPadROIDirection + i + ".bmp");
                            DontCareRight.Dispose();
                        }
                        if (m_intPadROIDirection == 3) // Bottom
                        {
                            ROI DontCareBottom = new ROI();

                            DontCareBottom.LoadROISetting(0, m_ImgTilt_Top_R.ref_intImageHeight - objThresholdSampleROI_Temp.ref_ROIHeight, objThresholdSampleROI_Temp.ref_ROIWidth, objThresholdSampleROI_Temp.ref_ROIHeight);
                            DontCareBottom.AttachImage(m_ImgTilt_Bottom_L);
                            EasyImage.Oper(EArithmeticLogicOperation.Subtract, objThresholdSampleROI_Temp.ref_ROI, DontCareBottom.ref_ROI, objThresholdSampleROI_Temp.ref_ROI);
                            DontCareBottom.LoadROISetting(m_ImgTilt_Top_R.ref_intImageWidth - objThresholdSampleROI_Temp.ref_ROIWidth, m_ImgTilt_Top_R.ref_intImageHeight - objThresholdSampleROI_Temp.ref_ROIHeight, objThresholdSampleROI_Temp.ref_ROIWidth, objThresholdSampleROI_Temp.ref_ROIHeight);
                            DontCareBottom.AttachImage(m_ImgTilt_Bottom_R);
                            EasyImage.Oper(EArithmeticLogicOperation.Subtract, objThresholdSampleROI_Temp.ref_ROI, DontCareBottom.ref_ROI, objThresholdSampleROI_Temp.ref_ROI);
                            if (blnDebugImage)
                                objThresholdSampleROI_Temp.SaveImage("D:\\TS\\objThresholdSampleROI_Bottom" + m_intPadROIDirection + i + ".bmp");
                            DontCareBottom.Dispose();
                        }
                        if (m_intPadROIDirection == 4) // Left
                        {
                            ROI DontCareLeft = new ROI();

                            DontCareLeft.LoadROISetting(0, 0, objThresholdSampleROI_Temp.ref_ROIWidth, objThresholdSampleROI_Temp.ref_ROIHeight);
                            DontCareLeft.AttachImage(m_ImgTilt_Left_T);
                            EasyImage.Oper(EArithmeticLogicOperation.Subtract, objThresholdSampleROI_Temp.ref_ROI, DontCareLeft.ref_ROI, objThresholdSampleROI_Temp.ref_ROI);
                            DontCareLeft.LoadROISetting(0, m_ImgTilt_Top_R.ref_intImageHeight - objThresholdSampleROI_Temp.ref_ROIHeight, objThresholdSampleROI_Temp.ref_ROIWidth, objThresholdSampleROI_Temp.ref_ROIHeight);
                            DontCareLeft.AttachImage(m_ImgTilt_Left_B);
                            EasyImage.Oper(EArithmeticLogicOperation.Subtract, objThresholdSampleROI_Temp.ref_ROI, DontCareLeft.ref_ROI, objThresholdSampleROI_Temp.ref_ROI);
                            if (blnDebugImage)
                                objThresholdSampleROI_Temp.SaveImage("D:\\TS\\objThresholdSampleROI_Left" + m_intPadROIDirection + i + ".bmp");
                            DontCareLeft.Dispose();
                        }

                        if (blnDebugImage)
                            objThresholdSampleROI_Temp.SaveImage("D:\\TS\\5.objThresholdSampleROI_AfterTiltAngle" + m_intPadROIDirection + i + ".bmp");

                        SubtractColorDontCareImage(objSampleROI, objThresholdSampleROI_Temp, m_arrDefectDontCareMode[i], m_arrPadColorDontCareImage[i]);

                        objThresholdSampleROI_Temp.LoadROISetting(objSampleUnitROI.ref_ROITotalX + GetColorDefectInspection_Left(i),
                            objSampleUnitROI.ref_ROITotalY + GetColorDefectInspection_Top(i),
                            objSampleUnitROI.ref_ROIWidth - GetColorDefectInspection_Left(i) - GetColorDefectInspection_Right(i),
                            objSampleUnitROI.ref_ROIHeight - GetColorDefectInspection_Top(i) - GetColorDefectInspection_Bottom(i));

                        objThresholdSampleROI.LoadROISetting(objSampleUnitROI.ref_ROITotalX + GetColorDefectInspection_Left(i),
                            objSampleUnitROI.ref_ROITotalY + GetColorDefectInspection_Top(i),
                            objSampleUnitROI.ref_ROIWidth - GetColorDefectInspection_Left(i) - GetColorDefectInspection_Right(i),
                            objSampleUnitROI.ref_ROIHeight - GetColorDefectInspection_Top(i) - GetColorDefectInspection_Bottom(i));

                        if (blnDebugImage)
                            objThresholdSampleROI_Temp.SaveImage("D:\\TS\\6.objThresholdSampleROI" + m_intPadROIDirection + i + ".bmp");

                        if (!blnFirstTime)
                        {
                            ROI.LogicOperationAddROI(objThresholdSampleROI, objThresholdSampleROI_Temp);
                        }
                        else
                        {
                            objThresholdSampleROI_Temp.CopyImage(ref objThresholdSampleROI);
                        }

                        if (blnDebugImage)
                        {
                            objThresholdSampleROI.SaveImage("D:\\TS\\7.objThresholdSampleROI" + i + ".bmp");
                            m_objInsPadPkgImage1.SaveImage("D:\\TS\\7.m_objInsPadPkgImage1" + i + ".bmp");
                        }
                        blnFirstTime = false;
                    }
                }
                else
                    continue;

                objThresholdSampleROI.LoadROISetting(objSampleUnitROI.ref_ROITotalX,
                 objSampleUnitROI.ref_ROITotalY,
                 objSampleUnitROI.ref_ROIWidth,
                 objSampleUnitROI.ref_ROIHeight);

                if (blnDebugImage)
                {
                    objThresholdSampleROI.SaveImage("D:\\TS\\8.objThresholdSampleROI" + intColorThresIndex + ".bmp");
                    m_objInsPadPkgImage1.SaveImage("D:\\TS\\8.m_objInsPadPkgImage1" + intColorThresIndex + ".bmp");
                }
                
                bool blnCheckLength = false;
                bool blnCheckArea = false;
                int intFailMask = 0;
                if (intColorThresIndex == 0)
                {
                    intFailMask = 0x01;
                    if ((m_intFailColorOptionMask & 0x01) > 0)
                        blnCheckLength = true;
                    if ((m_intFailColorOptionMask & 0x02) > 0)
                        blnCheckArea = true;
                }
                else if (intColorThresIndex == 1)
                {
                    intFailMask = 0x02;
                    if ((m_intFailColorOptionMask & 0x04) > 0)
                        blnCheckLength = true;
                    if ((m_intFailColorOptionMask & 0x08) > 0)
                        blnCheckArea = true;
                }
                else if (intColorThresIndex == 2)
                {
                    intFailMask = 0x04;
                    if ((m_intFailColorOptionMask & 0x10) > 0)
                        blnCheckLength = true;
                    if ((m_intFailColorOptionMask & 0x20) > 0)
                        blnCheckArea = true;
                }
                else if (intColorThresIndex == 3)
                {
                    intFailMask = 0x08;
                    if ((m_intFailColorOptionMask & 0x40) > 0)
                        blnCheckLength = true;
                    if ((m_intFailColorOptionMask & 0x80) > 0)
                        blnCheckArea = true;
                }
                else if (intColorThresIndex == 4)
                {
                    intFailMask = 0x10;
                    if ((m_intFailColorOptionMask & 0x100) > 0)
                        blnCheckLength = true;
                    if ((m_intFailColorOptionMask & 0x200) > 0)
                        blnCheckArea = true;
                }

                int intSelectedObjectNum = 0;
                intSelectedObjectNum = m_objColorBlobs.BuildObjects_Filter_GetElement(objThresholdSampleROI, !m_blnWhiteOnBlack, true, 0, -4,
                m_arrDefectColorMinArea[intColorThresIndex], objSampleUnitROI.ref_ROIWidth * objSampleUnitROI.ref_ROIHeight, false, 0xFF);

                //if (intSelectedObjectNum == 0 && m_arrDefectType[intColorThresIndex] == 1)
                //{
                //    ColorDefect objDefect = new ColorDefect();

                //    objDefect.ref_strName = m_arrDefectColorThresName[intColorThresIndex];
                //    objDefect.ref_intFailMask = intFailMask;
                //    objDefect.ref_fCenterX = -1;
                //    objDefect.ref_fCenterY = -1;
                //    objDefect.ref_fStartX = -1;
                //    objDefect.ref_fStartY = -1;
                //    objDefect.ref_fEndX = -1;
                //    objDefect.ref_fEndY = -1;
                //    objDefect.ref_fWidth = -1;
                //    objDefect.ref_fHeight = -1;
                //    objDefect.ref_fArea = -1;
                //    objDefect.ref_fWidthInMM = -1;
                //    objDefect.ref_fHeightInMM = -1;
                //    objDefect.ref_fAreaInMM2 = -1;
                //    objDefect.ref_intImageNo = m_arrDefectImageNo[intColorThresIndex] + 1;

                //    objDefect.ref_fAreaFailValue = -1;
                //    objDefect.ref_intFailCriteria |= 0x10;

                //    m_arrColorDefectList.Add(objDefect);

                //    m_intFailColorResultMask |= intFailMask;

                //    blnResult = false;
                //}

                bool blnOverallResult = true;
                if (intSelectedObjectNum > 0)
                {
                    List<List<System.Windows.Point>> arr2DPoints = new List<List<System.Windows.Point>>();
                    List<List<PointF>> arrRotatedPoints = new List<List<PointF>>();
                    List<float> fObjectHeightList = new List<float>(), fObjectWidthList = new List<float>(), fObjectCenterXList = new List<float>(), fObjectCenterYList = new List<float>(), fObjectAngleList = new List<float>();
                    List<float> fObjectLimitHeightList = new List<float>(), fObjectLimitWidthList = new List<float>(), fObjectLimitCenterXList = new List<float>(), fObjectLimitCenterYList = new List<float>();
                    List<int> fObjectAreaList = new List<int>(), fObjectAreaList2 = new List<int>();
                    int intObjectTotalArea = 0;
                    int intObjectArea = 0;
                    int intLengthMode = 0;
                    float fObjectHeight = 0, fObjectWidth = 0, fObjectCenterX = 0, fObjectCenterY = 0, fObjectAngle = 0;
                    float fObjectLimitHeight = 0, fObjectLimitWidth = 0, fObjectLimitCenterX = 0, fObjectLimitCenterY = 0;
                    bool blnOverAllFail = false;
                    for (int i = 0; i < intSelectedObjectNum; i++)
                    {
                        arrRotatedPoints.Add(new List<PointF>());
                        arr2DPoints.Add(new List<System.Windows.Point>());
                        intObjectArea = m_objColorBlobs.ref_arrArea[i];

                        if (m_objColorBlobs.ref_arrRectHeight[i] < m_objColorBlobs.ref_arrRectWidth[i])
                        {
                            fObjectWidth = m_objColorBlobs.ref_arrRectHeight[i];
                            fObjectHeight = m_objColorBlobs.ref_arrRectWidth[i];
                            intLengthMode = 0;
                            fObjectAngle = m_objColorBlobs.ref_arrRectAngle[i];

                            if (fObjectAngle >= 10)//&& fAngle <= 80)
                                fObjectAngle = m_objColorBlobs.ref_arrRectAngle[i] - 90;
                            else
                                fObjectAngle = 90 + m_objColorBlobs.ref_arrRectAngle[i];

                        }
                        else
                        {
                            fObjectHeight = m_objColorBlobs.ref_arrRectHeight[i];
                            fObjectWidth = m_objColorBlobs.ref_arrRectWidth[i];
                            intLengthMode = 0;

                            fObjectAngle = m_objColorBlobs.ref_arrRectAngle[i];

                        }
                        fObjectCenterX = m_objColorBlobs.ref_arrRectLimitCenterX[i];
                        fObjectCenterY = m_objColorBlobs.ref_arrRectLimitCenterY[i];

                        fObjectLimitCenterX = m_objColorBlobs.ref_arrLimitCenterX[i];
                        fObjectLimitCenterY = m_objColorBlobs.ref_arrLimitCenterY[i];
                        fObjectLimitWidth = m_objColorBlobs.ref_arrWidth[i];
                        fObjectLimitHeight = m_objColorBlobs.ref_arrHeight[i];

                        intObjectTotalArea += intObjectArea;
                        //float MaxX = 0, MaxY = 0, MinX = 0, MinY = 0;
                        float newX1 = 0, newY1 = 0;  // new point 1
                        float newX2 = 0, newY2 = 0; // new point 2
                        float newX3 = 0, newY3 = 0; // new point 3
                        float newX4 = 0, newY4 = 0; // new point 4

                        //2020-12-18 ZJYEOH : Change to this format
                        //  Point 1 *-------------* Point 2
                        //          |             |
                        //          |             |
                        //          |             |
                        //  Point 4 *-------------* Point 3

                        Math2.RotateWithAngleAccordingToReferencePoint(fObjectCenterX, fObjectCenterY, (fObjectCenterX - (fObjectWidth / 2)), (fObjectCenterY - (fObjectHeight / 2)), fObjectAngle, ref newX1, ref newY1);
                        Math2.RotateWithAngleAccordingToReferencePoint(fObjectCenterX, fObjectCenterY, (fObjectCenterX + (fObjectWidth / 2)), (fObjectCenterY - (fObjectHeight / 2)), fObjectAngle, ref newX2, ref newY2);
                        Math2.RotateWithAngleAccordingToReferencePoint(fObjectCenterX, fObjectCenterY, (fObjectCenterX + (fObjectWidth / 2)), (fObjectCenterY + (fObjectHeight / 2)), fObjectAngle, ref newX3, ref newY3);
                        Math2.RotateWithAngleAccordingToReferencePoint(fObjectCenterX, fObjectCenterY, (fObjectCenterX - (fObjectWidth / 2)), (fObjectCenterY + (fObjectHeight / 2)), fObjectAngle, ref newX4, ref newY4);


                        arrRotatedPoints[i].Add(new PointF(newX1, newY1));
                        arrRotatedPoints[i].Add(new PointF(newX2, newY2));
                        arrRotatedPoints[i].Add(new PointF(newX3, newY3));
                        arrRotatedPoints[i].Add(new PointF(newX4, newY4));

                        Math2.RotateWithAngleAccordingToReferencePoint(fObjectCenterX, fObjectCenterY, (fObjectCenterX - (fObjectWidth / 2)) - m_intColorDefectLinkTolerance, (fObjectCenterY - (fObjectHeight / 2)) - m_intColorDefectLinkTolerance, fObjectAngle, ref newX1, ref newY1);
                        Math2.RotateWithAngleAccordingToReferencePoint(fObjectCenterX, fObjectCenterY, (fObjectCenterX + (fObjectWidth / 2)) + m_intColorDefectLinkTolerance, (fObjectCenterY - (fObjectHeight / 2)) - m_intColorDefectLinkTolerance, fObjectAngle, ref newX2, ref newY2);
                        Math2.RotateWithAngleAccordingToReferencePoint(fObjectCenterX, fObjectCenterY, (fObjectCenterX + (fObjectWidth / 2)) + m_intColorDefectLinkTolerance, (fObjectCenterY + (fObjectHeight / 2)) + m_intColorDefectLinkTolerance, fObjectAngle, ref newX3, ref newY3);
                        Math2.RotateWithAngleAccordingToReferencePoint(fObjectCenterX, fObjectCenterY, (fObjectCenterX - (fObjectWidth / 2)) - m_intColorDefectLinkTolerance, (fObjectCenterY + (fObjectHeight / 2)) + m_intColorDefectLinkTolerance, fObjectAngle, ref newX4, ref newY4);

                        arr2DPoints[i].Add(new System.Windows.Point(newX1, newY1));
                        arr2DPoints[i].Add(new System.Windows.Point(newX2, newY2));
                        arr2DPoints[i].Add(new System.Windows.Point(newX3, newY3));
                        arr2DPoints[i].Add(new System.Windows.Point(newX4, newY4));

                        fObjectHeightList.Add(fObjectHeight);
                        fObjectWidthList.Add(fObjectWidth);
                        fObjectCenterXList.Add(fObjectCenterX);
                        fObjectCenterYList.Add(fObjectCenterY);
                        fObjectAngleList.Add(fObjectAngle);
                        fObjectAreaList.Add(intObjectArea);
                        fObjectAreaList2.Add(intObjectArea);
                    }
                    int intTolerance = m_intColorDefectLinkTolerance;
                    int intAngleTolerance = 10;
                    bool blnDecrement = false;
                    if (intTolerance >= 0)
                    {
                        for (int i = 0; i < fObjectHeightList.Count; i++)
                        {
                            if (blnDecrement)
                            {
                                blnDecrement = false;
                                if (i > 0)
                                    i--;
                            }
                            for (int j = 0; j < fObjectHeightList.Count; j++)
                            {
                                if (i != j && i < fObjectHeightList.Count && j < fObjectHeightList.Count)
                                {
                                    if (Intersection.CheckRectRectIntersection(arr2DPoints[i].ToArray(), arr2DPoints[j].ToArray(), intTolerance))
                                    {
                                        PointF[] arrPoints = new PointF[8];

                                        arrPoints[0] = arrRotatedPoints[i][0];
                                        arrPoints[1] = arrRotatedPoints[i][1];
                                        arrPoints[2] = arrRotatedPoints[i][2];
                                        arrPoints[3] = arrRotatedPoints[i][3];
                                        arrPoints[4] = arrRotatedPoints[j][0];
                                        arrPoints[5] = arrRotatedPoints[j][1];
                                        arrPoints[6] = arrRotatedPoints[j][2];
                                        arrPoints[7] = arrRotatedPoints[j][3];

                                        float fMinAngle = 0;
                                        List<PointF> arrMinRect = new List<PointF>();
                                        arrMinRect = MinimumBoundingBox.CalculateMinimumBoundingBox(arrPoints, ref fMinAngle);

                                        if (fMinAngle < 0)
                                            fObjectAngleList[i] = -(90 + fMinAngle);
                                        else
                                            fObjectAngleList[i] = 90 - fMinAngle;

                                        Line onjLine1 = new Line();
                                        Line onjLine2 = new Line();
                                        onjLine1.CalculateStraightLine(arrMinRect[0], arrMinRect[2]);
                                        onjLine2.CalculateStraightLine(arrMinRect[1], arrMinRect[3]);
                                        PointF pCenter = Line.GetCrossPoint(onjLine1, onjLine2);
                                        float p1X = 0, p1Y = 0;
                                        float p2X = 0, p2Y = 0;
                                        float p3X = 0, p3Y = 0;
                                        float p4X = 0, p4Y = 0;
                                        Math2.RotateWithAngleAccordingToReferencePoint(pCenter.X, pCenter.Y, arrMinRect[0].X, arrMinRect[0].Y, -fObjectAngleList[i], ref p1X, ref p1Y);
                                        Math2.RotateWithAngleAccordingToReferencePoint(pCenter.X, pCenter.Y, arrMinRect[1].X, arrMinRect[1].Y, -fObjectAngleList[i], ref p2X, ref p2Y);
                                        Math2.RotateWithAngleAccordingToReferencePoint(pCenter.X, pCenter.Y, arrMinRect[2].X, arrMinRect[2].Y, -fObjectAngleList[i], ref p3X, ref p3Y);
                                        Math2.RotateWithAngleAccordingToReferencePoint(pCenter.X, pCenter.Y, arrMinRect[3].X, arrMinRect[3].Y, -fObjectAngleList[i], ref p4X, ref p4Y);

                                        float pR1X = 0, pR1Y = 0;
                                        float pR2X = 0, pR2Y = 0;
                                        float pR3X = 0, pR3Y = 0;
                                        float pR4X = 0, pR4Y = 0;
                                        Math2.RotateWithAngleAccordingToReferencePoint(pCenter.X, pCenter.Y, Math.Min(Math.Min(p1X, p2X), Math.Min(p3X, p4X)), Math.Min(Math.Min(p1Y, p2Y), Math.Min(p3Y, p4Y)), fObjectAngleList[i], ref pR1X, ref pR1Y); // Top Left
                                        Math2.RotateWithAngleAccordingToReferencePoint(pCenter.X, pCenter.Y, Math.Max(Math.Max(p1X, p2X), Math.Max(p3X, p4X)), Math.Min(Math.Min(p1Y, p2Y), Math.Min(p3Y, p4Y)), fObjectAngleList[i], ref pR2X, ref pR2Y); // Top Right
                                        Math2.RotateWithAngleAccordingToReferencePoint(pCenter.X, pCenter.Y, Math.Max(Math.Max(p1X, p2X), Math.Max(p3X, p4X)), Math.Max(Math.Max(p1Y, p2Y), Math.Max(p3Y, p4Y)), fObjectAngleList[i], ref pR3X, ref pR3Y); // Bottom Right
                                        Math2.RotateWithAngleAccordingToReferencePoint(pCenter.X, pCenter.Y, Math.Min(Math.Min(p1X, p2X), Math.Min(p3X, p4X)), Math.Max(Math.Max(p1Y, p2Y), Math.Max(p3Y, p4Y)), fObjectAngleList[i], ref pR4X, ref pR4Y); // Bottom Left
                                        arrMinRect[0] = new PointF(pR1X, pR1Y);
                                        arrMinRect[1] = new PointF(pR2X, pR2Y);
                                        arrMinRect[2] = new PointF(pR3X, pR3Y);
                                        arrMinRect[3] = new PointF(pR4X, pR4Y);

                                        arrRotatedPoints[i][0] = arrMinRect[0];
                                        arrRotatedPoints[i][1] = arrMinRect[1];
                                        arrRotatedPoints[i][2] = arrMinRect[2];
                                        arrRotatedPoints[i][3] = arrMinRect[3];

                                        Math2.RotateWithAngleAccordingToReferencePoint(pCenter.X, pCenter.Y, Math.Min(Math.Min(p1X, p2X), Math.Min(p3X, p4X)) - m_intColorDefectLinkTolerance, Math.Min(Math.Min(p1Y, p2Y), Math.Min(p3Y, p4Y)) - m_intColorDefectLinkTolerance, fObjectAngleList[i], ref pR1X, ref pR1Y); // Top Left
                                        Math2.RotateWithAngleAccordingToReferencePoint(pCenter.X, pCenter.Y, Math.Max(Math.Max(p1X, p2X), Math.Max(p3X, p4X)) + m_intColorDefectLinkTolerance, Math.Min(Math.Min(p1Y, p2Y), Math.Min(p3Y, p4Y)) - m_intColorDefectLinkTolerance, fObjectAngleList[i], ref pR2X, ref pR2Y); // Top Right
                                        Math2.RotateWithAngleAccordingToReferencePoint(pCenter.X, pCenter.Y, Math.Max(Math.Max(p1X, p2X), Math.Max(p3X, p4X)) + m_intColorDefectLinkTolerance, Math.Max(Math.Max(p1Y, p2Y), Math.Max(p3Y, p4Y)) + m_intColorDefectLinkTolerance, fObjectAngleList[i], ref pR3X, ref pR3Y); // Bottom Right
                                        Math2.RotateWithAngleAccordingToReferencePoint(pCenter.X, pCenter.Y, Math.Min(Math.Min(p1X, p2X), Math.Min(p3X, p4X)) - m_intColorDefectLinkTolerance, Math.Max(Math.Max(p1Y, p2Y), Math.Max(p3Y, p4Y)) + m_intColorDefectLinkTolerance, fObjectAngleList[i], ref pR4X, ref pR4Y); // Bottom Left

                                        arr2DPoints[i][0] = new System.Windows.Point(pR1X, pR1Y);
                                        arr2DPoints[i][1] = new System.Windows.Point(pR2X, pR2Y);
                                        arr2DPoints[i][2] = new System.Windows.Point(pR3X, pR3Y);
                                        arr2DPoints[i][3] = new System.Windows.Point(pR4X, pR4Y);

                                        arrRotatedPoints.RemoveAt(j);
                                        arr2DPoints.RemoveAt(j);

                                        float fDiffX = Math.Max(Math.Abs(p1X - p4X), Math.Abs(p2X - p3X));
                                        float fDiffY = Math.Max(Math.Abs(p3Y - p4Y), Math.Abs(p2Y - p1Y));

                                        fObjectWidthList[i] = fDiffX;
                                        fObjectHeightList[i] = fDiffY;

                                        fObjectCenterXList[i] = pCenter.X;
                                        fObjectCenterYList[i] = pCenter.Y;

                                        fObjectAreaList2.RemoveAt(j);
                                        fObjectAreaList[i] = fObjectAreaList[i] + fObjectAreaList[j];

                                        fObjectHeightList.RemoveAt(j);
                                        fObjectWidthList.RemoveAt(j);
                                        fObjectCenterXList.RemoveAt(j);
                                        fObjectCenterYList.RemoveAt(j);
                                        fObjectAngleList.RemoveAt(j);
                                        fObjectAreaList.RemoveAt(j);

                                        if (j > 0)
                                            j = -1;
                                        if (i > 0)
                                        {
                                            i = 0;
                                        }
                                        else
                                            blnDecrement = true;

                                    }
                                }
                            }
                        }
                    }
                    float fStartX, fStartY, fEndX, fEndY, fWidthMM, fHeightMM, fAreaInMM;
                    for (int i = 0; i < fObjectHeightList.Count; i++)
                    {
                        if (fObjectHeightList[i] < fObjectWidthList[i])
                        {
                            fObjectWidth = fObjectHeightList[i];
                            fObjectHeight = fObjectWidthList[i];

                            fObjectAngle = fObjectAngleList[i];

                            if (fObjectAngle >= 10)//&& fAngle <= 80)
                                fObjectAngle = fObjectAngleList[i] - 90;
                            else
                                fObjectAngle = 90 + fObjectAngleList[i];

                            fObjectWidthList[i] = fObjectWidth;
                            fObjectHeightList[i] = fObjectHeight;
                            fObjectAngleList[i] = fObjectAngle;
                        }
                        else
                        {
                            fObjectHeight = fObjectHeightList[i];
                            fObjectWidth = fObjectWidthList[i];

                            fObjectAngle = fObjectAngleList[i];

                            fObjectWidthList[i] = fObjectWidth;
                            fObjectHeightList[i] = fObjectHeight;
                            fObjectAngleList[i] = fObjectAngle;
                        }

                        fObjectCenterXList[i] += intStartPixelFromEdgeX;
                        fObjectCenterYList[i] += intStartPixelFromEdgeY;
                        fStartX = (float)Math.Floor(fObjectCenterXList[i] - (fObjectWidthList[i] / 2));
                        fStartY = (float)Math.Floor(fObjectCenterYList[i] - (fObjectHeightList[i] / 2));
                        fEndX = (float)Math.Ceiling(fObjectCenterXList[i] + (fObjectWidthList[i] / 2));
                        fEndY = (float)Math.Ceiling(fObjectCenterYList[i] + (fObjectHeightList[i] / 2));

                        // convert width and height to mm
                        fWidthMM = fObjectWidthList[i] / m_fMMToPixelXValue;
                        fHeightMM = fObjectHeightList[i] / m_fMMToPixelYValue; // 11-04-2019 ZJYEOH : Changed m_fMMToPixelXValue to m_fMMToPixelYValue
                        fAreaInMM = fObjectAreaList[i] / m_fMMToPixelXValue / m_fMMToPixelYValue;

                        ColorDefect objDefect = new ColorDefect();

                        objDefect.ref_strName = m_arrDefectColorThresName[intColorThresIndex];
                        objDefect.ref_intFailMask = intFailMask;
                        objDefect.ref_fCenterX = objThresholdSampleROI.ref_ROITotalX + fObjectCenterXList[i];
                        objDefect.ref_fCenterY = objThresholdSampleROI.ref_ROITotalY + fObjectCenterYList[i];
                        objDefect.ref_fStartX = objThresholdSampleROI.ref_ROITotalX + fStartX;
                        objDefect.ref_fStartY = objThresholdSampleROI.ref_ROITotalY + fStartY;
                        objDefect.ref_fEndX = objThresholdSampleROI.ref_ROITotalX + fEndX;
                        objDefect.ref_fEndY = objThresholdSampleROI.ref_ROITotalY + fEndY;
                        objDefect.ref_fWidth = fObjectWidthList[i];
                        objDefect.ref_fHeight = fObjectHeightList[i];
                        objDefect.ref_fArea = fObjectAreaList[i];
                        objDefect.ref_fAngle = fObjectAngleList[i];
                        objDefect.ref_fWidthInMM = fWidthMM;
                        objDefect.ref_fHeightInMM = fHeightMM;
                        objDefect.ref_fAreaInMM2 = fAreaInMM;
                        objDefect.ref_intImageNo = m_arrDefectImageNo[intColorThresIndex] + 1;

                        if (blnCheckLength)
                        {
                            if (m_arrDefectColorInspectionFailCondition[intColorThresIndex] == 0)
                            {
                                if (fWidthMM > m_arrDefectColorInspectionWidth[intColorThresIndex])
                                {
                                    m_intFailColorResultMask |= intFailMask;

                                    blnOverallResult = false;
                                    objDefect.ref_fWidthFailValue = fWidthMM;
                                    objDefect.ref_intFailCriteria |= 0x01;
                                    blnResult = false;
                                }
                                if (fHeightMM > m_arrDefectColorInspectionLength[intColorThresIndex])
                                {
                                    m_intFailColorResultMask |= intFailMask;

                                    blnOverallResult = false;
                                    objDefect.ref_fHeightFailValue = fHeightMM;
                                    objDefect.ref_intFailCriteria |= 0x02;
                                    blnResult = false;
                                }
                            }
                            else
                            {
                                if ((fWidthMM > m_arrDefectColorInspectionWidth[intColorThresIndex]) && (fHeightMM > m_arrDefectColorInspectionLength[intColorThresIndex]))
                                {
                                    m_intFailColorResultMask |= intFailMask;

                                    blnOverallResult = false;
                                    objDefect.ref_fWidthFailValue = fWidthMM;
                                    objDefect.ref_fHeightFailValue = fHeightMM;
                                    objDefect.ref_intFailCriteria |= 0x01;
                                    objDefect.ref_intFailCriteria |= 0x02;
                                    blnResult = false;
                                }
                            }
                        }

                        if (blnCheckArea)
                        {
                            if (/*fAreaInMM < m_arrDefectColorInspectionMinArea[intColorThresIndex] ||*/ fAreaInMM > m_arrDefectColorInspectionMaxArea[intColorThresIndex])
                            {
                                m_intFailColorResultMask |= intFailMask;

                                blnOverallResult = false;
                                objDefect.ref_fAreaFailValue = fAreaInMM;
                                objDefect.ref_intFailCriteria |= 0x04;
                                blnResult = false;
                            }
                        }

                        m_arrColorDefectList.Add(objDefect);
                    }

                    if (blnCheckArea)
                    {
                        fAreaInMM = intObjectTotalArea / m_fMMToPixelXValue / m_fMMToPixelYValue;

                        if (fAreaInMM > m_arrDefectColorInspectionTotalArea[intColorThresIndex])
                        {
                            ColorDefect objDefect = new ColorDefect();

                            objDefect.ref_strName = m_arrDefectColorThresName[intColorThresIndex];
                            objDefect.ref_intFailMask = intFailMask;
                            objDefect.ref_fCenterX = -1;
                            objDefect.ref_fCenterY = -1;
                            objDefect.ref_fStartX = -1;
                            objDefect.ref_fStartY = -1;
                            objDefect.ref_fEndX = -1;
                            objDefect.ref_fEndY = -1;
                            objDefect.ref_fWidth = -1;
                            objDefect.ref_fHeight = -1;
                            objDefect.ref_fArea = intObjectTotalArea;
                            objDefect.ref_fWidthInMM = -1;
                            objDefect.ref_fHeightInMM = -1;
                            objDefect.ref_fAreaInMM2 = fAreaInMM;
                            objDefect.ref_intImageNo = m_arrDefectImageNo[intColorThresIndex] + 1;
                            objDefect.ref_blnFailTotalArea = true;

                            blnOverallResult = false;
                            objDefect.ref_fAreaFailValue = fAreaInMM;
                            objDefect.ref_intFailCriteria |= 0x08;

                            m_arrColorDefectList.Add(objDefect);

                            m_intFailColorResultMask |= intFailMask;

                            for (int b = 0; b < m_arrColorDefectList.Count; b++)
                            {
                                if (((ColorDefect)m_arrColorDefectList[b]).ref_strName == m_arrDefectColorThresName[intColorThresIndex])
                                {
                                    if (!((ColorDefect)m_arrColorDefectList[b]).ref_blnFailTotalArea)
                                    {
                                        ColorDefect objDefect2 = m_arrColorDefectList[b];
                                        objDefect2.ref_blnFailTotalArea = true;
                                        m_arrColorDefectList.RemoveAt(b);
                                        m_arrColorDefectList.Insert(b, objDefect2);
                                    }
                                }
                            }

                            blnResult = false;
                        }

                    }
                }
            }
            objThresholdSampleROI.Dispose();
            objThresholdSampleROI_Temp.Dispose();
            return blnResult;
        }
        private bool CheckImageMerge2PadDefect_PadUse(ROI objImage1SampleUnitROI)
        {
            /*
             * 1. objImage1SampleUnitROI = Sample Pad ROI == Sampel Package Size + Pad ROI Tolerance
             * 
             * 
             * 
             * 
             */

            int intInpectMode = 0; //0=Flexi template size, 1= use sample size, 2: Fix template size
            bool blnResult = true;
            bool blnDebugImage = false;

            // Find a suitable Unit Size for both template and sample ROI (Solution: Use Learn Package ROI size)
            int intTestUnitWidth = m_ImgUnitTemplateImage.Width;
            int intTestUnitHeight = m_ImgUnitTemplateImage.Height;
            // Get threshold value (merge 2 sample image)
            //int intThresholdValue;
            //if (m_blnWantSeparateBrokenPadThresholdSetting)
            //{
            //    if (m_intImageMerge2ThresholdValue < 0)
            //    {
            //        EBW8 objBW8 = EasyImage.AutoThreshold(objImage1SampleUnitROI.ref_ROI, EThresholdMode.MinResidue);
            //        intThresholdValue = objBW8.Value;
            //    }
            //    else
            //        intThresholdValue = m_intImageMerge2ThresholdValue;
            //}
            //else
            //{
            //    if (m_intImageMerge2ThresholdValue < 0)
            //    {
            //        EBW8 objBW8 = EasyImage.AutoThreshold(objImage1SampleUnitROI.ref_ROI, EThresholdMode.MinResidue);
            //        intThresholdValue = objBW8.Value;
            //    }
            //    else
            //        intThresholdValue = m_intImageMerge2ThresholdValue;
            //}

            // Get template threshold value
            int intTemplateThresholdValue = m_intThresholdValue;

            // ---- Sample -------
            // Get ready sample ROI,
            ROI objThresholdSampleROI = new ROI();
            objThresholdSampleROI.AttachImage(m_objInsPadPkgImage1); // Attach sample ROI to ori size image. m_objInsPadPkgImage1 is a ori size image used to keep the sample image temporary for modification such as double threshold
            objThresholdSampleROI.LoadROISetting(0, 0,
                                                 intTestUnitWidth, intTestUnitHeight);
#if (Debug_2_12 || Release_2_12)
            // Threshold sample unit using Pad Threshold
            //EasyImage.Threshold(objImage1SampleUnitROI.ref_ROI, objThresholdSampleROI.ref_ROI, (uint)intThresholdValue);   // error happen when set 255, 0);
            EasyImage.DoubleThreshold(objImage1SampleUnitROI.ref_ROI, objThresholdSampleROI.ref_ROI, (uint)m_intImageMerge2ThresholdLowValue, (uint)m_intImageMerge2ThresholdHighValue, 0, 255, 0);
            EasyImage.Oper(EArithmeticLogicOperation.Invert, objThresholdSampleROI.ref_ROI, objThresholdSampleROI.ref_ROI);

            if (blnDebugImage)
            {
                objImage1SampleUnitROI.SaveImage("D:\\TS\\01_objImage1SampleUnitROI.bmp"); // debug
                objThresholdSampleROI.SaveImage("D:\\TS\\02_objThresholdSampleROI.bmp");   // debug
            }

            // ---- Template ------
            // Get ready template ROI
            ROI objThresholdTemplateROI = new ROI();
            if ((m_ImgTUnitErodeThresImage.Width != m_ImgUnitTemplateImage.Width) || (m_ImgTUnitErodeThresImage.Height != m_ImgUnitTemplateImage.Height))
                m_ImgTUnitErodeThresImage.SetSize(m_ImgUnitTemplateImage.Width, m_ImgUnitTemplateImage.Height);
            if (m_fPadImageGain != 1f)
            {
                EasyImage.GainOffset(m_ImgUnitTemplateImage, m_ImgTUnitErodeThresImage, m_fPadImageGain);
                EasyImage.Threshold(m_ImgTUnitErodeThresImage, m_ImgTUnitErodeThresImage, (uint)m_intThresholdValue);
            }
            else
            {
                EasyImage.Threshold(m_ImgUnitTemplateImage, m_ImgTUnitErodeThresImage, (uint)m_intThresholdValue); //2019-11-11 ZJYEOH : changed intThresholdValue to m_intThresholdValue, pad template need to use pad threshold value
            }
            objThresholdTemplateROI.ref_ROI.Detach();
            objThresholdTemplateROI.ref_ROI.Attach(m_ImgTUnitErodeThresImage);
            objThresholdTemplateROI.LoadROISetting((int)Math.Round((float)m_ImgTUnitErodeThresImage.Width / 2 - (float)intTestUnitWidth / 2, 0, MidpointRounding.AwayFromZero),
                                 (int)Math.Round((float)m_ImgTUnitErodeThresImage.Height / 2 - (float)intTestUnitHeight / 2, 0, MidpointRounding.AwayFromZero),
                                 intTestUnitWidth, intTestUnitHeight);

#elif (DEBUG || RELEASE || RTXRelease || RTXDebug)
            // Threshold sample unit using Pad Threshold
            EasyImage.Threshold(objImage1SampleUnitROI.ref_ROI, objThresholdSampleROI.ref_ROI, intThresholdValue);   // error happen when set 255, 0);
            EasyImage.Oper(EArithmeticLogicOperation.Invert, objThresholdSampleROI.ref_ROI, objThresholdSampleROI.ref_ROI);

            if (blnDebugImage)
            {
                objImage1SampleUnitROI.SaveImage("D:\\TS\\01_objImage1SampleUnitROI.bmp"); // debug
                objThresholdSampleROI.SaveImage("D:\\TS\\02_objThresholdSampleROI.bmp");   // debug
            }

            // ---- Template ------
            // Get ready template ROI
            ROI objThresholdTemplateROI = new ROI();
            if ((m_ImgTUnitErodeThresImage.Width != m_ImgUnitTemplateImage.Width) || (m_ImgTUnitErodeThresImage.Height != m_ImgUnitTemplateImage.Height))
                m_ImgTUnitErodeThresImage.SetSize(m_ImgUnitTemplateImage.Width, m_ImgUnitTemplateImage.Height);
            if (m_fPadImageGain != 1f)
            {
                EasyImage.GainOffset(m_ImgUnitTemplateImage, m_ImgTUnitErodeThresImage, m_fPadImageGain);
                EasyImage.Threshold(m_ImgTUnitErodeThresImage, m_ImgTUnitErodeThresImage, m_intThresholdValue);
            }
            else
            {
                EasyImage.Threshold(m_ImgUnitTemplateImage, m_ImgTUnitErodeThresImage, m_intThresholdValue); //2019-11-11 ZJYEOH : changed intThresholdValue to m_intThresholdValue, pad template need to use pad threshold value
            }
            objThresholdTemplateROI.ref_ROI.Detach();
            objThresholdTemplateROI.ref_ROI.Attach(m_ImgTUnitErodeThresImage);
            objThresholdTemplateROI.LoadROISetting((int)Math.Round((float)m_ImgTUnitErodeThresImage.Width / 2 - (float)intTestUnitWidth / 2, 0, MidpointRounding.AwayFromZero),
                                 (int)Math.Round((float)m_ImgTUnitErodeThresImage.Height / 2 - (float)intTestUnitHeight / 2, 0, MidpointRounding.AwayFromZero),
                                 intTestUnitWidth, intTestUnitHeight);

#endif

            if (blnDebugImage)
            {
                m_ImgUnitTemplateImage.Save("D:\\TS\\03_ImgUnitTemplateImage.bmp");                   // debug
                m_ImgTUnitErodeThresImage.Save("D:\\TS\\04_ImgTUnitErodeThresImage.bmp");        // debug
                objThresholdTemplateROI.SaveImage("D:\\TS\\05_objThresholdTemplateROI.bmp");     // debug
            }

            // ---- White Background --------------
            m_ImgWhiteUnitTemplateImage2.SetSize(m_ImgWhiteUnitTemplateImage.Width, m_ImgWhiteUnitTemplateImage.Height);
            m_ImgWhiteUnitTemplateImage.CopyTo(m_ImgWhiteUnitTemplateImage2);
            ROI objWhiteBgTemplateROI = new ROI();
            objWhiteBgTemplateROI.ref_ROI.Detach();
            objWhiteBgTemplateROI.ref_ROI.Attach(m_ImgWhiteUnitTemplateImage2);
            objWhiteBgTemplateROI.LoadROISetting(0, 0, intTestUnitWidth, intTestUnitHeight);

            if (blnDebugImage)
            {
                objWhiteBgTemplateROI.SaveImage("D:\\TS\\06_objWhiteBgTemplateROI.bmp");     // debug
            }

            if (intInpectMode == 0)
            {
                #region InspectMode == 0 ----------------------------------------------------------------------------------
                int intToleSize = m_intMPDilateHalfWidth; // intToleSize is use to wider the Pad ROI size.
                float fSampleCenterX = 0, fSampleCenterY = 0, fSampleWidth = 0, fSampleHeight = 0;
                float fTemplateCenterX = 0, fTemplateCenterY = 0, fTemplateWidth = 0, fTemplateHeight = 0;

                for (int i = 0; i < m_arrTemplateBlobPads.Count; i++)
                {
                    if (m_arrSampleBlobPads[i].intFailMask != 0)
                        continue;
                    if (!((BlobsFeatures)m_arrTemplateBlobPads[i]).blnFeretActivated)
                    {
                        fSampleCenterX = m_arrSampleBlobPads[i].fCenterX;
                        fSampleCenterY = m_arrSampleBlobPads[i].fCenterY;
                        fSampleWidth = m_arrSampleBlobPads[i].fWidth;
                        fSampleHeight = m_arrSampleBlobPads[i].fHeight;

                        fTemplateCenterX = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fLimitCenterX;
                        fTemplateCenterY = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fLimitCenterY;
                        fTemplateWidth = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fWidth;
                        fTemplateHeight = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fHeight;
                    }
                    else
                    {
                        int MinX, MinY, MaxX, MaxY;

                        System.Drawing.Point p1 = new System.Drawing.Point((int)Math.Round(m_arrSampleBlobPads[i].fFeretCenterX - m_arrSampleBlobPads[i].fFeretWidth / 2), (int)Math.Round(m_arrSampleBlobPads[i].fFeretCenterY - m_arrSampleBlobPads[i].fFeretHeight / 2));
                        System.Drawing.Point p2 = new System.Drawing.Point((int)Math.Round(m_arrSampleBlobPads[i].fFeretCenterX + m_arrSampleBlobPads[i].fFeretWidth / 2), (int)Math.Round(m_arrSampleBlobPads[i].fFeretCenterY - m_arrSampleBlobPads[i].fFeretHeight / 2));
                        System.Drawing.Point p3 = new System.Drawing.Point((int)Math.Round(m_arrSampleBlobPads[i].fFeretCenterX + m_arrSampleBlobPads[i].fFeretWidth / 2), (int)Math.Round(m_arrSampleBlobPads[i].fFeretCenterY + m_arrSampleBlobPads[i].fFeretHeight / 2));
                        System.Drawing.Point p4 = new System.Drawing.Point((int)Math.Round(m_arrSampleBlobPads[i].fFeretCenterX - m_arrSampleBlobPads[i].fFeretWidth / 2), (int)Math.Round(m_arrSampleBlobPads[i].fFeretCenterY + m_arrSampleBlobPads[i].fFeretHeight / 2));


                        float newX1 = 0, newY1 = 0;  // new point 1 = p1
                        float newX2 = 0, newY2 = 0; // new point 2 = p4
                        float newX3 = 0, newY3 = 0; // new point 3  = p2
                        float newX4 = 0, newY4 = 0; // new point 4 = p3


                        float Angle = m_arrSampleBlobPads[i].fFeretAngle;


                        Math2.NewXYAfterRotate1(m_arrSampleBlobPads[i].fFeretCenterX, m_arrSampleBlobPads[i].fFeretCenterY, (float)p1.X, (float)p1.Y, Angle, ref newX1, ref newY1);
                        Math2.NewXYAfterRotate2(m_arrSampleBlobPads[i].fFeretCenterX, m_arrSampleBlobPads[i].fFeretCenterY, (float)p4.X, (float)p4.Y, Angle, ref newX4, ref newY4);
                        Math2.NewXYAfterRotate3(m_arrSampleBlobPads[i].fFeretCenterX, m_arrSampleBlobPads[i].fFeretCenterY, (float)p2.X, (float)p2.Y, Angle, ref newX2, ref newY2);
                        Math2.NewXYAfterRotate4(m_arrSampleBlobPads[i].fFeretCenterX, m_arrSampleBlobPads[i].fFeretCenterY, (float)p3.X, (float)p3.Y, Angle, ref newX3, ref newY3);
                        p1.X = (int)newX1;
                        p1.Y = (int)newY1;
                        p2.X = (int)newX2;
                        p2.Y = (int)newY2;
                        p3.X = (int)newX3;
                        p3.Y = (int)newY3;
                        p4.X = (int)newX4;
                        p4.Y = (int)newY4;

                        if (p1.X > p2.X && p1.X > p3.X && p1.X > p4.X)
                            MaxX = p1.X;
                        else if (p2.X > p1.X && p2.X > p3.X && p2.X > p4.X)
                            MaxX = p2.X;
                        else if (p3.X > p1.X && p3.X > p2.X && p3.X > p4.X)
                            MaxX = p3.X;
                        else
                            MaxX = p4.X;

                        if (p1.Y > p2.Y && p1.Y > p3.Y && p1.Y > p4.Y)
                            MaxY = p1.Y;
                        else if (p2.Y > p1.Y && p2.Y > p3.Y && p2.Y > p4.Y)
                            MaxY = p2.Y;
                        else if (p3.Y > p1.Y && p3.Y > p2.Y && p3.Y > p4.Y)
                            MaxY = p3.Y;
                        else
                            MaxY = p4.Y;

                        if (p1.X < p2.X && p1.X < p3.X && p1.X < p4.X)
                            MinX = p1.X;
                        else if (p2.X < p1.X && p2.X < p3.X && p2.X < p4.X)
                            MinX = p2.X;
                        else if (p3.X < p1.X && p3.X < p2.X && p3.X < p4.X)
                            MinX = p3.X;
                        else
                            MinX = p4.X;

                        if (p1.Y < p2.Y && p1.Y < p3.Y && p1.Y < p4.Y)
                            MinY = p1.Y;
                        else if (p2.Y < p1.Y && p2.Y < p3.Y && p2.Y < p4.Y)
                            MinY = p2.Y;
                        else if (p3.Y < p1.Y && p3.Y < p2.Y && p3.Y < p4.Y)
                            MinY = p3.Y;
                        else
                            MinY = p4.Y;

                        fSampleCenterX = m_arrSampleBlobPads[i].fFeretCenterX;
                        fSampleCenterY = m_arrSampleBlobPads[i].fFeretCenterY;
                        fSampleWidth = MaxX - MinX;// m_arrSampleBlobPads[i].fFeretWidth;
                        fSampleHeight = MaxY - MinY;// m_arrSampleBlobPads[i].fFeretHeight;



                        p1 = new System.Drawing.Point((int)Math.Round(((BlobsFeatures)m_arrTemplateBlobPads[i]).fFeretCenterX - ((BlobsFeatures)m_arrTemplateBlobPads[i]).fFeretWidth / 2), (int)Math.Round(((BlobsFeatures)m_arrTemplateBlobPads[i]).fFeretCenterY - ((BlobsFeatures)m_arrTemplateBlobPads[i]).fFeretHeight / 2));
                        p2 = new System.Drawing.Point((int)Math.Round(((BlobsFeatures)m_arrTemplateBlobPads[i]).fFeretCenterX + ((BlobsFeatures)m_arrTemplateBlobPads[i]).fFeretWidth / 2), (int)Math.Round(((BlobsFeatures)m_arrTemplateBlobPads[i]).fFeretCenterY - ((BlobsFeatures)m_arrTemplateBlobPads[i]).fFeretHeight / 2));
                        p3 = new System.Drawing.Point((int)Math.Round(((BlobsFeatures)m_arrTemplateBlobPads[i]).fFeretCenterX + ((BlobsFeatures)m_arrTemplateBlobPads[i]).fFeretWidth / 2), (int)Math.Round(((BlobsFeatures)m_arrTemplateBlobPads[i]).fFeretCenterY + ((BlobsFeatures)m_arrTemplateBlobPads[i]).fFeretHeight / 2));
                        p4 = new System.Drawing.Point((int)Math.Round(((BlobsFeatures)m_arrTemplateBlobPads[i]).fFeretCenterX - ((BlobsFeatures)m_arrTemplateBlobPads[i]).fFeretWidth / 2), (int)Math.Round(((BlobsFeatures)m_arrTemplateBlobPads[i]).fFeretCenterY + ((BlobsFeatures)m_arrTemplateBlobPads[i]).fFeretHeight / 2));

                        Angle = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fFeretAngle;


                        Math2.NewXYAfterRotate1(((BlobsFeatures)m_arrTemplateBlobPads[i]).fFeretCenterX, ((BlobsFeatures)m_arrTemplateBlobPads[i]).fFeretCenterY, (float)p1.X, (float)p1.Y, Angle, ref newX1, ref newY1);
                        Math2.NewXYAfterRotate2(((BlobsFeatures)m_arrTemplateBlobPads[i]).fFeretCenterX, ((BlobsFeatures)m_arrTemplateBlobPads[i]).fFeretCenterY, (float)p4.X, (float)p4.Y, Angle, ref newX4, ref newY4);
                        Math2.NewXYAfterRotate3(((BlobsFeatures)m_arrTemplateBlobPads[i]).fFeretCenterX, ((BlobsFeatures)m_arrTemplateBlobPads[i]).fFeretCenterY, (float)p2.X, (float)p2.Y, Angle, ref newX2, ref newY2);
                        Math2.NewXYAfterRotate4(((BlobsFeatures)m_arrTemplateBlobPads[i]).fFeretCenterX, ((BlobsFeatures)m_arrTemplateBlobPads[i]).fFeretCenterY, (float)p3.X, (float)p3.Y, Angle, ref newX3, ref newY3);
                        p1.X = (int)newX1;
                        p1.Y = (int)newY1;
                        p2.X = (int)newX2;
                        p2.Y = (int)newY2;
                        p3.X = (int)newX3;
                        p3.Y = (int)newY3;
                        p4.X = (int)newX4;
                        p4.Y = (int)newY4;

                        if (p1.X > p2.X && p1.X > p3.X && p1.X > p4.X)
                            MaxX = p1.X;
                        else if (p2.X > p1.X && p2.X > p3.X && p2.X > p4.X)
                            MaxX = p2.X;
                        else if (p3.X > p1.X && p3.X > p2.X && p3.X > p4.X)
                            MaxX = p3.X;
                        else
                            MaxX = p4.X;

                        if (p1.Y > p2.Y && p1.Y > p3.Y && p1.Y > p4.Y)
                            MaxY = p1.Y;
                        else if (p2.Y > p1.Y && p2.Y > p3.Y && p2.Y > p4.Y)
                            MaxY = p2.Y;
                        else if (p3.Y > p1.Y && p3.Y > p2.Y && p3.Y > p4.Y)
                            MaxY = p3.Y;
                        else
                            MaxY = p4.Y;

                        if (p1.X < p2.X && p1.X < p3.X && p1.X < p4.X)
                            MinX = p1.X;
                        else if (p2.X < p1.X && p2.X < p3.X && p2.X < p4.X)
                            MinX = p2.X;
                        else if (p3.X < p1.X && p3.X < p2.X && p3.X < p4.X)
                            MinX = p3.X;
                        else
                            MinX = p4.X;

                        if (p1.Y < p2.Y && p1.Y < p3.Y && p1.Y < p4.Y)
                            MinY = p1.Y;
                        else if (p2.Y < p1.Y && p2.Y < p3.Y && p2.Y < p4.Y)
                            MinY = p2.Y;
                        else if (p3.Y < p1.Y && p3.Y < p2.Y && p3.Y < p4.Y)
                            MinY = p3.Y;
                        else
                            MinY = p4.Y;

                        fTemplateCenterX = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fFeretCenterX;
                        fTemplateCenterY = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fFeretCenterY;
                        fTemplateWidth = MaxX - MinX;// ((BlobsFeatures)m_arrTemplateBlobPads[i]).fFeretWidth;
                        fTemplateHeight = MaxY - MinY;// ((BlobsFeatures)m_arrTemplateBlobPads[i]).fFeretHeight;
                    }
                    // check the different size between sample and template blobs
                    int intDiffSizeWidth = (int)Math.Round((fSampleWidth - fTemplateWidth) / 2, 0, MidpointRounding.AwayFromZero);
                    int intDiffSizeHeight = (int)Math.Round((fSampleHeight - fTemplateHeight) / 2, 0, MidpointRounding.AwayFromZero);

                    // set the smaller Diff Value to 0 if one is positive value and another one is negative value
                    if ((intDiffSizeWidth > 0 && intDiffSizeHeight < 0) || (intDiffSizeHeight > 0 && intDiffSizeWidth < 0))
                    {
                        if (Math.Abs(intDiffSizeWidth) > Math.Abs(intDiffSizeHeight))
                            intDiffSizeHeight = 0;
                        else
                            intDiffSizeWidth = 0;
                    }

                    // Get biggest size of width and height based on DiffSize value
                    float fWidth, fHeight;
                    if ((intDiffSizeWidth > 0) || (intDiffSizeHeight > 0))
                    {
                        fWidth = fSampleWidth;
                        fHeight = fSampleHeight;
                    }
                    else
                    {
                        fWidth = fTemplateWidth;
                        fHeight = fTemplateHeight;
                    }


                    int intAdjustX = 0, intAdjustY = 0;
                    int intStartX = (int)Math.Round(fTemplateCenterX - fWidth / 2 - intToleSize, 0, MidpointRounding.AwayFromZero);
                    if (intStartX < 0)
                    {
                        intAdjustX = intStartX; // Keep the minus value
                        intStartX = 0;  // Set start value to 0 if smaller than 0.
                    }
                    int intStartY = (int)Math.Round(fTemplateCenterY - fHeight / 2 - intToleSize, 0, MidpointRounding.AwayFromZero);
                    if (intStartY < 0)
                    {
                        intAdjustY = intStartY; // Keep the minus value
                        intStartY = 0;          // Set start value to 0 if smaller than 0
                    }

                    //int intStartX2 = (int)Math.Round(m_arrSampleBlobPads[i].fGravityCenterX - fWidth / 2, 0, MidpointRounding.AwayFromZero);  // 2018 10 05 - CCENG: change from fGravityCenterX to fCenterX. The GravityCenterX is too much different compare to centerX especially when pad shape is not rectangle or square.
                    int intStartX2 = (int)Math.Round(fSampleCenterX - fWidth / 2, 0, MidpointRounding.AwayFromZero);
                    intStartX2 -= intToleSize;
                    if (intStartX2 < 0)
                    {
                        if (intStartX2 > intAdjustX)
                            intAdjustX = intStartX2;
                        intStartX2 = 0;
                    }
                    //int intStartY2 = (int)Math.Round(m_arrSampleBlobPads[i].fGravityCenterY - fHeight / 2, 0, MidpointRounding.AwayFromZero); // 2018 10 05 - CCENG: change from fGravityCenterY to fCenterY. The GravityCenterY is too much different compare to centerY especially when pad shape is not rectangle or square.
                    int intStartY2 = (int)Math.Round(fSampleCenterY - fHeight / 2, 0, MidpointRounding.AwayFromZero);
                    intStartY2 -= intToleSize;
                    if (intStartY2 < 0)
                    {
                        if (intStartY2 > intAdjustY)
                            intAdjustY = intStartY2;
                        intStartY2 = 0;
                    }

                    int intWidth = (int)Math.Round(fWidth, 0, MidpointRounding.AwayFromZero) + intToleSize * 2;
                    int intEndX = intStartX + intWidth + intAdjustX;
                    int intEndAdjustX = 0;
                    if (intEndX > objThresholdTemplateROI.ref_ROIWidth - 1)
                    {
                        intEndAdjustX = (intEndX - (objThresholdTemplateROI.ref_ROIWidth - 1));
                    }
                    int intHeight = (int)Math.Round(fHeight, 0, MidpointRounding.AwayFromZero) + intToleSize * 2;
                    int intEndY = intStartY + intHeight + intAdjustY;
                    int intEndAdjustY = 0;
                    if (intEndY > objThresholdTemplateROI.ref_ROIHeight - 1)
                    {
                        intEndAdjustY = (intEndY - (objThresholdTemplateROI.ref_ROIHeight - 1));
                    }

                    //intEndX = intStartX2 + intWidth + intToleSize * 2 + intAdjustX;
                    intEndX = intStartX2 + intWidth + intAdjustX;
                    if (intEndX > m_ImgWhiteUnitTemplateImage2.Width - 1)
                    {
                        if (intEndAdjustX < (intEndX - (m_ImgWhiteUnitTemplateImage2.Width - 1)))
                            intEndAdjustX = (intEndX - (m_ImgWhiteUnitTemplateImage2.Width - 1));
                    }
                    //intEndY = intStartY2 + intHeight + intToleSize * 2 + intAdjustY;
                    intEndY = intStartY2 + intHeight + intAdjustY;
                    if (intEndY > m_ImgWhiteUnitTemplateImage2.Height - 1)
                    {
                        if (intEndAdjustY < (intEndY - (m_ImgWhiteUnitTemplateImage2.Height - 1)))
                            intEndAdjustY = (intEndY - (m_ImgWhiteUnitTemplateImage2.Height - 1));
                    }

                    intWidth -= intEndAdjustX;
                    intHeight -= intEndAdjustY;

                    // Get template pad roi
                    ROI objTemplatePadROI = new ROI();
                    objTemplatePadROI.AttachImage(objThresholdTemplateROI);
                    objTemplatePadROI.LoadROISetting(intStartX, intStartY, intWidth, intHeight);
                    m_ImgMPUnitTemplateImage.SetSize(objTemplatePadROI.ref_ROIWidth, objTemplatePadROI.ref_ROIHeight);
#if (Debug_2_12 || Release_2_12)
                    if ((intDiffSizeWidth > 0) || (intDiffSizeHeight > 0))
                    {
                        if ((intDiffSizeWidth > 0 && intDiffSizeHeight < 0) || (intDiffSizeHeight > 0 && intDiffSizeWidth < 0))
                        {
                            if (Math.Abs(intDiffSizeWidth) > Math.Abs(intDiffSizeHeight))
                                intDiffSizeHeight = 0;
                            else
                                intDiffSizeWidth = 0;
                        }

                        // Reduce template size follow the m_intMPErodeHalfWidth setting.    
                        EasyImage.ErodeBox(objTemplatePadROI.ref_ROI, m_ImgMPUnitTemplateImage, (uint)Math.Abs(m_intMPErodeHalfWidth), (uint)Math.Abs(m_intMPErodeHalfWidth));
                        EasyImage.Copy(m_ImgMPUnitTemplateImage, objTemplatePadROI.ref_ROI);
                    }
                    else
                    {
                        // ErodeBox will make the pad size smaller.
                        if ((Math.Abs(intDiffSizeWidth) + m_intMPErodeHalfWidth) > 0 || (Math.Abs(intDiffSizeHeight) + m_intMPErodeHalfWidth) > 0)
                        {
                            //EasyImage.ErodeBox(objTemplatePadROI.ref_ROI, m_ImgMPUnitTemplateImage, Math.Abs(intDiffSizeWidth) + m_intMPErodeHalfWidth, Math.Abs(intDiffSizeHeight) + m_intMPErodeHalfWidth);
                            EasyImage.ErodeBox(objTemplatePadROI.ref_ROI, m_ImgMPUnitTemplateImage, (uint)m_intMPErodeHalfWidth, (uint)m_intMPErodeHalfWidth);
                            EasyImage.Copy(m_ImgMPUnitTemplateImage, objTemplatePadROI.ref_ROI);
                        }
                    }

#elif (DEBUG || RELEASE || RTXRelease || RTXDebug)
                    if ((intDiffSizeWidth > 0) || (intDiffSizeHeight > 0))
                    {
                        if ((intDiffSizeWidth > 0 && intDiffSizeHeight < 0) || (intDiffSizeHeight > 0 && intDiffSizeWidth < 0))
                        {
                            if (Math.Abs(intDiffSizeWidth) > Math.Abs(intDiffSizeHeight))
                                intDiffSizeHeight = 0;
                            else
                                intDiffSizeWidth = 0;
                        }

                        // Reduce template size follow the m_intMPErodeHalfWidth setting.    
                        EasyImage.ErodeBox(objTemplatePadROI.ref_ROI, m_ImgMPUnitTemplateImage, Math.Abs(m_intMPErodeHalfWidth), Math.Abs(m_intMPErodeHalfWidth));
                        EasyImage.Copy(m_ImgMPUnitTemplateImage, objTemplatePadROI.ref_ROI);
                    }
                    else
                    {
                        // ErodeBox will make the pad size smaller.
                        if ((Math.Abs(intDiffSizeWidth) + m_intMPErodeHalfWidth) > 0 || (Math.Abs(intDiffSizeHeight) + m_intMPErodeHalfWidth) > 0)
                        {
                            //EasyImage.ErodeBox(objTemplatePadROI.ref_ROI, m_ImgMPUnitTemplateImage, Math.Abs(intDiffSizeWidth) + m_intMPErodeHalfWidth, Math.Abs(intDiffSizeHeight) + m_intMPErodeHalfWidth);
                            EasyImage.ErodeBox(objTemplatePadROI.ref_ROI, m_ImgMPUnitTemplateImage, m_intMPErodeHalfWidth, m_intMPErodeHalfWidth);
                            EasyImage.Copy(m_ImgMPUnitTemplateImage, objTemplatePadROI.ref_ROI);
                        }
                    }

#endif

                    // Get Sample pad ROI
                    ROI objTemplate2PadROI = new ROI();
                    objTemplate2PadROI.ref_ROI.Detach();
                    objTemplate2PadROI.ref_ROI.Attach(m_ImgWhiteUnitTemplateImage2);
                    objTemplate2PadROI.LoadROISetting(intStartX2, intStartY2, intWidth, intHeight);
                    if (blnDebugImage)
                    {
                        m_ImgMPUnitTemplateImage.Save("D:\\TS\\08_" + i.ToString() + "_BfMPTemplateImage.bmp");// debug
                        objTemplatePadROI.SaveImage("D:\\TS\\09_" + i.ToString() + "_AfMPTemplateImage.bmp");// debug
                        objTemplate2PadROI.SaveImage("D:\\TS\\10_" + i.ToString() + "_BfSBTemplate2PadImage.bmp");// debug
                    }

                    if (objTemplatePadROI.ref_ROIWidth != objTemplate2PadROI.ref_ROIWidth)
                    {
                        int intSmallWidth = Math.Min(objTemplatePadROI.ref_ROIWidth, objTemplate2PadROI.ref_ROIWidth);
                        objTemplatePadROI.LoadROISetting(objTemplatePadROI.ref_ROIPositionX, objTemplatePadROI.ref_ROIPositionY, intSmallWidth, objTemplatePadROI.ref_ROIHeight);
                        objTemplate2PadROI.LoadROISetting(objTemplate2PadROI.ref_ROIPositionX, objTemplate2PadROI.ref_ROIPositionY, intSmallWidth, objTemplate2PadROI.ref_ROIHeight);
                    }

                    if (objTemplatePadROI.ref_ROIHeight != objTemplate2PadROI.ref_ROIHeight)
                    {
                        int intSmallHeight = Math.Min(objTemplatePadROI.ref_ROIHeight, objTemplate2PadROI.ref_ROIHeight);
                        objTemplatePadROI.LoadROISetting(objTemplatePadROI.ref_ROIPositionX, objTemplatePadROI.ref_ROIPositionY, objTemplatePadROI.ref_ROIWidth, intSmallHeight);
                        objTemplate2PadROI.LoadROISetting(objTemplate2PadROI.ref_ROIPositionX, objTemplate2PadROI.ref_ROIPositionY, objTemplate2PadROI.ref_ROIWidth, intSmallHeight);
                    }

                    // subtract sample pad roi - template pad roi
                    EasyImage.Oper(EArithmeticLogicOperation.Subtract, objTemplate2PadROI.ref_ROI, objTemplatePadROI.ref_ROI, objTemplate2PadROI.ref_ROI);

                    if (blnDebugImage)
                        objTemplate2PadROI.SaveImage("D:\\TS\\11_" + i.ToString() + "_AfSBTemplate2PadImage.bmp");// debug

                    objTemplate2PadROI.Dispose();
                    objTemplatePadROI.Dispose();
                }

                #endregion ------------------------------------------------------------------------------------------------
            }

            // Subtract sample ROI - template ROI
            if (blnDebugImage)
            {
                objThresholdSampleROI.SaveImage("D:\\TS\\12_BfSBSampleROI.bmp");// debug   // sample: Background white color, pad black color, defect on pad is white color
                objWhiteBgTemplateROI.SaveImage("D:\\TS\\13_objTemplate2ROI.bmp");// debug // template: Background white color, pad black color.
            }

            if (objThresholdSampleROI.ref_ROIWidth != objWhiteBgTemplateROI.ref_ROIWidth)
            {
                int intSmallWidth = Math.Min(objThresholdSampleROI.ref_ROIWidth, objWhiteBgTemplateROI.ref_ROIWidth);
                objThresholdSampleROI.LoadROISetting(objThresholdSampleROI.ref_ROIPositionX, objThresholdSampleROI.ref_ROIPositionY, intSmallWidth, objThresholdSampleROI.ref_ROIHeight);
                objWhiteBgTemplateROI.LoadROISetting(objWhiteBgTemplateROI.ref_ROIPositionX, objWhiteBgTemplateROI.ref_ROIPositionY, intSmallWidth, objWhiteBgTemplateROI.ref_ROIHeight);
            }

            if (objThresholdSampleROI.ref_ROIHeight != objWhiteBgTemplateROI.ref_ROIHeight)
            {
                int intSmallHeight = Math.Min(objThresholdSampleROI.ref_ROIHeight, objWhiteBgTemplateROI.ref_ROIHeight);
                objThresholdSampleROI.LoadROISetting(objThresholdSampleROI.ref_ROIPositionX, objThresholdSampleROI.ref_ROIPositionY, objThresholdSampleROI.ref_ROIWidth, intSmallHeight);
                objWhiteBgTemplateROI.LoadROISetting(objWhiteBgTemplateROI.ref_ROIPositionX, objWhiteBgTemplateROI.ref_ROIPositionY, objWhiteBgTemplateROI.ref_ROIWidth, intSmallHeight);
            }

            EasyImage.Oper(EArithmeticLogicOperation.Subtract, objThresholdSampleROI.ref_ROI, objWhiteBgTemplateROI.ref_ROI, objThresholdSampleROI.ref_ROI);

            if (blnDebugImage)
                objThresholdSampleROI.SaveImage("D:\\TS\\14_AfSBSampleROI.bmp");// debug

            // Build blobs object for subtract image
            m_objImage1PadEBlobs.BuildObjects_Filter_GetElement(objThresholdSampleROI, false, true, 0, 125, (int)m_fImageMerge2BlobsMinArea, 999999, false, 0x0F);

            if (m_objImage1PadEBlobs.ref_intNumSelectedObject > 0)
            {
                float fGravityCenterX = 0, fGravityCenterY = 0, fCenterX = 0, fCenterY = 0, fWidth = 0, fHeight = 0;
                float fStartX = 0, fStartY = 0, fEndX = 0, fEndY = 0;
                int intArea = 0;

                for (int i = 0; i < m_objImage1PadEBlobs.ref_intNumSelectedObject; i++)
                {
                    fGravityCenterX = m_objImage1PadEBlobs.ref_arrGravityCenterX[i];
                    fGravityCenterY = m_objImage1PadEBlobs.ref_arrGravityCenterY[i];
                    fCenterX = m_objImage1PadEBlobs.ref_arrLimitCenterX[i];
                    fCenterY = m_objImage1PadEBlobs.ref_arrLimitCenterY[i];
                    fWidth = m_objImage1PadEBlobs.ref_arrWidth[i];
                    fHeight = m_objImage1PadEBlobs.ref_arrHeight[i];
                    intArea = m_objImage1PadEBlobs.ref_arrArea[i];

                    // Get object start point and end point
                    fStartX = fCenterX - (fWidth / 2);
                    fStartY = fCenterY - (fHeight / 2);
                    fEndX = fCenterX + (fWidth / 2);
                    fEndY = fCenterY + (fHeight / 2);

                    int intMatch = Match1TemplateObjects(fStartX, fStartY, fEndX, fEndY, fGravityCenterX, fGravityCenterY);

                    if (intMatch >= 0)
                    {
                        if (m_blnWantCheckBrokenPadLength || m_blnWantCheckBrokenPadArea)
                        {
                            if (m_arrSamplePadBroken[intMatch].fAreaMM == 0)
                            {
                                m_arrSamplePadBroken[intMatch].fAreaMM = intArea * m_fAreaMMPerPixel;  // Change unit pixel to mm
                                m_arrSamplePadBroken[intMatch].fWidthMM = fWidth * m_fMMPerPixelX;  // Change unit pixel to mm
                                m_arrSamplePadBroken[intMatch].fHeightMM = fHeight * m_fMMPerPixelY;  // Change unit pixel to mm

                                m_arrSamplePadBroken[intMatch].fWidth = fWidth;
                                m_arrSamplePadBroken[intMatch].fHeight = fHeight;
                                m_arrSamplePadBroken[intMatch].fStartX = fStartX;
                                m_arrSamplePadBroken[intMatch].fStartY = fStartY;
                                m_arrSamplePadBroken[intMatch].fEndX = fEndX;
                                m_arrSamplePadBroken[intMatch].fEndY = fEndY;
                            }
                        }

                        if (m_blnWantCheckBrokenPadLength)
                        {
                            if ((m_arrSampleBlobPads[intMatch].intFailMask & ~0x08) == 0) // Make sure the sample pad has not other failure.
                            {
                                if (((BlobsFeatures)m_arrTemplateBlobPads[intMatch]).blnEnable)
                                {
                                    float fWidthMM = fWidth / m_fMMToPixelXValue;
                                    float fHeightMM = fHeight / m_fMMToPixelYValue; // 11-04-2019 ZJYEOH : Changed m_fMMToPixelXValue to m_fMMToPixelYValue
                                    float fBrokenAreaMM2 = (float)intArea / m_fMMtoPixelAreaValue;

                                    bool blnResult1 = true;
                                    if (m_blnWantUseGroupToleranceSetting)
                                    {
                                        int intGroupNo = ((BlobsFeatures)m_arrTemplateBlobPads[intMatch]).intGroupID;
                                        if ((fWidthMM > ((BlobsFeatures)m_arrGroupTemplateBlobPads[intGroupNo]).fMaxBrokenLength) ||
                                            (fHeightMM > ((BlobsFeatures)m_arrGroupTemplateBlobPads[intGroupNo]).fMaxBrokenLength))
                                        {
                                            blnResult1 = false;
                                        }
                                    }
                                    else
                                    {
                                        if ((fWidthMM > ((BlobsFeatures)m_arrTemplateBlobPads[intMatch]).fMaxBrokenLength) ||
                                            (fHeightMM > ((BlobsFeatures)m_arrTemplateBlobPads[intMatch]).fMaxBrokenLength))
                                        {
                                            blnResult1 = false;
                                        }
                                    }

                                    if (!blnResult1)
                                    {
                                        if (Math.Max(m_arrSamplePadBroken[intMatch].fWidthMM, m_arrSamplePadBroken[intMatch].fHeightMM) <= Math.Max(fWidthMM, fHeightMM))
                                        {
                                            m_arrSamplePadBroken[intMatch].fAreaMM = intArea * m_fAreaMMPerPixel;  // Change unit pixel to mm
                                            m_arrSamplePadBroken[intMatch].fWidthMM = fWidth * m_fMMPerPixelX;  // Change unit pixel to mm
                                            m_arrSamplePadBroken[intMatch].fHeightMM = fHeight * m_fMMPerPixelY;  // Change unit pixel to mm

                                            m_arrSamplePadBroken[intMatch].fWidth = fWidth;
                                            m_arrSamplePadBroken[intMatch].fHeight = fHeight;
                                            m_arrSamplePadBroken[intMatch].fStartX = fStartX;
                                            m_arrSamplePadBroken[intMatch].fStartY = fStartY;
                                            m_arrSamplePadBroken[intMatch].fEndX = fEndX;
                                            m_arrSamplePadBroken[intMatch].fEndY = fEndY;
                                        }

                                        m_blnFailBrokenLength = true;
                                        m_arrSampleBlobPads[intMatch].intFailMask |= 0x08;
                                        m_intFailResultMask |= 0x08;

                                        float fMaxLength = Math.Max(fWidthMM, fHeightMM);

                                        // Collect scratch min and max area for display error message
                                        if ((m_fResultBrokenMinArea == -1) || (fMaxLength < m_fResultBrokenMinArea))
                                        {
                                            m_fResultBrokenMinArea = fMaxLength;
                                        }

                                        if ((m_fResultBrokenMaxArea == -1) || (fMaxLength > m_fResultBrokenMaxArea))
                                        {
                                            m_fResultBrokenMaxArea = fMaxLength;
                                        }

                                        Defect objDefect = new Defect();
                                        objDefect.ref_strName = "Broken Pad";
                                        objDefect.ref_intFailMask |= 0x08;
                                        objDefect.ref_fArea = Convert.ToSingle(intArea);
                                        objDefect.ref_fCenterX = objImage1SampleUnitROI.ref_ROITotalX + fCenterX;  // objThresholdSampleROI.ref_ROITotalX + fCenterX;
                                        objDefect.ref_fCenterY = objImage1SampleUnitROI.ref_ROITotalY + fCenterY;  // objThresholdSampleROI.ref_ROITotalY + fCenterY;
                                        objDefect.ref_fStartX = fStartX;
                                        objDefect.ref_fStartY = fStartY;
                                        objDefect.ref_fEndX = fEndX;
                                        objDefect.ref_fEndY = fEndY;
                                        objDefect.ref_fWidth = fWidth;
                                        objDefect.ref_fHeight = fHeight;
                                        objDefect.ref_fWidthInMM = fWidthMM;
                                        objDefect.ref_fHeightInMM = fHeightMM;
                                        objDefect.ref_fAreaInMM2 = fBrokenAreaMM2;

                                        if (fWidthMM > ((BlobsFeatures)m_arrTemplateBlobPads[intMatch]).fMaxBrokenLength)
                                            objDefect.ref_intFailCriteria |= 0x01;

                                        if (fHeightMM > ((BlobsFeatures)m_arrTemplateBlobPads[intMatch]).fMaxBrokenLength)
                                            objDefect.ref_intFailCriteria |= 0x02;

                                        m_arrPadDefectList.Add(objDefect);

                                        if (blnResult)
                                            blnResult = false;
                                    }
                                }
                            }
                        }

                        //if (m_blnWantCheckBrokenPadArea && !m_blnFailBrokenLength)
                        if (m_blnWantCheckBrokenPadArea)    // 2021 05 20 - CCENG: cannot check m_blnFailBrokenLength bcos this will cause second broken pad display fail but no draw red color.
                        {
                            if ((m_arrSampleBlobPads[intMatch].intFailMask & ~0x08) == 0) // Make sure the sample pad has not other failure.
                            {
                                if (((BlobsFeatures)m_arrTemplateBlobPads[intMatch]).blnEnable)
                                {
                                    float fWidthMM = fWidth / m_fMMToPixelXValue;
                                    float fHeightMM = fHeight / m_fMMToPixelYValue; // 11-04-2019 ZJYEOH : Changed m_fMMToPixelXValue to m_fMMToPixelYValue
                                    float fBrokenAreaMM2 = (float)intArea / m_fMMtoPixelAreaValue;

                                    bool blnResult1 = true;
                                    if (m_blnWantUseGroupToleranceSetting)
                                    {
                                        int intGroupNo = ((BlobsFeatures)m_arrTemplateBlobPads[intMatch]).intGroupID;
                                        if (fBrokenAreaMM2 > ((BlobsFeatures)m_arrGroupTemplateBlobPads[intGroupNo]).fMaxBroken)
                                        {
                                            blnResult1 = false;
                                        }

                                    }
                                    else
                                    {
                                        if (fBrokenAreaMM2 > ((BlobsFeatures)m_arrTemplateBlobPads[intMatch]).fMaxBroken)
                                        {
                                            blnResult1 = false;
                                        }
                                    }

                                    if (!blnResult1)
                                    {
                                        m_blnFailBrokenArea = true;
                                        m_arrSampleBlobPads[intMatch].intFailMask |= 0x08;
                                        m_intFailResultMask |= 0x08;

                                        // Collect scratch min and max area for display error message
                                        if ((m_fResultBrokenMinArea == -1) || (fBrokenAreaMM2 < m_fResultBrokenMinArea))
                                        {
                                            m_fResultBrokenMinArea = fBrokenAreaMM2;
                                        }

                                        if ((m_fResultBrokenMaxArea == -1) || (fBrokenAreaMM2 > m_fResultBrokenMaxArea))
                                        {
                                            m_fResultBrokenMaxArea = fBrokenAreaMM2;
                                        }

                                        Defect objDefect = new Defect();
                                        objDefect.ref_strName = "Broken Pad";
                                        objDefect.ref_intFailMask |= 0x08;
                                        objDefect.ref_fArea = Convert.ToSingle(intArea);
                                        objDefect.ref_fCenterX = objImage1SampleUnitROI.ref_ROITotalX + fCenterX;  // objThresholdSampleROI.ref_ROITotalX + fCenterX;
                                        objDefect.ref_fCenterY = objImage1SampleUnitROI.ref_ROITotalY + fCenterY;  // objThresholdSampleROI.ref_ROITotalY + fCenterY;
                                        objDefect.ref_fStartX = fStartX;
                                        objDefect.ref_fStartY = fStartY;
                                        objDefect.ref_fEndX = fEndX;
                                        objDefect.ref_fEndY = fEndY;
                                        objDefect.ref_fWidth = fWidth;
                                        objDefect.ref_fHeight = fHeight;
                                        objDefect.ref_fWidthInMM = fWidthMM;
                                        objDefect.ref_fHeightInMM = fHeightMM;
                                        objDefect.ref_fAreaInMM2 = fBrokenAreaMM2;
                                        objDefect.ref_intFailCriteria |= 0x04;

                                        m_arrPadDefectList.Add(objDefect);

                                        if (blnResult)
                                            blnResult = false;

                                    }
                                }
                            }
                        }
                    }
                }
            }

            objThresholdSampleROI.Dispose();
            objThresholdTemplateROI.Dispose();
            objWhiteBgTemplateROI.Dispose();
            return blnResult;
        }

//        private bool CheckImageMerge2PadDefect_PadUse_UsingCleanBackground(ROI objImage1SampleUnitROI)
//        {
//            /*
//             * 1. objImage1SampleUnitROI = Sample Pad ROI == Sampel Package Size + Pad ROI Tolerance
//             * 
//             * 
//             * 
//             * 
//             */

//            int intInpectMode = 0; //0=Flexi template size, 1= use sample size, 2: Fix template size
//            bool blnResult = true;
//            bool blnDebugImage = true;

//            // Find a suitable Unit Size for both template and sample ROI (Solution: Use Learn Package ROI size)
//            int intTestUnitWidth = m_ImgUnitTemplateImage.Width;
//            int intTestUnitHeight = m_ImgUnitTemplateImage.Height;
//            // Get threshold value
//            int intThresholdValue;
//            if (m_intImageMerge2ThresholdValue < 0)
//            {
//                EBW8 objBW8 = EasyImage.AutoThreshold(objImage1SampleUnitROI.ref_ROI, EThresholdMode.MinResidue);
//                intThresholdValue = objBW8.Value;
//            }
//            else
//                intThresholdValue = m_intImageMerge2ThresholdValue;

//            // ---- Sample -------
//            // Get ready sample ROI,
//            ROI objThresholdSampleROI = new ROI();
//            objThresholdSampleROI.AttachImage(m_objInsPadPkgImage1); // Attach sample ROI to ori size image. m_objInsPadPkgImage1 is a ori size image used to keep the sample image temporary for modification such as double threshold
//            objThresholdSampleROI.LoadROISetting(0, 0,
//                                                 intTestUnitWidth, intTestUnitHeight);
//#if (Debug_2_12 || Release_2_12)
//            // Threshold sample unit using Pad Threshold
//            EasyImage.Threshold(objImage1SampleUnitROI.ref_ROI, objThresholdSampleROI.ref_ROI, (uint)intThresholdValue);   // error happen when set 255, 0);
//            EasyImage.Oper(EArithmeticLogicOperation.Invert, objThresholdSampleROI.ref_ROI, objThresholdSampleROI.ref_ROI);

//            if (blnDebugImage)
//            {
//                objImage1SampleUnitROI.SaveImage("D:\\TS\\01_objImage1SampleUnitROI.bmp"); // debug
//                objThresholdSampleROI.SaveImage("D:\\TS\\02_objThresholdSampleROI.bmp");   // debug
//            }

//            // ---- Template ------
//            // Get ready template ROI
//            ROI objThresholdTemplateROI = new ROI();
//            if ((m_ImgTUnitErodeThresImage.Width != m_ImgUnitTemplateImage.Width) || (m_ImgTUnitErodeThresImage.Height != m_ImgUnitTemplateImage.Height))
//                m_ImgTUnitErodeThresImage.SetSize(m_ImgUnitTemplateImage.Width, m_ImgUnitTemplateImage.Height);
//            EasyImage.Threshold(m_ImgUnitTemplateImage, m_ImgTUnitErodeThresImage, (uint)m_intThresholdValue);//intThresholdValue);
//            objThresholdTemplateROI.ref_ROI.Detach();
//            objThresholdTemplateROI.ref_ROI.Attach(m_ImgTUnitErodeThresImage);
//            objThresholdTemplateROI.LoadROISetting((int)Math.Round((float)m_ImgTUnitErodeThresImage.Width / 2 - (float)intTestUnitWidth / 2, 0, MidpointRounding.AwayFromZero),
//                                 (int)Math.Round((float)m_ImgTUnitErodeThresImage.Height / 2 - (float)intTestUnitHeight / 2, 0, MidpointRounding.AwayFromZero),
//                                 intTestUnitWidth, intTestUnitHeight);

//#elif (DEBUG || RELEASE || RTXRelease || RTXDebug)
//            // Threshold sample unit using Pad Threshold
//            EasyImage.Threshold(objImage1SampleUnitROI.ref_ROI, objThresholdSampleROI.ref_ROI, intThresholdValue);   // error happen when set 255, 0);
//            EasyImage.Oper(EArithmeticLogicOperation.Invert, objThresholdSampleROI.ref_ROI, objThresholdSampleROI.ref_ROI);

//            if (blnDebugImage)
//            {
//                objImage1SampleUnitROI.SaveImage("D:\\TS\\01_objImage1SampleUnitROI.bmp"); // debug
//                objThresholdSampleROI.SaveImage("D:\\TS\\02_objThresholdSampleROI.bmp");   // debug
//            }

//            // ---- Template ------
//            // Get ready template ROI
//            ROI objThresholdTemplateROI = new ROI();
//            if ((m_ImgTUnitErodeThresImage.Width != m_ImgUnitTemplateImage.Width) || (m_ImgTUnitErodeThresImage.Height != m_ImgUnitTemplateImage.Height))
//                m_ImgTUnitErodeThresImage.SetSize(m_ImgUnitTemplateImage.Width, m_ImgUnitTemplateImage.Height);
//            EasyImage.Threshold(m_ImgUnitTemplateImage, m_ImgTUnitErodeThresImage, m_intThresholdValue);//intThresholdValue);
//            objThresholdTemplateROI.ref_ROI.Detach();
//            objThresholdTemplateROI.ref_ROI.Attach(m_ImgTUnitErodeThresImage);
//            objThresholdTemplateROI.LoadROISetting((int)Math.Round((float)m_ImgTUnitErodeThresImage.Width / 2 - (float)intTestUnitWidth / 2, 0, MidpointRounding.AwayFromZero),
//                                 (int)Math.Round((float)m_ImgTUnitErodeThresImage.Height / 2 - (float)intTestUnitHeight / 2, 0, MidpointRounding.AwayFromZero),
//                                 intTestUnitWidth, intTestUnitHeight);

//#endif

//            if (blnDebugImage)
//            {
//                m_ImgUnitTemplateImage.Save("D:\\TS\\03_ImgUnitTemplateImage.bmp");                   // debug
//                m_ImgTUnitErodeThresImage.Save("D:\\TS\\04_ImgTUnitErodeThresImage.bmp");        // debug
//                objThresholdTemplateROI.SaveImage("D:\\TS\\05_objThresholdTemplateROI.bmp");     // debug
//            }

//            // ---- White Background --------------
//            m_ImgWhiteUnitTemplateImage2.SetSize(m_ImgWhiteUnitTemplateImage.Width, m_ImgWhiteUnitTemplateImage.Height);
//            m_ImgWhiteUnitTemplateImage.CopyTo(m_ImgWhiteUnitTemplateImage2);
//            ROI objWhiteBgTemplateROI = new ROI();
//            objWhiteBgTemplateROI.ref_ROI.Detach();
//            objWhiteBgTemplateROI.ref_ROI.Attach(m_ImgWhiteUnitTemplateImage2);
//            objWhiteBgTemplateROI.LoadROISetting(0, 0, intTestUnitWidth, intTestUnitHeight);

//            if (blnDebugImage)
//            {
//                objWhiteBgTemplateROI.SaveImage("D:\\TS\\06_objWhiteBgTemplateROI.bmp");     // debug
//            }

//            if (intInpectMode == 0)
//            {
//                #region InspectMode == 0 ----------------------------------------------------------------------------------
//                int intToleSize = m_intMPDilateHalfWidth; // intToleSize is use to wider the Pad ROI size.
//                for (int i = 0; i < m_arrTemplateBlobPads.Count; i++)
//                {
//                    if (m_arrSampleBlobPads[i].intFailMask != 0)
//                        continue;

//                    // check the different size between sample and template blobs
//                    int intDiffSizeWidth = (int)Math.Round((m_arrSampleBlobPads[i].fWidth - ((BlobsFeatures)m_arrTemplateBlobPads[i]).fWidth) / 2, 0, MidpointRounding.AwayFromZero);
//                    int intDiffSizeHeight = (int)Math.Round((m_arrSampleBlobPads[i].fHeight - ((BlobsFeatures)m_arrTemplateBlobPads[i]).fHeight) / 2, 0, MidpointRounding.AwayFromZero);

//                    // set the smaller Diff Value to 0 if one is positive value and another one is negative value
//                    if ((intDiffSizeWidth > 0 && intDiffSizeHeight < 0) || (intDiffSizeHeight > 0 && intDiffSizeWidth < 0))
//                    {
//                        if (Math.Abs(intDiffSizeWidth) > Math.Abs(intDiffSizeHeight))
//                            intDiffSizeHeight = 0;
//                        else
//                            intDiffSizeWidth = 0;
//                    }

//                    // Get biggest size of width and height based on DiffSize value
//                    float fWidth, fHeight;
//                    if ((intDiffSizeWidth > 0) || (intDiffSizeHeight > 0))
//                    {
//                        fWidth = m_arrSampleBlobPads[i].fWidth;
//                        fHeight = m_arrSampleBlobPads[i].fHeight;
//                    }
//                    else
//                    {
//                        fWidth = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fWidth;
//                        fHeight = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fHeight;
//                    }


//                    int intAdjustX = 0, intAdjustY = 0;
//                    int intStartX = (int)Math.Round(((BlobsFeatures)m_arrTemplateBlobPads[i]).fLimitCenterX - fWidth / 2 - intToleSize, 0, MidpointRounding.AwayFromZero);
//                    if (intStartX < 0)
//                    {
//                        intAdjustX = intStartX; // Keep the minus value
//                        intStartX = 0;  // Set start value to 0 if smaller than 0.
//                    }
//                    int intStartY = (int)Math.Round(((BlobsFeatures)m_arrTemplateBlobPads[i]).fLimitCenterY - fHeight / 2 - intToleSize, 0, MidpointRounding.AwayFromZero);
//                    if (intStartY < 0)
//                    {
//                        intAdjustY = intStartY; // Keep the minus value
//                        intStartY = 0;          // Set start value to 0 if smaller than 0
//                    }

//                    //int intStartX2 = (int)Math.Round(m_arrSampleBlobPads[i].fGravityCenterX - fWidth / 2, 0, MidpointRounding.AwayFromZero);  // 2018 10 05 - CCENG: change from fGravityCenterX to fCenterX. The GravityCenterX is too much different compare to centerX especially when pad shape is not rectangle or square.
//                    int intStartX2 = (int)Math.Round(m_arrSampleBlobPads[i].fCenterX - fWidth / 2, 0, MidpointRounding.AwayFromZero);
//                    intStartX2 -= intToleSize;
//                    if (intStartX2 < 0)
//                    {
//                        if (intStartX2 > intAdjustX)
//                            intAdjustX = intStartX2;
//                        intStartX2 = 0;
//                    }
//                    //int intStartY2 = (int)Math.Round(m_arrSampleBlobPads[i].fGravityCenterY - fHeight / 2, 0, MidpointRounding.AwayFromZero); // 2018 10 05 - CCENG: change from fGravityCenterY to fCenterY. The GravityCenterY is too much different compare to centerY especially when pad shape is not rectangle or square.
//                    int intStartY2 = (int)Math.Round(m_arrSampleBlobPads[i].fCenterY - fHeight / 2, 0, MidpointRounding.AwayFromZero);
//                    intStartY2 -= intToleSize;
//                    if (intStartY2 < 0)
//                    {
//                        if (intStartY2 > intAdjustY)
//                            intAdjustY = intStartY2;
//                        intStartY2 = 0;
//                    }

//                    int intWidth = (int)Math.Round(fWidth, 0, MidpointRounding.AwayFromZero) + intToleSize * 2;
//                    int intEndX = intStartX + intWidth + intAdjustX;
//                    int intEndAdjustX = 0;
//                    if (intEndX > objThresholdTemplateROI.ref_ROIWidth - 1)
//                    {
//                        intEndAdjustX = (intEndX - (objThresholdTemplateROI.ref_ROIWidth - 1));
//                    }
//                    int intHeight = (int)Math.Round(fHeight, 0, MidpointRounding.AwayFromZero) + intToleSize * 2;
//                    int intEndY = intStartY + intHeight + intAdjustY;
//                    int intEndAdjustY = 0;
//                    if (intEndY > objThresholdTemplateROI.ref_ROIHeight - 1)
//                    {
//                        intEndAdjustY = (intEndY - (objThresholdTemplateROI.ref_ROIHeight - 1));
//                    }

//                    //intEndX = intStartX2 + intWidth + intToleSize * 2 + intAdjustX;
//                    intEndX = intStartX2 + intWidth + intAdjustX;
//                    if (intEndX > m_ImgWhiteUnitTemplateImage2.Width - 1)
//                    {
//                        if (intEndAdjustX < (intEndX - (m_ImgWhiteUnitTemplateImage2.Width - 1)))
//                            intEndAdjustX = (intEndX - (m_ImgWhiteUnitTemplateImage2.Width - 1));
//                    }
//                    //intEndY = intStartY2 + intHeight + intToleSize * 2 + intAdjustY;
//                    intEndY = intStartY2 + intHeight + intAdjustY;
//                    if (intEndY > m_ImgWhiteUnitTemplateImage2.Height - 1)
//                    {
//                        if (intEndAdjustY < (intEndY - (m_ImgWhiteUnitTemplateImage2.Height - 1)))
//                            intEndAdjustY = (intEndY - (m_ImgWhiteUnitTemplateImage2.Height - 1));
//                    }

//                    intWidth -= intEndAdjustX;
//                    intHeight -= intEndAdjustY;

//                    // Get template pad roi
//                    ROI objTemplatePadROI = new ROI();
//                    objTemplatePadROI.AttachImage(objThresholdTemplateROI);
//                    objTemplatePadROI.LoadROISetting(intStartX, intStartY, intWidth, intHeight);
//                    m_ImgMPUnitTemplateImage.SetSize(objTemplatePadROI.ref_ROIWidth, objTemplatePadROI.ref_ROIHeight);
//#if (Debug_2_12 || Release_2_12)
//                    if ((intDiffSizeWidth > 0) || (intDiffSizeHeight > 0))
//                    {
//                        if ((intDiffSizeWidth > 0 && intDiffSizeHeight < 0) || (intDiffSizeHeight > 0 && intDiffSizeWidth < 0))
//                        {
//                            if (Math.Abs(intDiffSizeWidth) > Math.Abs(intDiffSizeHeight))
//                                intDiffSizeHeight = 0;
//                            else
//                                intDiffSizeWidth = 0;
//                        }
//                        objTemplatePadROI.ref_ROI.Save("D:\\TS\\BeforeErode" + i.ToString() + ".bmp");// debug
//                        // Reduce template size follow the m_intMPErodeHalfWidth setting.    
//                        EasyImage.ErodeBox(objTemplatePadROI.ref_ROI, m_ImgMPUnitTemplateImage, (uint)Math.Abs(m_intMPErodeHalfWidth), (uint)Math.Abs(m_intMPErodeHalfWidth));
//                        EasyImage.Copy(m_ImgMPUnitTemplateImage, objTemplatePadROI.ref_ROI);
//                        objTemplatePadROI.ref_ROI.Save("D:\\TS\\AfterErode" + i.ToString() + ".bmp");// debug

//                        // Maybe will use in future
//                        // 2019-11-11 ZJYEOH : Subtract template threshold image with white edge image
//                        ImageDrawing ImgEdgeWhite = new ImageDrawing(m_ImgWhiteUnitTemplateImage.Width, m_ImgWhiteUnitTemplateImage.Height);
//                        EasyImage.Copy(m_ImgWhiteUnitTemplateImage, ImgEdgeWhite.ref_objMainImage);
//                        ROI ROIEdge = new ROI();
//                        ROI ROIWhite = new ROI();
//                        ROIEdge.LoadROISetting(0, 0, objTemplatePadROI.ref_ROIWidth, objTemplatePadROI.ref_ROIHeight);
//                        ROIEdge.AttachImage(ImgEdgeWhite);
//                        ROIEdge.LoadROISetting(m_intMPErodeHalfWidth, m_intMPErodeHalfWidth, objTemplatePadROI.ref_ROIWidth - m_intMPErodeHalfWidth * 2, objTemplatePadROI.ref_ROIHeight - m_intMPErodeHalfWidth * 2);
//                        ROIWhite.LoadROISetting(m_intMPErodeHalfWidth, m_intMPErodeHalfWidth, objTemplatePadROI.ref_ROIWidth - m_intMPErodeHalfWidth * 2, objTemplatePadROI.ref_ROIHeight - m_intMPErodeHalfWidth * 2);
//                        ROIWhite.AttachImage(ImgEdgeWhite);
//                        EasyImage.Oper(EArithmeticLogicOperation.Subtract, ROIEdge.ref_ROI, ROIWhite.ref_ROI, ROIEdge.ref_ROI);
//                        ROIEdge.LoadROISetting(0, 0, objTemplatePadROI.ref_ROIWidth, objTemplatePadROI.ref_ROIHeight);
//                        ROIEdge.ref_ROI.Save("D:\\ROIEdge.bmp");
//                        m_ImgWhiteUnitTemplateImage.Save("D:\\m_ImgWhiteUnitTemplateImage.bmp");
//                        objTemplatePadROI.ref_ROI.Save("D:\\objTemplatePadROIBefore.bmp");
//                        EasyImage.Oper(EArithmeticLogicOperation.Subtract, objTemplatePadROI.ref_ROI, ROIEdge.ref_ROI, objTemplatePadROI.ref_ROI);
//                        objTemplatePadROI.ref_ROI.Save("D:\\objTemplatePadROIAfter.bmp");
//                    }
//                    else
//                    {
//                        // ErodeBox will make the pad size smaller.
//                        if ((Math.Abs(intDiffSizeWidth) + m_intMPErodeHalfWidth) > 0 || (Math.Abs(intDiffSizeHeight) + m_intMPErodeHalfWidth) > 0)
//                        {
//                            objTemplatePadROI.ref_ROI.Save("D:\\TS\\BeforeErode" + i.ToString() + ".bmp");// debug
//                            //EasyImage.ErodeBox(objTemplatePadROI.ref_ROI, m_ImgMPUnitTemplateImage, Math.Abs(intDiffSizeWidth) + m_intMPErodeHalfWidth, Math.Abs(intDiffSizeHeight) + m_intMPErodeHalfWidth);
//                            EasyImage.ErodeBox(objTemplatePadROI.ref_ROI, m_ImgMPUnitTemplateImage, (uint)m_intMPErodeHalfWidth, (uint)m_intMPErodeHalfWidth);
//                            EasyImage.Copy(m_ImgMPUnitTemplateImage, objTemplatePadROI.ref_ROI);
//                            objTemplatePadROI.ref_ROI.Save("D:\\TS\\AfterErode" + i.ToString() + ".bmp");// debug

//                            // Maybe will use in future
//                            // 2019-11-11 ZJYEOH : Subtract template threshold image with white edge image
//                            ImageDrawing ImgEdgeWhite = new ImageDrawing(m_ImgWhiteUnitTemplateImage.Width, m_ImgWhiteUnitTemplateImage.Height);
//                            EasyImage.Copy(m_ImgWhiteUnitTemplateImage, ImgEdgeWhite.ref_objMainImage);
//                            ROI ROIEdge = new ROI();
//                            ROI ROIWhite = new ROI();
//                            ROIEdge.LoadROISetting(0, 0, objTemplatePadROI.ref_ROIWidth, objTemplatePadROI.ref_ROIHeight);
//                            ROIEdge.AttachImage(ImgEdgeWhite);
//                            ROIEdge.LoadROISetting(m_intMPErodeHalfWidth, m_intMPErodeHalfWidth, objTemplatePadROI.ref_ROIWidth - m_intMPErodeHalfWidth * 2, objTemplatePadROI.ref_ROIHeight - m_intMPErodeHalfWidth * 2);
//                            ROIWhite.LoadROISetting(m_intMPErodeHalfWidth, m_intMPErodeHalfWidth, objTemplatePadROI.ref_ROIWidth - m_intMPErodeHalfWidth * 2, objTemplatePadROI.ref_ROIHeight - m_intMPErodeHalfWidth * 2);
//                            ROIWhite.AttachImage(ImgEdgeWhite);
//                            EasyImage.Oper(EArithmeticLogicOperation.Subtract, ROIEdge.ref_ROI, ROIWhite.ref_ROI, ROIEdge.ref_ROI);
//                            ROIEdge.LoadROISetting(0, 0, objTemplatePadROI.ref_ROIWidth, objTemplatePadROI.ref_ROIHeight);
//                            ROIEdge.ref_ROI.Save("D:\\ROIEdge.bmp");
//                            m_ImgWhiteUnitTemplateImage.Save("D:\\m_ImgWhiteUnitTemplateImage.bmp");
//                            objTemplatePadROI.ref_ROI.Save("D:\\objTemplatePadROIBefore.bmp");
//                            EasyImage.Oper(EArithmeticLogicOperation.Subtract, objTemplatePadROI.ref_ROI, ROIEdge.ref_ROI, objTemplatePadROI.ref_ROI);
//                            objTemplatePadROI.ref_ROI.Save("D:\\objTemplatePadROIAfter.bmp");
//                        }
//                    }
//#elif (DEBUG || RELEASE || RTXRelease || RTXDebug)
//                    if ((intDiffSizeWidth > 0) || (intDiffSizeHeight > 0))
//                    {
//                        if ((intDiffSizeWidth > 0 && intDiffSizeHeight < 0) || (intDiffSizeHeight > 0 && intDiffSizeWidth < 0))
//                        {
//                            if (Math.Abs(intDiffSizeWidth) > Math.Abs(intDiffSizeHeight))
//                                intDiffSizeHeight = 0;
//                            else
//                                intDiffSizeWidth = 0;
//                        }
//                        objTemplatePadROI.ref_ROI.Save("D:\\TS\\BeforeErode" + i.ToString() + ".bmp");// debug
//                        // Reduce template size follow the m_intMPErodeHalfWidth setting.    
//                        EasyImage.ErodeBox(objTemplatePadROI.ref_ROI, m_ImgMPUnitTemplateImage, Math.Abs(m_intMPErodeHalfWidth), Math.Abs(m_intMPErodeHalfWidth));
//                        EasyImage.Copy(m_ImgMPUnitTemplateImage, objTemplatePadROI.ref_ROI);
//                        objTemplatePadROI.ref_ROI.Save("D:\\TS\\AfterErode" + i.ToString() + ".bmp");// debug

//                        // Maybe will use in future
//                        // 2019-11-11 ZJYEOH : Subtract template threshold image with white edge image
//                        ImageDrawing ImgEdgeWhite = new ImageDrawing(m_ImgWhiteUnitTemplateImage.Width, m_ImgWhiteUnitTemplateImage.Height);
//                        EasyImage.Copy(m_ImgWhiteUnitTemplateImage, ImgEdgeWhite.ref_objMainImage);
//                        ROI ROIEdge = new ROI();
//                        ROI ROIWhite = new ROI();
//                        ROIEdge.LoadROISetting(0, 0, objTemplatePadROI.ref_ROIWidth, objTemplatePadROI.ref_ROIHeight);
//                        ROIEdge.AttachImage(ImgEdgeWhite);
//                        ROIEdge.LoadROISetting(m_intMPErodeHalfWidth, m_intMPErodeHalfWidth, objTemplatePadROI.ref_ROIWidth - m_intMPErodeHalfWidth * 2, objTemplatePadROI.ref_ROIHeight - m_intMPErodeHalfWidth * 2);
//                        ROIWhite.LoadROISetting(m_intMPErodeHalfWidth, m_intMPErodeHalfWidth, objTemplatePadROI.ref_ROIWidth - m_intMPErodeHalfWidth * 2, objTemplatePadROI.ref_ROIHeight - m_intMPErodeHalfWidth * 2);
//                        ROIWhite.AttachImage(ImgEdgeWhite);
//                        EasyImage.Oper(EArithmeticLogicOperation.Subtract, ROIEdge.ref_ROI, ROIWhite.ref_ROI, ROIEdge.ref_ROI);
//                        ROIEdge.LoadROISetting(0, 0, objTemplatePadROI.ref_ROIWidth, objTemplatePadROI.ref_ROIHeight);
//                        ROIEdge.ref_ROI.Save("D:\\ROIEdge.bmp");
//                        m_ImgWhiteUnitTemplateImage.Save("D:\\m_ImgWhiteUnitTemplateImage.bmp");
//                        objTemplatePadROI.ref_ROI.Save("D:\\objTemplatePadROIBefore.bmp");
//                        EasyImage.Oper(EArithmeticLogicOperation.Subtract, objTemplatePadROI.ref_ROI, ROIEdge.ref_ROI, objTemplatePadROI.ref_ROI);
//                        objTemplatePadROI.ref_ROI.Save("D:\\objTemplatePadROIAfter.bmp");
//                    }
//                    else
//                    {
//                        // ErodeBox will make the pad size smaller.
//                        if ((Math.Abs(intDiffSizeWidth) + m_intMPErodeHalfWidth) > 0 || (Math.Abs(intDiffSizeHeight) + m_intMPErodeHalfWidth) > 0)
//                        {
//                            objTemplatePadROI.ref_ROI.Save("D:\\TS\\BeforeErode" + i.ToString() + ".bmp");// debug
//                            //EasyImage.ErodeBox(objTemplatePadROI.ref_ROI, m_ImgMPUnitTemplateImage, Math.Abs(intDiffSizeWidth) + m_intMPErodeHalfWidth, Math.Abs(intDiffSizeHeight) + m_intMPErodeHalfWidth);
//                            EasyImage.ErodeBox(objTemplatePadROI.ref_ROI, m_ImgMPUnitTemplateImage, m_intMPErodeHalfWidth, m_intMPErodeHalfWidth);
//                            EasyImage.Copy(m_ImgMPUnitTemplateImage, objTemplatePadROI.ref_ROI);
//                            objTemplatePadROI.ref_ROI.Save("D:\\TS\\AfterErode" + i.ToString() + ".bmp");// debug

//                            // Maybe will use in future
//                            // 2019-11-11 ZJYEOH : Subtract template threshold image with white edge image
//                            ImageDrawing ImgEdgeWhite = new ImageDrawing(m_ImgWhiteUnitTemplateImage.Width, m_ImgWhiteUnitTemplateImage.Height);
//                            EasyImage.Copy(m_ImgWhiteUnitTemplateImage, ImgEdgeWhite.ref_objMainImage);
//                            ROI ROIEdge = new ROI();
//                            ROI ROIWhite = new ROI();
//                            ROIEdge.LoadROISetting(0, 0, objTemplatePadROI.ref_ROIWidth, objTemplatePadROI.ref_ROIHeight);
//                            ROIEdge.AttachImage(ImgEdgeWhite);
//                            ROIEdge.LoadROISetting(m_intMPErodeHalfWidth, m_intMPErodeHalfWidth, objTemplatePadROI.ref_ROIWidth - m_intMPErodeHalfWidth * 2, objTemplatePadROI.ref_ROIHeight - m_intMPErodeHalfWidth * 2);
//                            ROIWhite.LoadROISetting(m_intMPErodeHalfWidth, m_intMPErodeHalfWidth, objTemplatePadROI.ref_ROIWidth - m_intMPErodeHalfWidth * 2, objTemplatePadROI.ref_ROIHeight - m_intMPErodeHalfWidth * 2);
//                            ROIWhite.AttachImage(ImgEdgeWhite);
//                            EasyImage.Oper(EArithmeticLogicOperation.Subtract, ROIEdge.ref_ROI, ROIWhite.ref_ROI, ROIEdge.ref_ROI);
//                            ROIEdge.LoadROISetting(0, 0, objTemplatePadROI.ref_ROIWidth, objTemplatePadROI.ref_ROIHeight);
//                            ROIEdge.ref_ROI.Save("D:\\ROIEdge.bmp");
//                            m_ImgWhiteUnitTemplateImage.Save("D:\\m_ImgWhiteUnitTemplateImage.bmp");
//                            objTemplatePadROI.ref_ROI.Save("D:\\objTemplatePadROIBefore.bmp");
//                            EasyImage.Oper(EArithmeticLogicOperation.Subtract, objTemplatePadROI.ref_ROI, ROIEdge.ref_ROI, objTemplatePadROI.ref_ROI);
//                            objTemplatePadROI.ref_ROI.Save("D:\\objTemplatePadROIAfter.bmp");
//                        }
//                    }
//#endif

//                    // Get Sample pad ROI
//                    ROI objTemplate2PadROI = new ROI();
//                    objTemplate2PadROI.ref_ROI.Detach();
//                    objTemplate2PadROI.ref_ROI.Attach(m_ImgWhiteUnitTemplateImage2);
//                    objTemplate2PadROI.LoadROISetting(intStartX2, intStartY2, intWidth, intHeight);
//                    if (blnDebugImage)
//                    {
//                        m_ImgMPUnitTemplateImage.Save("D:\\TS\\08_" + i.ToString() + "_BfMPTemplateImage.bmp");// debug
//                        objTemplatePadROI.SaveImage("D:\\TS\\09_" + i.ToString() + "_AfMPTemplateImage.bmp");// debug
//                        objTemplate2PadROI.SaveImage("D:\\TS\\10_" + i.ToString() + "_BfSBTemplate2PadImage.bmp");// debug
//                    }

//                    if (objTemplatePadROI.ref_ROIWidth != objTemplate2PadROI.ref_ROIWidth)
//                    {
//                        int intSmallWidth = Math.Min(objTemplatePadROI.ref_ROIWidth, objTemplate2PadROI.ref_ROIWidth);
//                        objTemplatePadROI.LoadROISetting(objTemplatePadROI.ref_ROIPositionX, objTemplatePadROI.ref_ROIPositionY, intSmallWidth, objTemplatePadROI.ref_ROIHeight);
//                        objTemplate2PadROI.LoadROISetting(objTemplate2PadROI.ref_ROIPositionX, objTemplate2PadROI.ref_ROIPositionY, intSmallWidth, objTemplate2PadROI.ref_ROIHeight);
//                    }

//                    if (objTemplatePadROI.ref_ROIHeight != objTemplate2PadROI.ref_ROIHeight)
//                    {
//                        int intSmallHeight = Math.Min(objTemplatePadROI.ref_ROIHeight, objTemplate2PadROI.ref_ROIHeight);
//                        objTemplatePadROI.LoadROISetting(objTemplatePadROI.ref_ROIPositionX, objTemplatePadROI.ref_ROIPositionY, objTemplatePadROI.ref_ROIWidth, intSmallHeight);
//                        objTemplate2PadROI.LoadROISetting(objTemplate2PadROI.ref_ROIPositionX, objTemplate2PadROI.ref_ROIPositionY, objTemplate2PadROI.ref_ROIWidth, intSmallHeight);
//                    }

//                    // subtract sample pad roi - template pad roi
//                    EasyImage.Oper(EArithmeticLogicOperation.Subtract, objTemplate2PadROI.ref_ROI, objTemplatePadROI.ref_ROI, objTemplate2PadROI.ref_ROI);

//                    if (blnDebugImage)
//                        objTemplate2PadROI.SaveImage("D:\\TS\\11_" + i.ToString() + "_AfSBTemplate2PadImage.bmp");// debug

//                    objTemplate2PadROI.Dispose();
//                    objTemplatePadROI.Dispose();
//                }

//                #endregion ------------------------------------------------------------------------------------------------
//            }

//            // Subtract sample ROI - template ROI
//            if (blnDebugImage)
//            {
//                objThresholdSampleROI.SaveImage("D:\\TS\\12_BfSBSampleROI.bmp");// debug   // sample: Background white color, pad black color, defect on pad is white color
//                objWhiteBgTemplateROI.SaveImage("D:\\TS\\13_objTemplate2ROI.bmp");// debug // template: Background white color, pad black color.
//            }

//            if (objThresholdSampleROI.ref_ROIWidth != objWhiteBgTemplateROI.ref_ROIWidth)
//            {
//                int intSmallWidth = Math.Min(objThresholdSampleROI.ref_ROIWidth, objWhiteBgTemplateROI.ref_ROIWidth);
//                objThresholdSampleROI.LoadROISetting(objThresholdSampleROI.ref_ROIPositionX, objThresholdSampleROI.ref_ROIPositionY, intSmallWidth, objThresholdSampleROI.ref_ROIHeight);
//                objWhiteBgTemplateROI.LoadROISetting(objWhiteBgTemplateROI.ref_ROIPositionX, objWhiteBgTemplateROI.ref_ROIPositionY, intSmallWidth, objWhiteBgTemplateROI.ref_ROIHeight);
//            }

//            if (objThresholdSampleROI.ref_ROIHeight != objWhiteBgTemplateROI.ref_ROIHeight)
//            {
//                int intSmallHeight = Math.Min(objThresholdSampleROI.ref_ROIHeight, objWhiteBgTemplateROI.ref_ROIHeight);
//                objThresholdSampleROI.LoadROISetting(objThresholdSampleROI.ref_ROIPositionX, objThresholdSampleROI.ref_ROIPositionY, objThresholdSampleROI.ref_ROIWidth, intSmallHeight);
//                objWhiteBgTemplateROI.LoadROISetting(objWhiteBgTemplateROI.ref_ROIPositionX, objWhiteBgTemplateROI.ref_ROIPositionY, objWhiteBgTemplateROI.ref_ROIWidth, intSmallHeight);
//            }

//            EasyImage.Oper(EArithmeticLogicOperation.Subtract, objThresholdSampleROI.ref_ROI, objWhiteBgTemplateROI.ref_ROI, objThresholdSampleROI.ref_ROI);

//            if (blnDebugImage)
//                objThresholdSampleROI.SaveImage("D:\\TS\\14_AfSBSampleROI.bmp");// debug

//            // Maybe will use in future
//            //2019-11-11 ZJYEOH : Subtract again with clean background image
//            objWhiteBgTemplateROI.ref_ROI.Detach();
//            objWhiteBgTemplateROI.ref_ROI.Attach(m_ImgUnitTemplateImage_CleanBackground);
//            EasyImage.Oper(EArithmeticLogicOperation.Subtract, objThresholdSampleROI.ref_ROI, objWhiteBgTemplateROI.ref_ROI, objThresholdSampleROI.ref_ROI);

//            if (blnDebugImage)
//                objThresholdSampleROI.SaveImage("D:\\TS\\15_AfSBSampleROIClean.bmp");// debug

//            // Build blobs object for subtract image
//            m_objImage1PadEBlobs.BuildObjects_Filter_GetElement(objThresholdSampleROI, false, true, 0, 125, (int)m_fImageMerge2BlobsMinArea, 999999, false, 0x0F);

//            if (m_objImage1PadEBlobs.ref_intNumSelectedObject > 0)
//            {
//                float fGravityCenterX = 0, fGravityCenterY = 0, fCenterX = 0, fCenterY = 0, fWidth = 0, fHeight = 0;
//                float fStartX = 0, fStartY = 0, fEndX = 0, fEndY = 0;
//                int intArea = 0;

//                for (int i = 0; i < m_objImage1PadEBlobs.ref_intNumSelectedObject; i++)
//                {
//                    fGravityCenterX = m_objImage1PadEBlobs.ref_arrGravityCenterX[i];
//                    fGravityCenterY = m_objImage1PadEBlobs.ref_arrGravityCenterY[i];
//                    fCenterX = m_objImage1PadEBlobs.ref_arrLimitCenterX[i];
//                    fCenterY = m_objImage1PadEBlobs.ref_arrLimitCenterY[i];
//                    fWidth = m_objImage1PadEBlobs.ref_arrWidth[i];
//                    fHeight = m_objImage1PadEBlobs.ref_arrHeight[i];
//                    intArea = m_objImage1PadEBlobs.ref_arrArea[i];

//                    // Get object start point and end point
//                    fStartX = fCenterX - (fWidth / 2);
//                    fStartY = fCenterY - (fHeight / 2);
//                    fEndX = fCenterX + (fWidth / 2);
//                    fEndY = fCenterY + (fHeight / 2);

//                    int intMatch = Match1TemplateObjects(fStartX, fStartY, fEndX, fEndY, fGravityCenterX, fGravityCenterY);

//                    if (intMatch >= 0)
//                    {
//                        if (m_blnWantCheckBrokenPadLength || m_blnWantCheckBrokenPadArea)
//                        {
//                            if (m_arrSamplePadBroken[intMatch].fAreaMM == 0)
//                            {
//                                m_arrSamplePadBroken[intMatch].fAreaMM = intArea * m_fAreaMMPerPixel;  // Change unit pixel to mm
//                                m_arrSamplePadBroken[intMatch].fWidthMM = fWidth * m_fMMPerPixelX;  // Change unit pixel to mm
//                                m_arrSamplePadBroken[intMatch].fHeightMM = fHeight * m_fMMPerPixelY;  // Change unit pixel to mm

//                                m_arrSamplePadBroken[intMatch].fWidth = fWidth;
//                                m_arrSamplePadBroken[intMatch].fHeight = fHeight;
//                                m_arrSamplePadBroken[intMatch].fStartX = fStartX;
//                                m_arrSamplePadBroken[intMatch].fStartY = fStartY;
//                                m_arrSamplePadBroken[intMatch].fEndX = fEndX;
//                                m_arrSamplePadBroken[intMatch].fEndY = fEndY;
//                            }
//                        }

//                        if (m_blnWantCheckBrokenPadLength)
//                        {
//                            if ((m_arrSampleBlobPads[intMatch].intFailMask & ~0x08) == 0) // Make sure the sample pad has not other failure.
//                            {
//                                if (((BlobsFeatures)m_arrTemplateBlobPads[intMatch]).blnEnable)
//                                {
//                                    float fWidthMM = fWidth / m_fMMToPixelXValue;
//                                    float fHeightMM = fHeight / m_fMMToPixelYValue; // 11-04-2019 ZJYEOH : Changed m_fMMToPixelXValue to m_fMMToPixelYValue
//                                    float fBrokenAreaMM2 = (float)intArea / m_fMMtoPixelAreaValue;

//                                    bool blnResult1 = true;
//                                    if (m_blnWantUseGroupToleranceSetting)
//                                    {
//                                        int intGroupNo = ((BlobsFeatures)m_arrTemplateBlobPads[intMatch]).intGroupID;
//                                        if ((fWidthMM > ((BlobsFeatures)m_arrGroupTemplateBlobPads[intGroupNo]).fMaxBrokenLength) ||
//                                            (fHeightMM > ((BlobsFeatures)m_arrGroupTemplateBlobPads[intGroupNo]).fMaxBrokenLength))
//                                        {
//                                            blnResult1 = false;
//                                        }
//                                    }
//                                    else
//                                    {
//                                        if ((fWidthMM > ((BlobsFeatures)m_arrTemplateBlobPads[intMatch]).fMaxBrokenLength) ||
//                                            (fHeightMM > ((BlobsFeatures)m_arrTemplateBlobPads[intMatch]).fMaxBrokenLength))
//                                        {
//                                            blnResult1 = false;
//                                        }
//                                    }

//                                    if (!blnResult1)
//                                    {
//                                        m_blnFailBrokenLength = true;
//                                        m_arrSampleBlobPads[intMatch].intFailMask |= 0x08;
//                                        m_intFailResultMask |= 0x08;

//                                        float fMaxLength = Math.Max(fWidthMM, fHeightMM);

//                                        // Collect scratch min and max area for display error message
//                                        if ((m_fResultBrokenMinArea == -1) || (fMaxLength < m_fResultBrokenMinArea))
//                                        {
//                                            m_fResultBrokenMinArea = fMaxLength;
//                                        }

//                                        if ((m_fResultBrokenMaxArea == -1) || (fMaxLength > m_fResultBrokenMaxArea))
//                                        {
//                                            m_fResultBrokenMaxArea = fMaxLength;
//                                        }

//                                        Defect objDefect = new Defect();
//                                        objDefect.ref_strName = "Broken Pad";
//                                        objDefect.ref_intFailMask |= 0x08;
//                                        objDefect.ref_fArea = Convert.ToSingle(intArea);
//                                        objDefect.ref_fCenterX = objImage1SampleUnitROI.ref_ROITotalX + fCenterX;  // objThresholdSampleROI.ref_ROITotalX + fCenterX;
//                                        objDefect.ref_fCenterY = objImage1SampleUnitROI.ref_ROITotalY + fCenterY;  // objThresholdSampleROI.ref_ROITotalY + fCenterY;
//                                        objDefect.ref_fStartX = fStartX;
//                                        objDefect.ref_fStartY = fStartY;
//                                        objDefect.ref_fEndX = fEndX;
//                                        objDefect.ref_fEndY = fEndY;
//                                        objDefect.ref_fWidth = fWidth;
//                                        objDefect.ref_fHeight = fHeight;
//                                        objDefect.ref_fWidthInMM = fWidthMM;
//                                        objDefect.ref_fHeightInMM = fHeightMM;
//                                        objDefect.ref_fAreaInMM2 = fBrokenAreaMM2;

//                                        if (fWidthMM > ((BlobsFeatures)m_arrTemplateBlobPads[intMatch]).fMaxBrokenLength)
//                                            objDefect.ref_intFailCriteria |= 0x01;

//                                        if (fHeightMM > ((BlobsFeatures)m_arrTemplateBlobPads[intMatch]).fMaxBrokenLength)
//                                            objDefect.ref_intFailCriteria |= 0x02;

//                                        m_arrPadDefectList.Add(objDefect);

//                                        if (blnResult)
//                                            blnResult = false;
//                                    }
//                                }
//                            }
//                        }

//                        if (m_blnWantCheckBrokenPadArea && !m_blnFailBrokenLength)
//                        {
//                            if ((m_arrSampleBlobPads[intMatch].intFailMask & ~0x08) == 0) // Make sure the sample pad has not other failure.
//                            {
//                                if (((BlobsFeatures)m_arrTemplateBlobPads[intMatch]).blnEnable)
//                                {
//                                    float fWidthMM = fWidth / m_fMMToPixelXValue;
//                                    float fHeightMM = fHeight / m_fMMToPixelYValue; // 11-04-2019 ZJYEOH : Changed m_fMMToPixelXValue to m_fMMToPixelYValue
//                                    float fBrokenAreaMM2 = (float)intArea / m_fMMtoPixelAreaValue;

//                                    bool blnResult1 = true;
//                                    if (m_blnWantUseGroupToleranceSetting)
//                                    {
//                                        int intGroupNo = ((BlobsFeatures)m_arrTemplateBlobPads[intMatch]).intGroupID;
//                                        if (fBrokenAreaMM2 > ((BlobsFeatures)m_arrGroupTemplateBlobPads[intGroupNo]).fMaxBroken)
//                                        {
//                                            blnResult1 = false;
//                                        }

//                                    }
//                                    else
//                                    {
//                                        if (fBrokenAreaMM2 > ((BlobsFeatures)m_arrTemplateBlobPads[intMatch]).fMaxBroken)
//                                        {
//                                            blnResult1 = false;
//                                        }
//                                    }

//                                    if (!blnResult1)
//                                    {
//                                        m_blnFailBrokenArea = true;
//                                        m_arrSampleBlobPads[intMatch].intFailMask |= 0x08;
//                                        m_intFailResultMask |= 0x08;

//                                        // Collect scratch min and max area for display error message
//                                        if ((m_fResultBrokenMinArea == -1) || (fBrokenAreaMM2 < m_fResultBrokenMinArea))
//                                        {
//                                            m_fResultBrokenMinArea = fBrokenAreaMM2;
//                                        }

//                                        if ((m_fResultBrokenMaxArea == -1) || (fBrokenAreaMM2 > m_fResultBrokenMaxArea))
//                                        {
//                                            m_fResultBrokenMaxArea = fBrokenAreaMM2;
//                                        }

//                                        Defect objDefect = new Defect();
//                                        objDefect.ref_strName = "Broken Pad";
//                                        objDefect.ref_intFailMask |= 0x08;
//                                        objDefect.ref_fArea = Convert.ToSingle(intArea);
//                                        objDefect.ref_fCenterX = objImage1SampleUnitROI.ref_ROITotalX + fCenterX;  // objThresholdSampleROI.ref_ROITotalX + fCenterX;
//                                        objDefect.ref_fCenterY = objImage1SampleUnitROI.ref_ROITotalY + fCenterY;  // objThresholdSampleROI.ref_ROITotalY + fCenterY;
//                                        objDefect.ref_fStartX = fStartX;
//                                        objDefect.ref_fStartY = fStartY;
//                                        objDefect.ref_fEndX = fEndX;
//                                        objDefect.ref_fEndY = fEndY;
//                                        objDefect.ref_fWidth = fWidth;
//                                        objDefect.ref_fHeight = fHeight;
//                                        objDefect.ref_fWidthInMM = fWidthMM;
//                                        objDefect.ref_fHeightInMM = fHeightMM;
//                                        objDefect.ref_fAreaInMM2 = fBrokenAreaMM2;
//                                        objDefect.ref_intFailCriteria |= 0x04;

//                                        m_arrPadDefectList.Add(objDefect);

//                                        if (blnResult)
//                                            blnResult = false;

//                                    }
//                                }
//                            }
//                        }
//                    }
//                }
//            }

//            objThresholdSampleROI.Dispose();
//            objThresholdTemplateROI.Dispose();
//            objWhiteBgTemplateROI.Dispose();
//            return blnResult;
//        }

        private bool CheckImageMoldFlashDefect_Area(ROI objImage1UnitROI, ROI objMoldFlashROI, int intPadIndex)
        {
            if (((m_intFailPkgOptionMask & 0x80) == 0) && ((m_intFailPkgOptionMask & 0x1000000) == 0))
                return true;

            //if (m_fMoldFlashArea == 0)
            //    return true;

            bool blnDebugImage = false;
            bool blnResult = true;
            int intTotalStartX = 0, intTotalStartY = 0;

            int intToleranceWidth = (objMoldFlashROI.ref_ROIWidth - objImage1UnitROI.ref_ROIWidth) / 2;
            int intToleranceHeight = (objMoldFlashROI.ref_ROIHeight - objImage1UnitROI.ref_ROIHeight) / 2;

            #region Subtract Template Pad ----------------------------------------------------------------------------------

            for (int i = 0; i < m_arrTemplateBlobPads.Count; i++)
            {
                if (blnDebugImage)
                    m_arrImgPadImage[i].Save("D:\\TS\\2_m_arrImgPadImage" + i.ToString() + ".bmp");// debug   
                ROI objROI = new ROI();
                ROI DilateROI = new ROI();
                ImageDrawing Img = new ImageDrawing();

                if (m_arrSampleBlobPads[i].intFailMask != 0)
                    continue;

                int intImageToleranceWidth = (int)Math.Round((m_arrImgPadImage[i].Width - objMoldFlashROI.ref_ROIWidth) / 2.0);
                int intImageToleranceHeight = (int)Math.Round((m_arrImgPadImage[i].Height - objMoldFlashROI.ref_ROIHeight) / 2.0);
                int intOffsetX = 0, intOffsetY = 0;
                if (intImageToleranceWidth < 0)
                {
                    intOffsetX = -intImageToleranceWidth;
                    intImageToleranceWidth = 0;
                }
                if (intImageToleranceHeight < 0)
                {
                    intOffsetY = -intImageToleranceHeight;
                    intImageToleranceHeight = 0;
                }

                if (!GetOverallWantGaugeMeasurePkgSize(false))
                {
                    intOffsetX += (int)Math.Round(GetResultCenterPoint_UnitMatcher().X - GetResultCenterPoint_RectGauge4L().X);
                    intOffsetY += (int)Math.Round(GetResultCenterPoint_UnitMatcher().Y - GetResultCenterPoint_RectGauge4L().Y);
                }

                Img.SetImageSize(m_arrImgPadImage[i].Width, m_arrImgPadImage[i].Height);
                Img.SetImageToBlack();
                objROI.ref_ROI.Attach(m_arrImgPadImage[i]);
                objROI.LoadROISetting(intImageToleranceWidth + intOffsetX, intImageToleranceHeight + intOffsetY, objMoldFlashROI.ref_ROIWidth - (intOffsetX * 2), objMoldFlashROI.ref_ROIHeight - (intOffsetY * 2));
                DilateROI.AttachImage(Img);
                DilateROI.LoadROISetting(intImageToleranceWidth + intOffsetX, intImageToleranceHeight + intOffsetY, objMoldFlashROI.ref_ROIWidth - (intOffsetX * 2), objMoldFlashROI.ref_ROIHeight - (intOffsetY * 2));

                EasyImage.Copy(objROI.ref_ROI, DilateROI.ref_ROI);
#if (Debug_2_12 || Release_2_12)
                EasyImage.DilateBox(DilateROI.ref_ROI, DilateROI.ref_ROI, (uint)Math.Abs(m_intMPDilateHalfWidth), (uint)Math.Abs(m_intMPDilateHalfWidth));
#elif (DEBUG || RELEASE || RTXRelease || RTXDebug)
                EasyImage.DilateBox(DilateROI.ref_ROI, DilateROI.ref_ROI, Math.Abs(m_intMPDilateHalfWidth), Math.Abs(m_intMPDilateHalfWidth));
#endif

                if (blnDebugImage)
                {
                    objROI.SaveImage("D:\\TS\\3.1_objROI.bmp");// debug  
                    DilateROI.SaveImage("D:\\TS\\3.2_DilateROI.bmp");// debug  
                }
                objROI.AttachImage(objMoldFlashROI);
                objROI.LoadROISetting_MustSameSize(DilateROI, intImageToleranceWidth + intOffsetX, intImageToleranceHeight + intOffsetY, objMoldFlashROI.ref_ROIWidth - (intOffsetX * 2), objMoldFlashROI.ref_ROIHeight - (intOffsetY * 2));
                if (blnDebugImage)
                {
                    objROI.SaveImage("D:\\TS\\3.3_objROI.bmp");// debug  
                }
                EasyImage.Oper(EArithmeticLogicOperation.Subtract, objROI.ref_ROI, DilateROI.ref_ROI, objROI.ref_ROI);
                if (blnDebugImage)
                {
                    m_arrImgPadImage[i].Save("D:\\TS\\4_m_arrImgPadImage" + i.ToString() + ".bmp");
                }
                objROI.Dispose();
                DilateROI.Dispose();
                Img.Dispose();
            }
            if (blnDebugImage)
            {
                objMoldFlashROI.SaveImage("D:\\TS\\5_objMoldFlashROI.bmp");// debug  
            }

            #endregion ------------------------------------------------------------------------------------------------

            objMoldFlashROI.LoadROISetting(objImage1UnitROI.ref_ROITotalX - (int)m_fMoldStartPixelFromLeft,
                                       objImage1UnitROI.ref_ROITotalY - (int)m_fMoldStartPixelFromEdge,
                                       objImage1UnitROI.ref_ROIWidth + (int)(m_fMoldStartPixelFromLeft + m_fMoldStartPixelFromRight),
                                       objImage1UnitROI.ref_ROIHeight + (int)(m_fMoldStartPixelFromEdge + m_fMoldStartPixelFromBottom));

            ROI objMoldFlashBorderROI = new ROI();
            objMoldFlashBorderROI.AttachImage(objMoldFlashROI);
            string strPosition = "";
            for (int i = 0; i < 4; i++)   // Create 4 direction ROI
            {
                if (m_intPadROIDirection == 1 && i == 2)    // Top Side Pad 
                    continue;
                else if (m_intPadROIDirection == 2 && i == 3) // Right Side Pad
                    continue;
                else if (m_intPadROIDirection == 3 && i == 0) // Bottom Side Pad
                    continue;
                else if (m_intPadROIDirection == 4 && i == 1) // Left Side Pad
                    continue;

                //switch (i)
                //{
                //    case 0:  // Top Border
                //        if (m_intPadROIDirection == 2)
                //            objMoldFlashBorderROI.LoadROISetting(intToleranceWidth, 0, objMoldFlashROI.ref_ROIWidth - intToleranceWidth, intToleranceHeight);
                //        else if (m_intPadROIDirection == 4)
                //            objMoldFlashBorderROI.LoadROISetting(0, 0, objMoldFlashROI.ref_ROIWidth - intToleranceWidth, intToleranceHeight);
                //        else
                //            objMoldFlashBorderROI.LoadROISetting(0, 0, objMoldFlashROI.ref_ROIWidth, (int)m_fMoldStartPixelFromEdge);


                //        intTotalStartX = objMoldFlashROI.ref_ROITotalX;
                //        intTotalStartY = objMoldFlashROI.ref_ROITotalY;

                //        break;
                //    case 1: // Right Border
                //        if (m_intPadROIDirection == 1)
                //            objMoldFlashBorderROI.LoadROISetting(objMoldFlashROI.ref_ROIWidth - intToleranceWidth, 0, intToleranceWidth, objMoldFlashROI.ref_ROIHeight - intToleranceHeight);
                //        else if (m_intPadROIDirection == 3)
                //            objMoldFlashBorderROI.LoadROISetting(objMoldFlashROI.ref_ROIWidth - intToleranceWidth, intToleranceHeight, intToleranceWidth, objMoldFlashROI.ref_ROIHeight - intToleranceHeight);
                //        else
                //            objMoldFlashBorderROI.LoadROISetting(objMoldFlashROI.ref_ROIWidth - (int)m_fMoldStartPixelFromRight, 0, (int)m_fMoldStartPixelFromRight, objMoldFlashROI.ref_ROIHeight);
                //        intTotalStartX = objMoldFlashROI.ref_ROITotalX + objMoldFlashROI.ref_ROIWidth - (int)m_fMoldStartPixelFromRight;
                //        intTotalStartY = objMoldFlashROI.ref_ROITotalY;


                //        break;
                //    case 2: // Bottom Border
                //        if (m_intPadROIDirection == 2)
                //            objMoldFlashBorderROI.LoadROISetting(intToleranceWidth, objMoldFlashROI.ref_ROIHeight - intToleranceHeight, objMoldFlashROI.ref_ROIWidth - intToleranceWidth, intToleranceHeight);
                //        else if (m_intPadROIDirection == 4)
                //            objMoldFlashBorderROI.LoadROISetting(0, objMoldFlashROI.ref_ROIHeight - intToleranceHeight, objMoldFlashROI.ref_ROIWidth - intToleranceWidth, intToleranceHeight);
                //        else
                //            objMoldFlashBorderROI.LoadROISetting(0, objMoldFlashROI.ref_ROIHeight - (int)m_fMoldStartPixelFromBottom, objMoldFlashROI.ref_ROIWidth, (int)m_fMoldStartPixelFromBottom);
                //        intTotalStartX = objMoldFlashROI.ref_ROITotalX;
                //        intTotalStartY = objMoldFlashROI.ref_ROITotalY + objMoldFlashROI.ref_ROIHeight - (int)m_fMoldStartPixelFromBottom;


                //        break;
                //    case 3: // Left Border
                //        if (m_intPadROIDirection == 1)
                //            objMoldFlashBorderROI.LoadROISetting(0, 0, intToleranceWidth, objMoldFlashROI.ref_ROIHeight - intToleranceHeight);
                //        else if (m_intPadROIDirection == 3)
                //            objMoldFlashBorderROI.LoadROISetting(0, intToleranceHeight, intToleranceWidth, objMoldFlashROI.ref_ROIHeight - intToleranceHeight);
                //        else
                //            objMoldFlashBorderROI.LoadROISetting(0, 0, (int)m_fMoldStartPixelFromLeft, objMoldFlashROI.ref_ROIHeight);
                //        intTotalStartX = objMoldFlashROI.ref_ROITotalX;
                //        intTotalStartY = objMoldFlashROI.ref_ROITotalY;


                //        break;
                //}
                switch (i)
                {
                    case 0:  // Top Border
                        strPosition = "Top Border";
                             //if (m_intPadROIDirection == 2)
                             //    objMoldFlashBorderROI.LoadROISetting(intToleranceWidth, 0, objMoldFlashROI.ref_ROIWidth - intToleranceWidth, intToleranceHeight);
                             //else if (m_intPadROIDirection == 4)
                             //    objMoldFlashBorderROI.LoadROISetting(0, 0, objMoldFlashROI.ref_ROIWidth - intToleranceWidth, intToleranceHeight);
                             //else
                        objMoldFlashBorderROI.LoadROISetting((int)m_fMoldStartPixelFromLeft, 0, objMoldFlashROI.ref_ROIWidth - (int)(m_fMoldStartPixelFromLeft + m_fMoldStartPixelFromRight), (int)(m_fMoldStartPixelFromEdge - m_fMoldStartPixelInnerFromEdge));


                        intTotalStartX = objMoldFlashROI.ref_ROITotalX + (int)m_fMoldStartPixelFromLeft;
                        intTotalStartY = objMoldFlashROI.ref_ROITotalY;

                        break;
                    case 1: // Right Border
                        strPosition = "Right Border";
                        //if (m_intPadROIDirection == 1)
                        //    objMoldFlashBorderROI.LoadROISetting(objMoldFlashROI.ref_ROIWidth - intToleranceWidth, 0, intToleranceWidth, objMoldFlashROI.ref_ROIHeight - intToleranceHeight);
                        //else if (m_intPadROIDirection == 3)
                        //    objMoldFlashBorderROI.LoadROISetting(objMoldFlashROI.ref_ROIWidth - intToleranceWidth, intToleranceHeight, intToleranceWidth, objMoldFlashROI.ref_ROIHeight - intToleranceHeight);
                        //else
                        objMoldFlashBorderROI.LoadROISetting(objMoldFlashROI.ref_ROIWidth - (int)(m_fMoldStartPixelFromRight - m_fMoldStartPixelInnerFromRight), (int)m_fMoldStartPixelFromEdge, (int)(m_fMoldStartPixelFromRight - m_fMoldStartPixelInnerFromRight), objMoldFlashROI.ref_ROIHeight - (int)(m_fMoldStartPixelFromEdge + m_fMoldStartPixelFromBottom));
                        intTotalStartX = objMoldFlashROI.ref_ROITotalX + objMoldFlashROI.ref_ROIWidth - (int)(m_fMoldStartPixelFromRight - m_fMoldStartPixelInnerFromRight);
                        intTotalStartY = objMoldFlashROI.ref_ROITotalY + (int)m_fMoldStartPixelFromEdge;


                        break;
                    case 2: // Bottom Border
                        strPosition = "Bottom Border";
                        //if (m_intPadROIDirection == 2)
                        //    objMoldFlashBorderROI.LoadROISetting(intToleranceWidth, objMoldFlashROI.ref_ROIHeight - intToleranceHeight, objMoldFlashROI.ref_ROIWidth - intToleranceWidth, intToleranceHeight);
                        //else if (m_intPadROIDirection == 4)
                        //    objMoldFlashBorderROI.LoadROISetting(0, objMoldFlashROI.ref_ROIHeight - intToleranceHeight, objMoldFlashROI.ref_ROIWidth - intToleranceWidth, intToleranceHeight);
                        //else
                        objMoldFlashBorderROI.LoadROISetting((int)m_fMoldStartPixelFromLeft, objMoldFlashROI.ref_ROIHeight - (int)(m_fMoldStartPixelFromBottom - m_fMoldStartPixelInnerFromBottom), objMoldFlashROI.ref_ROIWidth - (int)(m_fMoldStartPixelFromLeft + m_fMoldStartPixelFromRight), (int)(m_fMoldStartPixelFromBottom - m_fMoldStartPixelInnerFromBottom));
                        intTotalStartX = objMoldFlashROI.ref_ROITotalX + (int)m_fMoldStartPixelFromLeft;
                        intTotalStartY = objMoldFlashROI.ref_ROITotalY + objMoldFlashROI.ref_ROIHeight - (int)(m_fMoldStartPixelFromBottom - m_fMoldStartPixelInnerFromBottom);


                        break;
                    case 3: // Left Border
                        strPosition = "Left Border";
                        //if (m_intPadROIDirection == 1)
                        //    objMoldFlashBorderROI.LoadROISetting(0, 0, intToleranceWidth, objMoldFlashROI.ref_ROIHeight - intToleranceHeight);
                        //else if (m_intPadROIDirection == 3)
                        //    objMoldFlashBorderROI.LoadROISetting(0, intToleranceHeight, intToleranceWidth, objMoldFlashROI.ref_ROIHeight - intToleranceHeight);
                        //else
                        objMoldFlashBorderROI.LoadROISetting(0, (int)m_fMoldStartPixelFromEdge, (int)(m_fMoldStartPixelFromLeft - m_fMoldStartPixelInnerFromLeft), objMoldFlashROI.ref_ROIHeight - (int)(m_fMoldStartPixelFromEdge + m_fMoldStartPixelFromBottom));
                        intTotalStartX = objMoldFlashROI.ref_ROITotalX;
                        intTotalStartY = objMoldFlashROI.ref_ROITotalY + (int)m_fMoldStartPixelFromEdge;


                        break;
                }
                if (blnDebugImage)
                    objMoldFlashBorderROI.SaveImage("D:\\TS\\6.objMoldFlashBorderROI" + i.ToString() + ".bmp");

                // Build blobs object for subtract image
                m_objImage1MoldFlashEBlobs.BuildObjects_Filter_GetElement(objMoldFlashBorderROI, m_intMoldFlashDefectType == 1, true, 0, m_intPkgImage1MoldFlashThreshold,
                    (int)Math.Floor(m_fMoldFlashMinArea), 999999, false, 0x0F);

                if (m_objImage1MoldFlashEBlobs.ref_intNumSelectedObject > 0)
                {
                    int intTotalArea = 0;
                    float fCenterX = 0, fCenterY = 0, fWidth = 0, fHeight = 0;
                    float fStartX = 0, fStartY = 0, fEndX = 0, fEndY = 0;
                    int intArea = 0;
                    float fWidthMM = 0, fHeightMM = 0, fAreaInMM;
                    int intFailCount = 0;

                    for (int x = 0; x < m_objImage1MoldFlashEBlobs.ref_intNumSelectedObject; x++)
                    {
                        if (i == 0 || i == 2) //Top/Bottom border
                        {
                            fWidth = m_objImage1MoldFlashEBlobs.ref_arrWidth[x];
                            fHeight = m_objImage1MoldFlashEBlobs.ref_arrHeight[x];
                            fWidthMM = fWidth / m_fMMToPixelXValue;
                            fHeightMM = fHeight / m_fMMToPixelYValue;
                        }
                        else if (i == 1 || i == 3) //Left/Right border
                        {
                            fHeight = m_objImage1MoldFlashEBlobs.ref_arrWidth[x];
                            fWidth = m_objImage1MoldFlashEBlobs.ref_arrHeight[x];
                            fHeightMM = fHeight / m_fMMToPixelXValue;
                            fWidthMM = fWidth / m_fMMToPixelYValue;
                        }

                        fCenterX = m_objImage1MoldFlashEBlobs.ref_arrLimitCenterX[x];
                        fCenterY = m_objImage1MoldFlashEBlobs.ref_arrLimitCenterY[x];
                        //fWidth = m_objImage1MoldFlashEBlobs.ref_arrWidth[x];
                        //fHeight = m_objImage1MoldFlashEBlobs.ref_arrHeight[x];
                        intArea = m_objImage1MoldFlashEBlobs.ref_arrArea[x];
                        fStartX = (float)Math.Floor(fCenterX - (m_objImage1MoldFlashEBlobs.ref_arrWidth[x] / 2));
                        fStartY = (float)Math.Floor(fCenterY - (m_objImage1MoldFlashEBlobs.ref_arrHeight[x] / 2));
                        fEndX = (float)Math.Ceiling(fCenterX + (m_objImage1MoldFlashEBlobs.ref_arrWidth[x] / 2));
                        fEndY = (float)Math.Ceiling(fCenterY + (m_objImage1MoldFlashEBlobs.ref_arrHeight[x] / 2));
                        intTotalArea += intArea;

                        //fWidthMM = fWidth / m_fMMToPixelXValue;
                        //fHeightMM = fHeight / m_fMMToPixelYValue;
                        fAreaInMM = intArea / m_fMMToPixelXValue / m_fMMToPixelYValue;

                        bool blnDefect = false;
                        bool blnFailWidth = false;

                        //bool blnLengthFail = false;
                        // Not need to check length, only area
                        //if (i == 0)
                        //{
                        //    if (fHeight >= m_fMoldStartPixelFromEdge)
                        //        blnLengthFail = true;
                        //}
                        //else if (i == 1)
                        //{
                        //    if (fWidth >= m_fMoldStartPixelFromRight)
                        //        blnLengthFail = true;
                        //}
                        //else if (i == 2)
                        //{
                        //    if (fHeight >= m_fMoldStartPixelFromBottom)
                        //        blnLengthFail = true;
                        //}
                        //else if (i == 3)
                        //{
                        //    if (fWidth >= m_fMoldStartPixelFromLeft)
                        //        blnLengthFail = true;
                        //}

                        //if (blnLengthFail && fAreaInMM >= m_fMoldFlashArea)
                        /*if (fAreaInMM > m_fMoldFlashArea)*/  // 2019 07 21 - CCENG: Not need to check length anymore.
                        {
                            intFailCount++;
                            m_intFailPkgResultMask |= 0x80; // Fail Mold Flash

                            Defect objDefect = new Defect();

                            objDefect.ref_strName = strPosition + " Mold Flash";
                            //objDefect.ref_intFailCriteria |= 0x04;
                            objDefect.ref_intFailMask |= 0x80;
                            objDefect.ref_fCenterX = intTotalStartX + fCenterX;
                            objDefect.ref_fCenterY = intTotalStartY + fCenterY;
                            objDefect.ref_fStartX = intTotalStartX + fStartX;
                            objDefect.ref_fStartY = intTotalStartY + fStartY;
                            objDefect.ref_fEndX = intTotalStartX + fEndX;
                            objDefect.ref_fEndY = intTotalStartY + fEndY;
                            objDefect.ref_fWidth = fWidth;
                            objDefect.ref_fHeight = fHeight;
                            objDefect.ref_fArea = intArea;
                            objDefect.ref_fWidthInMM = fWidthMM;
                            objDefect.ref_fHeightInMM = fHeightMM;
                            objDefect.ref_fAreaInMM2 = fAreaInMM;
                            objDefect.ref_intImageNo = m_intPadPkgMoldFlashImageViewNo + 1;
                            //objDefect.ref_fFailValue = fAreaInMM;

                            if ((m_intFailPkgOptionMask & 0x1000000) > 0)
                            {
                                if (i == 0 || i == 2)
                                {
                                    if (m_intMoldFlashDefectDimensionFailCondition == 0)
                                    {
                                        if (fWidthMM >= m_fMoldFlashWidth)
                                        {
                                            blnResult = false;
                                            objDefect.ref_fWidthFailValue = fWidthMM;
                                            objDefect.ref_intFailCriteria |= 0x01;
                                        }

                                        if (fHeightMM >= m_fMoldFlashLength)
                                        {
                                            blnResult = false;
                                            objDefect.ref_fHeightFailValue = fHeightMM;
                                            objDefect.ref_intFailCriteria |= 0x02;
                                        }
                                    }
                                    else
                                    {
                                        if (fWidthMM >= m_fMoldFlashWidth && fHeightMM >= m_fMoldFlashLength)
                                        {
                                            blnResult = false;
                                            objDefect.ref_fWidthFailValue = fWidthMM;
                                            objDefect.ref_fHeightFailValue = fHeightMM;
                                            objDefect.ref_intFailCriteria |= 0x01;
                                            objDefect.ref_intFailCriteria |= 0x02;
                                        }
                                    }
                                }
                                else if (i == 1 || i == 3)
                                {
                                    if (m_intMoldFlashDefectDimensionFailCondition == 0)
                                    {
                                        if (fWidthMM >= m_fMoldFlashWidth)
                                        {
                                            blnResult = false;
                                            objDefect.ref_fWidthFailValue = fWidthMM;
                                            objDefect.ref_intFailCriteria |= 0x01;
                                        }

                                        if (fHeightMM >= m_fMoldFlashLength)
                                        {
                                            blnResult = false;
                                            objDefect.ref_fHeightFailValue = fHeightMM;
                                            objDefect.ref_intFailCriteria |= 0x02;
                                        }
                                    }
                                    else
                                    {
                                        if (fWidthMM >= m_fMoldFlashWidth && fHeightMM >= m_fMoldFlashLength)
                                        {
                                            blnResult = false;
                                            objDefect.ref_fWidthFailValue = fWidthMM;
                                            objDefect.ref_fHeightFailValue = fHeightMM;
                                            objDefect.ref_intFailCriteria |= 0x01;
                                            objDefect.ref_intFailCriteria |= 0x02;
                                        }
                                    }
                                }
                            }

                            if ((m_intFailPkgOptionMask & 0x80) > 0)
                            {
                                if (fAreaInMM >= m_fMoldFlashArea)
                                {
                                    blnResult = false;
                                    objDefect.ref_fAreaFailValue = fAreaInMM;
                                    objDefect.ref_intFailCriteria |= 0x04;
                                }
                            }
                            m_arrPkgDefectList.Add(objDefect);

                            //if (blnResult)
                            //    blnResult = false;
                        }
                    }


                    fAreaInMM = intTotalArea / m_fMMToPixelXValue / m_fMMToPixelYValue;

                    if (((m_intFailPkgOptionMask & 0x80) > 0) && (fAreaInMM >= m_fMoldFlashTotalArea))
                    {
                        Defect objDefect = new Defect();

                        objDefect.ref_strName = strPosition + " Total Mold Flash";
                        objDefect.ref_intFailMask = 0x80;
                        objDefect.ref_fCenterX = -1;
                        objDefect.ref_fCenterY = -1;
                        objDefect.ref_fStartX = -1;
                        objDefect.ref_fStartY = -1;
                        objDefect.ref_fEndX = -1;
                        objDefect.ref_fEndY = -1;
                        objDefect.ref_fWidth = -1;
                        objDefect.ref_fHeight = -1;
                        objDefect.ref_fArea = intTotalArea;
                        objDefect.ref_fWidthInMM = -1;
                        objDefect.ref_fHeightInMM = -1;
                        objDefect.ref_fAreaInMM2 = fAreaInMM;
                        objDefect.ref_intImageNo = m_intPadPkgMoldFlashImageViewNo + 1; //2020-01-09 ZJYEOH : Should not fixed to 1

                        blnResult = false;
                        objDefect.ref_fAreaFailValue = fAreaInMM;
                        objDefect.ref_intFailCriteria |= 0x08;

                        m_arrPkgDefectList.Add(objDefect);

                        Defect objDefect2 = new Defect();
                        for (int a = 0; a < m_arrPkgDefectList.Count; a++)
                        {
                            objDefect2 = m_arrPkgDefectList[a];
                            if (objDefect2.ref_strName.Contains(strPosition + " Mold Flash"))
                            {
                                objDefect2.ref_blnFailTotalArea = true;
                                m_arrPkgDefectList[a] = objDefect2;
                            }
                        }

                        m_intFailPkgResultMask |= 0x80; // Fail image 1 surface total bright field

                    }
                }


            }

            objMoldFlashBorderROI.Dispose();
            return blnResult;
        }
        private bool CheckImageMoldFlashDefect_Area_WithLinkFunction(ROI objImage1UnitROI, ROI objMoldFlashROI, int intPadIndex)
        {
            if (((m_intFailPkgOptionMask & 0x80) == 0) && ((m_intFailPkgOptionMask & 0x1000000) == 0))
                return true;

            //if (m_fMoldFlashArea == 0)
            //    return true;

            bool blnDebugImage = false;
            bool blnResult = true;
            int intTotalStartX = 0, intTotalStartY = 0;

            int intToleranceWidth = (objMoldFlashROI.ref_ROIWidth - objImage1UnitROI.ref_ROIWidth) / 2;
            int intToleranceHeight = (objMoldFlashROI.ref_ROIHeight - objImage1UnitROI.ref_ROIHeight) / 2;

            #region Subtract Template Pad ----------------------------------------------------------------------------------

            for (int i = 0; i < m_arrTemplateBlobPads.Count; i++)
            {
                if (blnDebugImage)
                    m_arrImgPadImage[i].Save("D:\\TS\\2_m_arrImgPadImage" + i.ToString() + ".bmp");// debug   
                ROI objROI = new ROI();
                ROI DilateROI = new ROI();
                ImageDrawing Img = new ImageDrawing();

                if (m_arrSampleBlobPads[i].intFailMask != 0)
                    continue;

                int intImageToleranceWidth = (int)Math.Round((m_arrImgPadImage[i].Width - objMoldFlashROI.ref_ROIWidth) / 2.0);
                int intImageToleranceHeight = (int)Math.Round((m_arrImgPadImage[i].Height - objMoldFlashROI.ref_ROIHeight) / 2.0);
                int intOffsetX = 0, intOffsetY = 0;
                if (intImageToleranceWidth < 0)
                {
                    intOffsetX = -intImageToleranceWidth;
                    intImageToleranceWidth = 0;
                }
                if (intImageToleranceHeight < 0)
                {
                    intOffsetY = -intImageToleranceHeight;
                    intImageToleranceHeight = 0;
                }

                if (!GetOverallWantGaugeMeasurePkgSize(false))
                {
                    intOffsetX += (int)Math.Round(GetResultCenterPoint_UnitMatcher().X - GetResultCenterPoint_RectGauge4L().X);
                    intOffsetY += (int)Math.Round(GetResultCenterPoint_UnitMatcher().Y - GetResultCenterPoint_RectGauge4L().Y);
                }

                Img.SetImageSize(m_arrImgPadImage[i].Width, m_arrImgPadImage[i].Height);
                Img.SetImageToBlack();
                objROI.ref_ROI.Attach(m_arrImgPadImage[i]);
                objROI.LoadROISetting(intImageToleranceWidth + intOffsetX, intImageToleranceHeight + intOffsetY, objMoldFlashROI.ref_ROIWidth - (intOffsetX * 2), objMoldFlashROI.ref_ROIHeight - (intOffsetY * 2));
                DilateROI.AttachImage(Img);
                DilateROI.LoadROISetting(intImageToleranceWidth + intOffsetX, intImageToleranceHeight + intOffsetY, objMoldFlashROI.ref_ROIWidth - (intOffsetX * 2), objMoldFlashROI.ref_ROIHeight - (intOffsetY * 2));

                EasyImage.Copy(objROI.ref_ROI, DilateROI.ref_ROI);
#if (Debug_2_12 || Release_2_12)
                EasyImage.DilateBox(DilateROI.ref_ROI, DilateROI.ref_ROI, (uint)Math.Abs(m_intMPDilateHalfWidth), (uint)Math.Abs(m_intMPDilateHalfWidth));
#elif (DEBUG || RELEASE || RTXRelease || RTXDebug)
                EasyImage.DilateBox(DilateROI.ref_ROI, DilateROI.ref_ROI, Math.Abs(m_intMPDilateHalfWidth), Math.Abs(m_intMPDilateHalfWidth));
#endif

                if (blnDebugImage)
                {
                    objROI.SaveImage("D:\\TS\\3.1_objROI.bmp");// debug  
                    DilateROI.SaveImage("D:\\TS\\3.2_DilateROI.bmp");// debug  
                }
                objROI.AttachImage(objMoldFlashROI);
                objROI.LoadROISetting_MustSameSize(DilateROI, intImageToleranceWidth + intOffsetX, intImageToleranceHeight + intOffsetY, objMoldFlashROI.ref_ROIWidth - (intOffsetX * 2), objMoldFlashROI.ref_ROIHeight - (intOffsetY * 2));
                if (blnDebugImage)
                {
                    objROI.SaveImage("D:\\TS\\3.3_objROI.bmp");// debug  
                }
                EasyImage.Oper(EArithmeticLogicOperation.Subtract, objROI.ref_ROI, DilateROI.ref_ROI, objROI.ref_ROI);
                if (blnDebugImage)
                {
                    m_arrImgPadImage[i].Save("D:\\TS\\4_m_arrImgPadImage" + i.ToString() + ".bmp");
                }
                objROI.Dispose();
                DilateROI.Dispose();
                Img.Dispose();
            }
            if (blnDebugImage)
            {
                objMoldFlashROI.SaveImage("D:\\TS\\5_objMoldFlashROI.bmp");// debug  
            }

            #endregion ------------------------------------------------------------------------------------------------

            objMoldFlashROI.LoadROISetting(objImage1UnitROI.ref_ROITotalX - (int)m_fMoldStartPixelFromLeft,
                                       objImage1UnitROI.ref_ROITotalY - (int)m_fMoldStartPixelFromEdge,
                                       objImage1UnitROI.ref_ROIWidth + (int)(m_fMoldStartPixelFromLeft + m_fMoldStartPixelFromRight),
                                       objImage1UnitROI.ref_ROIHeight + (int)(m_fMoldStartPixelFromEdge + m_fMoldStartPixelFromBottom));

            ROI objMoldFlashBorderROI = new ROI();
            objMoldFlashBorderROI.AttachImage(objMoldFlashROI);
            List<List<List<System.Windows.Point>>> arr2DPoints = new List<List<List<System.Windows.Point>>>();
            List<List<List<PointF>>> arrRotatedPoints = new List<List<List<PointF>>>();
            List<List<float>> fObjectHeightList = new List<List<float>>(), fObjectWidthList = new List<List<float>>(), fObjectCenterXList = new List<List<float>>(), fObjectCenterYList = new List<List<float>>(), fObjectAngleList = new List<List<float>>();
            List<List<int>> fObjectAreaList = new List<List<int>>(), fObjectAreaList2 = new List<List<int>>();
            string strPosition = "";
            for (int i = 0; i < 4; i++)   // Create 4 direction ROI
            {
                arrRotatedPoints.Add(new List<List<PointF>>());
                arr2DPoints.Add(new List<List<System.Windows.Point>>());
                fObjectHeightList.Add(new List<float>());
                fObjectWidthList.Add(new List<float>());
                fObjectCenterXList.Add(new List<float>());
                fObjectCenterYList.Add(new List<float>());
                fObjectAngleList.Add(new List<float>());
                fObjectAreaList.Add(new List<int>());
                fObjectAreaList2.Add(new List<int>());

                if (m_intPadROIDirection == 1 && i == 2)    // Top Side Pad 
                    continue;
                else if (m_intPadROIDirection == 2 && i == 3) // Right Side Pad
                    continue;
                else if (m_intPadROIDirection == 3 && i == 0) // Bottom Side Pad
                    continue;
                else if (m_intPadROIDirection == 4 && i == 1) // Left Side Pad
                    continue;

                //switch (i)
                //{
                //    case 0:  // Top Border
                //        if (m_intPadROIDirection == 2)
                //            objMoldFlashBorderROI.LoadROISetting(intToleranceWidth, 0, objMoldFlashROI.ref_ROIWidth - intToleranceWidth, intToleranceHeight);
                //        else if (m_intPadROIDirection == 4)
                //            objMoldFlashBorderROI.LoadROISetting(0, 0, objMoldFlashROI.ref_ROIWidth - intToleranceWidth, intToleranceHeight);
                //        else
                //            objMoldFlashBorderROI.LoadROISetting(0, 0, objMoldFlashROI.ref_ROIWidth, (int)m_fMoldStartPixelFromEdge);


                //        intTotalStartX = objMoldFlashROI.ref_ROITotalX;
                //        intTotalStartY = objMoldFlashROI.ref_ROITotalY;

                //        break;
                //    case 1: // Right Border
                //        if (m_intPadROIDirection == 1)
                //            objMoldFlashBorderROI.LoadROISetting(objMoldFlashROI.ref_ROIWidth - intToleranceWidth, 0, intToleranceWidth, objMoldFlashROI.ref_ROIHeight - intToleranceHeight);
                //        else if (m_intPadROIDirection == 3)
                //            objMoldFlashBorderROI.LoadROISetting(objMoldFlashROI.ref_ROIWidth - intToleranceWidth, intToleranceHeight, intToleranceWidth, objMoldFlashROI.ref_ROIHeight - intToleranceHeight);
                //        else
                //            objMoldFlashBorderROI.LoadROISetting(objMoldFlashROI.ref_ROIWidth - (int)m_fMoldStartPixelFromRight, 0, (int)m_fMoldStartPixelFromRight, objMoldFlashROI.ref_ROIHeight);
                //        intTotalStartX = objMoldFlashROI.ref_ROITotalX + objMoldFlashROI.ref_ROIWidth - (int)m_fMoldStartPixelFromRight;
                //        intTotalStartY = objMoldFlashROI.ref_ROITotalY;


                //        break;
                //    case 2: // Bottom Border
                //        if (m_intPadROIDirection == 2)
                //            objMoldFlashBorderROI.LoadROISetting(intToleranceWidth, objMoldFlashROI.ref_ROIHeight - intToleranceHeight, objMoldFlashROI.ref_ROIWidth - intToleranceWidth, intToleranceHeight);
                //        else if (m_intPadROIDirection == 4)
                //            objMoldFlashBorderROI.LoadROISetting(0, objMoldFlashROI.ref_ROIHeight - intToleranceHeight, objMoldFlashROI.ref_ROIWidth - intToleranceWidth, intToleranceHeight);
                //        else
                //            objMoldFlashBorderROI.LoadROISetting(0, objMoldFlashROI.ref_ROIHeight - (int)m_fMoldStartPixelFromBottom, objMoldFlashROI.ref_ROIWidth, (int)m_fMoldStartPixelFromBottom);
                //        intTotalStartX = objMoldFlashROI.ref_ROITotalX;
                //        intTotalStartY = objMoldFlashROI.ref_ROITotalY + objMoldFlashROI.ref_ROIHeight - (int)m_fMoldStartPixelFromBottom;


                //        break;
                //    case 3: // Left Border
                //        if (m_intPadROIDirection == 1)
                //            objMoldFlashBorderROI.LoadROISetting(0, 0, intToleranceWidth, objMoldFlashROI.ref_ROIHeight - intToleranceHeight);
                //        else if (m_intPadROIDirection == 3)
                //            objMoldFlashBorderROI.LoadROISetting(0, intToleranceHeight, intToleranceWidth, objMoldFlashROI.ref_ROIHeight - intToleranceHeight);
                //        else
                //            objMoldFlashBorderROI.LoadROISetting(0, 0, (int)m_fMoldStartPixelFromLeft, objMoldFlashROI.ref_ROIHeight);
                //        intTotalStartX = objMoldFlashROI.ref_ROITotalX;
                //        intTotalStartY = objMoldFlashROI.ref_ROITotalY;


                //        break;
                //}
                switch (i)
                {
                    case 0:  // Top Border
                        strPosition = "Top Border";
                             //if (m_intPadROIDirection == 2)
                             //    objMoldFlashBorderROI.LoadROISetting(intToleranceWidth, 0, objMoldFlashROI.ref_ROIWidth - intToleranceWidth, intToleranceHeight);
                             //else if (m_intPadROIDirection == 4)
                             //    objMoldFlashBorderROI.LoadROISetting(0, 0, objMoldFlashROI.ref_ROIWidth - intToleranceWidth, intToleranceHeight);
                             //else
                        objMoldFlashBorderROI.LoadROISetting((int)m_fMoldStartPixelFromLeft, 0, objMoldFlashROI.ref_ROIWidth - (int)(m_fMoldStartPixelFromLeft + m_fMoldStartPixelFromRight), (int)(m_fMoldStartPixelFromEdge - m_fMoldStartPixelInnerFromEdge));


                        intTotalStartX = objMoldFlashROI.ref_ROITotalX + (int)m_fMoldStartPixelFromLeft;
                        intTotalStartY = objMoldFlashROI.ref_ROITotalY;

                        break;
                    case 1: // Right Border
                        strPosition = "Right Border";
                        //if (m_intPadROIDirection == 1)
                        //    objMoldFlashBorderROI.LoadROISetting(objMoldFlashROI.ref_ROIWidth - intToleranceWidth, 0, intToleranceWidth, objMoldFlashROI.ref_ROIHeight - intToleranceHeight);
                        //else if (m_intPadROIDirection == 3)
                        //    objMoldFlashBorderROI.LoadROISetting(objMoldFlashROI.ref_ROIWidth - intToleranceWidth, intToleranceHeight, intToleranceWidth, objMoldFlashROI.ref_ROIHeight - intToleranceHeight);
                        //else
                        objMoldFlashBorderROI.LoadROISetting(objMoldFlashROI.ref_ROIWidth - (int)(m_fMoldStartPixelFromRight - m_fMoldStartPixelInnerFromRight), (int)m_fMoldStartPixelFromEdge, (int)(m_fMoldStartPixelFromRight - m_fMoldStartPixelInnerFromRight), objMoldFlashROI.ref_ROIHeight - (int)(m_fMoldStartPixelFromEdge + m_fMoldStartPixelFromBottom));
                        intTotalStartX = objMoldFlashROI.ref_ROITotalX + objMoldFlashROI.ref_ROIWidth - (int)(m_fMoldStartPixelFromRight - m_fMoldStartPixelInnerFromRight);
                        intTotalStartY = objMoldFlashROI.ref_ROITotalY + (int)m_fMoldStartPixelFromEdge;


                        break;
                    case 2: // Bottom Border
                        strPosition = "Bottom Border";
                        //if (m_intPadROIDirection == 2)
                        //    objMoldFlashBorderROI.LoadROISetting(intToleranceWidth, objMoldFlashROI.ref_ROIHeight - intToleranceHeight, objMoldFlashROI.ref_ROIWidth - intToleranceWidth, intToleranceHeight);
                        //else if (m_intPadROIDirection == 4)
                        //    objMoldFlashBorderROI.LoadROISetting(0, objMoldFlashROI.ref_ROIHeight - intToleranceHeight, objMoldFlashROI.ref_ROIWidth - intToleranceWidth, intToleranceHeight);
                        //else
                        objMoldFlashBorderROI.LoadROISetting((int)m_fMoldStartPixelFromLeft, objMoldFlashROI.ref_ROIHeight - (int)(m_fMoldStartPixelFromBottom - m_fMoldStartPixelInnerFromBottom), objMoldFlashROI.ref_ROIWidth - (int)(m_fMoldStartPixelFromLeft + m_fMoldStartPixelFromRight), (int)(m_fMoldStartPixelFromBottom - m_fMoldStartPixelInnerFromBottom));
                        intTotalStartX = objMoldFlashROI.ref_ROITotalX + (int)m_fMoldStartPixelFromLeft;
                        intTotalStartY = objMoldFlashROI.ref_ROITotalY + objMoldFlashROI.ref_ROIHeight - (int)(m_fMoldStartPixelFromBottom - m_fMoldStartPixelInnerFromBottom);


                        break;
                    case 3: // Left Border
                        strPosition = "Left Border";
                        //if (m_intPadROIDirection == 1)
                        //    objMoldFlashBorderROI.LoadROISetting(0, 0, intToleranceWidth, objMoldFlashROI.ref_ROIHeight - intToleranceHeight);
                        //else if (m_intPadROIDirection == 3)
                        //    objMoldFlashBorderROI.LoadROISetting(0, intToleranceHeight, intToleranceWidth, objMoldFlashROI.ref_ROIHeight - intToleranceHeight);
                        //else
                        objMoldFlashBorderROI.LoadROISetting(0, (int)m_fMoldStartPixelFromEdge, (int)(m_fMoldStartPixelFromLeft - m_fMoldStartPixelInnerFromLeft), objMoldFlashROI.ref_ROIHeight - (int)(m_fMoldStartPixelFromEdge + m_fMoldStartPixelFromBottom));
                        intTotalStartX = objMoldFlashROI.ref_ROITotalX;
                        intTotalStartY = objMoldFlashROI.ref_ROITotalY + (int)m_fMoldStartPixelFromEdge;


                        break;
                }
                if (blnDebugImage)
                    objMoldFlashBorderROI.SaveImage("D:\\TS\\6.objMoldFlashBorderROI" + i.ToString() + ".bmp");

                // Build blobs object for subtract image
                m_objImage1MoldFlashEBlobs.BuildObjects_Filter_GetElement(objMoldFlashBorderROI, m_intMoldFlashDefectType == 1, true, 0, m_intPkgImage1MoldFlashThreshold,
                    (int)Math.Floor(m_fMoldFlashMinArea), 999999, false, 0xED);//0x0F

                if (m_objImage1MoldFlashEBlobs.ref_intNumSelectedObject > 0)
                {
                    int intTotalArea = 0;
                    float fCenterX = 0, fCenterY = 0, fWidth = 0, fHeight = 0, fAngle = 0;
                    float fStartX = 0, fStartY = 0, fEndX = 0, fEndY = 0;
                    int intArea = 0;
                    float fWidthMM = 0, fHeightMM = 0, fAreaInMM;
                    int intFailCount = 0;

                    for (int x = 0; x < m_objImage1MoldFlashEBlobs.ref_intNumSelectedObject; x++)
                    {
                        arrRotatedPoints[i].Add(new List<PointF>());
                        arr2DPoints[i].Add(new List<System.Windows.Point>());

                        //fCenterX = m_objImage1MoldFlashEBlobs.ref_arrLimitCenterX[x];
                        //fCenterY = m_objImage1MoldFlashEBlobs.ref_arrLimitCenterY[x];
                        //fWidth = m_objImage1MoldFlashEBlobs.ref_arrWidth[x];
                        //fHeight = m_objImage1MoldFlashEBlobs.ref_arrHeight[x];
                        intArea = m_objImage1MoldFlashEBlobs.ref_arrArea[x];
                        //fStartX = (float)Math.Floor(fCenterX - (fWidth / 2));
                        //fStartY = (float)Math.Floor(fCenterY - (fHeight / 2));
                        //fEndX = (float)Math.Ceiling(fCenterX + (fWidth / 2));
                        //fEndY = (float)Math.Ceiling(fCenterY + (fHeight / 2));
                        intTotalArea += intArea;

                        if (i == 0 || i == 2)
                        {
                            fWidth = m_objImage1MoldFlashEBlobs.ref_arrRectHeight[x];
                            fHeight = m_objImage1MoldFlashEBlobs.ref_arrRectWidth[x];

                            fAngle = m_objImage1MoldFlashEBlobs.ref_arrRectAngle[x];

                            if (fAngle >= 10)//&& fAngle <= 80)
                                fAngle = m_objImage1MoldFlashEBlobs.ref_arrRectAngle[x] - 90;
                            else
                                fAngle = 90 + m_objImage1MoldFlashEBlobs.ref_arrRectAngle[x];
                        }
                        else
                        {
                            fHeight = m_objImage1MoldFlashEBlobs.ref_arrRectHeight[x];
                            fWidth = m_objImage1MoldFlashEBlobs.ref_arrRectWidth[x];

                            fAngle = m_objImage1MoldFlashEBlobs.ref_arrRectAngle[x];
                        }

                        //if (m_objImage1MoldFlashEBlobs.ref_arrRectHeight[x] > m_objImage1MoldFlashEBlobs.ref_arrRectWidth[x])
                        //{
                        //    fWidth = m_objImage1MoldFlashEBlobs.ref_arrRectHeight[x];
                        //    fHeight = m_objImage1MoldFlashEBlobs.ref_arrRectWidth[x];

                        //    fAngle = m_objImage1MoldFlashEBlobs.ref_arrRectAngle[x];

                        //    if (fAngle >= 10)//&& fAngle <= 80)
                        //        fAngle = m_objImage1MoldFlashEBlobs.ref_arrRectAngle[x] - 90;
                        //    else
                        //        fAngle = 90 + m_objImage1MoldFlashEBlobs.ref_arrRectAngle[x];

                        //}
                        //else
                        //{

                        //}
                        fCenterX = m_objImage1MoldFlashEBlobs.ref_arrRectLimitCenterX[x];
                        fCenterY = m_objImage1MoldFlashEBlobs.ref_arrRectLimitCenterY[x];


                        float newX1 = 0, newY1 = 0;  // new point 1
                        float newX2 = 0, newY2 = 0; // new point 2
                        float newX3 = 0, newY3 = 0; // new point 3
                        float newX4 = 0, newY4 = 0; // new point 4

                        //2020-12-18 ZJYEOH : Change to this format
                        //  Point 1 *-------------* Point 2
                        //          |             |
                        //          |             |
                        //          |             |
                        //  Point 4 *-------------* Point 3

                        Math2.RotateWithAngleAccordingToReferencePoint(fCenterX, fCenterY, (fCenterX - (fWidth / 2)), (fCenterY - (fHeight / 2)), fAngle, ref newX1, ref newY1);
                        Math2.RotateWithAngleAccordingToReferencePoint(fCenterX, fCenterY, (fCenterX + (fWidth / 2)), (fCenterY - (fHeight / 2)), fAngle, ref newX2, ref newY2);
                        Math2.RotateWithAngleAccordingToReferencePoint(fCenterX, fCenterY, (fCenterX + (fWidth / 2)), (fCenterY + (fHeight / 2)), fAngle, ref newX3, ref newY3);
                        Math2.RotateWithAngleAccordingToReferencePoint(fCenterX, fCenterY, (fCenterX - (fWidth / 2)), (fCenterY + (fHeight / 2)), fAngle, ref newX4, ref newY4);


                        arrRotatedPoints[i][x].Add(new PointF(newX1, newY1));
                        arrRotatedPoints[i][x].Add(new PointF(newX2, newY2));
                        arrRotatedPoints[i][x].Add(new PointF(newX3, newY3));
                        arrRotatedPoints[i][x].Add(new PointF(newX4, newY4));

                        Math2.RotateWithAngleAccordingToReferencePoint(fCenterX, fCenterY, (fCenterX - (fWidth / 2)) - m_intMoldFlashDefectLinkTolerance, (fCenterY - (fHeight / 2)) - m_intMoldFlashDefectLinkTolerance, fAngle, ref newX1, ref newY1);
                        Math2.RotateWithAngleAccordingToReferencePoint(fCenterX, fCenterY, (fCenterX + (fWidth / 2)) + m_intMoldFlashDefectLinkTolerance, (fCenterY - (fHeight / 2)) - m_intMoldFlashDefectLinkTolerance, fAngle, ref newX2, ref newY2);
                        Math2.RotateWithAngleAccordingToReferencePoint(fCenterX, fCenterY, (fCenterX + (fWidth / 2)) + m_intMoldFlashDefectLinkTolerance, (fCenterY + (fHeight / 2)) + m_intMoldFlashDefectLinkTolerance, fAngle, ref newX3, ref newY3);
                        Math2.RotateWithAngleAccordingToReferencePoint(fCenterX, fCenterY, (fCenterX - (fWidth / 2)) - m_intMoldFlashDefectLinkTolerance, (fCenterY + (fHeight / 2)) + m_intMoldFlashDefectLinkTolerance, fAngle, ref newX4, ref newY4);

                        arr2DPoints[i][x].Add(new System.Windows.Point(newX1, newY1));
                        arr2DPoints[i][x].Add(new System.Windows.Point(newX2, newY2));
                        arr2DPoints[i][x].Add(new System.Windows.Point(newX3, newY3));
                        arr2DPoints[i][x].Add(new System.Windows.Point(newX4, newY4));

                        fObjectHeightList[i].Add(fHeight);
                        fObjectWidthList[i].Add(fWidth);
                        fObjectCenterXList[i].Add(fCenterX);
                        fObjectCenterYList[i].Add(fCenterY);
                        fObjectAngleList[i].Add(fAngle);
                        fObjectAreaList[i].Add(intArea);
                        fObjectAreaList2[i].Add(intArea);
                    }
                    int intTolerance = m_intMoldFlashDefectLinkTolerance;
                    int intAngleTolerance = 10;
                    bool blnDecrement = false;
                    if (intTolerance >= 0)
                    {
                        for (int x = 0; x < fObjectHeightList[i].Count; x++)
                        {
                            if (blnDecrement)
                            {
                                blnDecrement = false;
                                if (x > 0)
                                    x--;
                            }
                            for (int j = 0; j < fObjectHeightList[i].Count; j++)
                            {
                                if (x != j && x < fObjectHeightList[i].Count && j < fObjectHeightList[i].Count)
                                {
                                    if (Intersection.CheckRectRectIntersection(arr2DPoints[i][x].ToArray(), arr2DPoints[i][j].ToArray(), intTolerance))
                                    {

                                        PointF[] arrPoints = new PointF[8];

                                        arrPoints[0] = arrRotatedPoints[i][x][0];
                                        arrPoints[1] = arrRotatedPoints[i][x][1];
                                        arrPoints[2] = arrRotatedPoints[i][x][2];
                                        arrPoints[3] = arrRotatedPoints[i][x][3];
                                        arrPoints[4] = arrRotatedPoints[i][j][0];
                                        arrPoints[5] = arrRotatedPoints[i][j][1];
                                        arrPoints[6] = arrRotatedPoints[i][j][2];
                                        arrPoints[7] = arrRotatedPoints[i][j][3];

                                        float fMinAngle = 0;
                                        List<PointF> arrMinRect = new List<PointF>();
                                        arrMinRect = MinimumBoundingBox.CalculateMinimumBoundingBox(arrPoints, ref fMinAngle);

                                        if (fMinAngle < 0)
                                            fObjectAngleList[i][x] = -(90 + fMinAngle);
                                        else
                                            fObjectAngleList[i][x] = 90 - fMinAngle;

                                        Line onjLine1 = new Line();
                                        Line onjLine2 = new Line();
                                        onjLine1.CalculateStraightLine(arrMinRect[0], arrMinRect[2]);
                                        onjLine2.CalculateStraightLine(arrMinRect[1], arrMinRect[3]);
                                        PointF pCenter = Line.GetCrossPoint(onjLine1, onjLine2);
                                        float p1X = 0, p1Y = 0;
                                        float p2X = 0, p2Y = 0;
                                        float p3X = 0, p3Y = 0;
                                        float p4X = 0, p4Y = 0;
                                        Math2.RotateWithAngleAccordingToReferencePoint(pCenter.X, pCenter.Y, arrMinRect[0].X, arrMinRect[0].Y, -fObjectAngleList[i][x], ref p1X, ref p1Y);
                                        Math2.RotateWithAngleAccordingToReferencePoint(pCenter.X, pCenter.Y, arrMinRect[1].X, arrMinRect[1].Y, -fObjectAngleList[i][x], ref p2X, ref p2Y);
                                        Math2.RotateWithAngleAccordingToReferencePoint(pCenter.X, pCenter.Y, arrMinRect[2].X, arrMinRect[2].Y, -fObjectAngleList[i][x], ref p3X, ref p3Y);
                                        Math2.RotateWithAngleAccordingToReferencePoint(pCenter.X, pCenter.Y, arrMinRect[3].X, arrMinRect[3].Y, -fObjectAngleList[i][x], ref p4X, ref p4Y);

                                        float pR1X = 0, pR1Y = 0;
                                        float pR2X = 0, pR2Y = 0;
                                        float pR3X = 0, pR3Y = 0;
                                        float pR4X = 0, pR4Y = 0;
                                        Math2.RotateWithAngleAccordingToReferencePoint(pCenter.X, pCenter.Y, Math.Min(Math.Min(p1X, p2X), Math.Min(p3X, p4X)), Math.Min(Math.Min(p1Y, p2Y), Math.Min(p3Y, p4Y)), fObjectAngleList[i][x], ref pR1X, ref pR1Y); // Top Left
                                        Math2.RotateWithAngleAccordingToReferencePoint(pCenter.X, pCenter.Y, Math.Max(Math.Max(p1X, p2X), Math.Max(p3X, p4X)), Math.Min(Math.Min(p1Y, p2Y), Math.Min(p3Y, p4Y)), fObjectAngleList[i][x], ref pR2X, ref pR2Y); // Top Right
                                        Math2.RotateWithAngleAccordingToReferencePoint(pCenter.X, pCenter.Y, Math.Max(Math.Max(p1X, p2X), Math.Max(p3X, p4X)), Math.Max(Math.Max(p1Y, p2Y), Math.Max(p3Y, p4Y)), fObjectAngleList[i][x], ref pR3X, ref pR3Y); // Bottom Right
                                        Math2.RotateWithAngleAccordingToReferencePoint(pCenter.X, pCenter.Y, Math.Min(Math.Min(p1X, p2X), Math.Min(p3X, p4X)), Math.Max(Math.Max(p1Y, p2Y), Math.Max(p3Y, p4Y)), fObjectAngleList[i][x], ref pR4X, ref pR4Y); // Bottom Left
                                        arrMinRect[0] = new PointF(pR1X, pR1Y);
                                        arrMinRect[1] = new PointF(pR2X, pR2Y);
                                        arrMinRect[2] = new PointF(pR3X, pR3Y);
                                        arrMinRect[3] = new PointF(pR4X, pR4Y);

                                        arrRotatedPoints[i][x][0] = arrMinRect[0];
                                        arrRotatedPoints[i][x][1] = arrMinRect[1];
                                        arrRotatedPoints[i][x][2] = arrMinRect[2];
                                        arrRotatedPoints[i][x][3] = arrMinRect[3];

                                        Math2.RotateWithAngleAccordingToReferencePoint(pCenter.X, pCenter.Y, Math.Min(Math.Min(p1X, p2X), Math.Min(p3X, p4X)) - m_intMoldFlashDefectLinkTolerance, Math.Min(Math.Min(p1Y, p2Y), Math.Min(p3Y, p4Y)) - m_intMoldFlashDefectLinkTolerance, fObjectAngleList[i][x], ref pR1X, ref pR1Y); // Top Left
                                        Math2.RotateWithAngleAccordingToReferencePoint(pCenter.X, pCenter.Y, Math.Max(Math.Max(p1X, p2X), Math.Max(p3X, p4X)) + m_intMoldFlashDefectLinkTolerance, Math.Min(Math.Min(p1Y, p2Y), Math.Min(p3Y, p4Y)) - m_intMoldFlashDefectLinkTolerance, fObjectAngleList[i][x], ref pR2X, ref pR2Y); // Top Right
                                        Math2.RotateWithAngleAccordingToReferencePoint(pCenter.X, pCenter.Y, Math.Max(Math.Max(p1X, p2X), Math.Max(p3X, p4X)) + m_intMoldFlashDefectLinkTolerance, Math.Max(Math.Max(p1Y, p2Y), Math.Max(p3Y, p4Y)) + m_intMoldFlashDefectLinkTolerance, fObjectAngleList[i][x], ref pR3X, ref pR3Y); // Bottom Right
                                        Math2.RotateWithAngleAccordingToReferencePoint(pCenter.X, pCenter.Y, Math.Min(Math.Min(p1X, p2X), Math.Min(p3X, p4X)) - m_intMoldFlashDefectLinkTolerance, Math.Max(Math.Max(p1Y, p2Y), Math.Max(p3Y, p4Y)) + m_intMoldFlashDefectLinkTolerance, fObjectAngleList[i][x], ref pR4X, ref pR4Y); // Bottom Left

                                        arr2DPoints[i][x][0] = new System.Windows.Point(pR1X, pR1Y);
                                        arr2DPoints[i][x][1] = new System.Windows.Point(pR2X, pR2Y);
                                        arr2DPoints[i][x][2] = new System.Windows.Point(pR3X, pR3Y);
                                        arr2DPoints[i][x][3] = new System.Windows.Point(pR4X, pR4Y);

                                        arrRotatedPoints[i].RemoveAt(j);
                                        arr2DPoints[i].RemoveAt(j);

                                        float fDiffX = Math.Max(Math.Abs(p1X - p4X), Math.Abs(p2X - p3X));
                                        float fDiffY = Math.Max(Math.Abs(p3Y - p4Y), Math.Abs(p2Y - p1Y));

                                        fObjectWidthList[i][x] = fDiffX;
                                        fObjectHeightList[i][x] = fDiffY;

                                        fObjectCenterXList[i][x] = pCenter.X;
                                        fObjectCenterYList[i][x] = pCenter.Y;

                                        fObjectAreaList2[i].RemoveAt(j);
                                        fObjectAreaList[i][x] = fObjectAreaList[i][x] + fObjectAreaList[i][j];

                                        fObjectHeightList[i].RemoveAt(j);
                                        fObjectWidthList[i].RemoveAt(j);
                                        fObjectCenterXList[i].RemoveAt(j);
                                        fObjectCenterYList[i].RemoveAt(j);
                                        fObjectAngleList[i].RemoveAt(j);
                                        fObjectAreaList[i].RemoveAt(j);

                                        if (j > 0)
                                            j = -1;
                                        if (x > 0)
                                        {
                                            x = 0;
                                        }
                                        else
                                            blnDecrement = true;

                                    }

                                }
                            }
                        }
                    }
                    for (int x = 0; x < fObjectAreaList[i].Count; x++)
                    {
                        //if (i == 0 || i == 2) //Top/Bottom border
                        {
                            fWidth = fObjectWidthList[i][x];
                            fHeight = fObjectHeightList[i][x];
                            fWidthMM = fWidth / m_fMMToPixelXValue;
                            fHeightMM = fHeight / m_fMMToPixelYValue;
                        }
                        //else if (i == 1 || i == 3) //Left/Right border
                        //{
                        //    fHeight = fObjectWidthList[i][x];
                        //    fWidth = fObjectHeightList[i][x];
                        //    fHeightMM = fHeight / m_fMMToPixelXValue;
                        //    fWidthMM = fWidth / m_fMMToPixelYValue;
                        //}

                        ////fWidthMM = fWidth / m_fMMToPixelXValue;
                        ////fHeightMM = fHeight / m_fMMToPixelYValue;
                        ////fAreaInMM = intArea / m_fMMToPixelXValue / m_fMMToPixelYValue;
                        //fWidthMM = fObjectWidthList[i][x] / m_fMMToPixelXValue;
                        //fHeightMM = fObjectHeightList[i][x] / m_fMMToPixelYValue;
                        fAreaInMM = fObjectAreaList[i][x] / (m_fMMToPixelXValue * m_fMMToPixelYValue);

                        bool blnDefect = false;
                        bool blnFailWidth = false;

                        //bool blnLengthFail = false;
                        // Not need to check length, only area
                        //if (i == 0)
                        //{
                        //    if (fHeight >= m_fMoldStartPixelFromEdge)
                        //        blnLengthFail = true;
                        //}
                        //else if (i == 1)
                        //{
                        //    if (fWidth >= m_fMoldStartPixelFromRight)
                        //        blnLengthFail = true;
                        //}
                        //else if (i == 2)
                        //{
                        //    if (fHeight >= m_fMoldStartPixelFromBottom)
                        //        blnLengthFail = true;
                        //}
                        //else if (i == 3)
                        //{
                        //    if (fWidth >= m_fMoldStartPixelFromLeft)
                        //        blnLengthFail = true;
                        //}

                        //if (blnLengthFail && fAreaInMM >= m_fMoldFlashArea)
                        //if (fAreaInMM > m_fMoldFlashArea)  // 2019 07 21 - CCENG: Not need to check length anymore.
                        {
                            intFailCount++;
                            m_intFailPkgResultMask |= 0x80; // Fail Mold Flash

                            Defect objDefect = new Defect();

                            objDefect.ref_strName = strPosition + " Mold Flash";
                            //objDefect.ref_intFailCriteria |= 0x04;
                            objDefect.ref_intFailMask |= 0x80;
                            objDefect.ref_fCenterX = intTotalStartX + fObjectCenterXList[i][x];
                            objDefect.ref_fCenterY = intTotalStartY + fObjectCenterYList[i][x];
                            //objDefect.ref_fStartX = intTotalStartX + fStartX;
                            //objDefect.ref_fStartY = intTotalStartY + fStartY;
                            //objDefect.ref_fEndX = intTotalStartX + fEndX;
                            //objDefect.ref_fEndY = intTotalStartY + fEndY;
                            objDefect.ref_fWidth = fWidth;
                            objDefect.ref_fHeight = fHeight;
                            objDefect.ref_fArea = fObjectAreaList[i][x];
                            objDefect.ref_fAngle = fObjectAngleList[i][x];
                            objDefect.ref_fWidthInMM = fWidthMM;
                            objDefect.ref_fHeightInMM = fHeightMM;
                            objDefect.ref_fAreaInMM2 = fAreaInMM;
                            objDefect.ref_intImageNo = m_intPadPkgMoldFlashImageViewNo + 1;
                            //objDefect.ref_fFailValue = fAreaInMM;

                            if ((m_intFailPkgOptionMask & 0x1000000) > 0)
                            {
                                if (i == 0 || i == 2)
                                {
                                    if (m_intMoldFlashDefectDimensionFailCondition == 0)
                                    {
                                        if (fWidthMM > m_fMoldFlashWidth)
                                        {
                                            blnResult = false;
                                            objDefect.ref_fWidthFailValue = fWidthMM;
                                            objDefect.ref_intFailCriteria |= 0x01;
                                        }

                                        if (fHeightMM > m_fMoldFlashLength)
                                        {
                                            blnResult = false;
                                            objDefect.ref_fHeightFailValue = fHeightMM;
                                            objDefect.ref_intFailCriteria |= 0x02;
                                        }
                                    }
                                    else
                                    {
                                        if (fWidthMM > m_fMoldFlashWidth && fHeightMM > m_fMoldFlashLength)
                                        {
                                            blnResult = false;
                                            objDefect.ref_fWidthFailValue = fWidthMM;
                                            objDefect.ref_fHeightFailValue = fHeightMM;
                                            objDefect.ref_intFailCriteria |= 0x01;
                                            objDefect.ref_intFailCriteria |= 0x02;
                                        }
                                    }
                                }
                                else if (i == 1 || i == 3)
                                {
                                    if (m_intMoldFlashDefectDimensionFailCondition == 0)
                                    {
                                        if (fWidthMM > m_fMoldFlashWidth)
                                        {
                                            blnResult = false;
                                            objDefect.ref_fWidthFailValue = fWidthMM;
                                            objDefect.ref_intFailCriteria |= 0x01;
                                        }

                                        if (fHeightMM > m_fMoldFlashLength)
                                        {
                                            blnResult = false;
                                            objDefect.ref_fHeightFailValue = fHeightMM;
                                            objDefect.ref_intFailCriteria |= 0x02;
                                        }
                                    }
                                    else
                                    {
                                        if (fWidthMM > m_fMoldFlashWidth && fHeightMM > m_fMoldFlashLength)
                                        {
                                            blnResult = false;
                                            objDefect.ref_fWidthFailValue = fWidthMM;
                                            objDefect.ref_fHeightFailValue = fHeightMM;
                                            objDefect.ref_intFailCriteria |= 0x01;
                                            objDefect.ref_intFailCriteria |= 0x02;
                                        }
                                    }
                                }
                            }

                            if ((m_intFailPkgOptionMask & 0x80) > 0)
                            {
                                if (fAreaInMM > m_fMoldFlashArea)
                                {
                                    blnResult = false;
                                    objDefect.ref_fAreaFailValue = fAreaInMM;
                                    objDefect.ref_intFailCriteria |= 0x04;
                                }
                            }

                            m_arrPkgDefectList.Add(objDefect);

                            //if (blnResult)
                            //    blnResult = false;
                        }
                    }


                    fAreaInMM = intTotalArea / m_fMMToPixelXValue / m_fMMToPixelYValue;

                    if (((m_intFailPkgOptionMask & 0x80) > 0) && fAreaInMM > m_fMoldFlashTotalArea)
                    {
                        Defect objDefect = new Defect();

                        objDefect.ref_strName = strPosition + " Total Mold Flash";
                        objDefect.ref_intFailMask = 0x80;
                        objDefect.ref_fCenterX = -1;
                        objDefect.ref_fCenterY = -1;
                        objDefect.ref_fStartX = -1;
                        objDefect.ref_fStartY = -1;
                        objDefect.ref_fEndX = -1;
                        objDefect.ref_fEndY = -1;
                        objDefect.ref_fWidth = -1;
                        objDefect.ref_fHeight = -1;
                        objDefect.ref_fArea = intTotalArea;
                        objDefect.ref_fWidthInMM = -1;
                        objDefect.ref_fHeightInMM = -1;
                        objDefect.ref_fAreaInMM2 = fAreaInMM;
                        objDefect.ref_intImageNo = m_intPadPkgMoldFlashImageViewNo + 1; //2020-01-09 ZJYEOH : Should not fixed to 1

                        blnResult = false;
                        objDefect.ref_fAreaFailValue = fAreaInMM;
                        objDefect.ref_intFailCriteria |= 0x08;

                        m_arrPkgDefectList.Add(objDefect);

                        Defect objDefect2 = new Defect();
                        for (int a = 0; a < m_arrPkgDefectList.Count; a++)
                        {
                            objDefect2 = m_arrPkgDefectList[a];
                            if (objDefect2.ref_strName.Contains(strPosition + " Mold Flash"))
                            {
                                objDefect2.ref_blnFailTotalArea = true;
                                m_arrPkgDefectList[a] = objDefect2;
                            }
                        }

                        m_intFailPkgResultMask |= 0x80; // Fail image 1 surface total bright field

                    }
                }


            }

            objMoldFlashBorderROI.Dispose();
            return blnResult;
        }

        private bool CheckImageMoldFlashDefect_Area_TiltAngle(ROI objImage1UnitROI, ROI objMoldFlashROI, int intPadIndex)
        {
            if (((m_intFailPkgOptionMask & 0x80) == 0) && ((m_intFailPkgOptionMask & 0x1000000) == 0))
                return true;

            //if (m_fMoldFlashArea == 0)
            //    return true;

            bool blnResult = true;
            int intTotalStartX = objMoldFlashROI.ref_ROITotalX, intTotalStartY = objMoldFlashROI.ref_ROITotalY;

            int intToleranceWidth = (objMoldFlashROI.ref_ROIWidth - objImage1UnitROI.ref_ROIWidth) / 2;
            int intToleranceHeight = (objMoldFlashROI.ref_ROIHeight - objImage1UnitROI.ref_ROIHeight) / 2;


            bool blnDebugImage = false;
            if (blnDebugImage)
                objMoldFlashROI.SaveImage("D:\\TS\\1_objMoldFlashROI.bmp");// debug   
            objMoldFlashROI.LoadROISetting(objImage1UnitROI.ref_ROITotalX - (int)m_fMoldStartPixelInnerFromLeft,
                                           objImage1UnitROI.ref_ROITotalY - (int)m_fMoldStartPixelInnerFromEdge,
                                           objImage1UnitROI.ref_ROIWidth + (int)(m_fMoldStartPixelInnerFromLeft + m_fMoldStartPixelInnerFromRight),
                                           objImage1UnitROI.ref_ROIHeight + (int)(m_fMoldStartPixelInnerFromEdge + m_fMoldStartPixelInnerFromBottom));
            if (blnDebugImage)
                objMoldFlashROI.SaveImage("D:\\TS\\2_objMoldFlashROI.bmp");// debug   

            //2019-09-23 ZJYEOH : Subtract tilt dont care area 
            if (intPadIndex == 0) // Center
            {
                ROI PkgROI = new ROI();
                ROI MoldPkgROI = new ROI();
                ImageDrawing PkgImg = new ImageDrawing(objImage1UnitROI.ref_ROIWidth, objImage1UnitROI.ref_ROIHeight);

                objImage1UnitROI.CopyToImage(ref PkgImg);
                PkgROI.LoadROISetting(0, 0, objImage1UnitROI.ref_ROIWidth, objImage1UnitROI.ref_ROIHeight);
                PkgROI.AttachImage(PkgImg);

                MoldPkgROI.LoadROISetting(intToleranceWidth, intToleranceHeight, PkgROI.ref_ROIWidth, PkgROI.ref_ROIHeight);
                MoldPkgROI.AttachImage(objMoldFlashROI);

                EasyImage.Oper(EArithmeticLogicOperation.Subtract, MoldPkgROI.ref_ROI, PkgROI.ref_ROI, MoldPkgROI.ref_ROI);
                //objMoldFlashROI.SaveImage("D:\\CheckImageMoldFlashDefect_Area_PkgROICenter.bmp");

                MoldPkgROI.Dispose();
                PkgImg.Dispose();
                PkgROI.Dispose();

            }
            else if (intPadIndex == 1) // Top
            {
                ROI PkgROI = new ROI();
                ROI MoldPkgROI = new ROI();
                ROI MoldBorderROI = new ROI();
                ImageDrawing PkgImg = new ImageDrawing(objMoldFlashROI.ref_ROIWidth, objMoldFlashROI.ref_ROIHeight);
                ImageDrawing DontCareImg = new ImageDrawing(objMoldFlashROI.ref_ROIWidth, objMoldFlashROI.ref_ROIHeight);
                ROI DontCareTop1 = new ROI();
                ROI DontCareTop2 = new ROI();
                ROI DontCareTop3 = new ROI();

                objMoldFlashROI.CopyToImage(ref PkgImg);
                DontCareTop3.LoadROISetting(0, 0, objMoldFlashROI.ref_ROIWidth, objMoldFlashROI.ref_ROIHeight);
                DontCareTop3.AttachImage(DontCareImg);
                PkgROI.LoadROISetting(0, 0, objMoldFlashROI.ref_ROIWidth, objMoldFlashROI.ref_ROIHeight);
                //PkgROI.AttachImage(objImage1UnitROI);
                PkgROI.AttachImage(PkgImg);
                DontCareTop1.LoadROISetting(0, 0, objMoldFlashROI.ref_ROIWidth, objMoldFlashROI.ref_ROIHeight);
                DontCareTop1.AttachImage(m_ImgTilt_Top_L);

                DontCareTop2.LoadROISetting(m_ImgTilt_Top_R.ref_intImageWidth - objMoldFlashROI.ref_ROIWidth, 0, objMoldFlashROI.ref_ROIWidth, objMoldFlashROI.ref_ROIHeight);
                DontCareTop2.AttachImage(m_ImgTilt_Top_R);

                //DontCareTop1.SaveImage("D:\\DontCareTop1.bmp");
                //DontCareTop2.SaveImage("D:\\DontCareTop2.bmp");
                EasyImage.Oper(EArithmeticLogicOperation.LogicalOr, DontCareTop1.ref_ROI, DontCareTop2.ref_ROI, DontCareTop3.ref_ROI);
                //DontCareTop3.SaveImage("D:\\DontCareTop3.bmp");

                EasyImage.Oper(EArithmeticLogicOperation.Subtract, PkgROI.ref_ROI, DontCareTop3.ref_ROI, PkgROI.ref_ROI);
                //PkgROI.SaveImage("D:\\CheckImageMoldFlashDefect_Area_PkgROITop1.bmp");

                MoldPkgROI.LoadROISetting(0, 0, PkgROI.ref_ROIWidth, PkgROI.ref_ROIHeight);
                MoldPkgROI.AttachImage(objMoldFlashROI);
                //MoldPkgROI.SaveImage("D:\\MoldPkgROI.bmp");
                EasyImage.Oper(EArithmeticLogicOperation.Subtract, MoldPkgROI.ref_ROI, PkgROI.ref_ROI, MoldPkgROI.ref_ROI);
                //objMoldFlashROI.SaveImage("D:\\CheckImageMoldFlashDefect_Area_PkgROITop2.bmp");

                objMoldFlashROI.LoadROISetting(objImage1UnitROI.ref_ROITotalX - (int)m_fMoldStartPixelFromLeft,
                                           objImage1UnitROI.ref_ROITotalY - (int)m_fMoldStartPixelFromEdge,
                                           objImage1UnitROI.ref_ROIWidth + (int)(m_fMoldStartPixelFromLeft + m_fMoldStartPixelFromRight),
                                           objImage1UnitROI.ref_ROIHeight + (int)(m_fMoldStartPixelFromEdge + m_fMoldStartPixelFromBottom));

                objMoldFlashROI.CopyToImage(ref PkgImg);
                DontCareImg.SetImageSize(objMoldFlashROI.ref_ROIWidth, objMoldFlashROI.ref_ROIHeight);
                DontCareTop3.LoadROISetting(0, 0, objMoldFlashROI.ref_ROIWidth, objMoldFlashROI.ref_ROIHeight);

                DontCareTop3.AttachImage(DontCareImg);
                PkgROI.LoadROISetting(0, 0, objMoldFlashROI.ref_ROIWidth, objMoldFlashROI.ref_ROIHeight);
                PkgROI.AttachImage(PkgImg);

                DontCareTop1.LoadROISetting(0, 0, objMoldFlashROI.ref_ROIWidth, objMoldFlashROI.ref_ROIHeight);
                DontCareTop1.AttachImage(m_ImgTilt_Top_L);

                DontCareTop2.LoadROISetting(m_ImgTilt_Top_R.ref_intImageWidth - objMoldFlashROI.ref_ROIWidth, 0, objMoldFlashROI.ref_ROIWidth, objMoldFlashROI.ref_ROIHeight);
                DontCareTop2.AttachImage(m_ImgTilt_Top_R);

                //DontCareTop1.SaveImage("D:\\DontCareTop11.bmp");
                //DontCareTop2.SaveImage("D:\\DontCareTop12.bmp");
                EasyImage.Oper(EArithmeticLogicOperation.LogicalOr, DontCareTop1.ref_ROI, DontCareTop2.ref_ROI, DontCareTop3.ref_ROI);
                //DontCareTop3.SaveImage("D:\\DontCareTop13.bmp");

                EasyImage.Oper(EArithmeticLogicOperation.Subtract, PkgROI.ref_ROI, DontCareTop3.ref_ROI, PkgROI.ref_ROI);
                //PkgROI.SaveImage("D:\\CheckImageMoldFlashDefect_Area_PkgROITop11.bmp");

                //MoldPkgROI.LoadROISetting(0, intToleranceHeight + PkgROI.ref_ROIHeight, objMoldFlashROI.ref_ROIWidth, intToleranceHeight);
                //MoldBorderROI.LoadROISetting(0, intToleranceHeight + PkgROI.ref_ROIHeight, objMoldFlashROI.ref_ROIWidth, intToleranceHeight);
                //MoldBorderROI.AttachImage(objMoldFlashROI);
                //EasyImage.Oper(EArithmeticLogicOperation.Subtract, MoldPkgROI.ref_ROI, MoldBorderROI.ref_ROI, MoldPkgROI.ref_ROI);
                //objMoldFlashROI.SaveImage("D:\\CheckImageMoldFlashDefect_Area_PkgROITop3.bmp");

                DontCareTop1.Dispose();
                DontCareTop2.Dispose();
                DontCareTop3.Dispose();
                MoldPkgROI.Dispose();
                MoldBorderROI.Dispose();
                PkgImg.Dispose();
                PkgROI.Dispose();
                DontCareImg.Dispose();
            }
            else if (intPadIndex == 2) // Right
            {
                ROI PkgROI = new ROI();
                ROI MoldPkgROI = new ROI();
                ROI MoldBorderROI = new ROI();
                ImageDrawing PkgImg = new ImageDrawing(objMoldFlashROI.ref_ROIWidth, objMoldFlashROI.ref_ROIHeight);
                ImageDrawing DontCareImg = new ImageDrawing(objMoldFlashROI.ref_ROIWidth, objMoldFlashROI.ref_ROIHeight);
                ROI DontCareRight1 = new ROI();
                ROI DontCareRight2 = new ROI();
                ROI DontCareRight3 = new ROI();

                objMoldFlashROI.CopyToImage(ref PkgImg);
                DontCareRight3.LoadROISetting(0, 0, objMoldFlashROI.ref_ROIWidth, objMoldFlashROI.ref_ROIHeight);
                DontCareRight3.AttachImage(DontCareImg);
                PkgROI.LoadROISetting(0, 0, objMoldFlashROI.ref_ROIWidth, objMoldFlashROI.ref_ROIHeight);
                //PkgROI.AttachImage(objImage1UnitROI);
                PkgROI.AttachImage(PkgImg);
                DontCareRight1.LoadROISetting(m_ImgTilt_Right_T.ref_intImageWidth - objMoldFlashROI.ref_ROIWidth, 0, objMoldFlashROI.ref_ROIWidth, objMoldFlashROI.ref_ROIHeight);
                DontCareRight1.AttachImage(m_ImgTilt_Right_T);

                DontCareRight2.LoadROISetting(m_ImgTilt_Right_B.ref_intImageWidth - objMoldFlashROI.ref_ROIWidth, m_ImgTilt_Right_B.ref_intImageHeight - objMoldFlashROI.ref_ROIHeight, objMoldFlashROI.ref_ROIWidth, objMoldFlashROI.ref_ROIHeight);
                DontCareRight2.AttachImage(m_ImgTilt_Right_B);

                //DontCareRight1.SaveImage("D:\\DontCareRight1.bmp");
                //DontCareRight2.SaveImage("D:\\DontCareRight2.bmp");
                EasyImage.Oper(EArithmeticLogicOperation.LogicalOr, DontCareRight1.ref_ROI, DontCareRight2.ref_ROI, DontCareRight3.ref_ROI);
                //DontCareRight3.SaveImage("D:\\DontCareRight3.bmp");

                EasyImage.Oper(EArithmeticLogicOperation.Subtract, PkgROI.ref_ROI, DontCareRight3.ref_ROI, PkgROI.ref_ROI);
                //PkgROI.SaveImage("D:\\CheckImageMoldFlashDefect_Area_PkgROIRight1.bmp");
                MoldPkgROI.LoadROISetting(0, 0, PkgROI.ref_ROIWidth, PkgROI.ref_ROIHeight);
                MoldPkgROI.AttachImage(objMoldFlashROI);

                EasyImage.Oper(EArithmeticLogicOperation.Subtract, MoldPkgROI.ref_ROI, PkgROI.ref_ROI, MoldPkgROI.ref_ROI);
                //objMoldFlashROI.SaveImage("D:\\CheckImageMoldFlashDefect_Area_PkgROIRight2.bmp");

                objMoldFlashROI.LoadROISetting(objImage1UnitROI.ref_ROITotalX - (int)m_fMoldStartPixelFromLeft,
                                           objImage1UnitROI.ref_ROITotalY - (int)m_fMoldStartPixelFromEdge,
                                           objImage1UnitROI.ref_ROIWidth + (int)(m_fMoldStartPixelFromLeft + m_fMoldStartPixelFromRight),
                                           objImage1UnitROI.ref_ROIHeight + (int)(m_fMoldStartPixelFromEdge + m_fMoldStartPixelFromBottom));

                objMoldFlashROI.CopyToImage(ref PkgImg);
                DontCareImg.SetImageSize(objMoldFlashROI.ref_ROIWidth, objMoldFlashROI.ref_ROIHeight);
                DontCareRight3.LoadROISetting(0, 0, objMoldFlashROI.ref_ROIWidth, objMoldFlashROI.ref_ROIHeight);
                DontCareRight3.AttachImage(DontCareImg);
                PkgROI.LoadROISetting(0, 0, objMoldFlashROI.ref_ROIWidth, objMoldFlashROI.ref_ROIHeight);
                //PkgROI.AttachImage(objImage1UnitROI);
                PkgROI.AttachImage(PkgImg);
                DontCareRight1.LoadROISetting(m_ImgTilt_Right_T.ref_intImageWidth - objMoldFlashROI.ref_ROIWidth, 0, objMoldFlashROI.ref_ROIWidth, objMoldFlashROI.ref_ROIHeight);
                DontCareRight1.AttachImage(m_ImgTilt_Right_T);

                DontCareRight2.LoadROISetting(m_ImgTilt_Right_B.ref_intImageWidth - objMoldFlashROI.ref_ROIWidth, m_ImgTilt_Right_B.ref_intImageHeight - objMoldFlashROI.ref_ROIHeight, objMoldFlashROI.ref_ROIWidth, objMoldFlashROI.ref_ROIHeight);
                DontCareRight2.AttachImage(m_ImgTilt_Right_B);

                //DontCareRight1.SaveImage("D:\\DontCareRight11.bmp");
                //DontCareRight2.SaveImage("D:\\DontCareRight12.bmp");
                EasyImage.Oper(EArithmeticLogicOperation.LogicalOr, DontCareRight1.ref_ROI, DontCareRight2.ref_ROI, DontCareRight3.ref_ROI);
                //DontCareRight3.SaveImage("D:\\DontCareRight13.bmp");

                EasyImage.Oper(EArithmeticLogicOperation.Subtract, PkgROI.ref_ROI, DontCareRight3.ref_ROI, PkgROI.ref_ROI);
                //PkgROI.SaveImage("D:\\CheckImageMoldFlashDefect_Area_PkgROIRight11.bmp");

                //MoldPkgROI.LoadROISetting(0, 0, intToleranceWidth, objMoldFlashROI.ref_ROIHeight);
                //MoldBorderROI.LoadROISetting(0, 0, intToleranceWidth, objMoldFlashROI.ref_ROIHeight);
                //MoldBorderROI.AttachImage(objMoldFlashROI);
                //EasyImage.Oper(EArithmeticLogicOperation.Subtract, MoldPkgROI.ref_ROI, MoldBorderROI.ref_ROI, MoldPkgROI.ref_ROI);
                ////objMoldFlashROI.SaveImage("D:\\CheckImageMoldFlashDefect_Area_PkgROIRight3.bmp");

                DontCareRight1.Dispose();
                DontCareRight2.Dispose();
                DontCareRight3.Dispose();
                MoldPkgROI.Dispose();
                MoldBorderROI.Dispose();
                PkgImg.Dispose();
                PkgROI.Dispose();
                DontCareImg.Dispose();
            }
            else if (intPadIndex == 3) // Bottom
            {
                ROI PkgROI = new ROI();
                ROI MoldPkgROI = new ROI();
                ROI MoldBorderROI = new ROI();
                ImageDrawing PkgImg = new ImageDrawing(objMoldFlashROI.ref_ROIWidth, objMoldFlashROI.ref_ROIHeight);
                ImageDrawing DontCareImg = new ImageDrawing(objMoldFlashROI.ref_ROIWidth, objMoldFlashROI.ref_ROIHeight);
                ROI DontCareBottom1 = new ROI();
                ROI DontCareBottom2 = new ROI();
                ROI DontCareBottom3 = new ROI();

                objMoldFlashROI.CopyToImage(ref PkgImg);
                DontCareBottom3.LoadROISetting(0, 0, objMoldFlashROI.ref_ROIWidth, objMoldFlashROI.ref_ROIHeight);
                DontCareBottom3.AttachImage(DontCareImg);
                PkgROI.LoadROISetting(0, 0, objMoldFlashROI.ref_ROIWidth, objMoldFlashROI.ref_ROIHeight);
                //PkgROI.AttachImage(objImage1UnitROI);
                PkgROI.AttachImage(PkgImg);
                DontCareBottom1.LoadROISetting(0, m_ImgTilt_Bottom_L.ref_intImageHeight - objMoldFlashROI.ref_ROIHeight, objMoldFlashROI.ref_ROIWidth, objMoldFlashROI.ref_ROIHeight);
                DontCareBottom1.AttachImage(m_ImgTilt_Bottom_L);

                DontCareBottom2.LoadROISetting(m_ImgTilt_Bottom_R.ref_intImageWidth - objMoldFlashROI.ref_ROIWidth, m_ImgTilt_Bottom_R.ref_intImageHeight - objMoldFlashROI.ref_ROIHeight, objMoldFlashROI.ref_ROIWidth, objMoldFlashROI.ref_ROIHeight);
                DontCareBottom2.AttachImage(m_ImgTilt_Bottom_R);

                //DontCareBottom1.SaveImage("D:\\DontCareBottom1.bmp");
                //DontCareBottom2.SaveImage("D:\\DontCareBottom2.bmp");
                EasyImage.Oper(EArithmeticLogicOperation.LogicalOr, DontCareBottom1.ref_ROI, DontCareBottom2.ref_ROI, DontCareBottom3.ref_ROI);
                //DontCareBottom3.SaveImage("D:\\DontCareBottom3.bmp");

                EasyImage.Oper(EArithmeticLogicOperation.Subtract, PkgROI.ref_ROI, DontCareBottom3.ref_ROI, PkgROI.ref_ROI);
                //PkgROI.SaveImage("D:\\CheckImageMoldFlashDefect_Area_PkgROIBottom1.bmp");
                MoldPkgROI.LoadROISetting(0, 0, PkgROI.ref_ROIWidth, PkgROI.ref_ROIHeight);
                MoldPkgROI.AttachImage(objMoldFlashROI);

                EasyImage.Oper(EArithmeticLogicOperation.Subtract, MoldPkgROI.ref_ROI, PkgROI.ref_ROI, MoldPkgROI.ref_ROI);
                //objMoldFlashROI.SaveImage("D:\\CheckImageMoldFlashDefect_Area_PkgROIBottom2.bmp");

                objMoldFlashROI.LoadROISetting(objImage1UnitROI.ref_ROITotalX - (int)m_fMoldStartPixelFromLeft,
                                           objImage1UnitROI.ref_ROITotalY - (int)m_fMoldStartPixelFromEdge,
                                           objImage1UnitROI.ref_ROIWidth + (int)(m_fMoldStartPixelFromLeft + m_fMoldStartPixelFromRight),
                                           objImage1UnitROI.ref_ROIHeight + (int)(m_fMoldStartPixelFromEdge + m_fMoldStartPixelFromBottom));

                objMoldFlashROI.CopyToImage(ref PkgImg);
                DontCareImg.SetImageSize(objMoldFlashROI.ref_ROIWidth, objMoldFlashROI.ref_ROIHeight);
                DontCareBottom3.LoadROISetting(0, 0, objMoldFlashROI.ref_ROIWidth, objMoldFlashROI.ref_ROIHeight);
                DontCareBottom3.AttachImage(DontCareImg);
                PkgROI.LoadROISetting(0, 0, objMoldFlashROI.ref_ROIWidth, objMoldFlashROI.ref_ROIHeight);
                //PkgROI.AttachImage(objImage1UnitROI);
                PkgROI.AttachImage(PkgImg);
                DontCareBottom1.LoadROISetting(0, m_ImgTilt_Bottom_L.ref_intImageHeight - objMoldFlashROI.ref_ROIHeight, objMoldFlashROI.ref_ROIWidth, objMoldFlashROI.ref_ROIHeight);
                DontCareBottom1.AttachImage(m_ImgTilt_Bottom_L);

                DontCareBottom2.LoadROISetting(m_ImgTilt_Bottom_R.ref_intImageWidth - objMoldFlashROI.ref_ROIWidth, m_ImgTilt_Bottom_R.ref_intImageHeight - objMoldFlashROI.ref_ROIHeight, objMoldFlashROI.ref_ROIWidth, objMoldFlashROI.ref_ROIHeight);
                DontCareBottom2.AttachImage(m_ImgTilt_Bottom_R);

                //DontCareBottom1.SaveImage("D:\\DontCareBottom11.bmp");
                //DontCareBottom2.SaveImage("D:\\DontCareBottom12.bmp");
                EasyImage.Oper(EArithmeticLogicOperation.LogicalOr, DontCareBottom1.ref_ROI, DontCareBottom2.ref_ROI, DontCareBottom3.ref_ROI);
                //DontCareBottom3.SaveImage("D:\\DontCareBottom13.bmp");

                EasyImage.Oper(EArithmeticLogicOperation.Subtract, PkgROI.ref_ROI, DontCareBottom3.ref_ROI, PkgROI.ref_ROI);
                //PkgROI.SaveImage("D:\\CheckImageMoldFlashDefect_Area_PkgROIBottom11.bmp");

                //MoldPkgROI.LoadROISetting(0, 0, objMoldFlashROI.ref_ROIWidth, intToleranceHeight);
                //MoldBorderROI.LoadROISetting(0, 0, objMoldFlashROI.ref_ROIWidth, intToleranceHeight);
                //MoldBorderROI.AttachImage(objMoldFlashROI);
                //EasyImage.Oper(EArithmeticLogicOperation.Subtract, MoldPkgROI.ref_ROI, MoldBorderROI.ref_ROI, MoldPkgROI.ref_ROI);
                ////objMoldFlashROI.SaveImage("D:\\CheckImageMoldFlashDefect_Area_PkgROIBottom3.bmp");

                DontCareBottom1.Dispose();
                DontCareBottom2.Dispose();
                DontCareBottom3.Dispose();
                MoldPkgROI.Dispose();
                MoldBorderROI.Dispose();
                PkgImg.Dispose();
                PkgROI.Dispose();
                DontCareImg.Dispose();
            }
            else if (intPadIndex == 4) // Left
            {
                ROI PkgROI = new ROI();
                ROI MoldPkgROI = new ROI();
                ROI MoldBorderROI = new ROI();
                ImageDrawing PkgImg = new ImageDrawing(objMoldFlashROI.ref_ROIWidth, objMoldFlashROI.ref_ROIHeight);
                ImageDrawing DontCareImg = new ImageDrawing(objMoldFlashROI.ref_ROIWidth, objMoldFlashROI.ref_ROIHeight);
                ROI DontCareLeft1 = new ROI();
                ROI DontCareLeft2 = new ROI();
                ROI DontCareLeft3 = new ROI();

                objMoldFlashROI.CopyToImage(ref PkgImg);
                DontCareLeft3.LoadROISetting(0, 0, objMoldFlashROI.ref_ROIWidth, objMoldFlashROI.ref_ROIHeight);
                DontCareLeft3.AttachImage(DontCareImg);
                PkgROI.LoadROISetting(0, 0, objMoldFlashROI.ref_ROIWidth, objMoldFlashROI.ref_ROIHeight);
                //PkgROI.AttachImage(objImage1UnitROI);
                PkgROI.AttachImage(PkgImg);
                DontCareLeft1.LoadROISetting(0, 0, objMoldFlashROI.ref_ROIWidth, objMoldFlashROI.ref_ROIHeight);
                DontCareLeft1.AttachImage(m_ImgTilt_Left_T);

                DontCareLeft2.LoadROISetting(0, m_ImgTilt_Left_B.ref_intImageHeight - objMoldFlashROI.ref_ROIHeight, objMoldFlashROI.ref_ROIWidth, objMoldFlashROI.ref_ROIHeight);
                DontCareLeft2.AttachImage(m_ImgTilt_Left_B);

                //DontCareLeft1.SaveImage("D:\\DontCareLeft1.bmp");
                //DontCareLeft2.SaveImage("D:\\DontCareLeft2.bmp");
                EasyImage.Oper(EArithmeticLogicOperation.LogicalOr, DontCareLeft1.ref_ROI, DontCareLeft2.ref_ROI, DontCareLeft3.ref_ROI);
                //DontCareLeft3.SaveImage("D:\\DontCareLeft3.bmp");

                EasyImage.Oper(EArithmeticLogicOperation.Subtract, PkgROI.ref_ROI, DontCareLeft3.ref_ROI, PkgROI.ref_ROI);
                //PkgROI.SaveImage("D:\\CheckImageMoldFlashDefect_Area_PkgROILeft1.bmp");

                MoldPkgROI.LoadROISetting(0, 0, PkgROI.ref_ROIWidth, PkgROI.ref_ROIHeight);
                MoldPkgROI.AttachImage(objMoldFlashROI);

                EasyImage.Oper(EArithmeticLogicOperation.Subtract, MoldPkgROI.ref_ROI, PkgROI.ref_ROI, MoldPkgROI.ref_ROI);
                //objMoldFlashROI.SaveImage("D:\\CheckImageMoldFlashDefect_Area_PkgROIBottom2.bmp");


                objMoldFlashROI.LoadROISetting(objImage1UnitROI.ref_ROITotalX - (int)m_fMoldStartPixelFromLeft,
                                           objImage1UnitROI.ref_ROITotalY - (int)m_fMoldStartPixelFromEdge,
                                           objImage1UnitROI.ref_ROIWidth + (int)(m_fMoldStartPixelFromLeft + m_fMoldStartPixelFromRight),
                                           objImage1UnitROI.ref_ROIHeight + (int)(m_fMoldStartPixelFromEdge + m_fMoldStartPixelFromBottom));

                objMoldFlashROI.CopyToImage(ref PkgImg);
                DontCareImg.SetImageSize(objMoldFlashROI.ref_ROIWidth, objMoldFlashROI.ref_ROIHeight);
                DontCareLeft3.LoadROISetting(0, 0, objMoldFlashROI.ref_ROIWidth, objMoldFlashROI.ref_ROIHeight);
                DontCareLeft3.AttachImage(DontCareImg);
                PkgROI.LoadROISetting(0, 0, objMoldFlashROI.ref_ROIWidth, objMoldFlashROI.ref_ROIHeight);
                //PkgROI.AttachImage(objImage1UnitROI);
                PkgROI.AttachImage(PkgImg);
                DontCareLeft1.LoadROISetting(0, 0, objMoldFlashROI.ref_ROIWidth, objMoldFlashROI.ref_ROIHeight);
                DontCareLeft1.AttachImage(m_ImgTilt_Left_T);

                DontCareLeft2.LoadROISetting(0, m_ImgTilt_Left_B.ref_intImageHeight - objMoldFlashROI.ref_ROIHeight, objMoldFlashROI.ref_ROIWidth, objMoldFlashROI.ref_ROIHeight);
                DontCareLeft2.AttachImage(m_ImgTilt_Left_B);

                //DontCareLeft1.SaveImage("D:\\DontCareLeft11.bmp");
                //DontCareLeft2.SaveImage("D:\\DontCareLeft12.bmp");
                EasyImage.Oper(EArithmeticLogicOperation.LogicalOr, DontCareLeft1.ref_ROI, DontCareLeft2.ref_ROI, DontCareLeft3.ref_ROI);
                //DontCareLeft3.SaveImage("D:\\DontCareLeft13.bmp");

                EasyImage.Oper(EArithmeticLogicOperation.Subtract, PkgROI.ref_ROI, DontCareLeft3.ref_ROI, PkgROI.ref_ROI);
                //PkgROI.SaveImage("D:\\CheckImageMoldFlashDefect_Area_PkgROILeft11.bmp");

                //EasyImage.Oper(EArithmeticLogicOperation.Subtract, MoldPkgROI.ref_ROI, PkgROI.ref_ROI, MoldPkgROI.ref_ROI);
                ////objMoldFlashROI.SaveImage("D:\\CheckImageMoldFlashDefect_Area_PkgROILeft2.bmp");

                //MoldPkgROI.LoadROISetting(intToleranceWidth + PkgROI.ref_ROIWidth, 0, intToleranceWidth, objMoldFlashROI.ref_ROIHeight);
                //MoldBorderROI.LoadROISetting(intToleranceWidth + PkgROI.ref_ROIWidth, 0, intToleranceWidth, objMoldFlashROI.ref_ROIHeight);
                //MoldBorderROI.AttachImage(objMoldFlashROI);
                //EasyImage.Oper(EArithmeticLogicOperation.Subtract, MoldPkgROI.ref_ROI, MoldBorderROI.ref_ROI, MoldPkgROI.ref_ROI);
                ////objMoldFlashROI.SaveImage("D:\\CheckImageMoldFlashDefect_Area_PkgROILeft3.bmp");

                DontCareLeft1.Dispose();
                DontCareLeft2.Dispose();
                DontCareLeft3.Dispose();
                MoldPkgROI.Dispose();
                MoldBorderROI.Dispose();
                PkgImg.Dispose();
                PkgROI.Dispose();
                DontCareImg.Dispose();
            }

            #region Subtract Template Pad ----------------------------------------------------------------------------------

            for (int i = 0; i < m_arrTemplateBlobPads.Count; i++)
            {
                if (blnDebugImage)
                    m_arrImgPadImage[i].Save("D:\\TS\\2_m_arrImgPadImage" + i.ToString() + ".bmp");// debug   
                ROI objROI = new ROI();
                ROI DilateROI = new ROI();
                ImageDrawing Img = new ImageDrawing();

                if (m_arrSampleBlobPads[i].intFailMask != 0)
                    continue;

                int intImageToleranceWidth = (int)Math.Round((m_arrImgPadImage[i].Width - objMoldFlashROI.ref_ROIWidth) / 2.0);
                int intImageToleranceHeight = (int)Math.Round((m_arrImgPadImage[i].Height - objMoldFlashROI.ref_ROIHeight) / 2.0);
                int intOffsetX = 0, intOffsetY = 0;
                if (intImageToleranceWidth < 0)
                {
                    intOffsetX = -intImageToleranceWidth;
                    intImageToleranceWidth = 0;
                }
                if (intImageToleranceHeight < 0)
                {
                    intOffsetY = -intImageToleranceHeight;
                    intImageToleranceHeight = 0;
                }

                if (!GetOverallWantGaugeMeasurePkgSize(false))
                {
                    intOffsetX += (int)Math.Round(GetResultCenterPoint_UnitMatcher().X - GetResultCenterPoint_RectGauge4L().X);
                    intOffsetY += (int)Math.Round(GetResultCenterPoint_UnitMatcher().Y - GetResultCenterPoint_RectGauge4L().Y);
                }

                Img.SetImageSize(m_arrImgPadImage[i].Width, m_arrImgPadImage[i].Height);
                Img.SetImageToBlack();
                objROI.ref_ROI.Attach(m_arrImgPadImage[i]);
                objROI.LoadROISetting(intImageToleranceWidth + intOffsetX, intImageToleranceHeight + intOffsetY, objMoldFlashROI.ref_ROIWidth - (intOffsetX * 2), objMoldFlashROI.ref_ROIHeight - (intOffsetY * 2));
                DilateROI.AttachImage(Img);
                DilateROI.LoadROISetting(intImageToleranceWidth + intOffsetX, intImageToleranceHeight + intOffsetY, objMoldFlashROI.ref_ROIWidth - (intOffsetX * 2), objMoldFlashROI.ref_ROIHeight - (intOffsetY * 2));

                EasyImage.Copy(objROI.ref_ROI, DilateROI.ref_ROI);
#if (Debug_2_12 || Release_2_12)
                EasyImage.DilateBox(DilateROI.ref_ROI, DilateROI.ref_ROI, (uint)Math.Abs(m_intMPDilateHalfWidth), (uint)Math.Abs(m_intMPDilateHalfWidth));
#elif (DEBUG || RELEASE || RTXRelease || RTXDebug)
                EasyImage.DilateBox(DilateROI.ref_ROI, DilateROI.ref_ROI, Math.Abs(m_intMPDilateHalfWidth), Math.Abs(m_intMPDilateHalfWidth));
#endif

                if (blnDebugImage)
                {
                    objROI.SaveImage("D:\\TS\\3.1_objROI.bmp");// debug  
                    DilateROI.SaveImage("D:\\TS\\3.2_DilateROI.bmp");// debug  
                }
                objROI.AttachImage(objMoldFlashROI);
                objROI.LoadROISetting_MustSameSize(DilateROI, intImageToleranceWidth + intOffsetX, intImageToleranceHeight + intOffsetY, objMoldFlashROI.ref_ROIWidth - (intOffsetX * 2), objMoldFlashROI.ref_ROIHeight - (intOffsetY * 2));
                if (blnDebugImage)
                {
                    objROI.SaveImage("D:\\TS\\3.3_objROI.bmp");// debug  
                }
                EasyImage.Oper(EArithmeticLogicOperation.Subtract, objROI.ref_ROI, DilateROI.ref_ROI, objROI.ref_ROI);
                if (blnDebugImage)
                {
                    m_arrImgPadImage[i].Save("D:\\TS\\4_m_arrImgPadImage" + i.ToString() + ".bmp");
                }
                objROI.Dispose();
                DilateROI.Dispose();
                Img.Dispose();
            }
            if (blnDebugImage)
            {
                objMoldFlashROI.SaveImage("D:\\TS\\5_objMoldFlashROI.bmp");// debug  
            }

            #endregion ------------------------------------------------------------------------------------------------

            //ROI objMoldFlashBorderROI = new ROI();
            //objMoldFlashBorderROI.AttachImage(objMoldFlashROI);

            //for (int i = 0; i < 4; i++)   // Create 4 direction ROI
            //{
            //    if (m_intPadROIDirection == 1 && i == 2)    // Top Side Pad 
            //        continue;
            //    else if (m_intPadROIDirection == 2 && i == 3) // Right Side Pad
            //        continue;
            //    else if (m_intPadROIDirection == 3 && i == 0) // Bottom Side Pad
            //        continue;
            //    else if (m_intPadROIDirection == 4 && i == 1) // Left Side Pad
            //        continue;

            //    switch (i)
            //    {
            //        case 0:  // Top Border
            //            if (m_intPadROIDirection == 2)
            //                objMoldFlashBorderROI.LoadROISetting(intToleranceWidth, 0, objMoldFlashROI.ref_ROIWidth - intToleranceWidth, intToleranceHeight);
            //            else if (m_intPadROIDirection == 4)
            //                objMoldFlashBorderROI.LoadROISetting(0, 0, objMoldFlashROI.ref_ROIWidth - intToleranceWidth, intToleranceHeight);
            //            else
            //                objMoldFlashBorderROI.LoadROISetting(0, 0, objMoldFlashROI.ref_ROIWidth, (int)m_fMoldStartPixelFromEdge);

            //            objMoldFlashBorderROI.SaveImage("D:\\TS\\" + m_intPadROIDirection.ToString() + "objMoldFlashBorderROITop.bmp");
            //            intTotalStartX = objMoldFlashROI.ref_ROITotalX;
            //            intTotalStartY = objMoldFlashROI.ref_ROITotalY;

            //            break;
            //        case 1: // Right Border
            //            if (m_intPadROIDirection == 1)
            //                objMoldFlashBorderROI.LoadROISetting(objMoldFlashROI.ref_ROIWidth - intToleranceWidth, 0, intToleranceWidth, objMoldFlashROI.ref_ROIHeight - intToleranceHeight);
            //            else if (m_intPadROIDirection == 3)
            //                objMoldFlashBorderROI.LoadROISetting(objMoldFlashROI.ref_ROIWidth - intToleranceWidth, intToleranceHeight, intToleranceWidth, objMoldFlashROI.ref_ROIHeight - intToleranceHeight);
            //            else
            //                objMoldFlashBorderROI.LoadROISetting(objMoldFlashROI.ref_ROIWidth - (int)m_fMoldStartPixelFromRight, 0, (int)m_fMoldStartPixelFromRight, objMoldFlashROI.ref_ROIHeight);
            //            intTotalStartX = objMoldFlashROI.ref_ROITotalX + objMoldFlashROI.ref_ROIWidth - (int)m_fMoldStartPixelFromRight;
            //            intTotalStartY = objMoldFlashROI.ref_ROITotalY;
            //            objMoldFlashBorderROI.SaveImage("D:\\TS\\" + m_intPadROIDirection.ToString() + "objMoldFlashBorderROIRight.bmp");

            //            break;
            //        case 2: // Bottom Border
            //            if (m_intPadROIDirection == 2)
            //                objMoldFlashBorderROI.LoadROISetting(intToleranceWidth, objMoldFlashROI.ref_ROIHeight - intToleranceHeight, objMoldFlashROI.ref_ROIWidth - intToleranceWidth, intToleranceHeight);
            //            else if (m_intPadROIDirection == 4)
            //                objMoldFlashBorderROI.LoadROISetting(0, objMoldFlashROI.ref_ROIHeight - intToleranceHeight, objMoldFlashROI.ref_ROIWidth - intToleranceWidth, intToleranceHeight);
            //            else
            //                objMoldFlashBorderROI.LoadROISetting(0, objMoldFlashROI.ref_ROIHeight - (int)m_fMoldStartPixelFromBottom, objMoldFlashROI.ref_ROIWidth, (int)m_fMoldStartPixelFromBottom);
            //            intTotalStartX = objMoldFlashROI.ref_ROITotalX;
            //            intTotalStartY = objMoldFlashROI.ref_ROITotalY + objMoldFlashROI.ref_ROIHeight - (int)m_fMoldStartPixelFromBottom;
            //            objMoldFlashBorderROI.SaveImage("D:\\TS\\" + m_intPadROIDirection.ToString() + "objMoldFlashBorderROIBottom.bmp");

            //            break;
            //        case 3: // Left Border
            //            if (m_intPadROIDirection == 1)
            //                objMoldFlashBorderROI.LoadROISetting(0, 0, intToleranceWidth, objMoldFlashROI.ref_ROIHeight - intToleranceHeight);
            //            else if (m_intPadROIDirection == 3)
            //                objMoldFlashBorderROI.LoadROISetting(0, intToleranceHeight, intToleranceWidth, objMoldFlashROI.ref_ROIHeight - intToleranceHeight);
            //            else
            //                objMoldFlashBorderROI.LoadROISetting(0, 0, (int)m_fMoldStartPixelFromLeft, objMoldFlashROI.ref_ROIHeight);
            //            intTotalStartX = objMoldFlashROI.ref_ROITotalX;
            //            intTotalStartY = objMoldFlashROI.ref_ROITotalY;
            //            objMoldFlashBorderROI.SaveImage("D:\\TS\\" + m_intPadROIDirection.ToString() + "objMoldFlashBorderROILeft.bmp");

            //            break;
            //    }

            // Build blobs object for subtract image
            m_objImage1MoldFlashEBlobs.BuildObjects_Filter_GetElement(objMoldFlashROI, m_intMoldFlashDefectType == 1, true, 0, m_intPkgImage1MoldFlashThreshold, //2019-09-27 ZJYEOH : Direct inspect objMoldFlashROI, no need cut to objMoldFlashBorderROI
                (int)Math.Floor(m_fMoldFlashMinArea), 999999, false, 0x0F);
            if (blnDebugImage)
                objMoldFlashROI.SaveImage("D:\\TS\\objMoldFlashROI" + intPadIndex + ".bmp");
            if (m_objImage1MoldFlashEBlobs.ref_intNumSelectedObject > 0)
            {
                int intTotalArea = 0;
                float fCenterX = 0, fCenterY = 0, fWidth = 0, fHeight = 0;
                float fStartX = 0, fStartY = 0, fEndX = 0, fEndY = 0;
                int intArea = 0;
                float fWidthMM, fHeightMM, fAreaInMM;
                int intFailCount = 0;

                for (int x = 0; x < m_objImage1MoldFlashEBlobs.ref_intNumSelectedObject; x++)
                {
                    fCenterX = m_objImage1MoldFlashEBlobs.ref_arrLimitCenterX[x];
                    fCenterY = m_objImage1MoldFlashEBlobs.ref_arrLimitCenterY[x];
                    fWidth = m_objImage1MoldFlashEBlobs.ref_arrWidth[x];
                    fHeight = m_objImage1MoldFlashEBlobs.ref_arrHeight[x];
                    intArea = m_objImage1MoldFlashEBlobs.ref_arrArea[x];
                    fStartX = (float)Math.Floor(fCenterX - (fWidth / 2));
                    fStartY = (float)Math.Floor(fCenterY - (fHeight / 2));
                    fEndX = (float)Math.Ceiling(fCenterX + (fWidth / 2));
                    fEndY = (float)Math.Ceiling(fCenterY + (fHeight / 2));
                    intTotalArea += intArea;

                    fWidthMM = fWidth / m_fMMToPixelXValue;
                    fHeightMM = fHeight / m_fMMToPixelYValue;
                    fAreaInMM = intArea / m_fMMToPixelXValue / m_fMMToPixelYValue;

                    bool blnDefect = false;
                    bool blnFailWidth = false;

                    //bool blnLengthFail = false;
                    // Not need to check length, only area
                    //if (i == 0)
                    //{
                    //    if (fHeight >= m_fMoldStartPixelFromEdge)
                    //        blnLengthFail = true;
                    //}
                    //else if (i == 1)
                    //{
                    //    if (fWidth >= m_fMoldStartPixelFromRight)
                    //        blnLengthFail = true;
                    //}
                    //else if (i == 2)
                    //{
                    //    if (fHeight >= m_fMoldStartPixelFromBottom)
                    //        blnLengthFail = true;
                    //}
                    //else if (i == 3)
                    //{
                    //    if (fWidth >= m_fMoldStartPixelFromLeft)
                    //        blnLengthFail = true;
                    //}

                    //if (blnLengthFail && fAreaInMM >= m_fMoldFlashArea)
                    //if (fAreaInMM > m_fMoldFlashArea)  // 2019 07 21 - CCENG: Not need to check length anymore.
                    {
                        intFailCount++;
                        m_intFailPkgResultMask |= 0x80; // Fail Mold Flash

                        Defect objDefect = new Defect();

                        objDefect.ref_strName = "Mold Flash";
                        //objDefect.ref_intFailCriteria |= 0x04;
                        objDefect.ref_intFailMask |= 0x80;
                        objDefect.ref_fCenterX = intTotalStartX + fCenterX;
                        objDefect.ref_fCenterY = intTotalStartY + fCenterY;
                        objDefect.ref_fStartX = intTotalStartX + fStartX;
                        objDefect.ref_fStartY = intTotalStartY + fStartY;
                        objDefect.ref_fEndX = intTotalStartX + fEndX;
                        objDefect.ref_fEndY = intTotalStartY + fEndY;
                        objDefect.ref_fWidth = fWidth;
                        objDefect.ref_fHeight = fHeight;
                        objDefect.ref_fArea = intArea;
                        objDefect.ref_fWidthInMM = fWidthMM;
                        objDefect.ref_fHeightInMM = fHeightMM;
                        objDefect.ref_fAreaInMM2 = fAreaInMM;
                        objDefect.ref_intImageNo = m_intPadPkgMoldFlashImageViewNo + 1;
                        //objDefect.ref_fFailValue = fAreaInMM;

                        if ((m_intFailPkgOptionMask & 0x1000000) > 0)
                        {
                            if (m_intMoldFlashDefectDimensionFailCondition == 0)
                            {
                                if (fWidthMM > m_fMoldFlashWidth)
                                {
                                    blnResult = false;
                                    objDefect.ref_fWidthFailValue = fWidthMM;
                                    objDefect.ref_intFailCriteria |= 0x01;
                                }

                                if (fHeightMM > m_fMoldFlashLength)
                                {
                                    blnResult = false;
                                    objDefect.ref_fHeightFailValue = fHeightMM;
                                    objDefect.ref_intFailCriteria |= 0x02;
                                }
                            }
                            else
                            {
                                if (fWidthMM > m_fMoldFlashWidth && fHeightMM > m_fMoldFlashLength)
                                {
                                    blnResult = false;
                                    objDefect.ref_fWidthFailValue = fWidthMM;
                                    objDefect.ref_fHeightFailValue = fHeightMM;
                                    objDefect.ref_intFailCriteria |= 0x01;
                                    objDefect.ref_intFailCriteria |= 0x02;
                                }
                            }
                        }

                        if ((m_intFailPkgOptionMask & 0x80) > 0)
                        {
                            if (fAreaInMM > m_fMoldFlashArea)
                            {
                                blnResult = false;
                                objDefect.ref_fAreaFailValue = fAreaInMM;
                                objDefect.ref_intFailCriteria |= 0x04;
                            }
                        }

                        m_arrPkgDefectList.Add(objDefect);

                        //if (blnResult)
                        //    blnResult = false;
                    }
                }

                fAreaInMM = intTotalArea / m_fMMToPixelXValue / m_fMMToPixelYValue;

                if (((m_intFailPkgOptionMask & 0x80) > 0) && fAreaInMM > m_fMoldFlashTotalArea)
                {
                    Defect objDefect = new Defect();

                    objDefect.ref_strName = "Total Mold Flash";
                    objDefect.ref_intFailMask = 0x80;
                    objDefect.ref_fCenterX = -1;
                    objDefect.ref_fCenterY = -1;
                    objDefect.ref_fStartX = -1;
                    objDefect.ref_fStartY = -1;
                    objDefect.ref_fEndX = -1;
                    objDefect.ref_fEndY = -1;
                    objDefect.ref_fWidth = -1;
                    objDefect.ref_fHeight = -1;
                    objDefect.ref_fArea = intTotalArea;
                    objDefect.ref_fWidthInMM = -1;
                    objDefect.ref_fHeightInMM = -1;
                    objDefect.ref_fAreaInMM2 = fAreaInMM;
                    objDefect.ref_intImageNo = m_intPadPkgMoldFlashImageViewNo + 1; //2020-01-09 ZJYEOH : Should not fixed to 1

                    blnResult = false;
                    objDefect.ref_fAreaFailValue = fAreaInMM;
                    objDefect.ref_intFailCriteria |= 0x08;

                    m_arrPkgDefectList.Add(objDefect);

                    Defect objDefect2 = new Defect();
                    for (int a = 0; a < m_arrPkgDefectList.Count; a++)
                    {
                        objDefect2 = m_arrPkgDefectList[a];
                        if (objDefect2.ref_strName.Contains("Mold Flash"))
                        {
                            objDefect2.ref_blnFailTotalArea = true;
                            m_arrPkgDefectList[a] = objDefect2;
                        }
                    }

                    m_intFailPkgResultMask |= 0x80; // Fail image 1 surface total bright field

                }
            }

            //}

            //objMoldFlashBorderROI.Dispose();
            return blnResult;
        }
        private bool CheckImageMoldFlashDefect_Area_TiltAngle_WithLinkFunction(ROI objImage1UnitROI, ROI objMoldFlashROI, int intPadIndex)
        {
            if (((m_intFailPkgOptionMask & 0x80) == 0) && ((m_intFailPkgOptionMask & 0x1000000) == 0))
                return true;

            //if (m_fMoldFlashArea == 0)
            //    return true;

            bool blnResult = true;
            int intTotalStartX = objMoldFlashROI.ref_ROITotalX, intTotalStartY = objMoldFlashROI.ref_ROITotalY;

            int intToleranceWidth = (objMoldFlashROI.ref_ROIWidth - objImage1UnitROI.ref_ROIWidth) / 2;
            int intToleranceHeight = (objMoldFlashROI.ref_ROIHeight - objImage1UnitROI.ref_ROIHeight) / 2;


            bool blnDebugImage = false;
            if (blnDebugImage)
                objMoldFlashROI.SaveImage("D:\\TS\\1_objMoldFlashROI.bmp");// debug   
            objMoldFlashROI.LoadROISetting(objImage1UnitROI.ref_ROITotalX - (int)m_fMoldStartPixelInnerFromLeft,
                                           objImage1UnitROI.ref_ROITotalY - (int)m_fMoldStartPixelInnerFromEdge,
                                           objImage1UnitROI.ref_ROIWidth + (int)(m_fMoldStartPixelInnerFromLeft + m_fMoldStartPixelInnerFromRight),
                                           objImage1UnitROI.ref_ROIHeight + (int)(m_fMoldStartPixelInnerFromEdge + m_fMoldStartPixelInnerFromBottom));
            if (blnDebugImage)
                objMoldFlashROI.SaveImage("D:\\TS\\2_objMoldFlashROI.bmp");// debug   

            //2019-09-23 ZJYEOH : Subtract tilt dont care area 
            if (intPadIndex == 0) // Center
            {
                ROI PkgROI = new ROI();
                ROI MoldPkgROI = new ROI();
                ImageDrawing PkgImg = new ImageDrawing(objImage1UnitROI.ref_ROIWidth, objImage1UnitROI.ref_ROIHeight);

                objImage1UnitROI.CopyToImage(ref PkgImg);
                PkgROI.LoadROISetting(0, 0, objImage1UnitROI.ref_ROIWidth, objImage1UnitROI.ref_ROIHeight);
                PkgROI.AttachImage(PkgImg);

                MoldPkgROI.LoadROISetting(intToleranceWidth, intToleranceHeight, PkgROI.ref_ROIWidth, PkgROI.ref_ROIHeight);
                MoldPkgROI.AttachImage(objMoldFlashROI);

                EasyImage.Oper(EArithmeticLogicOperation.Subtract, MoldPkgROI.ref_ROI, PkgROI.ref_ROI, MoldPkgROI.ref_ROI);
                //objMoldFlashROI.SaveImage("D:\\CheckImageMoldFlashDefect_Area_PkgROICenter.bmp");

                MoldPkgROI.Dispose();
                PkgImg.Dispose();
                PkgROI.Dispose();

            }
            if (intPadIndex == 1) // Top
            {
                ROI PkgROI = new ROI();
                ROI MoldPkgROI = new ROI();
                ROI MoldBorderROI = new ROI();
                ImageDrawing PkgImg = new ImageDrawing(objMoldFlashROI.ref_ROIWidth, objMoldFlashROI.ref_ROIHeight);
                ImageDrawing DontCareImg = new ImageDrawing(objMoldFlashROI.ref_ROIWidth, objMoldFlashROI.ref_ROIHeight);
                ROI DontCareTop1 = new ROI();
                ROI DontCareTop2 = new ROI();
                ROI DontCareTop3 = new ROI();

                objMoldFlashROI.CopyToImage(ref PkgImg);
                DontCareTop3.LoadROISetting(0, 0, objMoldFlashROI.ref_ROIWidth, objMoldFlashROI.ref_ROIHeight);
                DontCareTop3.AttachImage(DontCareImg);
                PkgROI.LoadROISetting(0, 0, objMoldFlashROI.ref_ROIWidth, objMoldFlashROI.ref_ROIHeight);
                //PkgROI.AttachImage(objImage1UnitROI);
                PkgROI.AttachImage(PkgImg);
                DontCareTop1.LoadROISetting(0, 0, objMoldFlashROI.ref_ROIWidth, objMoldFlashROI.ref_ROIHeight);
                DontCareTop1.AttachImage(m_ImgTilt_Top_L);

                DontCareTop2.LoadROISetting(m_ImgTilt_Top_R.ref_intImageWidth - objMoldFlashROI.ref_ROIWidth, 0, objMoldFlashROI.ref_ROIWidth, objMoldFlashROI.ref_ROIHeight);
                DontCareTop2.AttachImage(m_ImgTilt_Top_R);

                //DontCareTop1.SaveImage("D:\\DontCareTop1.bmp");
                //DontCareTop2.SaveImage("D:\\DontCareTop2.bmp");
                EasyImage.Oper(EArithmeticLogicOperation.LogicalOr, DontCareTop1.ref_ROI, DontCareTop2.ref_ROI, DontCareTop3.ref_ROI);
                //DontCareTop3.SaveImage("D:\\DontCareTop3.bmp");

                EasyImage.Oper(EArithmeticLogicOperation.Subtract, PkgROI.ref_ROI, DontCareTop3.ref_ROI, PkgROI.ref_ROI);
                //PkgROI.SaveImage("D:\\CheckImageMoldFlashDefect_Area_PkgROITop1.bmp");

                MoldPkgROI.LoadROISetting(0, 0, PkgROI.ref_ROIWidth, PkgROI.ref_ROIHeight);
                MoldPkgROI.AttachImage(objMoldFlashROI);
                //MoldPkgROI.SaveImage("D:\\MoldPkgROI.bmp");
                EasyImage.Oper(EArithmeticLogicOperation.Subtract, MoldPkgROI.ref_ROI, PkgROI.ref_ROI, MoldPkgROI.ref_ROI);
                //objMoldFlashROI.SaveImage("D:\\CheckImageMoldFlashDefect_Area_PkgROITop2.bmp");

                objMoldFlashROI.LoadROISetting(objImage1UnitROI.ref_ROITotalX - (int)m_fMoldStartPixelFromLeft,
                                           objImage1UnitROI.ref_ROITotalY - (int)m_fMoldStartPixelFromEdge,
                                           objImage1UnitROI.ref_ROIWidth + (int)(m_fMoldStartPixelFromLeft + m_fMoldStartPixelFromRight),
                                           objImage1UnitROI.ref_ROIHeight + (int)(m_fMoldStartPixelFromEdge + m_fMoldStartPixelFromBottom));

                objMoldFlashROI.CopyToImage(ref PkgImg);
                DontCareImg.SetImageSize(objMoldFlashROI.ref_ROIWidth, objMoldFlashROI.ref_ROIHeight);
                DontCareTop3.LoadROISetting(0, 0, objMoldFlashROI.ref_ROIWidth, objMoldFlashROI.ref_ROIHeight);

                DontCareTop3.AttachImage(DontCareImg);
                PkgROI.LoadROISetting(0, 0, objMoldFlashROI.ref_ROIWidth, objMoldFlashROI.ref_ROIHeight);
                PkgROI.AttachImage(PkgImg);

                DontCareTop1.LoadROISetting(0, 0, objMoldFlashROI.ref_ROIWidth, objMoldFlashROI.ref_ROIHeight);
                DontCareTop1.AttachImage(m_ImgTilt_Top_L);

                DontCareTop2.LoadROISetting(m_ImgTilt_Top_R.ref_intImageWidth - objMoldFlashROI.ref_ROIWidth, 0, objMoldFlashROI.ref_ROIWidth, objMoldFlashROI.ref_ROIHeight);
                DontCareTop2.AttachImage(m_ImgTilt_Top_R);

                //DontCareTop1.SaveImage("D:\\DontCareTop11.bmp");
                //DontCareTop2.SaveImage("D:\\DontCareTop12.bmp");
                EasyImage.Oper(EArithmeticLogicOperation.LogicalOr, DontCareTop1.ref_ROI, DontCareTop2.ref_ROI, DontCareTop3.ref_ROI);
                //DontCareTop3.SaveImage("D:\\DontCareTop13.bmp");

                EasyImage.Oper(EArithmeticLogicOperation.Subtract, PkgROI.ref_ROI, DontCareTop3.ref_ROI, PkgROI.ref_ROI);
                //PkgROI.SaveImage("D:\\CheckImageMoldFlashDefect_Area_PkgROITop11.bmp");

                //MoldPkgROI.LoadROISetting(0, intToleranceHeight + PkgROI.ref_ROIHeight, objMoldFlashROI.ref_ROIWidth, intToleranceHeight);
                //MoldBorderROI.LoadROISetting(0, intToleranceHeight + PkgROI.ref_ROIHeight, objMoldFlashROI.ref_ROIWidth, intToleranceHeight);
                //MoldBorderROI.AttachImage(objMoldFlashROI);
                //EasyImage.Oper(EArithmeticLogicOperation.Subtract, MoldPkgROI.ref_ROI, MoldBorderROI.ref_ROI, MoldPkgROI.ref_ROI);
                //objMoldFlashROI.SaveImage("D:\\CheckImageMoldFlashDefect_Area_PkgROITop3.bmp");

                DontCareTop1.Dispose();
                DontCareTop2.Dispose();
                DontCareTop3.Dispose();
                MoldPkgROI.Dispose();
                MoldBorderROI.Dispose();
                PkgImg.Dispose();
                PkgROI.Dispose();
                DontCareImg.Dispose();
            }
            if (intPadIndex == 2) // Right
            {
                ROI PkgROI = new ROI();
                ROI MoldPkgROI = new ROI();
                ROI MoldBorderROI = new ROI();
                ImageDrawing PkgImg = new ImageDrawing(objMoldFlashROI.ref_ROIWidth, objMoldFlashROI.ref_ROIHeight);
                ImageDrawing DontCareImg = new ImageDrawing(objMoldFlashROI.ref_ROIWidth, objMoldFlashROI.ref_ROIHeight);
                ROI DontCareRight1 = new ROI();
                ROI DontCareRight2 = new ROI();
                ROI DontCareRight3 = new ROI();

                objMoldFlashROI.CopyToImage(ref PkgImg);
                DontCareRight3.LoadROISetting(0, 0, objMoldFlashROI.ref_ROIWidth, objMoldFlashROI.ref_ROIHeight);
                DontCareRight3.AttachImage(DontCareImg);
                PkgROI.LoadROISetting(0, 0, objMoldFlashROI.ref_ROIWidth, objMoldFlashROI.ref_ROIHeight);
                //PkgROI.AttachImage(objImage1UnitROI);
                PkgROI.AttachImage(PkgImg);
                DontCareRight1.LoadROISetting(m_ImgTilt_Right_T.ref_intImageWidth - objMoldFlashROI.ref_ROIWidth, 0, objMoldFlashROI.ref_ROIWidth, objMoldFlashROI.ref_ROIHeight);
                DontCareRight1.AttachImage(m_ImgTilt_Right_T);

                DontCareRight2.LoadROISetting(m_ImgTilt_Right_B.ref_intImageWidth - objMoldFlashROI.ref_ROIWidth, m_ImgTilt_Right_B.ref_intImageHeight - objMoldFlashROI.ref_ROIHeight, objMoldFlashROI.ref_ROIWidth, objMoldFlashROI.ref_ROIHeight);
                DontCareRight2.AttachImage(m_ImgTilt_Right_B);

                //DontCareRight1.SaveImage("D:\\DontCareRight1.bmp");
                //DontCareRight2.SaveImage("D:\\DontCareRight2.bmp");
                EasyImage.Oper(EArithmeticLogicOperation.LogicalOr, DontCareRight1.ref_ROI, DontCareRight2.ref_ROI, DontCareRight3.ref_ROI);
                //DontCareRight3.SaveImage("D:\\DontCareRight3.bmp");

                EasyImage.Oper(EArithmeticLogicOperation.Subtract, PkgROI.ref_ROI, DontCareRight3.ref_ROI, PkgROI.ref_ROI);
                //PkgROI.SaveImage("D:\\CheckImageMoldFlashDefect_Area_PkgROIRight1.bmp");
                MoldPkgROI.LoadROISetting(0, 0, PkgROI.ref_ROIWidth, PkgROI.ref_ROIHeight);
                MoldPkgROI.AttachImage(objMoldFlashROI);

                EasyImage.Oper(EArithmeticLogicOperation.Subtract, MoldPkgROI.ref_ROI, PkgROI.ref_ROI, MoldPkgROI.ref_ROI);
                //objMoldFlashROI.SaveImage("D:\\CheckImageMoldFlashDefect_Area_PkgROIRight2.bmp");

                objMoldFlashROI.LoadROISetting(objImage1UnitROI.ref_ROITotalX - (int)m_fMoldStartPixelFromLeft,
                                           objImage1UnitROI.ref_ROITotalY - (int)m_fMoldStartPixelFromEdge,
                                           objImage1UnitROI.ref_ROIWidth + (int)(m_fMoldStartPixelFromLeft + m_fMoldStartPixelFromRight),
                                           objImage1UnitROI.ref_ROIHeight + (int)(m_fMoldStartPixelFromEdge + m_fMoldStartPixelFromBottom));

                objMoldFlashROI.CopyToImage(ref PkgImg);
                DontCareImg.SetImageSize(objMoldFlashROI.ref_ROIWidth, objMoldFlashROI.ref_ROIHeight);
                DontCareRight3.LoadROISetting(0, 0, objMoldFlashROI.ref_ROIWidth, objMoldFlashROI.ref_ROIHeight);
                DontCareRight3.AttachImage(DontCareImg);
                PkgROI.LoadROISetting(0, 0, objMoldFlashROI.ref_ROIWidth, objMoldFlashROI.ref_ROIHeight);
                //PkgROI.AttachImage(objImage1UnitROI);
                PkgROI.AttachImage(PkgImg);
                DontCareRight1.LoadROISetting(m_ImgTilt_Right_T.ref_intImageWidth - objMoldFlashROI.ref_ROIWidth, 0, objMoldFlashROI.ref_ROIWidth, objMoldFlashROI.ref_ROIHeight);
                DontCareRight1.AttachImage(m_ImgTilt_Right_T);

                DontCareRight2.LoadROISetting(m_ImgTilt_Right_B.ref_intImageWidth - objMoldFlashROI.ref_ROIWidth, m_ImgTilt_Right_B.ref_intImageHeight - objMoldFlashROI.ref_ROIHeight, objMoldFlashROI.ref_ROIWidth, objMoldFlashROI.ref_ROIHeight);
                DontCareRight2.AttachImage(m_ImgTilt_Right_B);

                //DontCareRight1.SaveImage("D:\\DontCareRight11.bmp");
                //DontCareRight2.SaveImage("D:\\DontCareRight12.bmp");
                EasyImage.Oper(EArithmeticLogicOperation.LogicalOr, DontCareRight1.ref_ROI, DontCareRight2.ref_ROI, DontCareRight3.ref_ROI);
                //DontCareRight3.SaveImage("D:\\DontCareRight13.bmp");

                EasyImage.Oper(EArithmeticLogicOperation.Subtract, PkgROI.ref_ROI, DontCareRight3.ref_ROI, PkgROI.ref_ROI);
                //PkgROI.SaveImage("D:\\CheckImageMoldFlashDefect_Area_PkgROIRight11.bmp");

                //MoldPkgROI.LoadROISetting(0, 0, intToleranceWidth, objMoldFlashROI.ref_ROIHeight);
                //MoldBorderROI.LoadROISetting(0, 0, intToleranceWidth, objMoldFlashROI.ref_ROIHeight);
                //MoldBorderROI.AttachImage(objMoldFlashROI);
                //EasyImage.Oper(EArithmeticLogicOperation.Subtract, MoldPkgROI.ref_ROI, MoldBorderROI.ref_ROI, MoldPkgROI.ref_ROI);
                ////objMoldFlashROI.SaveImage("D:\\CheckImageMoldFlashDefect_Area_PkgROIRight3.bmp");

                DontCareRight1.Dispose();
                DontCareRight2.Dispose();
                DontCareRight3.Dispose();
                MoldPkgROI.Dispose();
                MoldBorderROI.Dispose();
                PkgImg.Dispose();
                PkgROI.Dispose();
                DontCareImg.Dispose();
            }
            if (intPadIndex == 3) // Bottom
            {
                ROI PkgROI = new ROI();
                ROI MoldPkgROI = new ROI();
                ROI MoldBorderROI = new ROI();
                ImageDrawing PkgImg = new ImageDrawing(objMoldFlashROI.ref_ROIWidth, objMoldFlashROI.ref_ROIHeight);
                ImageDrawing DontCareImg = new ImageDrawing(objMoldFlashROI.ref_ROIWidth, objMoldFlashROI.ref_ROIHeight);
                ROI DontCareBottom1 = new ROI();
                ROI DontCareBottom2 = new ROI();
                ROI DontCareBottom3 = new ROI();

                objMoldFlashROI.CopyToImage(ref PkgImg);
                DontCareBottom3.LoadROISetting(0, 0, objMoldFlashROI.ref_ROIWidth, objMoldFlashROI.ref_ROIHeight);
                DontCareBottom3.AttachImage(DontCareImg);
                PkgROI.LoadROISetting(0, 0, objMoldFlashROI.ref_ROIWidth, objMoldFlashROI.ref_ROIHeight);
                //PkgROI.AttachImage(objImage1UnitROI);
                PkgROI.AttachImage(PkgImg);
                DontCareBottom1.LoadROISetting(0, m_ImgTilt_Bottom_L.ref_intImageHeight - objMoldFlashROI.ref_ROIHeight, objMoldFlashROI.ref_ROIWidth, objMoldFlashROI.ref_ROIHeight);
                DontCareBottom1.AttachImage(m_ImgTilt_Bottom_L);

                DontCareBottom2.LoadROISetting(m_ImgTilt_Bottom_R.ref_intImageWidth - objMoldFlashROI.ref_ROIWidth, m_ImgTilt_Bottom_R.ref_intImageHeight - objMoldFlashROI.ref_ROIHeight, objMoldFlashROI.ref_ROIWidth, objMoldFlashROI.ref_ROIHeight);
                DontCareBottom2.AttachImage(m_ImgTilt_Bottom_R);

                //DontCareBottom1.SaveImage("D:\\DontCareBottom1.bmp");
                //DontCareBottom2.SaveImage("D:\\DontCareBottom2.bmp");
                EasyImage.Oper(EArithmeticLogicOperation.LogicalOr, DontCareBottom1.ref_ROI, DontCareBottom2.ref_ROI, DontCareBottom3.ref_ROI);
                //DontCareBottom3.SaveImage("D:\\DontCareBottom3.bmp");

                EasyImage.Oper(EArithmeticLogicOperation.Subtract, PkgROI.ref_ROI, DontCareBottom3.ref_ROI, PkgROI.ref_ROI);
                //PkgROI.SaveImage("D:\\CheckImageMoldFlashDefect_Area_PkgROIBottom1.bmp");
                MoldPkgROI.LoadROISetting(0, 0, PkgROI.ref_ROIWidth, PkgROI.ref_ROIHeight);
                MoldPkgROI.AttachImage(objMoldFlashROI);

                EasyImage.Oper(EArithmeticLogicOperation.Subtract, MoldPkgROI.ref_ROI, PkgROI.ref_ROI, MoldPkgROI.ref_ROI);
                //objMoldFlashROI.SaveImage("D:\\CheckImageMoldFlashDefect_Area_PkgROIBottom2.bmp");

                objMoldFlashROI.LoadROISetting(objImage1UnitROI.ref_ROITotalX - (int)m_fMoldStartPixelFromLeft,
                                           objImage1UnitROI.ref_ROITotalY - (int)m_fMoldStartPixelFromEdge,
                                           objImage1UnitROI.ref_ROIWidth + (int)(m_fMoldStartPixelFromLeft + m_fMoldStartPixelFromRight),
                                           objImage1UnitROI.ref_ROIHeight + (int)(m_fMoldStartPixelFromEdge + m_fMoldStartPixelFromBottom));

                objMoldFlashROI.CopyToImage(ref PkgImg);
                DontCareImg.SetImageSize(objMoldFlashROI.ref_ROIWidth, objMoldFlashROI.ref_ROIHeight);
                DontCareBottom3.LoadROISetting(0, 0, objMoldFlashROI.ref_ROIWidth, objMoldFlashROI.ref_ROIHeight);
                DontCareBottom3.AttachImage(DontCareImg);
                PkgROI.LoadROISetting(0, 0, objMoldFlashROI.ref_ROIWidth, objMoldFlashROI.ref_ROIHeight);
                //PkgROI.AttachImage(objImage1UnitROI);
                PkgROI.AttachImage(PkgImg);
                DontCareBottom1.LoadROISetting(0, m_ImgTilt_Bottom_L.ref_intImageHeight - objMoldFlashROI.ref_ROIHeight, objMoldFlashROI.ref_ROIWidth, objMoldFlashROI.ref_ROIHeight);
                DontCareBottom1.AttachImage(m_ImgTilt_Bottom_L);

                DontCareBottom2.LoadROISetting(m_ImgTilt_Bottom_R.ref_intImageWidth - objMoldFlashROI.ref_ROIWidth, m_ImgTilt_Bottom_R.ref_intImageHeight - objMoldFlashROI.ref_ROIHeight, objMoldFlashROI.ref_ROIWidth, objMoldFlashROI.ref_ROIHeight);
                DontCareBottom2.AttachImage(m_ImgTilt_Bottom_R);

                //DontCareBottom1.SaveImage("D:\\DontCareBottom11.bmp");
                //DontCareBottom2.SaveImage("D:\\DontCareBottom12.bmp");
                EasyImage.Oper(EArithmeticLogicOperation.LogicalOr, DontCareBottom1.ref_ROI, DontCareBottom2.ref_ROI, DontCareBottom3.ref_ROI);
                //DontCareBottom3.SaveImage("D:\\DontCareBottom13.bmp");

                EasyImage.Oper(EArithmeticLogicOperation.Subtract, PkgROI.ref_ROI, DontCareBottom3.ref_ROI, PkgROI.ref_ROI);
                //PkgROI.SaveImage("D:\\CheckImageMoldFlashDefect_Area_PkgROIBottom11.bmp");

                //MoldPkgROI.LoadROISetting(0, 0, objMoldFlashROI.ref_ROIWidth, intToleranceHeight);
                //MoldBorderROI.LoadROISetting(0, 0, objMoldFlashROI.ref_ROIWidth, intToleranceHeight);
                //MoldBorderROI.AttachImage(objMoldFlashROI);
                //EasyImage.Oper(EArithmeticLogicOperation.Subtract, MoldPkgROI.ref_ROI, MoldBorderROI.ref_ROI, MoldPkgROI.ref_ROI);
                ////objMoldFlashROI.SaveImage("D:\\CheckImageMoldFlashDefect_Area_PkgROIBottom3.bmp");

                DontCareBottom1.Dispose();
                DontCareBottom2.Dispose();
                DontCareBottom3.Dispose();
                MoldPkgROI.Dispose();
                MoldBorderROI.Dispose();
                PkgImg.Dispose();
                PkgROI.Dispose();
                DontCareImg.Dispose();
            }
            if (intPadIndex == 4) // Left
            {
                ROI PkgROI = new ROI();
                ROI MoldPkgROI = new ROI();
                ROI MoldBorderROI = new ROI();
                ImageDrawing PkgImg = new ImageDrawing(objMoldFlashROI.ref_ROIWidth, objMoldFlashROI.ref_ROIHeight);
                ImageDrawing DontCareImg = new ImageDrawing(objMoldFlashROI.ref_ROIWidth, objMoldFlashROI.ref_ROIHeight);
                ROI DontCareLeft1 = new ROI();
                ROI DontCareLeft2 = new ROI();
                ROI DontCareLeft3 = new ROI();

                objMoldFlashROI.CopyToImage(ref PkgImg);
                DontCareLeft3.LoadROISetting(0, 0, objMoldFlashROI.ref_ROIWidth, objMoldFlashROI.ref_ROIHeight);
                DontCareLeft3.AttachImage(DontCareImg);
                PkgROI.LoadROISetting(0, 0, objMoldFlashROI.ref_ROIWidth, objMoldFlashROI.ref_ROIHeight);
                //PkgROI.AttachImage(objImage1UnitROI);
                PkgROI.AttachImage(PkgImg);
                DontCareLeft1.LoadROISetting(0, 0, objMoldFlashROI.ref_ROIWidth, objMoldFlashROI.ref_ROIHeight);
                DontCareLeft1.AttachImage(m_ImgTilt_Left_T);

                DontCareLeft2.LoadROISetting(0, m_ImgTilt_Left_B.ref_intImageHeight - objMoldFlashROI.ref_ROIHeight, objMoldFlashROI.ref_ROIWidth, objMoldFlashROI.ref_ROIHeight);
                DontCareLeft2.AttachImage(m_ImgTilt_Left_B);

                //DontCareLeft1.SaveImage("D:\\DontCareLeft1.bmp");
                //DontCareLeft2.SaveImage("D:\\DontCareLeft2.bmp");
                EasyImage.Oper(EArithmeticLogicOperation.LogicalOr, DontCareLeft1.ref_ROI, DontCareLeft2.ref_ROI, DontCareLeft3.ref_ROI);
                //DontCareLeft3.SaveImage("D:\\DontCareLeft3.bmp");

                EasyImage.Oper(EArithmeticLogicOperation.Subtract, PkgROI.ref_ROI, DontCareLeft3.ref_ROI, PkgROI.ref_ROI);
                //PkgROI.SaveImage("D:\\CheckImageMoldFlashDefect_Area_PkgROILeft1.bmp");

                MoldPkgROI.LoadROISetting(0, 0, PkgROI.ref_ROIWidth, PkgROI.ref_ROIHeight);
                MoldPkgROI.AttachImage(objMoldFlashROI);

                EasyImage.Oper(EArithmeticLogicOperation.Subtract, MoldPkgROI.ref_ROI, PkgROI.ref_ROI, MoldPkgROI.ref_ROI);
                //objMoldFlashROI.SaveImage("D:\\CheckImageMoldFlashDefect_Area_PkgROIBottom2.bmp");


                objMoldFlashROI.LoadROISetting(objImage1UnitROI.ref_ROITotalX - (int)m_fMoldStartPixelFromLeft,
                                           objImage1UnitROI.ref_ROITotalY - (int)m_fMoldStartPixelFromEdge,
                                           objImage1UnitROI.ref_ROIWidth + (int)(m_fMoldStartPixelFromLeft + m_fMoldStartPixelFromRight),
                                           objImage1UnitROI.ref_ROIHeight + (int)(m_fMoldStartPixelFromEdge + m_fMoldStartPixelFromBottom));

                objMoldFlashROI.CopyToImage(ref PkgImg);
                DontCareImg.SetImageSize(objMoldFlashROI.ref_ROIWidth, objMoldFlashROI.ref_ROIHeight);
                DontCareLeft3.LoadROISetting(0, 0, objMoldFlashROI.ref_ROIWidth, objMoldFlashROI.ref_ROIHeight);
                DontCareLeft3.AttachImage(DontCareImg);
                PkgROI.LoadROISetting(0, 0, objMoldFlashROI.ref_ROIWidth, objMoldFlashROI.ref_ROIHeight);
                //PkgROI.AttachImage(objImage1UnitROI);
                PkgROI.AttachImage(PkgImg);
                DontCareLeft1.LoadROISetting(0, 0, objMoldFlashROI.ref_ROIWidth, objMoldFlashROI.ref_ROIHeight);
                DontCareLeft1.AttachImage(m_ImgTilt_Left_T);

                DontCareLeft2.LoadROISetting(0, m_ImgTilt_Left_B.ref_intImageHeight - objMoldFlashROI.ref_ROIHeight, objMoldFlashROI.ref_ROIWidth, objMoldFlashROI.ref_ROIHeight);
                DontCareLeft2.AttachImage(m_ImgTilt_Left_B);

                //DontCareLeft1.SaveImage("D:\\DontCareLeft11.bmp");
                //DontCareLeft2.SaveImage("D:\\DontCareLeft12.bmp");
                EasyImage.Oper(EArithmeticLogicOperation.LogicalOr, DontCareLeft1.ref_ROI, DontCareLeft2.ref_ROI, DontCareLeft3.ref_ROI);
                //DontCareLeft3.SaveImage("D:\\DontCareLeft13.bmp");

                EasyImage.Oper(EArithmeticLogicOperation.Subtract, PkgROI.ref_ROI, DontCareLeft3.ref_ROI, PkgROI.ref_ROI);
                //PkgROI.SaveImage("D:\\CheckImageMoldFlashDefect_Area_PkgROILeft11.bmp");

                //EasyImage.Oper(EArithmeticLogicOperation.Subtract, MoldPkgROI.ref_ROI, PkgROI.ref_ROI, MoldPkgROI.ref_ROI);
                ////objMoldFlashROI.SaveImage("D:\\CheckImageMoldFlashDefect_Area_PkgROILeft2.bmp");

                //MoldPkgROI.LoadROISetting(intToleranceWidth + PkgROI.ref_ROIWidth, 0, intToleranceWidth, objMoldFlashROI.ref_ROIHeight);
                //MoldBorderROI.LoadROISetting(intToleranceWidth + PkgROI.ref_ROIWidth, 0, intToleranceWidth, objMoldFlashROI.ref_ROIHeight);
                //MoldBorderROI.AttachImage(objMoldFlashROI);
                //EasyImage.Oper(EArithmeticLogicOperation.Subtract, MoldPkgROI.ref_ROI, MoldBorderROI.ref_ROI, MoldPkgROI.ref_ROI);
                ////objMoldFlashROI.SaveImage("D:\\CheckImageMoldFlashDefect_Area_PkgROILeft3.bmp");

                DontCareLeft1.Dispose();
                DontCareLeft2.Dispose();
                DontCareLeft3.Dispose();
                MoldPkgROI.Dispose();
                MoldBorderROI.Dispose();
                PkgImg.Dispose();
                PkgROI.Dispose();
                DontCareImg.Dispose();
            }

            #region Subtract Template Pad ----------------------------------------------------------------------------------

            for (int i = 0; i < m_arrTemplateBlobPads.Count; i++)
            {
                if (blnDebugImage)
                    m_arrImgPadImage[i].Save("D:\\TS\\2_m_arrImgPadImage" + i.ToString() + ".bmp");// debug   
                ROI objROI = new ROI();
                ROI DilateROI = new ROI();
                ImageDrawing Img = new ImageDrawing();

                if (m_arrSampleBlobPads[i].intFailMask != 0)
                    continue;

                int intImageToleranceWidth = (int)Math.Round((m_arrImgPadImage[i].Width - objMoldFlashROI.ref_ROIWidth) / 2.0);
                int intImageToleranceHeight = (int)Math.Round((m_arrImgPadImage[i].Height - objMoldFlashROI.ref_ROIHeight) / 2.0);
                int intOffsetX = 0, intOffsetY = 0;
                if (intImageToleranceWidth < 0)
                {
                    intOffsetX = -intImageToleranceWidth;
                    intImageToleranceWidth = 0;
                }
                if (intImageToleranceHeight < 0)
                {
                    intOffsetY = -intImageToleranceHeight;
                    intImageToleranceHeight = 0;
                }

                if (!GetOverallWantGaugeMeasurePkgSize(false))
                {
                    intOffsetX += (int)Math.Round(GetResultCenterPoint_UnitMatcher().X - GetResultCenterPoint_RectGauge4L().X);
                    intOffsetY += (int)Math.Round(GetResultCenterPoint_UnitMatcher().Y - GetResultCenterPoint_RectGauge4L().Y);
                }

                Img.SetImageSize(m_arrImgPadImage[i].Width, m_arrImgPadImage[i].Height);
                Img.SetImageToBlack();
                objROI.ref_ROI.Attach(m_arrImgPadImage[i]);
                objROI.LoadROISetting(intImageToleranceWidth + intOffsetX, intImageToleranceHeight + intOffsetY, objMoldFlashROI.ref_ROIWidth - (intOffsetX * 2), objMoldFlashROI.ref_ROIHeight - (intOffsetY * 2));
                DilateROI.AttachImage(Img);
                DilateROI.LoadROISetting(intImageToleranceWidth + intOffsetX, intImageToleranceHeight + intOffsetY, objMoldFlashROI.ref_ROIWidth - (intOffsetX * 2), objMoldFlashROI.ref_ROIHeight - (intOffsetY * 2));

                EasyImage.Copy(objROI.ref_ROI, DilateROI.ref_ROI);
#if (Debug_2_12 || Release_2_12)
                EasyImage.DilateBox(DilateROI.ref_ROI, DilateROI.ref_ROI, (uint)Math.Abs(m_intMPDilateHalfWidth), (uint)Math.Abs(m_intMPDilateHalfWidth));
#elif (DEBUG || RELEASE || RTXRelease || RTXDebug)
                EasyImage.DilateBox(DilateROI.ref_ROI, DilateROI.ref_ROI, Math.Abs(m_intMPDilateHalfWidth), Math.Abs(m_intMPDilateHalfWidth));
#endif

                if (blnDebugImage)
                {
                    objROI.SaveImage("D:\\TS\\3.1_objROI.bmp");// debug  
                    DilateROI.SaveImage("D:\\TS\\3.2_DilateROI.bmp");// debug  
                }
                objROI.AttachImage(objMoldFlashROI);
                objROI.LoadROISetting_MustSameSize(DilateROI, intImageToleranceWidth + intOffsetX, intImageToleranceHeight + intOffsetY, objMoldFlashROI.ref_ROIWidth - (intOffsetX * 2), objMoldFlashROI.ref_ROIHeight - (intOffsetY * 2));
                if (blnDebugImage)
                {
                    objROI.SaveImage("D:\\TS\\3.3_objROI.bmp");// debug  
                }
                EasyImage.Oper(EArithmeticLogicOperation.Subtract, objROI.ref_ROI, DilateROI.ref_ROI, objROI.ref_ROI);
                if (blnDebugImage)
                {
                    m_arrImgPadImage[i].Save("D:\\TS\\4_m_arrImgPadImage" + i.ToString() + ".bmp");
                }
                objROI.Dispose();
                DilateROI.Dispose();
                Img.Dispose();
            }
            if (blnDebugImage)
            {
                objMoldFlashROI.SaveImage("D:\\TS\\5_objMoldFlashROI.bmp");// debug  
            }

            #endregion ------------------------------------------------------------------------------------------------

            //ROI objMoldFlashBorderROI = new ROI();
            //objMoldFlashBorderROI.AttachImage(objMoldFlashROI);

            //for (int i = 0; i < 4; i++)   // Create 4 direction ROI
            //{
            //    if (m_intPadROIDirection == 1 && i == 2)    // Top Side Pad 
            //        continue;
            //    else if (m_intPadROIDirection == 2 && i == 3) // Right Side Pad
            //        continue;
            //    else if (m_intPadROIDirection == 3 && i == 0) // Bottom Side Pad
            //        continue;
            //    else if (m_intPadROIDirection == 4 && i == 1) // Left Side Pad
            //        continue;

            //    switch (i)
            //    {
            //        case 0:  // Top Border
            //            if (m_intPadROIDirection == 2)
            //                objMoldFlashBorderROI.LoadROISetting(intToleranceWidth, 0, objMoldFlashROI.ref_ROIWidth - intToleranceWidth, intToleranceHeight);
            //            else if (m_intPadROIDirection == 4)
            //                objMoldFlashBorderROI.LoadROISetting(0, 0, objMoldFlashROI.ref_ROIWidth - intToleranceWidth, intToleranceHeight);
            //            else
            //                objMoldFlashBorderROI.LoadROISetting(0, 0, objMoldFlashROI.ref_ROIWidth, (int)m_fMoldStartPixelFromEdge);

            //            objMoldFlashBorderROI.SaveImage("D:\\TS\\" + m_intPadROIDirection.ToString() + "objMoldFlashBorderROITop.bmp");
            //            intTotalStartX = objMoldFlashROI.ref_ROITotalX;
            //            intTotalStartY = objMoldFlashROI.ref_ROITotalY;

            //            break;
            //        case 1: // Right Border
            //            if (m_intPadROIDirection == 1)
            //                objMoldFlashBorderROI.LoadROISetting(objMoldFlashROI.ref_ROIWidth - intToleranceWidth, 0, intToleranceWidth, objMoldFlashROI.ref_ROIHeight - intToleranceHeight);
            //            else if (m_intPadROIDirection == 3)
            //                objMoldFlashBorderROI.LoadROISetting(objMoldFlashROI.ref_ROIWidth - intToleranceWidth, intToleranceHeight, intToleranceWidth, objMoldFlashROI.ref_ROIHeight - intToleranceHeight);
            //            else
            //                objMoldFlashBorderROI.LoadROISetting(objMoldFlashROI.ref_ROIWidth - (int)m_fMoldStartPixelFromRight, 0, (int)m_fMoldStartPixelFromRight, objMoldFlashROI.ref_ROIHeight);
            //            intTotalStartX = objMoldFlashROI.ref_ROITotalX + objMoldFlashROI.ref_ROIWidth - (int)m_fMoldStartPixelFromRight;
            //            intTotalStartY = objMoldFlashROI.ref_ROITotalY;
            //            objMoldFlashBorderROI.SaveImage("D:\\TS\\" + m_intPadROIDirection.ToString() + "objMoldFlashBorderROIRight.bmp");

            //            break;
            //        case 2: // Bottom Border
            //            if (m_intPadROIDirection == 2)
            //                objMoldFlashBorderROI.LoadROISetting(intToleranceWidth, objMoldFlashROI.ref_ROIHeight - intToleranceHeight, objMoldFlashROI.ref_ROIWidth - intToleranceWidth, intToleranceHeight);
            //            else if (m_intPadROIDirection == 4)
            //                objMoldFlashBorderROI.LoadROISetting(0, objMoldFlashROI.ref_ROIHeight - intToleranceHeight, objMoldFlashROI.ref_ROIWidth - intToleranceWidth, intToleranceHeight);
            //            else
            //                objMoldFlashBorderROI.LoadROISetting(0, objMoldFlashROI.ref_ROIHeight - (int)m_fMoldStartPixelFromBottom, objMoldFlashROI.ref_ROIWidth, (int)m_fMoldStartPixelFromBottom);
            //            intTotalStartX = objMoldFlashROI.ref_ROITotalX;
            //            intTotalStartY = objMoldFlashROI.ref_ROITotalY + objMoldFlashROI.ref_ROIHeight - (int)m_fMoldStartPixelFromBottom;
            //            objMoldFlashBorderROI.SaveImage("D:\\TS\\" + m_intPadROIDirection.ToString() + "objMoldFlashBorderROIBottom.bmp");

            //            break;
            //        case 3: // Left Border
            //            if (m_intPadROIDirection == 1)
            //                objMoldFlashBorderROI.LoadROISetting(0, 0, intToleranceWidth, objMoldFlashROI.ref_ROIHeight - intToleranceHeight);
            //            else if (m_intPadROIDirection == 3)
            //                objMoldFlashBorderROI.LoadROISetting(0, intToleranceHeight, intToleranceWidth, objMoldFlashROI.ref_ROIHeight - intToleranceHeight);
            //            else
            //                objMoldFlashBorderROI.LoadROISetting(0, 0, (int)m_fMoldStartPixelFromLeft, objMoldFlashROI.ref_ROIHeight);
            //            intTotalStartX = objMoldFlashROI.ref_ROITotalX;
            //            intTotalStartY = objMoldFlashROI.ref_ROITotalY;
            //            objMoldFlashBorderROI.SaveImage("D:\\TS\\" + m_intPadROIDirection.ToString() + "objMoldFlashBorderROILeft.bmp");

            //            break;
            //    }

            // Build blobs object for subtract image
            m_objImage1MoldFlashEBlobs.BuildObjects_Filter_GetElement(objMoldFlashROI, m_intMoldFlashDefectType == 1, true, 0, m_intPkgImage1MoldFlashThreshold, //2019-09-27 ZJYEOH : Direct inspect objMoldFlashROI, no need cut to objMoldFlashBorderROI
                (int)Math.Floor(m_fMoldFlashMinArea), 999999, false, 0xED); //0x0F
            //objMoldFlashBorderROI.SaveImage("D:\\objMoldFlashBorderROI.bmp");
            if (m_objImage1MoldFlashEBlobs.ref_intNumSelectedObject > 0)
            {
                List<List<System.Windows.Point>> arr2DPoints = new List<List<System.Windows.Point>>();
                List<List<PointF>> arrRotatedPoints = new List<List<PointF>>();
                List<float> fObjectHeightList = new List<float>(), fObjectWidthList = new List<float>(), fObjectCenterXList = new List<float>(), fObjectCenterYList = new List<float>(), fObjectAngleList = new List<float>();
                List<float> fObjectLimitHeightList = new List<float>(), fObjectLimitWidthList = new List<float>(), fObjectLimitCenterXList = new List<float>(), fObjectLimitCenterYList = new List<float>();
                List<int> fObjectAreaList = new List<int>(), fObjectAreaList2 = new List<int>();
                int intTotalArea = 0;
                float fCenterX = 0, fCenterY = 0, fWidth = 0, fHeight = 0, fAngle = 0;
                float fStartX = 0, fStartY = 0, fEndX = 0, fEndY = 0;
                int intArea = 0;
                float fWidthMM, fHeightMM, fAreaInMM;
                int intFailCount = 0;
                int intTolerance = m_intMoldFlashDefectLinkTolerance;
                for (int x = 0; x < m_objImage1MoldFlashEBlobs.ref_intNumSelectedObject; x++)
                {
                    arrRotatedPoints.Add(new List<PointF>());
                    arr2DPoints.Add(new List<System.Windows.Point>());
                    //fCenterX = m_objImage1MoldFlashEBlobs.ref_arrLimitCenterX[x];
                    //fCenterY = m_objImage1MoldFlashEBlobs.ref_arrLimitCenterY[x];
                    //fWidth = m_objImage1MoldFlashEBlobs.ref_arrWidth[x];
                    //fHeight = m_objImage1MoldFlashEBlobs.ref_arrHeight[x];
                    intArea = m_objImage1MoldFlashEBlobs.ref_arrArea[x];
                    //fStartX = (float)Math.Floor(fCenterX - (fWidth / 2));
                    //fStartY = (float)Math.Floor(fCenterY - (fHeight / 2));
                    //fEndX = (float)Math.Ceiling(fCenterX + (fWidth / 2));
                    //fEndY = (float)Math.Ceiling(fCenterY + (fHeight / 2));
                    intTotalArea += intArea;

                    if (m_objImage1MoldFlashEBlobs.ref_arrRectHeight[x] < m_objImage1MoldFlashEBlobs.ref_arrRectWidth[x])
                    {
                        fWidth = m_objImage1MoldFlashEBlobs.ref_arrRectHeight[x];
                        fHeight = m_objImage1MoldFlashEBlobs.ref_arrRectWidth[x];

                        fAngle = m_objImage1MoldFlashEBlobs.ref_arrRectAngle[x];

                        if (fAngle >= 10)//&& fAngle <= 80)
                            fAngle = m_objImage1MoldFlashEBlobs.ref_arrRectAngle[x] - 90;
                        else
                            fAngle = 90 + m_objImage1MoldFlashEBlobs.ref_arrRectAngle[x];

                    }
                    else
                    {
                        fHeight = m_objImage1MoldFlashEBlobs.ref_arrRectHeight[x];
                        fWidth = m_objImage1MoldFlashEBlobs.ref_arrRectWidth[x];

                        fAngle = m_objImage1MoldFlashEBlobs.ref_arrRectAngle[x];

                    }
                    fCenterX = m_objImage1MoldFlashEBlobs.ref_arrRectLimitCenterX[x];
                    fCenterY = m_objImage1MoldFlashEBlobs.ref_arrRectLimitCenterY[x];

                    float newX1 = 0, newY1 = 0;  // new point 1
                    float newX2 = 0, newY2 = 0; // new point 2
                    float newX3 = 0, newY3 = 0; // new point 3
                    float newX4 = 0, newY4 = 0; // new point 4

                    //2020-12-18 ZJYEOH : Change to this format
                    //  Point 1 *-------------* Point 2
                    //          |             |
                    //          |             |
                    //          |             |
                    //  Point 4 *-------------* Point 3

                    Math2.RotateWithAngleAccordingToReferencePoint(fCenterX, fCenterY, (fCenterX - (fWidth / 2)), (fCenterY - (fHeight / 2)), fAngle, ref newX1, ref newY1);
                    Math2.RotateWithAngleAccordingToReferencePoint(fCenterX, fCenterY, (fCenterX + (fWidth / 2)), (fCenterY - (fHeight / 2)), fAngle, ref newX2, ref newY2);
                    Math2.RotateWithAngleAccordingToReferencePoint(fCenterX, fCenterY, (fCenterX + (fWidth / 2)), (fCenterY + (fHeight / 2)), fAngle, ref newX3, ref newY3);
                    Math2.RotateWithAngleAccordingToReferencePoint(fCenterX, fCenterY, (fCenterX - (fWidth / 2)), (fCenterY + (fHeight / 2)), fAngle, ref newX4, ref newY4);


                    arrRotatedPoints[x].Add(new PointF(newX1, newY1));
                    arrRotatedPoints[x].Add(new PointF(newX2, newY2));
                    arrRotatedPoints[x].Add(new PointF(newX3, newY3));
                    arrRotatedPoints[x].Add(new PointF(newX4, newY4));

                    Math2.RotateWithAngleAccordingToReferencePoint(fCenterX, fCenterY, (fCenterX - (fWidth / 2)) - intTolerance, (fCenterY - (fHeight / 2)) - intTolerance, fAngle, ref newX1, ref newY1);
                    Math2.RotateWithAngleAccordingToReferencePoint(fCenterX, fCenterY, (fCenterX + (fWidth / 2)) + intTolerance, (fCenterY - (fHeight / 2)) - intTolerance, fAngle, ref newX2, ref newY2);
                    Math2.RotateWithAngleAccordingToReferencePoint(fCenterX, fCenterY, (fCenterX + (fWidth / 2)) + intTolerance, (fCenterY + (fHeight / 2)) + intTolerance, fAngle, ref newX3, ref newY3);
                    Math2.RotateWithAngleAccordingToReferencePoint(fCenterX, fCenterY, (fCenterX - (fWidth / 2)) - intTolerance, (fCenterY + (fHeight / 2)) + intTolerance, fAngle, ref newX4, ref newY4);

                    arr2DPoints[x].Add(new System.Windows.Point(newX1, newY1));
                    arr2DPoints[x].Add(new System.Windows.Point(newX2, newY2));
                    arr2DPoints[x].Add(new System.Windows.Point(newX3, newY3));
                    arr2DPoints[x].Add(new System.Windows.Point(newX4, newY4));

                    fObjectHeightList.Add(fHeight);
                    fObjectWidthList.Add(fWidth);
                    fObjectCenterXList.Add(fCenterX);
                    fObjectCenterYList.Add(fCenterY);
                    fObjectAngleList.Add(fAngle);
                    fObjectAreaList.Add(intArea);
                    fObjectAreaList2.Add(intArea);
                }
                
                int intAngleTolerance = 10;
                bool blnDecrement = false;
                if (intTolerance >= 0)
                {
                    for (int i = 0; i < fObjectHeightList.Count; i++)
                    {
                        if (blnDecrement)
                        {
                            blnDecrement = false;
                            if (i > 0)
                                i--;
                        }
                        for (int j = 0; j < fObjectHeightList.Count; j++)
                        {
                            if (i != j && i < fObjectHeightList.Count && j < fObjectHeightList.Count)
                            {
                                if (Intersection.CheckRectRectIntersection(arr2DPoints[i].ToArray(), arr2DPoints[j].ToArray(), intTolerance))
                                {

                                    PointF[] arrPoints = new PointF[8];

                                    arrPoints[0] = arrRotatedPoints[i][0];
                                    arrPoints[1] = arrRotatedPoints[i][1];
                                    arrPoints[2] = arrRotatedPoints[i][2];
                                    arrPoints[3] = arrRotatedPoints[i][3];
                                    arrPoints[4] = arrRotatedPoints[j][0];
                                    arrPoints[5] = arrRotatedPoints[j][1];
                                    arrPoints[6] = arrRotatedPoints[j][2];
                                    arrPoints[7] = arrRotatedPoints[j][3];

                                    float fMinAngle = 0;
                                    List<PointF> arrMinRect = new List<PointF>();
                                    arrMinRect = MinimumBoundingBox.CalculateMinimumBoundingBox(arrPoints, ref fMinAngle);
                                    //fObjectAngleList[i] = fMinAngle;
                                    if (fMinAngle < 0)
                                        fObjectAngleList[i] = -(90 + fMinAngle);
                                    else
                                        fObjectAngleList[i] = 90 - fMinAngle;

                                    //if (fMinAngle < 0)
                                    //    fObjectAngleList[i] = -(90 + fMinAngle);
                                    //else
                                    //    fObjectAngleList[i] = 90 - fMinAngle;

                                    Line onjLine1 = new Line();
                                    Line onjLine2 = new Line();
                                    onjLine1.CalculateStraightLine(arrMinRect[0], arrMinRect[2]);
                                    onjLine2.CalculateStraightLine(arrMinRect[1], arrMinRect[3]);
                                    PointF pCenter = Line.GetCrossPoint(onjLine1, onjLine2);
                                    float p1X = 0, p1Y = 0;
                                    float p2X = 0, p2Y = 0;
                                    float p3X = 0, p3Y = 0;
                                    float p4X = 0, p4Y = 0;
                                    Math2.RotateWithAngleAccordingToReferencePoint(pCenter.X, pCenter.Y, arrMinRect[0].X, arrMinRect[0].Y, -fObjectAngleList[i], ref p1X, ref p1Y);
                                    Math2.RotateWithAngleAccordingToReferencePoint(pCenter.X, pCenter.Y, arrMinRect[1].X, arrMinRect[1].Y, -fObjectAngleList[i], ref p2X, ref p2Y);
                                    Math2.RotateWithAngleAccordingToReferencePoint(pCenter.X, pCenter.Y, arrMinRect[2].X, arrMinRect[2].Y, -fObjectAngleList[i], ref p3X, ref p3Y);
                                    Math2.RotateWithAngleAccordingToReferencePoint(pCenter.X, pCenter.Y, arrMinRect[3].X, arrMinRect[3].Y, -fObjectAngleList[i], ref p4X, ref p4Y);

                                    float pR1X = 0, pR1Y = 0;
                                    float pR2X = 0, pR2Y = 0;
                                    float pR3X = 0, pR3Y = 0;
                                    float pR4X = 0, pR4Y = 0;
                                    Math2.RotateWithAngleAccordingToReferencePoint(pCenter.X, pCenter.Y, Math.Min(Math.Min(p1X, p2X), Math.Min(p3X, p4X)), Math.Min(Math.Min(p1Y, p2Y), Math.Min(p3Y, p4Y)), fObjectAngleList[i], ref pR1X, ref pR1Y); // Top Left
                                    Math2.RotateWithAngleAccordingToReferencePoint(pCenter.X, pCenter.Y, Math.Max(Math.Max(p1X, p2X), Math.Max(p3X, p4X)), Math.Min(Math.Min(p1Y, p2Y), Math.Min(p3Y, p4Y)), fObjectAngleList[i], ref pR2X, ref pR2Y); // Top Right
                                    Math2.RotateWithAngleAccordingToReferencePoint(pCenter.X, pCenter.Y, Math.Max(Math.Max(p1X, p2X), Math.Max(p3X, p4X)), Math.Max(Math.Max(p1Y, p2Y), Math.Max(p3Y, p4Y)), fObjectAngleList[i], ref pR3X, ref pR3Y); // Bottom Right
                                    Math2.RotateWithAngleAccordingToReferencePoint(pCenter.X, pCenter.Y, Math.Min(Math.Min(p1X, p2X), Math.Min(p3X, p4X)), Math.Max(Math.Max(p1Y, p2Y), Math.Max(p3Y, p4Y)), fObjectAngleList[i], ref pR4X, ref pR4Y); // Bottom Left
                                    arrMinRect[0] = new PointF(pR1X, pR1Y);
                                    arrMinRect[1] = new PointF(pR2X, pR2Y);
                                    arrMinRect[2] = new PointF(pR3X, pR3Y);
                                    arrMinRect[3] = new PointF(pR4X, pR4Y);

                                    arrRotatedPoints[i][0] = arrMinRect[0];
                                    arrRotatedPoints[i][1] = arrMinRect[1];
                                    arrRotatedPoints[i][2] = arrMinRect[2];
                                    arrRotatedPoints[i][3] = arrMinRect[3];

                                    Math2.RotateWithAngleAccordingToReferencePoint(pCenter.X, pCenter.Y, Math.Min(Math.Min(p1X, p2X), Math.Min(p3X, p4X)) - intTolerance, Math.Min(Math.Min(p1Y, p2Y), Math.Min(p3Y, p4Y)) - intTolerance, fObjectAngleList[i], ref pR1X, ref pR1Y); // Top Left
                                    Math2.RotateWithAngleAccordingToReferencePoint(pCenter.X, pCenter.Y, Math.Max(Math.Max(p1X, p2X), Math.Max(p3X, p4X)) + intTolerance, Math.Min(Math.Min(p1Y, p2Y), Math.Min(p3Y, p4Y)) - intTolerance, fObjectAngleList[i], ref pR2X, ref pR2Y); // Top Right
                                    Math2.RotateWithAngleAccordingToReferencePoint(pCenter.X, pCenter.Y, Math.Max(Math.Max(p1X, p2X), Math.Max(p3X, p4X)) + intTolerance, Math.Max(Math.Max(p1Y, p2Y), Math.Max(p3Y, p4Y)) + intTolerance, fObjectAngleList[i], ref pR3X, ref pR3Y); // Bottom Right
                                    Math2.RotateWithAngleAccordingToReferencePoint(pCenter.X, pCenter.Y, Math.Min(Math.Min(p1X, p2X), Math.Min(p3X, p4X)) - intTolerance, Math.Max(Math.Max(p1Y, p2Y), Math.Max(p3Y, p4Y)) + intTolerance, fObjectAngleList[i], ref pR4X, ref pR4Y); // Bottom Left

                                    arr2DPoints[i][0] = new System.Windows.Point(pR1X, pR1Y);
                                    arr2DPoints[i][1] = new System.Windows.Point(pR2X, pR2Y);
                                    arr2DPoints[i][2] = new System.Windows.Point(pR3X, pR3Y);
                                    arr2DPoints[i][3] = new System.Windows.Point(pR4X, pR4Y);

                                    arrRotatedPoints.RemoveAt(j);
                                    arr2DPoints.RemoveAt(j);

                                    float fDiffX = Math.Max(Math.Abs(p1X - p4X), Math.Abs(p2X - p3X));
                                    float fDiffY = Math.Max(Math.Abs(p3Y - p4Y), Math.Abs(p2Y - p1Y));

                                    fObjectWidthList[i] = fDiffX;
                                    fObjectHeightList[i] = fDiffY;

                                    fObjectCenterXList[i] = pCenter.X;
                                    fObjectCenterYList[i] = pCenter.Y;

                                    fObjectAreaList2.RemoveAt(j);
                                    fObjectAreaList[i] = fObjectAreaList[i] + fObjectAreaList[j];

                                    fObjectHeightList.RemoveAt(j);
                                    fObjectWidthList.RemoveAt(j);
                                    fObjectCenterXList.RemoveAt(j);
                                    fObjectCenterYList.RemoveAt(j);
                                    fObjectAngleList.RemoveAt(j);
                                    fObjectAreaList.RemoveAt(j);

                                    if (j > 0)
                                        j = -1;
                                    if (i > 0)
                                    {
                                        i = 0;
                                    }
                                    else
                                        blnDecrement = true;

                                }

                            }
                        }
                    }
                }
                for (int x = 0; x < fObjectHeightList.Count; x++)
                {
                    //fWidthMM = fWidth / m_fMMToPixelXValue;
                    //fHeightMM = fHeight / m_fMMToPixelYValue;
                    //fAreaInMM = intArea / m_fMMToPixelXValue / m_fMMToPixelYValue;
                    fWidthMM = fObjectWidthList[x] / m_fMMToPixelXValue;
                    fHeightMM = fObjectHeightList[x] / m_fMMToPixelYValue;
                    fAreaInMM = fObjectAreaList[x] / (m_fMMToPixelXValue * m_fMMToPixelYValue);
                    bool blnDefect = false;
                    bool blnFailWidth = false;

                    //bool blnLengthFail = false;
                    // Not need to check length, only area
                    //if (i == 0)
                    //{
                    //    if (fHeight >= m_fMoldStartPixelFromEdge)
                    //        blnLengthFail = true;
                    //}
                    //else if (i == 1)
                    //{
                    //    if (fWidth >= m_fMoldStartPixelFromRight)
                    //        blnLengthFail = true;
                    //}
                    //else if (i == 2)
                    //{
                    //    if (fHeight >= m_fMoldStartPixelFromBottom)
                    //        blnLengthFail = true;
                    //}
                    //else if (i == 3)
                    //{
                    //    if (fWidth >= m_fMoldStartPixelFromLeft)
                    //        blnLengthFail = true;
                    //}

                    //if (blnLengthFail && fAreaInMM >= m_fMoldFlashArea)
                    //if (fAreaInMM > m_fMoldFlashArea)  // 2019 07 21 - CCENG: Not need to check length anymore.
                    {
                        intFailCount++;
                        m_intFailPkgResultMask |= 0x80; // Fail Mold Flash

                        Defect objDefect = new Defect();

                        objDefect.ref_strName = "Mold Flash";
                        //objDefect.ref_intFailCriteria |= 0x04;
                        objDefect.ref_intFailMask |= 0x80;
                        objDefect.ref_fCenterX = intTotalStartX + fObjectCenterXList[x];
                        objDefect.ref_fCenterY = intTotalStartY + fObjectCenterYList[x];
                        //objDefect.ref_fStartX = intTotalStartX + fStartX;
                        //objDefect.ref_fStartY = intTotalStartY + fStartY;
                        //objDefect.ref_fEndX = intTotalStartX + fEndX;
                        //objDefect.ref_fEndY = intTotalStartY + fEndY;
                        objDefect.ref_fWidth = fObjectWidthList[x];
                        objDefect.ref_fHeight = fObjectHeightList[x];
                        objDefect.ref_fArea = fObjectAreaList[x];
                        objDefect.ref_fAngle = fObjectAngleList[x];
                        objDefect.ref_fWidthInMM = fWidthMM;
                        objDefect.ref_fHeightInMM = fHeightMM;
                        objDefect.ref_fAreaInMM2 = fAreaInMM;
                        objDefect.ref_intImageNo = m_intPadPkgMoldFlashImageViewNo + 1;
                        //objDefect.ref_fFailValue = fAreaInMM;

                        if ((m_intFailPkgOptionMask & 0x1000000) > 0)
                        {
                            if (m_intMoldFlashDefectDimensionFailCondition == 0)
                            {
                                if (fWidthMM > m_fMoldFlashWidth)
                                {
                                    blnResult = false;
                                    objDefect.ref_fWidthFailValue = fWidthMM;
                                    objDefect.ref_intFailCriteria |= 0x01;
                                }

                                if (fHeightMM > m_fMoldFlashLength)
                                {
                                    blnResult = false;
                                    objDefect.ref_fHeightFailValue = fHeightMM;
                                    objDefect.ref_intFailCriteria |= 0x02;
                                }
                            }
                            else
                            {
                                if (fWidthMM > m_fMoldFlashWidth && fHeightMM > m_fMoldFlashLength)
                                {
                                    blnResult = false;
                                    objDefect.ref_fWidthFailValue = fWidthMM;
                                    objDefect.ref_fHeightFailValue = fHeightMM;
                                    objDefect.ref_intFailCriteria |= 0x01;
                                    objDefect.ref_intFailCriteria |= 0x02;
                                }
                            }
                        }

                        if ((m_intFailPkgOptionMask & 0x80) > 0)
                        {
                            if (fAreaInMM > m_fMoldFlashArea)
                            {
                                blnResult = false;
                                objDefect.ref_fAreaFailValue = fAreaInMM;
                                objDefect.ref_intFailCriteria |= 0x04;
                            }
                        }

                        m_arrPkgDefectList.Add(objDefect);

                        //if (blnResult)
                        //    blnResult = false;
                    }
                }

                fAreaInMM = intTotalArea / m_fMMToPixelXValue / m_fMMToPixelYValue;

                if (((m_intFailPkgOptionMask & 0x80) > 0) && fAreaInMM > m_fMoldFlashTotalArea)
                {
                    Defect objDefect = new Defect();

                    objDefect.ref_strName = "Total Mold Flash";
                    objDefect.ref_intFailMask = 0x80;
                    objDefect.ref_fCenterX = -1;
                    objDefect.ref_fCenterY = -1;
                    objDefect.ref_fStartX = -1;
                    objDefect.ref_fStartY = -1;
                    objDefect.ref_fEndX = -1;
                    objDefect.ref_fEndY = -1;
                    objDefect.ref_fWidth = -1;
                    objDefect.ref_fHeight = -1;
                    objDefect.ref_fArea = intTotalArea;
                    objDefect.ref_fWidthInMM = -1;
                    objDefect.ref_fHeightInMM = -1;
                    objDefect.ref_fAreaInMM2 = fAreaInMM;
                    objDefect.ref_intImageNo = m_intPadPkgMoldFlashImageViewNo + 1; //2020-01-09 ZJYEOH : Should not fixed to 1

                    blnResult = false;
                    objDefect.ref_fAreaFailValue = fAreaInMM;
                    objDefect.ref_intFailCriteria |= 0x08;

                    m_arrPkgDefectList.Add(objDefect);

                    Defect objDefect2 = new Defect();
                    for (int a = 0; a < m_arrPkgDefectList.Count; a++)
                    {
                        objDefect2 = m_arrPkgDefectList[a];
                        if (objDefect2.ref_strName.Contains("Mold Flash"))
                        {
                            objDefect2.ref_blnFailTotalArea = true;
                            m_arrPkgDefectList[a] = objDefect2;
                        }
                    }

                    m_intFailPkgResultMask |= 0x80; // Fail image 1 surface total bright field

                }
            }

            //}

            //objMoldFlashBorderROI.Dispose();
            return blnResult;
        }
        private bool CheckImageMoldFlashDefect(ROI objImage1UnitROI, ROI objMoldFlashROI, int intImageIndex)
        {
            if ((m_intFailPkgOptionMask & 0x80) == 0)
                return true;

            if (m_fMoldFlashLength == 0)
                return true;

            bool blnResult = true;
            int intTotalStartX = 0, intTotalStartY = 0;
            int intMoldFlashSetting = (int)Math.Ceiling(m_fMoldFlashLength * m_fMMToPixelXValue);
            int intToleranceWidth = (objMoldFlashROI.ref_ROIWidth - objImage1UnitROI.ref_ROIWidth) / 2;
            int intToleranceHeight = (objMoldFlashROI.ref_ROIHeight - objImage1UnitROI.ref_ROIHeight) / 2;
            ROI objMoldFlashBorderROI = new ROI();
            objMoldFlashBorderROI.AttachImage(objMoldFlashROI);

            for (int i = 0; i < 4; i++)   // Create 4 direction ROI
            {
                if (m_intPadROIDirection == 1 && i == 2)    // Top Side Pad 
                    continue;
                else if (m_intPadROIDirection == 2 && i == 3) // Right Side Pad
                    continue;
                else if (m_intPadROIDirection == 3 && i == 0) // Bottom Side Pad
                    continue;
                else if (m_intPadROIDirection == 4 && i == 1) // Left Side Pad
                    continue;

                switch (i)
                {
                    case 0:  // Top Border
                        if (m_intPadROIDirection == 2)
                            objMoldFlashBorderROI.LoadROISetting(intMoldFlashSetting, 0, objMoldFlashROI.ref_ROIWidth - intToleranceWidth, intToleranceHeight);
                        else if (m_intPadROIDirection == 4)
                            objMoldFlashBorderROI.LoadROISetting(0, 0, objMoldFlashROI.ref_ROIWidth - intToleranceWidth, intToleranceHeight);
                        else
                            objMoldFlashBorderROI.LoadROISetting(0, 0, objMoldFlashROI.ref_ROIWidth, intToleranceHeight);
                        intTotalStartX = objMoldFlashROI.ref_ROITotalX;
                        intTotalStartY = objMoldFlashROI.ref_ROITotalY;
                        //if (m_intPadROIDirection == 2)
                        //    objMoldFlashBorderROI.LoadROISetting(intMoldFlashSetting, 0, objMoldFlashROI.ref_ROIWidth - intMoldFlashSetting, intMoldFlashSetting);
                        //else if (m_intPadROIDirection == 4)
                        //    objMoldFlashBorderROI.LoadROISetting(0, 0, objMoldFlashROI.ref_ROIWidth - intMoldFlashSetting, intMoldFlashSetting);
                        //else 
                        //    objMoldFlashBorderROI.LoadROISetting(0, 0, objMoldFlashROI.ref_ROIWidth, intMoldFlashSetting);
                        //intTotalStartX = objMoldFlashROI.ref_ROITotalX;
                        //intTotalStartY = objMoldFlashROI.ref_ROITotalY;
                        break;
                    case 1: // Right Border
                        if (m_intPadROIDirection == 1)
                            objMoldFlashBorderROI.LoadROISetting(objMoldFlashROI.ref_ROIWidth - intToleranceWidth, 0, intToleranceWidth, objMoldFlashROI.ref_ROIHeight - intToleranceHeight);
                        else if (m_intPadROIDirection == 3)
                            objMoldFlashBorderROI.LoadROISetting(objMoldFlashROI.ref_ROIWidth - intToleranceWidth, intToleranceHeight, intToleranceWidth, objMoldFlashROI.ref_ROIHeight - intToleranceHeight);
                        else
                            objMoldFlashBorderROI.LoadROISetting(objMoldFlashROI.ref_ROIWidth - intToleranceWidth, 0, intToleranceWidth, objMoldFlashROI.ref_ROIHeight);
                        intTotalStartX = objMoldFlashROI.ref_ROITotalX + objMoldFlashROI.ref_ROIWidth - intToleranceWidth;
                        intTotalStartY = objMoldFlashROI.ref_ROITotalY;

                        //if (m_intPadROIDirection == 1)
                        //    objMoldFlashBorderROI.LoadROISetting(objMoldFlashROI.ref_ROIWidth - intMoldFlashSetting, 0, intMoldFlashSetting, objMoldFlashROI.ref_ROIHeight - intMoldFlashSetting);
                        //else if (m_intPadROIDirection == 3)
                        //    objMoldFlashBorderROI.LoadROISetting(objMoldFlashROI.ref_ROIWidth - intMoldFlashSetting, intMoldFlashSetting, intMoldFlashSetting, objMoldFlashROI.ref_ROIHeight - intMoldFlashSetting);
                        //else 
                        //    objMoldFlashBorderROI.LoadROISetting(objMoldFlashROI.ref_ROIWidth - intMoldFlashSetting, 0, intMoldFlashSetting, objMoldFlashROI.ref_ROIHeight);
                        //intTotalStartX = objMoldFlashROI.ref_ROITotalX + objMoldFlashROI.ref_ROIWidth - intMoldFlashSetting;
                        //intTotalStartY = objMoldFlashROI.ref_ROITotalY;
                        break;
                    case 2: // Bottom Border
                        if (m_intPadROIDirection == 2)
                            objMoldFlashBorderROI.LoadROISetting(intToleranceWidth, objMoldFlashROI.ref_ROIHeight - intToleranceHeight, objMoldFlashROI.ref_ROIWidth - intToleranceWidth, intToleranceHeight);
                        else if (m_intPadROIDirection == 4)
                            objMoldFlashBorderROI.LoadROISetting(0, objMoldFlashROI.ref_ROIHeight - intToleranceHeight, objMoldFlashROI.ref_ROIWidth - intToleranceWidth, intToleranceHeight);
                        else
                            objMoldFlashBorderROI.LoadROISetting(0, objMoldFlashROI.ref_ROIHeight - intToleranceHeight, objMoldFlashROI.ref_ROIWidth, intToleranceHeight);
                        intTotalStartX = objMoldFlashROI.ref_ROITotalX;
                        intTotalStartY = objMoldFlashROI.ref_ROITotalY + objMoldFlashROI.ref_ROIHeight - intToleranceHeight;

                        //if (m_intPadROIDirection == 2)
                        //    objMoldFlashBorderROI.LoadROISetting(intMoldFlashSetting, objMoldFlashROI.ref_ROIHeight - intMoldFlashSetting, objMoldFlashROI.ref_ROIWidth - intMoldFlashSetting, intMoldFlashSetting);
                        //else if (m_intPadROIDirection == 4)
                        //    objMoldFlashBorderROI.LoadROISetting(0, objMoldFlashROI.ref_ROIHeight - intMoldFlashSetting, objMoldFlashROI.ref_ROIWidth - intMoldFlashSetting, intMoldFlashSetting);
                        //else 
                        //    objMoldFlashBorderROI.LoadROISetting(0, objMoldFlashROI.ref_ROIHeight - intMoldFlashSetting, objMoldFlashROI.ref_ROIWidth, intMoldFlashSetting);
                        //intTotalStartX = objMoldFlashROI.ref_ROITotalX;
                        //intTotalStartY = objMoldFlashROI.ref_ROITotalY + objMoldFlashROI.ref_ROIHeight - intMoldFlashSetting;
                        break;
                    case 3: // Left Border
                        if (m_intPadROIDirection == 1)
                            objMoldFlashBorderROI.LoadROISetting(0, 0, intToleranceWidth, objMoldFlashROI.ref_ROIHeight - intToleranceHeight);
                        else if (m_intPadROIDirection == 3)
                            objMoldFlashBorderROI.LoadROISetting(0, intToleranceHeight, intToleranceWidth, objMoldFlashROI.ref_ROIHeight - intToleranceHeight);
                        else
                            objMoldFlashBorderROI.LoadROISetting(0, 0, intToleranceWidth, objMoldFlashROI.ref_ROIHeight);
                        intTotalStartX = objMoldFlashROI.ref_ROITotalX;
                        intTotalStartY = objMoldFlashROI.ref_ROITotalY;

                        //if (m_intPadROIDirection == 1)
                        //    objMoldFlashBorderROI.LoadROISetting(0, 0, intMoldFlashSetting, objMoldFlashROI.ref_ROIHeight- intMoldFlashSetting);
                        //else if (m_intPadROIDirection == 3)
                        //    objMoldFlashBorderROI.LoadROISetting(0, intMoldFlashSetting, intMoldFlashSetting, objMoldFlashROI.ref_ROIHeight - intMoldFlashSetting);
                        //else 
                        //    objMoldFlashBorderROI.LoadROISetting(0, 0, intMoldFlashSetting, objMoldFlashROI.ref_ROIHeight);
                        //intTotalStartX = objMoldFlashROI.ref_ROITotalX;
                        //intTotalStartY = objMoldFlashROI.ref_ROITotalY;
                        break;
                }

                // Build blobs object for subtract image
                m_objImage1MoldFlashEBlobs.BuildObjects_Filter_GetElement(objMoldFlashBorderROI, false, true, 0, m_intPkgImage1MoldFlashThreshold,
                    (int)Math.Floor(m_fMoldFlashMinArea), 999999, false, 0x0F);
                //objMoldFlashBorderROI.SaveImage("D:\\objMoldFlashBorderROI.bmp");
                if (m_objImage1MoldFlashEBlobs.ref_intNumSelectedObject > 0)
                {
                    float fCenterX = 0, fCenterY = 0, fWidth = 0, fHeight = 0;
                    float fStartX = 0, fStartY = 0, fEndX = 0, fEndY = 0;
                    int intArea = 0;
                    float fWidthMM, fHeightMM, fAreaInMM;
                    int intFailCount = 0;

                    for (int x = 0; x < m_objImage1MoldFlashEBlobs.ref_intNumSelectedObject; x++)
                    {
                        fCenterX = m_objImage1MoldFlashEBlobs.ref_arrLimitCenterX[x];
                        fCenterY = m_objImage1MoldFlashEBlobs.ref_arrLimitCenterY[x];
                        fWidth = m_objImage1MoldFlashEBlobs.ref_arrWidth[x];
                        fHeight = m_objImage1MoldFlashEBlobs.ref_arrHeight[x];
                        intArea = m_objImage1MoldFlashEBlobs.ref_arrArea[x];
                        fStartX = (float)Math.Floor(fCenterX - (fWidth / 2));
                        fStartY = (float)Math.Floor(fCenterY - (fHeight / 2));
                        fEndX = (float)Math.Ceiling(fCenterX + (fWidth / 2));
                        fEndY = (float)Math.Ceiling(fCenterY + (fHeight / 2));

                        fWidthMM = fWidth / m_fMMToPixelXValue;
                        fHeightMM = fHeight / m_fMMToPixelYValue;
                        fAreaInMM = intArea / m_fMMToPixelXValue / m_fMMToPixelYValue;

                        if (((i == 0 || i == 2) && ((fHeightMM > m_fMoldFlashLength) || (fHeight == objMoldFlashBorderROI.ref_ROIHeight))) ||
                            ((i == 1 || i == 3) && ((fWidthMM > m_fMoldFlashLength) || (fWidth == objMoldFlashBorderROI.ref_ROIWidth))))
                        {
                            intFailCount++;
                            m_intFailPkgResultMask |= 0x80; // Fail Mold Flash

                            Defect objDefect = new Defect();

                            if (intImageIndex != 0)
                                objDefect.ref_strName = "Image 2 Mold Flash " + intFailCount.ToString();
                            else
                                objDefect.ref_strName = "Image 1 Mold Flash " + intFailCount.ToString();

                            objDefect.ref_intFailMask |= 0x80;
                            objDefect.ref_fCenterX = intTotalStartX + fCenterX;
                            objDefect.ref_fCenterY = intTotalStartY + fCenterY;
                            objDefect.ref_fStartX = intTotalStartX + fStartX;
                            objDefect.ref_fStartY = intTotalStartY + fStartY;
                            objDefect.ref_fEndX = intTotalStartX + fEndX;
                            objDefect.ref_fEndY = intTotalStartY + fEndY;
                            objDefect.ref_fWidth = fWidth;
                            objDefect.ref_fHeight = fHeight;
                            objDefect.ref_fArea = intArea;
                            objDefect.ref_fWidthInMM = fWidthMM;
                            objDefect.ref_fHeightInMM = fHeightMM;
                            objDefect.ref_fAreaInMM2 = fAreaInMM;
                            objDefect.ref_intImageNo = 1;

                            if (i == 0 || i == 2)
                            {
                                objDefect.ref_fFailValue = fHeightMM;
                                objDefect.ref_intFailCriteria |= 0x02;
                            }
                            else
                            {
                                objDefect.ref_fFailValue = fWidthMM;
                                objDefect.ref_intFailCriteria |= 0x01;
                            }

                            m_arrPkgDefectList.Add(objDefect);

                            if (blnResult)
                                blnResult = false;
                        }
                    }
                }

            }

            objMoldFlashBorderROI.Dispose();
            return blnResult;
        }

        private void CheckPitchGap(ROI objROI)
        {
            #region ---- Check Pitch and Gap ----
            if ((m_intFailOptionMask & 0x400) > 0 || (m_intFailOptionMask & 0x200) > 0)
            {
                for (int i = 0; i < m_arrPitchGap.Count; i++)
                {
                    int intFrom = m_arrPitchGap[i].intFromPadNo;
                    int intTo = m_arrPitchGap[i].intToPadNo;
                    float fPitch, fDiffX, fDiffY, fGap, fPitchMM, fGapMM;
                    fPitch = fDiffX = fDiffY = fGap = fPitchMM = fGapMM = 0.0f;

                    //if is valid, broken, hole blob
                    if (((m_arrSampleBlobPads[intFrom].intFailMask & 0x02) == 0) && ((m_arrSampleBlobPads[intFrom].intFailMask & 0x04) == 0))
                    {
                        if (((m_arrSampleBlobPads[intTo].intFailMask & 0x02) == 0) && ((m_arrSampleBlobPads[intTo].intFailMask & 0x04) == 0))
                        {
                            bool blnResult = true;
                            //Check Pitch Pad
                            //fDiffX = Math.Abs(m_arrSampleBlobPads[intFrom].fCenterX - m_arrSampleBlobPads[intTo].fCenterX);
                            //fDiffY = Math.Abs(m_arrSampleBlobPads[intFrom].fCenterY - m_arrSampleBlobPads[intTo].fCenterY);

                            //if (fDiffX > fDiffY)
                            //    fPitch = fDiffX;
                            //else
                            //    fPitch = fDiffY;

                            m_stcPitchGap = m_arrPitchGap[i];
                            if (m_stcPitchGap.intDirection == 0 || m_stcPitchGap.intDirection == 180)
                            {

                                fPitch = Math.Abs(m_arrSampleBlobPads[intFrom].fCenterY - m_arrSampleBlobPads[intTo].fCenterY);
                                // 05-07-2019 ZJYEOH : Include offset in Pitch
                                if (m_blnWantUseGroupToleranceSetting)
                                    fPitch += ((BlobsFeatures)m_arrGroupTemplateBlobPads[((BlobsFeatures)m_arrTemplateBlobPads[intFrom]).intGroupID]).fPitchOffset * m_fMMToPixelYValue;
                                else
                                    fPitch += ((BlobsFeatures)m_arrTemplateBlobPads[intFrom]).fPitchOffset * m_fMMToPixelYValue;
                                fPitchMM = fPitch / m_fMMToPixelYValue;
                            }
                            else
                            {
                                fPitch = Math.Abs(m_arrSampleBlobPads[intFrom].fCenterX - m_arrSampleBlobPads[intTo].fCenterX);
                                // 05-07-2019 ZJYEOH : Include offset in Pitch
                                if (m_blnWantUseGroupToleranceSetting)
                                    fPitch += ((BlobsFeatures)m_arrGroupTemplateBlobPads[((BlobsFeatures)m_arrTemplateBlobPads[intFrom]).intGroupID]).fPitchOffset * m_fMMToPixelXValue;
                                else
                                    fPitch += ((BlobsFeatures)m_arrTemplateBlobPads[intFrom]).fPitchOffset * m_fMMToPixelXValue;
                                fPitchMM = fPitch / m_fMMToPixelXValue;
                            }

                            bool blnPitchResult;
                            if (m_blnWantUseGroupToleranceSetting)
                            {
                                int intGroupNo = ((BlobsFeatures)m_arrTemplateBlobPads[intFrom]).intGroupID;
                                if (m_blnWantTightSetting)
                                {
                                    if ((fPitchMM < (((BlobsFeatures)m_arrGroupTemplateBlobPads[intGroupNo]).fMinPitch + m_fTightSettingTolerance)) || (fPitchMM > (((BlobsFeatures)m_arrGroupTemplateBlobPads[intGroupNo]).fMaxPitch - m_fTightSettingTolerance)))
                                        blnPitchResult = true;
                                    else
                                        blnPitchResult = false;
                                }
                                else
                                {
                                    if ((fPitchMM < ((BlobsFeatures)m_arrGroupTemplateBlobPads[intGroupNo]).fMinPitch) || (fPitchMM > ((BlobsFeatures)m_arrGroupTemplateBlobPads[intGroupNo]).fMaxPitch))
                                        blnPitchResult = true;
                                    else
                                        blnPitchResult = false;
                                }
                            }
                            else
                            {
                                if (m_blnWantTightSetting)
                                {
                                    if ((fPitchMM < (m_arrPitchGap[i].fMinPitch + m_fTightSettingTolerance)) || (fPitchMM > (m_arrPitchGap[i].fMaxPitch - m_fTightSettingTolerance)))
                                        blnPitchResult = true;
                                    else
                                        blnPitchResult = false;
                                }
                                else
                                {
                                    if ((fPitchMM < m_arrPitchGap[i].fMinPitch) || (fPitchMM > m_arrPitchGap[i].fMaxPitch))
                                        blnPitchResult = true;
                                    else
                                        blnPitchResult = false;
                                }
                            }

                            // Check is pitch fail
                            if (blnPitchResult)
                            {
                                PitchGap objPitchGap = new PitchGap();
                                objPitchGap.intFromPadNo = intFrom;
                                objPitchGap.intToPadNo = intTo;
                                if (m_arrPitchGap[i].intStartPointX == m_arrPitchGap[i].intEndPointX)
                                {
                                    objPitchGap.intStartPointX = objROI.ref_ROITotalX + m_arrPitchGap[i].intStartPointX;
                                    objPitchGap.intStartPointY = objROI.ref_ROITotalY + (int)Math.Round(m_arrSampleBlobPads[intFrom].fCenterY, 0, MidpointRounding.AwayFromZero);
                                    objPitchGap.intEndPointX = objROI.ref_ROITotalX + m_arrPitchGap[i].intStartPointX;
                                    objPitchGap.intEndPointY = objROI.ref_ROITotalY + (int)Math.Round(m_arrSampleBlobPads[intTo].fCenterY, 0, MidpointRounding.AwayFromZero);
                                }
                                else
                                {
                                    objPitchGap.intStartPointX = objROI.ref_ROITotalX + (int)Math.Round(m_arrSampleBlobPads[intFrom].fCenterX, 0, MidpointRounding.AwayFromZero);
                                    objPitchGap.intStartPointY = objROI.ref_ROITotalY + m_arrPitchGap[i].intStartPointY;
                                    objPitchGap.intEndPointX = objROI.ref_ROITotalX + (int)Math.Round(m_arrSampleBlobPads[intTo].fCenterX, 0, MidpointRounding.AwayFromZero);
                                    objPitchGap.intEndPointY = objROI.ref_ROITotalY + m_arrPitchGap[i].intStartPointY;

                                }
                                m_arrFailPitchGapList.Add(objPitchGap);     // Add Pitch location
                                //m_arrSampleBlobPads[intFrom].intFailMask |= 0x400;
                                m_stcPitchGap.intFailMask = 0x400;
                                m_intFailResultMask |= 0x400;

                                blnResult = false;
                            }
                            else
                            {
                                m_stcPitchGap.intFailMask = 0x00;   // 2020 03 25 - CCENG: need double check again is it ok
                            }

                            // record the inspection result
                            m_stcPitchGap.fPitchMM = fPitchMM;
                            m_arrPitchGap.RemoveAt(i);
                            m_arrPitchGap.Insert(i, m_stcPitchGap);
                            m_arrSampleBlobPads[intFrom].fPitch = fPitch;


                            //Check Gap Pad
                            if (m_arrSampleBlobPads[intTo].fCenterX > m_arrSampleBlobPads[intFrom].fCenterX)
                            {
                                fDiffX = (m_arrSampleBlobPads[intTo].fCenterX - (m_arrSampleBlobPads[intTo].fWidth / 2)) -
                                (m_arrSampleBlobPads[intFrom].fCenterX + (m_arrSampleBlobPads[intFrom].fWidth / 2));
                            }
                            else
                            {
                                fDiffX = (m_arrSampleBlobPads[intFrom].fCenterX - (m_arrSampleBlobPads[intFrom].fWidth / 2)) -
                                 (m_arrSampleBlobPads[intTo].fCenterX + (m_arrSampleBlobPads[intTo].fWidth / 2));
                            }

                            if (m_arrSampleBlobPads[intTo].fCenterY > m_arrSampleBlobPads[intFrom].fCenterY)
                            {
                                fDiffY = (m_arrSampleBlobPads[intTo].fCenterY - (m_arrSampleBlobPads[intTo].fHeight / 2)) -
                                (m_arrSampleBlobPads[intFrom].fCenterY + (m_arrSampleBlobPads[intFrom].fHeight / 2));
                            }
                            else
                            {
                                fDiffY = (m_arrSampleBlobPads[intFrom].fCenterY - (m_arrSampleBlobPads[intFrom].fHeight / 2)) -
                                 (m_arrSampleBlobPads[intTo].fCenterY + (m_arrSampleBlobPads[intTo].fHeight / 2));
                            }

                            float fFromSize, fToSize;
                            if (fDiffX > fDiffY)
                            {
                                fGap = fDiffX;
                                // 05-07-2019 ZJYEOH : Include offset in Gap
                                if (m_blnWantUseGroupToleranceSetting)
                                    fGap += ((BlobsFeatures)m_arrGroupTemplateBlobPads[((BlobsFeatures)m_arrTemplateBlobPads[intFrom]).intGroupID]).fGapOffset * m_fMMToPixelXValue;
                                else
                                    fGap += ((BlobsFeatures)m_arrTemplateBlobPads[intFrom]).fGapOffset * m_fMMToPixelXValue;
                                fFromSize = m_arrSampleBlobPads[intFrom].fWidth / 2;
                                fToSize = m_arrSampleBlobPads[intTo].fWidth / 2;
                            }
                            else
                            {
                                fGap = fDiffY;
                                // 05-07-2019 ZJYEOH : Include offset in Gap
                                if (m_blnWantUseGroupToleranceSetting)
                                    fGap += ((BlobsFeatures)m_arrGroupTemplateBlobPads[((BlobsFeatures)m_arrTemplateBlobPads[intFrom]).intGroupID]).fGapOffset * m_fMMToPixelYValue;
                                else
                                    fGap += ((BlobsFeatures)m_arrTemplateBlobPads[intFrom]).fGapOffset * m_fMMToPixelYValue;
                                fFromSize = m_arrSampleBlobPads[intFrom].fHeight / 2;
                                fToSize = m_arrSampleBlobPads[intTo].fHeight / 2;
                            }

                            m_stcPitchGap = m_arrPitchGap[i];
                            if (m_stcPitchGap.intDirection == 0 || m_stcPitchGap.intDirection == 180)
                                fGapMM = fGap / m_fMMToPixelYValue;
                            else
                                fGapMM = fGap / m_fMMToPixelXValue;

                            bool blnGapResult;
                            if (m_blnWantUseGroupToleranceSetting)
                            {
                                int intGroupNo = ((BlobsFeatures)m_arrTemplateBlobPads[intFrom]).intGroupID;
                                if (m_blnWantTightSetting)
                                {
                                    if ((fGapMM < (((BlobsFeatures)m_arrGroupTemplateBlobPads[intGroupNo]).fMinGap + m_fTightSettingTolerance)) || (fGapMM > (((BlobsFeatures)m_arrGroupTemplateBlobPads[intGroupNo]).fMaxGap - m_fTightSettingTolerance)))
                                        blnGapResult = true;
                                    else
                                        blnGapResult = false;
                                }
                                else
                                {
                                    if ((fGapMM < ((BlobsFeatures)m_arrGroupTemplateBlobPads[intGroupNo]).fMinGap) || (fGapMM > ((BlobsFeatures)m_arrGroupTemplateBlobPads[intGroupNo]).fMaxGap))
                                        blnGapResult = true;
                                    else
                                        blnGapResult = false;
                                }
                            }
                            else
                            {
                                if (m_blnWantTightSetting)
                                {
                                    if ((fGapMM < (m_arrPitchGap[i].fMinGap + m_fTightSettingTolerance)) || (fGapMM > (m_arrPitchGap[i].fMaxGap - m_fTightSettingTolerance)))
                                        blnGapResult = true;
                                    else
                                        blnGapResult = false;
                                }
                                else
                                {
                                    if ((fGapMM < m_arrPitchGap[i].fMinGap) || (fGapMM > m_arrPitchGap[i].fMaxGap))
                                        blnGapResult = true;
                                    else
                                        blnGapResult = false;
                                }
                            }

                            if (blnGapResult)
                            {
                                m_intFailResultMask |= 0x200;
                                m_arrSampleBlobPads[intFrom].fGap = fGap;
                                //m_arrSampleBlobPads[intFrom].intFailMask |= 0x200;
                                m_stcPitchGap.intFailMask |= 0x200;

                                if (blnResult)
                                {
                                    PitchGap objPitchGap = new PitchGap();
                                    objPitchGap.intFromPadNo = intFrom;
                                    objPitchGap.intToPadNo = intTo;
                                    if (m_arrPitchGap[i].intStartPointX == m_arrPitchGap[i].intEndPointX)
                                    {
                                        if (m_arrSampleBlobPads[intFrom].fCenterY > m_arrSampleBlobPads[intTo].fCenterY)
                                        {
                                            objPitchGap.intStartPointX = objROI.ref_ROITotalX + m_arrPitchGap[i].intStartPointX;
                                            objPitchGap.intStartPointY = objROI.ref_ROITotalY + (int)Math.Round(m_arrSampleBlobPads[intFrom].fCenterY - fFromSize, 0, MidpointRounding.AwayFromZero);
                                            objPitchGap.intEndPointX = objROI.ref_ROITotalX + m_arrPitchGap[i].intStartPointX;
                                            objPitchGap.intEndPointY = objROI.ref_ROITotalY + (int)Math.Round(m_arrSampleBlobPads[intTo].fCenterY + fToSize, 0, MidpointRounding.AwayFromZero);
                                        }
                                        else
                                        {
                                            objPitchGap.intStartPointX = objROI.ref_ROITotalX + m_arrPitchGap[i].intStartPointX;
                                            objPitchGap.intStartPointY = objROI.ref_ROITotalY + (int)Math.Round(m_arrSampleBlobPads[intFrom].fCenterY + fFromSize, 0, MidpointRounding.AwayFromZero);
                                            objPitchGap.intEndPointX = objROI.ref_ROITotalX + m_arrPitchGap[i].intStartPointX;
                                            objPitchGap.intEndPointY = objROI.ref_ROITotalY + (int)Math.Round(m_arrSampleBlobPads[intTo].fCenterY - fToSize, 0, MidpointRounding.AwayFromZero);

                                        }
                                    }
                                    else
                                    {
                                        if (m_arrSampleBlobPads[intFrom].fCenterX > m_arrSampleBlobPads[intTo].fCenterX)
                                        {
                                            objPitchGap.intStartPointX = objROI.ref_ROITotalX + (int)Math.Round(m_arrSampleBlobPads[intFrom].fCenterX - fFromSize, 0, MidpointRounding.AwayFromZero);
                                            objPitchGap.intStartPointY = objROI.ref_ROITotalY + m_arrPitchGap[i].intStartPointY;
                                            objPitchGap.intEndPointX = objROI.ref_ROITotalX + (int)Math.Round(m_arrSampleBlobPads[intTo].fCenterX + fToSize, 0, MidpointRounding.AwayFromZero);
                                            objPitchGap.intEndPointY = objROI.ref_ROITotalY + m_arrPitchGap[i].intStartPointY;
                                        }
                                        else
                                        {
                                            objPitchGap.intStartPointX = objROI.ref_ROITotalX + (int)Math.Round(m_arrSampleBlobPads[intFrom].fCenterX + fFromSize, 0, MidpointRounding.AwayFromZero);
                                            objPitchGap.intStartPointY = objROI.ref_ROITotalY + m_arrPitchGap[i].intStartPointY;
                                            objPitchGap.intEndPointX = objROI.ref_ROITotalX + (int)Math.Round(m_arrSampleBlobPads[intTo].fCenterX - fToSize, 0, MidpointRounding.AwayFromZero);
                                            objPitchGap.intEndPointY = objROI.ref_ROITotalY + m_arrPitchGap[i].intStartPointY;
                                        }
                                    }
                                    m_arrFailPitchGapList.Add(objPitchGap); // Add gap location
                                }
                            }
                            else
                            {
                                if (m_stcPitchGap.intFailMask > 0)
                                    m_stcPitchGap.intFailMask &= ~0x200;
                            }

                            m_stcPitchGap.fGapMM = fGapMM;
                            m_arrPitchGap.RemoveAt(i);
                            m_arrPitchGap.Insert(i, m_stcPitchGap);
                            m_arrSampleBlobPads[intFrom].fGap = fGap;

                        }
                    }
                }
            }
            #endregion

        }

        private void CheckDimention(ROI objROI)
        {
            #region ----- Check Area, Width, Height, OffSet -----

            if ((m_intFailOptionMask & 0x20) > 0 || (m_intFailOptionMask & 0x40) > 0 || (m_intFailOptionMask & 0x80) > 0 || (m_intFailOptionMask & 0x100) > 0 || m_blnTestAllPad)
            {
                float fArea;
                float fWidth, fHeight, fLimitCenterX, fLimitCenterY, fNewCenterX, fNewCenterY, fWidthMM, fHeightMM;
                float fMaxOffSet, fMinOffset;
                float fLine3MM = -1;
                float fLine4MM = -1;
                float fLine5MM = -1;
                float fLine6MM = -1;
                float fLine7MM = -1;
                float fLine8MM = -1;
                float fLine9MM = -1;
                float fLine10MM = -1;
                float fLine11MM = -1;
                float fLine12MM = -1;
                m_arrPadPointGaugeStartX.Clear();
                m_arrPadPointGaugeStartY.Clear();
                m_arrPadPointGaugeTolerance.Clear();
                m_arrPadPointGaugeAngle.Clear();
                m_arrPadEdgeGaugePoints.Clear();
                m_arrPadEdgeGaugePointsFound.Clear();

                for (int i = 0; i < m_arrSampleBlobPads.Length; i++)
                {
                    fWidth = fHeight = fLimitCenterX = fLimitCenterY = 0;
                    fArea = 0;
                    fMaxOffSet = 0;
                    fMinOffset = 0;

                    //Skip if join pad
                    if (((m_arrSampleBlobPads[i].intFailMask & 0x02) > 0) && !m_blnTestAllPad)
                        continue;

                    //Skip if missing pad
                    if (((m_arrSampleBlobPads[i].intFailMask & 0x04) > 0) && !m_blnTestAllPad)
                        continue;

                    BlobsFeatures m_stcBlobPad = (BlobsFeatures)m_arrTemplateBlobPads[i];

                    fLimitCenterX = m_arrSampleBlobPads[i].fCenterX;
                    fLimitCenterY = m_arrSampleBlobPads[i].fCenterY;
                    fWidth = m_arrSampleBlobPads[i].fWidth;
                    fHeight = m_arrSampleBlobPads[i].fHeight;
                    fArea = m_arrSampleBlobPads[i].fArea;
                    fNewCenterX = fLimitCenterX;
                    fNewCenterY = fLimitCenterY;

                    if (!m_blnWantUseGaugeMeasureDimension)
                    {
                        if (m_fPadImageGain != 1f)
                        {
                            ROI objROI2 = new ROI();
                            objROI2.LoadROISetting(objROI.ref_ROITotalX, objROI.ref_ROITotalY, objROI.ref_ROIWidth, objROI.ref_ROIHeight);
                            ImageDrawing objImage = new ImageDrawing(objROI.ref_ROI.TopParent.Width, objROI.ref_ROI.TopParent.Height);
                            EasyImage.Copy(objROI.ref_ROI.TopParent, objImage.ref_objMainImage);
                            objROI2.AttachImage(objImage);

                            EasyImage.GainOffset(objROI2.ref_ROI, objROI2.ref_ROI, m_fPadImageGain);

                            Math2.UpdateBlobSizeAndCenterPointWithSubPixel(objROI2, fLimitCenterX, fLimitCenterY,
                            ref fWidth, ref fHeight, ref fNewCenterX, ref fNewCenterY, m_intThresholdValue);

                            objROI2.Dispose();
                            objImage.Dispose();
                        }
                        else
                        {
                            Math2.UpdateBlobSizeAndCenterPointWithSubPixel(objROI, fLimitCenterX, fLimitCenterY,
                            ref fWidth, ref fHeight, ref fNewCenterX, ref fNewCenterY, m_intThresholdValue);
                        }
                    }
                    else
                    {

                        //UpdateBlobSizeAndCenterPointWithGauge(objROI, fLimitCenterX, fLimitCenterY,
                        //    ref fWidth, ref fHeight, ref fNewCenterX, ref fNewCenterY, m_intThresholdValue);
                        List<PointF> pfStart = new List<PointF>();
                        List<PointF> pfEnd = new List<PointF>();
                        List<PointF> pfStart_Ori = new List<PointF>();
                        List<PointF> pfEnd_Ori = new List<PointF>();
                        for (int j = 0; j < ((BlobsFeatures)m_arrTemplateBlobPads[i]).intLineCount; j++)
                        {
                            float IndividualfCenterX = 0;
                            float IndividualfCenterY = 0;
                            float IndividualfWidth = 0;
                            float IndividualfHeight = 0;
                            float IndividualfArea = m_arrSampleBlobPads[i].fArea;
                            float IndividualfAngle = 0;
                            if (!m_stcBlobPad.blnFeretActivated)
                            {
                                IndividualfCenterX = m_arrSampleBlobPads[i].fStartX;
                                IndividualfCenterY = m_arrSampleBlobPads[i].fStartY;
                                IndividualfWidth = m_arrSampleBlobPads[i].fWidth;
                                IndividualfHeight = m_arrSampleBlobPads[i].fHeight;
                            }
                            else
                            {
                                IndividualfCenterX = m_arrSampleBlobPads[i].fFeretCenterX;
                                IndividualfCenterY = m_arrSampleBlobPads[i].fFeretCenterY;
                                IndividualfAngle = m_arrSampleBlobPads[i].fFeretAngle;
                                IndividualfWidth = m_arrSampleBlobPads[i].fFeretWidth;
                                IndividualfHeight = m_arrSampleBlobPads[i].fFeretHeight;
                            }
                       
                            float IndividualfNewCenterX = IndividualfCenterX;
                            float IndividualfNewCenterY = IndividualfCenterY;
                            float IndividualfLine = 0;
                            float fWidthPercentStart = 0;
                            float fWidthPercentEnd = 0;
                            float fHeightPercentStart = 0;
                            float fHeightPercentEnd = 0;
                            float fInwardPercentStart = 0;
                            float fInwardPercentEnd = 0;
                            int intMeasureMode = 0;

                            pfStart.Add(new PointF(m_intPadEdgeGaugePointToPackageEdgeTolerance, m_intPadEdgeGaugePointToPackageEdgeTolerance));    // 2020 07 09 - CCENG: Default -3
                            pfEnd.Add(new PointF(m_intPadEdgeGaugePointToPackageEdgeTolerance, m_intPadEdgeGaugePointToPackageEdgeTolerance));

                            pfStart_Ori.Add(new PointF(m_intPadEdgeGaugePointToPackageEdgeTolerance, m_intPadEdgeGaugePointToPackageEdgeTolerance));
                            pfEnd_Ori.Add(new PointF(m_intPadEdgeGaugePointToPackageEdgeTolerance, m_intPadEdgeGaugePointToPackageEdgeTolerance));
                            switch (j)
                            {
                                case 0:
                                    fWidthPercentStart = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fWidthPercentStart1;
                                    fWidthPercentEnd = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fWidthPercentEnd1;
                                    fHeightPercentStart = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fHeightPercentStart1;
                                    fHeightPercentEnd = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fHeightPercentEnd1;
                                    fInwardPercentStart = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fInwardPercentStart1;
                                    fInwardPercentEnd = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fInwardPercentEnd1;
                                    intMeasureMode = ((BlobsFeatures)m_arrTemplateBlobPads[i]).intMeasureMethod1;
                                    break;
                                case 1:
                                    fWidthPercentStart = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fWidthPercentStart2;
                                    fWidthPercentEnd = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fWidthPercentEnd2;
                                    fHeightPercentStart = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fHeightPercentStart2;
                                    fHeightPercentEnd = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fHeightPercentEnd2;
                                    fInwardPercentStart = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fInwardPercentStart2;
                                    fInwardPercentEnd = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fInwardPercentEnd2;
                                    intMeasureMode = ((BlobsFeatures)m_arrTemplateBlobPads[i]).intMeasureMethod2;
                                    break;
                                case 2:
                                    fWidthPercentStart = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fWidthPercentStart3;
                                    fWidthPercentEnd = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fWidthPercentEnd3;
                                    fHeightPercentStart = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fHeightPercentStart3;
                                    fHeightPercentEnd = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fHeightPercentEnd3;
                                    fInwardPercentStart = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fInwardPercentStart3;
                                    fInwardPercentEnd = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fInwardPercentEnd3;
                                    intMeasureMode = ((BlobsFeatures)m_arrTemplateBlobPads[i]).intMeasureMethod3;
                                    break;
                                case 3:
                                    fWidthPercentStart = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fWidthPercentStart4;
                                    fWidthPercentEnd = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fWidthPercentEnd4;
                                    fHeightPercentStart = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fHeightPercentStart4;
                                    fHeightPercentEnd = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fHeightPercentEnd4;
                                    fInwardPercentStart = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fInwardPercentStart4;
                                    fInwardPercentEnd = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fInwardPercentEnd4;
                                    intMeasureMode = ((BlobsFeatures)m_arrTemplateBlobPads[i]).intMeasureMethod4;
                                    break;
                                case 4:
                                    fWidthPercentStart = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fWidthPercentStart5;
                                    fWidthPercentEnd = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fWidthPercentEnd5;
                                    fHeightPercentStart = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fHeightPercentStart5;
                                    fHeightPercentEnd = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fHeightPercentEnd5;
                                    fInwardPercentStart = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fInwardPercentStart5;
                                    fInwardPercentEnd = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fInwardPercentEnd5;
                                    intMeasureMode = ((BlobsFeatures)m_arrTemplateBlobPads[i]).intMeasureMethod5;
                                    break;
                                case 5:
                                    fWidthPercentStart = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fWidthPercentStart6;
                                    fWidthPercentEnd = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fWidthPercentEnd6;
                                    fHeightPercentStart = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fHeightPercentStart6;
                                    fHeightPercentEnd = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fHeightPercentEnd6;
                                    fInwardPercentStart = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fInwardPercentStart6;
                                    fInwardPercentEnd = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fInwardPercentEnd6;
                                    intMeasureMode = ((BlobsFeatures)m_arrTemplateBlobPads[i]).intMeasureMethod6;
                                    break;
                                case 6:
                                    fWidthPercentStart = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fWidthPercentStart7;
                                    fWidthPercentEnd = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fWidthPercentEnd7;
                                    fHeightPercentStart = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fHeightPercentStart7;
                                    fHeightPercentEnd = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fHeightPercentEnd7;
                                    fInwardPercentStart = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fInwardPercentStart7;
                                    fInwardPercentEnd = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fInwardPercentEnd7;
                                    intMeasureMode = ((BlobsFeatures)m_arrTemplateBlobPads[i]).intMeasureMethod7;
                                    break;
                                case 7:
                                    fWidthPercentStart = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fWidthPercentStart8;
                                    fWidthPercentEnd = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fWidthPercentEnd8;
                                    fHeightPercentStart = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fHeightPercentStart8;
                                    fHeightPercentEnd = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fHeightPercentEnd8;
                                    fInwardPercentStart = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fInwardPercentStart8;
                                    fInwardPercentEnd = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fInwardPercentEnd8;
                                    intMeasureMode = ((BlobsFeatures)m_arrTemplateBlobPads[i]).intMeasureMethod8;
                                    break;
                                case 8:
                                    fWidthPercentStart = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fWidthPercentStart9;
                                    fWidthPercentEnd = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fWidthPercentEnd9;
                                    fHeightPercentStart = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fHeightPercentStart9;
                                    fHeightPercentEnd = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fHeightPercentEnd9;
                                    fInwardPercentStart = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fInwardPercentStart9;
                                    fInwardPercentEnd = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fInwardPercentEnd9;
                                    intMeasureMode = ((BlobsFeatures)m_arrTemplateBlobPads[i]).intMeasureMethod9;
                                    break;
                                case 9:
                                    fWidthPercentStart = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fWidthPercentStart10;
                                    fWidthPercentEnd = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fWidthPercentEnd10;
                                    fHeightPercentStart = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fHeightPercentStart10;
                                    fHeightPercentEnd = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fHeightPercentEnd10;
                                    fInwardPercentStart = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fInwardPercentStart10;
                                    fInwardPercentEnd = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fInwardPercentEnd10;
                                    intMeasureMode = ((BlobsFeatures)m_arrTemplateBlobPads[i]).intMeasureMethod10;
                                    break;
                                case 10:
                                    fWidthPercentStart = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fWidthPercentStart11;
                                    fWidthPercentEnd = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fWidthPercentEnd11;
                                    fHeightPercentStart = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fHeightPercentStart11;
                                    fHeightPercentEnd = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fHeightPercentEnd11;
                                    fInwardPercentStart = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fInwardPercentStart11;
                                    fInwardPercentEnd = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fInwardPercentEnd11;
                                    intMeasureMode = ((BlobsFeatures)m_arrTemplateBlobPads[i]).intMeasureMethod11;
                                    break;
                                case 11:
                                    fWidthPercentStart = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fWidthPercentStart12;
                                    fWidthPercentEnd = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fWidthPercentEnd12;
                                    fHeightPercentStart = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fHeightPercentStart12;
                                    fHeightPercentEnd = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fHeightPercentEnd12;
                                    fInwardPercentStart = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fInwardPercentStart12;
                                    fInwardPercentEnd = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fInwardPercentEnd12;
                                    intMeasureMode = ((BlobsFeatures)m_arrTemplateBlobPads[i]).intMeasureMethod12;
                                    break;
                            }

                            if (m_stcBlobPad.blnFeretActivated)
                            {
                                if (m_fPadImageGain != 1f)
                                {
                                    ROI objROI2 = new ROI();
                                    objROI2.LoadROISetting(objROI.ref_ROITotalX, objROI.ref_ROITotalY, objROI.ref_ROIWidth, objROI.ref_ROIHeight);
                                    ImageDrawing objImage = new ImageDrawing(objROI.ref_ROI.TopParent.Width, objROI.ref_ROI.TopParent.Height);
                                    EasyImage.Copy(objROI.ref_ROI.TopParent, objImage.ref_objMainImage);
                                    objROI2.AttachImage(objImage);

                                    EasyImage.GainOffset(objROI2.ref_ROI, objROI2.ref_ROI, m_fPadImageGain);

                                    UpdateBlobSizeAndCenterPointWithGauge_WithIndividualLineAndFeret(objROI2, IndividualfCenterX, IndividualfCenterY,
                                              ref IndividualfWidth, ref IndividualfHeight, ref IndividualfNewCenterX, ref IndividualfNewCenterY, m_intThresholdValue,
                                              fWidthPercentStart, fWidthPercentEnd, fHeightPercentStart, fHeightPercentEnd,
                                              fInwardPercentStart, fInwardPercentEnd,
                                              ((BlobsFeatures)m_arrTemplateBlobPads[i]).intLineCount, j,
                                              ((BlobsFeatures)m_arrTemplateBlobPads[i]).intLengthMode, IndividualfAngle /*((BlobsFeatures)m_arrTemplateBlobPads[i]).fFeretAngle*/, ref IndividualfLine,
                                               //((BlobsFeatures)m_arrTemplateBlobPads[i]).P1X, ((BlobsFeatures)m_arrTemplateBlobPads[i]).P1Y,
                                               //((BlobsFeatures)m_arrTemplateBlobPads[i]).P2X, ((BlobsFeatures)m_arrTemplateBlobPads[i]).P2Y,
                                               //((BlobsFeatures)m_arrTemplateBlobPads[i]).P3X, ((BlobsFeatures)m_arrTemplateBlobPads[i]).P3Y,
                                               //((BlobsFeatures)m_arrTemplateBlobPads[i]).P4X, ((BlobsFeatures)m_arrTemplateBlobPads[i]).P4Y,
                                               ref m_arrSampleBlobPads[i].P1X, ref m_arrSampleBlobPads[i].P1Y,
                                              ref m_arrSampleBlobPads[i].P2X, ref m_arrSampleBlobPads[i].P2Y,
                                              ref m_arrSampleBlobPads[i].P3X, ref m_arrSampleBlobPads[i].P3Y,
                                              ref m_arrSampleBlobPads[i].P4X, ref m_arrSampleBlobPads[i].P4Y,
                                              ref pfStart, ref pfEnd, i);

                                    objROI2.Dispose();
                                    objImage.Dispose();
                                }
                                else
                                {
                                    UpdateBlobSizeAndCenterPointWithGauge_WithIndividualLineAndFeret(objROI, IndividualfCenterX, IndividualfCenterY,
                                           ref IndividualfWidth, ref IndividualfHeight, ref IndividualfNewCenterX, ref IndividualfNewCenterY, m_intThresholdValue,
                                           fWidthPercentStart, fWidthPercentEnd, fHeightPercentStart, fHeightPercentEnd,
                                           fInwardPercentStart, fInwardPercentEnd,
                                           ((BlobsFeatures)m_arrTemplateBlobPads[i]).intLineCount, j,
                                           ((BlobsFeatures)m_arrTemplateBlobPads[i]).intLengthMode, IndividualfAngle /*((BlobsFeatures)m_arrTemplateBlobPads[i]).fFeretAngle*/, ref IndividualfLine,
                                            //((BlobsFeatures)m_arrTemplateBlobPads[i]).P1X, ((BlobsFeatures)m_arrTemplateBlobPads[i]).P1Y,
                                            //((BlobsFeatures)m_arrTemplateBlobPads[i]).P2X, ((BlobsFeatures)m_arrTemplateBlobPads[i]).P2Y,
                                            //((BlobsFeatures)m_arrTemplateBlobPads[i]).P3X, ((BlobsFeatures)m_arrTemplateBlobPads[i]).P3Y,
                                            //((BlobsFeatures)m_arrTemplateBlobPads[i]).P4X, ((BlobsFeatures)m_arrTemplateBlobPads[i]).P4Y,
                                            ref m_arrSampleBlobPads[i].P1X, ref m_arrSampleBlobPads[i].P1Y,
                                           ref m_arrSampleBlobPads[i].P2X, ref m_arrSampleBlobPads[i].P2Y,
                                           ref m_arrSampleBlobPads[i].P3X, ref m_arrSampleBlobPads[i].P3Y,
                                           ref m_arrSampleBlobPads[i].P4X, ref m_arrSampleBlobPads[i].P4Y,
                                           ref pfStart, ref pfEnd, i);
                                }
                            }
                            else
                            {
                                if (m_fPadImageGain != 1f)
                                {
                                    ROI objROI2 = new ROI();
                                    objROI2.LoadROISetting(objROI.ref_ROITotalX, objROI.ref_ROITotalY, objROI.ref_ROIWidth, objROI.ref_ROIHeight);
                                    ImageDrawing objImage = new ImageDrawing(objROI.ref_ROI.TopParent.Width, objROI.ref_ROI.TopParent.Height);
                                    EasyImage.Copy(objROI.ref_ROI.TopParent, objImage.ref_objMainImage);
                                    objROI2.AttachImage(objImage);

                                    EasyImage.GainOffset(objROI2.ref_ROI, objROI2.ref_ROI, m_fPadImageGain);

                                    UpdateBlobSizeAndCenterPointWithGauge_WithIndividualLine(objROI2, IndividualfCenterX, IndividualfCenterY,
                                             ref IndividualfWidth, ref IndividualfHeight, ref IndividualfNewCenterX, ref IndividualfNewCenterY, m_intThresholdValue,
                                             fWidthPercentStart, fWidthPercentEnd, fHeightPercentStart, fHeightPercentEnd,
                                             fInwardPercentStart, fInwardPercentEnd,
                                             ((BlobsFeatures)m_arrTemplateBlobPads[i]).intLineCount, j,
                                             ((BlobsFeatures)m_arrTemplateBlobPads[i]).intLengthMode, ((BlobsFeatures)m_arrTemplateBlobPads[i]).fAngle, ref IndividualfLine,
                                             ((BlobsFeatures)m_arrTemplateBlobPads[i]).P1X, ((BlobsFeatures)m_arrTemplateBlobPads[i]).P1Y,
                                             ((BlobsFeatures)m_arrTemplateBlobPads[i]).P2X, ((BlobsFeatures)m_arrTemplateBlobPads[i]).P2Y,
                                             ((BlobsFeatures)m_arrTemplateBlobPads[i]).P3X, ((BlobsFeatures)m_arrTemplateBlobPads[i]).P3Y,
                                             ((BlobsFeatures)m_arrTemplateBlobPads[i]).P4X, ((BlobsFeatures)m_arrTemplateBlobPads[i]).P4Y,
                                             ref pfStart, ref pfEnd, intMeasureMode, ref pfStart_Ori, ref pfEnd_Ori);

                                    objROI2.Dispose();
                                    objImage.Dispose();
                                }
                                else
                                {
                                    UpdateBlobSizeAndCenterPointWithGauge_WithIndividualLine(objROI, IndividualfCenterX, IndividualfCenterY,
                                         ref IndividualfWidth, ref IndividualfHeight, ref IndividualfNewCenterX, ref IndividualfNewCenterY, m_intThresholdValue,
                                         fWidthPercentStart, fWidthPercentEnd, fHeightPercentStart, fHeightPercentEnd,
                                         fInwardPercentStart, fInwardPercentEnd,
                                         ((BlobsFeatures)m_arrTemplateBlobPads[i]).intLineCount, j,
                                         ((BlobsFeatures)m_arrTemplateBlobPads[i]).intLengthMode, ((BlobsFeatures)m_arrTemplateBlobPads[i]).fAngle, ref IndividualfLine,
                                         ((BlobsFeatures)m_arrTemplateBlobPads[i]).P1X, ((BlobsFeatures)m_arrTemplateBlobPads[i]).P1Y,
                                         ((BlobsFeatures)m_arrTemplateBlobPads[i]).P2X, ((BlobsFeatures)m_arrTemplateBlobPads[i]).P2Y,
                                         ((BlobsFeatures)m_arrTemplateBlobPads[i]).P3X, ((BlobsFeatures)m_arrTemplateBlobPads[i]).P3Y,
                                         ((BlobsFeatures)m_arrTemplateBlobPads[i]).P4X, ((BlobsFeatures)m_arrTemplateBlobPads[i]).P4Y,
                                         ref pfStart, ref pfEnd, intMeasureMode, ref pfStart_Ori, ref pfEnd_Ori);
                                }
                            }
                            switch (j)
                            {
                                case 0:
                                    if (((BlobsFeatures)m_arrTemplateBlobPads[i]).intLengthMode == 1 && !m_stcBlobPad.blnFeretActivated)
                                    {
                                        //t.WriteLine("IndividualfLine fHeight case 0 intLengthMode 1 = " + IndividualfLine.ToString());
                                        //t.WriteLine("IndividualfLine CenterY case 0 intLengthMode 1 = " + IndividualfNewCenterY.ToString());
                                        //fNewCenterY = IndividualfNewCenterY;
                                        //fNewCenterX = IndividualfNewCenterX;
                                        //if (IndividualfLine > 0 && pfStart[j].X > 0 && pfStart[j].Y > 0 && pfEnd[j].X > 0 && pfEnd[j].Y > 0)
                                        if (IndividualfLine > 0 &&
                                            pfStart[j].X > m_intPadEdgeGaugePointToPackageEdgeTolerance &&
                                            pfStart[j].Y > m_intPadEdgeGaugePointToPackageEdgeTolerance &&
                                            pfEnd[j].X > m_intPadEdgeGaugePointToPackageEdgeTolerance &&
                                            pfEnd[j].Y > m_intPadEdgeGaugePointToPackageEdgeTolerance)
                                        {
                                            fNewCenterY = IndividualfNewCenterY;
                                            //fNewCenterX = IndividualfNewCenterX;
                                            fHeight = IndividualfLine;
                                            m_arrSampleBlobPads[i].fHeightMM = IndividualfLine / m_fMMToPixelYValue;
                                        }
                                    }
                                    else if (((BlobsFeatures)m_arrTemplateBlobPads[i]).intLengthMode == 2 && !m_stcBlobPad.blnFeretActivated)
                                    {
                                        //t.WriteLine("IndividualfLine fWidth case 1 intLengthMode 2 = " + IndividualfLine.ToString());
                                        //t.WriteLine("IndividualfLine CenterX case 1 intLengthMode 2 = " + IndividualfNewCenterX.ToString());

                                        //fNewCenterY = IndividualfNewCenterY;
                                        //fNewCenterX = IndividualfNewCenterX;
                                        //if (IndividualfLine > 0 && pfStart[j].X > 0 && pfStart[j].Y > 0 && pfEnd[j].X > 0 && pfEnd[j].Y > 0)
                                        if (IndividualfLine > 0 &&
                                            pfStart[j].X > m_intPadEdgeGaugePointToPackageEdgeTolerance &&
                                            pfStart[j].Y > m_intPadEdgeGaugePointToPackageEdgeTolerance &&
                                            pfEnd[j].X > m_intPadEdgeGaugePointToPackageEdgeTolerance &&
                                            pfEnd[j].Y > m_intPadEdgeGaugePointToPackageEdgeTolerance)
                                        {
                                            //fNewCenterY = IndividualfNewCenterY;
                                            fNewCenterX = IndividualfNewCenterX;
                                            fWidth = IndividualfLine;

                                            m_arrSampleBlobPads[i].fWidthMM = IndividualfLine / m_fMMToPixelXValue;
                                        }
                                    }
                                    if (IndividualfWidth >= IndividualfHeight && m_stcBlobPad.blnFeretActivated)//if (m_stcBlobPad.fFeretAngle < 85 && m_stcBlobPad.fFeretAngle > -85 && m_stcBlobPad.blnFeretActivated)
                                    {
                                        //t.WriteLine("IndividualfLine fHeight case 0 intLengthMode 1 = " + IndividualfLine.ToString());
                                        //t.WriteLine("IndividualfLine CenterY case 0 intLengthMode 1 = " + IndividualfNewCenterY.ToString());
                                        //fNewCenterY = IndividualfNewCenterY;
                                        //fNewCenterX = IndividualfNewCenterX;
                                        //if (IndividualfLine > 0 && pfStart[j].X > 0 && pfStart[j].Y > 0 && pfEnd[j].X > 0 && pfEnd[j].Y > 0)
                                        if (IndividualfLine > 0 &&
                                            pfStart[j].X > m_intPadEdgeGaugePointToPackageEdgeTolerance &&
                                            pfStart[j].Y > m_intPadEdgeGaugePointToPackageEdgeTolerance &&
                                            pfEnd[j].X > m_intPadEdgeGaugePointToPackageEdgeTolerance &&
                                            pfEnd[j].Y > m_intPadEdgeGaugePointToPackageEdgeTolerance)
                                        {

                                            fNewCenterY = IndividualfNewCenterY;
                                            //fNewCenterX = IndividualfNewCenterX;
                                            fHeight = IndividualfLine;
                                            m_arrSampleBlobPads[i].fHeightMM = IndividualfLine / m_fMMToPixelYValue;
                                        }
                                    }
                                    if (m_stcBlobPad.blnFeretActivated && IndividualfWidth <= IndividualfHeight)// else if (m_stcBlobPad.fFeretAngle <= -85 && m_stcBlobPad.fFeretAngle >= 85 && m_stcBlobPad.blnFeretActivated)
                                    {
                                        //t.WriteLine("IndividualfLine fWidth case 1 intLengthMode 2 = " + IndividualfLine.ToString());
                                        //t.WriteLine("IndividualfLine CenterX case 1 intLengthMode 2 = " + IndividualfNewCenterX.ToString());

                                        //fNewCenterY = IndividualfNewCenterY;
                                        //fNewCenterX = IndividualfNewCenterX;
                                        //if (IndividualfLine > 0 && pfStart[j].X > 0 && pfStart[j].Y > 0 && pfEnd[j].X > 0 && pfEnd[j].Y > 0)
                                        if (IndividualfLine > 0 &&
                                            pfStart[j].X > m_intPadEdgeGaugePointToPackageEdgeTolerance &&
                                            pfStart[j].Y > m_intPadEdgeGaugePointToPackageEdgeTolerance &&
                                            pfEnd[j].X > m_intPadEdgeGaugePointToPackageEdgeTolerance &&
                                            pfEnd[j].Y > m_intPadEdgeGaugePointToPackageEdgeTolerance)
                                        {
                                            //if (pfStart[j].X == pfEnd[j].X)
                                            //    fNewCenterY = IndividualfNewCenterY;
                                            //else
                                            fNewCenterX = IndividualfNewCenterX;
                                            fWidth = IndividualfLine;

                                            m_arrSampleBlobPads[i].fWidthMM = IndividualfLine / m_fMMToPixelXValue;
                                        }
                                    }

                                    if (pfStart[j].X != m_intPadEdgeGaugePointToPackageEdgeTolerance)
                                        m_arrSampleBlobPads[i].fStartXLine1 = pfStart[j].X;
                                    else
                                        m_arrSampleBlobPads[i].fStartXLine1 = pfStart_Ori[j].X;
                                    if (pfStart[j].Y != m_intPadEdgeGaugePointToPackageEdgeTolerance)
                                        m_arrSampleBlobPads[i].fStartYLine1 = pfStart[j].Y;
                                    else
                                        m_arrSampleBlobPads[i].fStartYLine1 = pfStart_Ori[j].Y;
                                    if (pfEnd[j].X != m_intPadEdgeGaugePointToPackageEdgeTolerance)
                                        m_arrSampleBlobPads[i].fEndXLine1 = pfEnd[j].X;
                                    else
                                        m_arrSampleBlobPads[i].fEndXLine1 = pfEnd_Ori[j].X;
                                    if (pfEnd[j].Y != m_intPadEdgeGaugePointToPackageEdgeTolerance)
                                        m_arrSampleBlobPads[i].fEndYLine1 = pfEnd[j].Y;
                                    else
                                        m_arrSampleBlobPads[i].fEndYLine1 = pfEnd_Ori[j].Y;
                                    break;
                                case 1:
                                    if (((BlobsFeatures)m_arrTemplateBlobPads[i]).intLengthMode == 1 && !m_stcBlobPad.blnFeretActivated)
                                    {
                                        //t.WriteLine("IndividualfLine fWidth case 1 intLengthMode 1 = " + IndividualfLine.ToString());
                                        //t.WriteLine("IndividualfLine CenterX case 1 intLengthMode 1 = " + IndividualfNewCenterX.ToString());

                                        //fNewCenterY = (IndividualfNewCenterY + fNewCenterY) / 2;
                                        //fNewCenterX = (IndividualfNewCenterX + fNewCenterX) / 2;
                                        //if (IndividualfLine > 0 && pfStart[j].X > 0 && pfStart[j].Y > 0 && pfEnd[j].X > 0 && pfEnd[j].Y > 0)
                                        if (IndividualfLine > 0 &&
                                            pfStart[j].X > m_intPadEdgeGaugePointToPackageEdgeTolerance &&
                                            pfStart[j].Y > m_intPadEdgeGaugePointToPackageEdgeTolerance &&
                                            pfEnd[j].X > m_intPadEdgeGaugePointToPackageEdgeTolerance &&
                                            pfEnd[j].Y > m_intPadEdgeGaugePointToPackageEdgeTolerance)
                                        {

                                            //fNewCenterY = IndividualfNewCenterY;
                                            fNewCenterX = IndividualfNewCenterX;
                                            fWidth = IndividualfLine;
                                         
                                            m_arrSampleBlobPads[i].fWidthMM = IndividualfLine / m_fMMToPixelXValue;
                                        }
                                    }
                                    else if (((BlobsFeatures)m_arrTemplateBlobPads[i]).intLengthMode == 2 && !m_stcBlobPad.blnFeretActivated)
                                    {
                                        //t.WriteLine("IndividualfLine fHeight case 0 intLengthMode 2 = " + IndividualfLine.ToString());
                                        //t.WriteLine("IndividualfLine CenterY case 0 intLengthMode 2 = " + IndividualfNewCenterY.ToString());
                                        //fNewCenterY = (IndividualfNewCenterY + fNewCenterY) / 2;
                                        //fNewCenterX = (IndividualfNewCenterX + fNewCenterX) / 2;
                                        //if (IndividualfLine > 0 && pfStart[j].X > 0 && pfStart[j].Y > 0 && pfEnd[j].X > 0 && pfEnd[j].Y > 0)
                                        if (IndividualfLine > 0 &&
                                            pfStart[j].X > m_intPadEdgeGaugePointToPackageEdgeTolerance &&
                                            pfStart[j].Y > m_intPadEdgeGaugePointToPackageEdgeTolerance &&
                                            pfEnd[j].X > m_intPadEdgeGaugePointToPackageEdgeTolerance &&
                                            pfEnd[j].Y > m_intPadEdgeGaugePointToPackageEdgeTolerance)
                                        {

                                            fNewCenterY = IndividualfNewCenterY;
                                            //fNewCenterX = IndividualfNewCenterX;
                                            fHeight = IndividualfLine;
                                            m_arrSampleBlobPads[i].fHeightMM = IndividualfLine / m_fMMToPixelYValue;
                                        }
                                    }
                                    if (IndividualfWidth >= IndividualfHeight && m_stcBlobPad.blnFeretActivated)//if (m_stcBlobPad.fFeretAngle < 85 && m_stcBlobPad.fFeretAngle > -85 && m_stcBlobPad.blnFeretActivated)
                                    {
                                        //t.WriteLine("IndividualfLine fWidth case 1 intLengthMode 1 = " + IndividualfLine.ToString());
                                        //t.WriteLine("IndividualfLine CenterX case 1 intLengthMode 1 = " + IndividualfNewCenterX.ToString());

                                        //fNewCenterY = (IndividualfNewCenterY + fNewCenterY) / 2;
                                        //fNewCenterX = (IndividualfNewCenterX + fNewCenterX) / 2;
                                        //if (IndividualfLine > 0 && pfStart[j].X > 0 && pfStart[j].Y > 0 && pfEnd[j].X > 0 && pfEnd[j].Y > 0)
                                        if (IndividualfLine > 0 &&
                                            pfStart[j].X > m_intPadEdgeGaugePointToPackageEdgeTolerance &&
                                            pfStart[j].Y > m_intPadEdgeGaugePointToPackageEdgeTolerance &&
                                            pfEnd[j].X > m_intPadEdgeGaugePointToPackageEdgeTolerance &&
                                            pfEnd[j].Y > m_intPadEdgeGaugePointToPackageEdgeTolerance)
                                        {

                                            //fNewCenterY = IndividualfNewCenterY;
                                            fNewCenterX = IndividualfNewCenterX;
                                            fWidth = IndividualfLine;
                                        
                                            m_arrSampleBlobPads[i].fWidthMM = IndividualfLine / m_fMMToPixelXValue;
                                        }
                                    }
                                    if (m_stcBlobPad.blnFeretActivated && IndividualfWidth <= IndividualfHeight)//else if (m_stcBlobPad.fFeretAngle <= -85 && m_stcBlobPad.fFeretAngle >= 85 && m_stcBlobPad.blnFeretActivated)
                                    {
                                        //    t.WriteLine("IndividualfLine fHeight case 0 intLengthMode 2 = " + IndividualfLine.ToString());
                                        //    t.WriteLine("IndividualfLine CenterY case 0 intLengthMode 2 = " + IndividualfNewCenterY.ToString());
                                        //fNewCenterY = (IndividualfNewCenterY + fNewCenterY) / 2;
                                        //fNewCenterX = (IndividualfNewCenterX + fNewCenterX) / 2;
                                        //if (IndividualfLine > 0 && pfStart[j].X > 0 && pfStart[j].Y > 0 && pfEnd[j].X > 0 && pfEnd[j].Y > 0)
                                        if (IndividualfLine > 0 &&
                                            pfStart[j].X > m_intPadEdgeGaugePointToPackageEdgeTolerance &&
                                            pfStart[j].Y > m_intPadEdgeGaugePointToPackageEdgeTolerance &&
                                            pfEnd[j].X > m_intPadEdgeGaugePointToPackageEdgeTolerance &&
                                            pfEnd[j].Y > m_intPadEdgeGaugePointToPackageEdgeTolerance)
                                        {
                                            //if (pfStart[j].X == pfEnd[j].X)
                                            fNewCenterY = IndividualfNewCenterY;
                                            //else
                                            //    fNewCenterX = IndividualfNewCenterX;
                                            fHeight = IndividualfLine;
                                            m_arrSampleBlobPads[i].fHeightMM = IndividualfLine / m_fMMToPixelYValue;
                                        }
                                    }

                                    if (pfStart[j].X != m_intPadEdgeGaugePointToPackageEdgeTolerance)
                                        m_arrSampleBlobPads[i].fStartXLine2 = pfStart[j].X;
                                    else
                                        m_arrSampleBlobPads[i].fStartXLine2 = pfStart_Ori[j].X;
                                    if (pfStart[j].Y != m_intPadEdgeGaugePointToPackageEdgeTolerance)
                                        m_arrSampleBlobPads[i].fStartYLine2 = pfStart[j].Y;
                                    else
                                        m_arrSampleBlobPads[i].fStartYLine2 = pfStart_Ori[j].Y;
                                    if (pfEnd[j].X != m_intPadEdgeGaugePointToPackageEdgeTolerance)
                                        m_arrSampleBlobPads[i].fEndXLine2 = pfEnd[j].X;
                                    else
                                        m_arrSampleBlobPads[i].fEndXLine2 = pfEnd_Ori[j].X;
                                    if (pfEnd[j].Y != m_intPadEdgeGaugePointToPackageEdgeTolerance)
                                        m_arrSampleBlobPads[i].fEndYLine2 = pfEnd[j].Y;
                                    else
                                        m_arrSampleBlobPads[i].fEndYLine2 = pfEnd_Ori[j].Y;
                                    break;
                                case 2:
                                    if (pfStart[j].X != m_intPadEdgeGaugePointToPackageEdgeTolerance)
                                        m_arrSampleBlobPads[i].fStartXLine3 = pfStart[j].X;
                                    else
                                        m_arrSampleBlobPads[i].fStartXLine3 = pfStart_Ori[j].X;
                                    if (pfStart[j].Y != m_intPadEdgeGaugePointToPackageEdgeTolerance)
                                        m_arrSampleBlobPads[i].fStartYLine3 = pfStart[j].Y;
                                    else
                                        m_arrSampleBlobPads[i].fStartYLine3 = pfStart_Ori[j].Y;
                                    if (pfEnd[j].X != m_intPadEdgeGaugePointToPackageEdgeTolerance)
                                        m_arrSampleBlobPads[i].fEndXLine3 = pfEnd[j].X;
                                    else
                                        m_arrSampleBlobPads[i].fEndXLine3 = pfEnd_Ori[j].X;
                                    if (pfEnd[j].Y != m_intPadEdgeGaugePointToPackageEdgeTolerance)
                                        m_arrSampleBlobPads[i].fEndYLine3 = pfEnd[j].Y;
                                    else
                                        m_arrSampleBlobPads[i].fEndYLine3 = pfEnd_Ori[j].Y;
                                    // 2019-10-24 ZJYEOH : Convert unit using calibration data X and Y respectively when calculate length
                                    if (IndividualfLine > 0)
                                        fLine3MM = m_arrSampleBlobPads[i].fLine3MM = (float)Math.Sqrt(Math.Pow(Math.Abs(pfStart[j].X - pfEnd[j].X) / m_fMMToPixelXValue, 2) + Math.Pow(Math.Abs(pfStart[j].Y - pfEnd[j].Y) / m_fMMToPixelYValue, 2));
                                    //fLine3MM = m_arrSampleBlobPads[i].fLine3MM = IndividualfLine / m_fMMToPixelXValue;
                                    break;
                                case 3:
                                    if (pfStart[j].X != m_intPadEdgeGaugePointToPackageEdgeTolerance)
                                        m_arrSampleBlobPads[i].fStartXLine4 = pfStart[j].X;
                                    else
                                        m_arrSampleBlobPads[i].fStartXLine4 = pfStart_Ori[j].X;
                                    if (pfStart[j].Y != m_intPadEdgeGaugePointToPackageEdgeTolerance)
                                        m_arrSampleBlobPads[i].fStartYLine4 = pfStart[j].Y;
                                    else
                                        m_arrSampleBlobPads[i].fStartYLine4 = pfStart_Ori[j].Y;
                                    if (pfEnd[j].X != m_intPadEdgeGaugePointToPackageEdgeTolerance)
                                        m_arrSampleBlobPads[i].fEndXLine4 = pfEnd[j].X;
                                    else
                                        m_arrSampleBlobPads[i].fEndXLine4 = pfEnd_Ori[j].X;
                                    if (pfEnd[j].Y != m_intPadEdgeGaugePointToPackageEdgeTolerance)
                                        m_arrSampleBlobPads[i].fEndYLine4 = pfEnd[j].Y;
                                    else
                                        m_arrSampleBlobPads[i].fEndYLine4 = pfEnd_Ori[j].Y;
                                    // 2019-10-24 ZJYEOH : Convert unit using calibration data X and Y respectively when calculate length
                                    if (IndividualfLine > 0)
                                        fLine4MM = m_arrSampleBlobPads[i].fLine4MM = (float)Math.Sqrt(Math.Pow(Math.Abs(pfStart[j].X - pfEnd[j].X) / m_fMMToPixelXValue, 2) + Math.Pow(Math.Abs(pfStart[j].Y - pfEnd[j].Y) / m_fMMToPixelYValue, 2));
                                    //fLine4MM = m_arrSampleBlobPads[i].fLine4MM = IndividualfLine / m_fMMToPixelXValue;
                                    break;
                                case 4:
                                    if (pfStart[j].X != m_intPadEdgeGaugePointToPackageEdgeTolerance)
                                        m_arrSampleBlobPads[i].fStartXLine5 = pfStart[j].X;
                                    else
                                        m_arrSampleBlobPads[i].fStartXLine5 = pfStart_Ori[j].X;
                                    if (pfStart[j].Y != m_intPadEdgeGaugePointToPackageEdgeTolerance)
                                        m_arrSampleBlobPads[i].fStartYLine5 = pfStart[j].Y;
                                    else
                                        m_arrSampleBlobPads[i].fStartYLine5 = pfStart_Ori[j].Y;
                                    if (pfEnd[j].X != m_intPadEdgeGaugePointToPackageEdgeTolerance)
                                        m_arrSampleBlobPads[i].fEndXLine5 = pfEnd[j].X;
                                    else
                                        m_arrSampleBlobPads[i].fEndXLine5 = pfEnd_Ori[j].X;
                                    if (pfEnd[j].Y != m_intPadEdgeGaugePointToPackageEdgeTolerance)
                                        m_arrSampleBlobPads[i].fEndYLine5 = pfEnd[j].Y;
                                    else
                                        m_arrSampleBlobPads[i].fEndYLine5 = pfEnd_Ori[j].Y;
                                    // 2019-10-24 ZJYEOH : Convert unit using calibration data X and Y respectively when calculate length
                                    if (IndividualfLine > 0)
                                        fLine5MM = m_arrSampleBlobPads[i].fLine5MM = (float)Math.Sqrt(Math.Pow(Math.Abs(pfStart[j].X - pfEnd[j].X) / m_fMMToPixelXValue, 2) + Math.Pow(Math.Abs(pfStart[j].Y - pfEnd[j].Y) / m_fMMToPixelYValue, 2));
                                    //fLine5MM = m_arrSampleBlobPads[i].fLine5MM = IndividualfLine / m_fMMToPixelXValue;
                                    break;
                                case 5:
                                    if (pfStart[j].X != m_intPadEdgeGaugePointToPackageEdgeTolerance)
                                        m_arrSampleBlobPads[i].fStartXLine6 = pfStart[j].X;
                                    else
                                        m_arrSampleBlobPads[i].fStartXLine6 = pfStart_Ori[j].X;
                                    if (pfStart[j].Y != m_intPadEdgeGaugePointToPackageEdgeTolerance)
                                        m_arrSampleBlobPads[i].fStartYLine6 = pfStart[j].Y;
                                    else
                                        m_arrSampleBlobPads[i].fStartYLine6 = pfStart_Ori[j].Y;
                                    if (pfEnd[j].X != m_intPadEdgeGaugePointToPackageEdgeTolerance)
                                        m_arrSampleBlobPads[i].fEndXLine6 = pfEnd[j].X;
                                    else
                                        m_arrSampleBlobPads[i].fEndXLine6 = pfEnd_Ori[j].X;
                                    if (pfEnd[j].Y != m_intPadEdgeGaugePointToPackageEdgeTolerance)
                                        m_arrSampleBlobPads[i].fEndYLine6 = pfEnd[j].Y;
                                    else
                                        m_arrSampleBlobPads[i].fEndYLine6 = pfEnd_Ori[j].Y;
                                    // 2019-10-24 ZJYEOH : Convert unit using calibration data X and Y respectively when calculate length
                                    if (IndividualfLine > 0)
                                        fLine6MM = m_arrSampleBlobPads[i].fLine6MM = (float)Math.Sqrt(Math.Pow(Math.Abs(pfStart[j].X - pfEnd[j].X) / m_fMMToPixelXValue, 2) + Math.Pow(Math.Abs(pfStart[j].Y - pfEnd[j].Y) / m_fMMToPixelYValue, 2));
                                    //fLine6MM = m_arrSampleBlobPads[i].fLine6MM = IndividualfLine / m_fMMToPixelXValue;
                                    break;
                                case 6:
                                    if (pfStart[j].X != m_intPadEdgeGaugePointToPackageEdgeTolerance)
                                        m_arrSampleBlobPads[i].fStartXLine7 = pfStart[j].X;
                                    else
                                        m_arrSampleBlobPads[i].fStartXLine7 = pfStart_Ori[j].X;
                                    if (pfStart[j].Y != m_intPadEdgeGaugePointToPackageEdgeTolerance)
                                        m_arrSampleBlobPads[i].fStartYLine7 = pfStart[j].Y;
                                    else
                                        m_arrSampleBlobPads[i].fStartYLine7 = pfStart_Ori[j].Y;
                                    if (pfEnd[j].X != m_intPadEdgeGaugePointToPackageEdgeTolerance)
                                        m_arrSampleBlobPads[i].fEndXLine7 = pfEnd[j].X;
                                    else
                                        m_arrSampleBlobPads[i].fEndXLine7 = pfEnd_Ori[j].X;
                                    if (pfEnd[j].Y != m_intPadEdgeGaugePointToPackageEdgeTolerance)
                                        m_arrSampleBlobPads[i].fEndYLine7 = pfEnd[j].Y;
                                    else
                                        m_arrSampleBlobPads[i].fEndYLine7 = pfEnd_Ori[j].Y;
                                    // 2019-10-24 ZJYEOH : Convert unit using calibration data X and Y respectively when calculate length
                                    if (IndividualfLine > 0)
                                        fLine7MM = m_arrSampleBlobPads[i].fLine7MM = (float)Math.Sqrt(Math.Pow(Math.Abs(pfStart[j].X - pfEnd[j].X) / m_fMMToPixelXValue, 2) + Math.Pow(Math.Abs(pfStart[j].Y - pfEnd[j].Y) / m_fMMToPixelYValue, 2));
                                    //fLine7MM = m_arrSampleBlobPads[i].fLine7MM = IndividualfLine / m_fMMToPixelXValue;
                                    break;
                                case 7:
                                    if (pfStart[j].X != m_intPadEdgeGaugePointToPackageEdgeTolerance)
                                        m_arrSampleBlobPads[i].fStartXLine8 = pfStart[j].X;
                                    else
                                        m_arrSampleBlobPads[i].fStartXLine8 = pfStart_Ori[j].X;
                                    if (pfStart[j].Y != m_intPadEdgeGaugePointToPackageEdgeTolerance)
                                        m_arrSampleBlobPads[i].fStartYLine8 = pfStart[j].Y;
                                    else
                                        m_arrSampleBlobPads[i].fStartYLine8 = pfStart_Ori[j].Y;
                                    if (pfEnd[j].X != m_intPadEdgeGaugePointToPackageEdgeTolerance)
                                        m_arrSampleBlobPads[i].fEndXLine8 = pfEnd[j].X;
                                    else
                                        m_arrSampleBlobPads[i].fEndXLine8 = pfEnd_Ori[j].X;
                                    if (pfEnd[j].Y != m_intPadEdgeGaugePointToPackageEdgeTolerance)
                                        m_arrSampleBlobPads[i].fEndYLine8 = pfEnd[j].Y;
                                    else
                                        m_arrSampleBlobPads[i].fEndYLine8 = pfEnd_Ori[j].Y;
                                    // 2019-10-24 ZJYEOH : Convert unit using calibration data X and Y respectively when calculate length
                                    if (IndividualfLine > 0)
                                        fLine8MM = m_arrSampleBlobPads[i].fLine8MM = (float)Math.Sqrt(Math.Pow(Math.Abs(pfStart[j].X - pfEnd[j].X) / m_fMMToPixelXValue, 2) + Math.Pow(Math.Abs(pfStart[j].Y - pfEnd[j].Y) / m_fMMToPixelYValue, 2));
                                    //fLine8MM = m_arrSampleBlobPads[i].fLine8MM = IndividualfLine / m_fMMToPixelXValue;
                                    break;
                                case 8:
                                    if (pfStart[j].X != m_intPadEdgeGaugePointToPackageEdgeTolerance)
                                        m_arrSampleBlobPads[i].fStartXLine9 = pfStart[j].X;
                                    else
                                        m_arrSampleBlobPads[i].fStartXLine9 = pfStart_Ori[j].X;
                                    if (pfStart[j].Y != m_intPadEdgeGaugePointToPackageEdgeTolerance)
                                        m_arrSampleBlobPads[i].fStartYLine9 = pfStart[j].Y;
                                    else
                                        m_arrSampleBlobPads[i].fStartYLine9 = pfStart_Ori[j].Y;
                                    if (pfEnd[j].X != m_intPadEdgeGaugePointToPackageEdgeTolerance)
                                        m_arrSampleBlobPads[i].fEndXLine9 = pfEnd[j].X;
                                    else
                                        m_arrSampleBlobPads[i].fEndXLine9 = pfEnd_Ori[j].X;
                                    if (pfEnd[j].Y != m_intPadEdgeGaugePointToPackageEdgeTolerance)
                                        m_arrSampleBlobPads[i].fEndYLine9 = pfEnd[j].Y;
                                    else
                                        m_arrSampleBlobPads[i].fEndYLine9 = pfEnd_Ori[j].Y;
                                    // 2019-10-24 ZJYEOH : Convert unit using calibration data X and Y respectively when calculate length
                                    if (IndividualfLine > 0)
                                        fLine9MM = m_arrSampleBlobPads[i].fLine9MM = (float)Math.Sqrt(Math.Pow(Math.Abs(pfStart[j].X - pfEnd[j].X) / m_fMMToPixelXValue, 2) + Math.Pow(Math.Abs(pfStart[j].Y - pfEnd[j].Y) / m_fMMToPixelYValue, 2));
                                    //fLine9MM = m_arrSampleBlobPads[i].fLine9MM = IndividualfLine / m_fMMToPixelXValue;
                                    break;
                                case 9:
                                    if (pfStart[j].X != m_intPadEdgeGaugePointToPackageEdgeTolerance)
                                        m_arrSampleBlobPads[i].fStartXLine10 = pfStart[j].X;
                                    else
                                        m_arrSampleBlobPads[i].fStartXLine10 = pfStart_Ori[j].X;
                                    if (pfStart[j].Y != m_intPadEdgeGaugePointToPackageEdgeTolerance)
                                        m_arrSampleBlobPads[i].fStartYLine10 = pfStart[j].Y;
                                    else
                                        m_arrSampleBlobPads[i].fStartYLine10 = pfStart_Ori[j].Y;
                                    if (pfEnd[j].X != m_intPadEdgeGaugePointToPackageEdgeTolerance)
                                        m_arrSampleBlobPads[i].fEndXLine10 = pfEnd[j].X;
                                    else
                                        m_arrSampleBlobPads[i].fEndXLine10 = pfEnd_Ori[j].X;
                                    if (pfEnd[j].Y != m_intPadEdgeGaugePointToPackageEdgeTolerance)
                                        m_arrSampleBlobPads[i].fEndYLine10 = pfEnd[j].Y;
                                    else
                                        m_arrSampleBlobPads[i].fEndYLine10 = pfEnd_Ori[j].Y;
                                    // 2019-10-24 ZJYEOH : Convert unit using calibration data X and Y respectively when calculate length
                                    if (IndividualfLine > 0)
                                        fLine10MM = m_arrSampleBlobPads[i].fLine10MM = (float)Math.Sqrt(Math.Pow(Math.Abs(pfStart[j].X - pfEnd[j].X) / m_fMMToPixelXValue, 2) + Math.Pow(Math.Abs(pfStart[j].Y - pfEnd[j].Y) / m_fMMToPixelYValue, 2));
                                    //fLine10MM = m_arrSampleBlobPads[i].fLine10MM = IndividualfLine / m_fMMToPixelXValue;
                                    break;
                                case 10:
                                    if (pfStart[j].X != m_intPadEdgeGaugePointToPackageEdgeTolerance)
                                        m_arrSampleBlobPads[i].fStartXLine11 = pfStart[j].X;
                                    else
                                        m_arrSampleBlobPads[i].fStartXLine11 = pfStart_Ori[j].X;
                                    if (pfStart[j].Y != m_intPadEdgeGaugePointToPackageEdgeTolerance)
                                        m_arrSampleBlobPads[i].fStartYLine11 = pfStart[j].Y;
                                    else
                                        m_arrSampleBlobPads[i].fStartYLine11 = pfStart_Ori[j].Y;
                                    if (pfEnd[j].X != m_intPadEdgeGaugePointToPackageEdgeTolerance)
                                        m_arrSampleBlobPads[i].fEndXLine11 = pfEnd[j].X;
                                    else
                                        m_arrSampleBlobPads[i].fEndXLine11 = pfEnd_Ori[j].X;
                                    if (pfEnd[j].Y != m_intPadEdgeGaugePointToPackageEdgeTolerance)
                                        m_arrSampleBlobPads[i].fEndYLine11 = pfEnd[j].Y;
                                    else
                                        m_arrSampleBlobPads[i].fEndYLine11 = pfEnd_Ori[j].Y;
                                    // 2019-10-24 ZJYEOH : Convert unit using calibration data X and Y respectively when calculate length
                                    if (IndividualfLine > 0)
                                        fLine11MM = m_arrSampleBlobPads[i].fLine11MM = (float)Math.Sqrt(Math.Pow(Math.Abs(pfStart[j].X - pfEnd[j].X) / m_fMMToPixelXValue, 2) + Math.Pow(Math.Abs(pfStart[j].Y - pfEnd[j].Y) / m_fMMToPixelYValue, 2));
                                    //fLine11MM = m_arrSampleBlobPads[i].fLine11MM = IndividualfLine / m_fMMToPixelXValue;
                                    break;
                                case 11:
                                    if (pfStart[j].X != m_intPadEdgeGaugePointToPackageEdgeTolerance)
                                        m_arrSampleBlobPads[i].fStartXLine12 = pfStart[j].X;
                                    else
                                        m_arrSampleBlobPads[i].fStartXLine12 = pfStart_Ori[j].X;
                                    if (pfStart[j].Y != m_intPadEdgeGaugePointToPackageEdgeTolerance)
                                        m_arrSampleBlobPads[i].fStartYLine12 = pfStart[j].Y;
                                    else
                                        m_arrSampleBlobPads[i].fStartYLine12 = pfStart_Ori[j].Y;
                                    if (pfEnd[j].X != m_intPadEdgeGaugePointToPackageEdgeTolerance)
                                        m_arrSampleBlobPads[i].fEndXLine12 = pfEnd[j].X;
                                    else
                                        m_arrSampleBlobPads[i].fEndXLine12 = pfEnd_Ori[j].X;
                                    if (pfEnd[j].Y != m_intPadEdgeGaugePointToPackageEdgeTolerance)
                                        m_arrSampleBlobPads[i].fEndYLine12 = pfEnd[j].Y;
                                    else
                                        m_arrSampleBlobPads[i].fEndYLine12 = pfEnd_Ori[j].Y;
                                    // 2019-10-24 ZJYEOH : Convert unit using calibration data X and Y respectively when calculate length
                                    if (IndividualfLine > 0)
                                        fLine12MM = m_arrSampleBlobPads[i].fLine12MM = (float)Math.Sqrt(Math.Pow(Math.Abs(pfStart[j].X - pfEnd[j].X) / m_fMMToPixelXValue, 2) + Math.Pow(Math.Abs(pfStart[j].Y - pfEnd[j].Y) / m_fMMToPixelYValue, 2));
                                    //fLine12MM = m_arrSampleBlobPads[i].fLine12MM = IndividualfLine / m_fMMToPixelXValue;
                                    break;
                            }
                        }
                        //if (pfStart[0].X > 0 && pfStart[0].Y > 0 && pfStart[1].X > 0 && pfStart[1].Y > 0 && pfEnd[0].X > 0 && pfEnd[0].Y > 0 && pfEnd[1].X > 0 && pfEnd[1].Y > 0)// && m_stcBlobPad.blnFeretActivated)
                        //    Math2.GetCenterPointWithFourPointFormingRectangle(pfStart, pfEnd, ref fNewCenterX, ref fNewCenterY);

                        if (m_blnWantCollectPadEdgeGaugePoints)
                        {
                            for (int p = m_arrPadEdgeGaugePoints.Count; p <= i; p++)
                            {
                                m_arrPadEdgeGaugePoints.Add(new List<PointF>());
                                m_arrPadEdgeGaugePointsFound.Add(new List<bool>());
                            }

                            for (int p = m_arrPadPointGaugeStartX.Count; p <= i; p++)
                            {
                                m_arrPadPointGaugeStartX.Add(new List<float>());
                                m_arrPadPointGaugeStartX[m_arrPadPointGaugeStartX.Count - 1].Add(m_objPointGauge.ref_GaugeCenterX);
                                m_arrPadPointGaugeStartX[m_arrPadPointGaugeStartX.Count - 1].Add(-1);
                                m_arrPadPointGaugeStartX[m_arrPadPointGaugeStartX.Count - 1].Add(-1);
                                m_arrPadPointGaugeStartX[m_arrPadPointGaugeStartX.Count - 1].Add(-1);

                                m_arrPadPointGaugeStartY.Add(new List<float>());
                                m_arrPadPointGaugeStartY[m_arrPadPointGaugeStartY.Count - 1].Add(m_objPointGauge.ref_GaugeCenterY);
                                m_arrPadPointGaugeStartY[m_arrPadPointGaugeStartY.Count - 1].Add(-1);
                                m_arrPadPointGaugeStartY[m_arrPadPointGaugeStartY.Count - 1].Add(-1);
                                m_arrPadPointGaugeStartY[m_arrPadPointGaugeStartY.Count - 1].Add(-1);

                                m_arrPadPointGaugeTolerance.Add(new List<float>());
                                m_arrPadPointGaugeTolerance[m_arrPadPointGaugeTolerance.Count - 1].Add(m_objPointGauge.ref_GaugeTolerance);
                                m_arrPadPointGaugeTolerance[m_arrPadPointGaugeTolerance.Count - 1].Add(-1);
                                m_arrPadPointGaugeTolerance[m_arrPadPointGaugeTolerance.Count - 1].Add(-1);
                                m_arrPadPointGaugeTolerance[m_arrPadPointGaugeTolerance.Count - 1].Add(-1);

                                m_arrPadPointGaugeAngle.Add(new List<float>());
                                m_arrPadPointGaugeAngle[m_arrPadPointGaugeAngle.Count - 1].Add(m_objPointGauge.ref_GaugeAngle);
                                m_arrPadPointGaugeAngle[m_arrPadPointGaugeAngle.Count - 1].Add(-1);
                                m_arrPadPointGaugeAngle[m_arrPadPointGaugeAngle.Count - 1].Add(-1);
                                m_arrPadPointGaugeAngle[m_arrPadPointGaugeAngle.Count - 1].Add(-1);
                            }

                            if (((BlobsFeatures)m_arrTemplateBlobPads[i]).intLengthMode == 1)
                            {
                                /*
                                 *          0=start0
                                 * 3=start1           1=end1
                                 *          2=End0
                                 */

                                // 2020 07 09 - CCENG: add some tolerance to pad edge point result. Sometime edge point result will have slighly out a bit of Pad ROI.
                                //if (pfStart[0].X >= 0 && pfStart[0].Y >= 0)
                                if (pfStart[0].X >= m_intPadEdgeGaugePointToPackageEdgeTolerance && pfStart[0].Y >= m_intPadEdgeGaugePointToPackageEdgeTolerance)
                                {
                                    m_arrPadEdgeGaugePoints[i].Add(new PointF(objROI.ref_ROI.TotalOrgX + pfStart[0].X, objROI.ref_ROI.TotalOrgY + pfStart[0].Y));
                                    m_arrPadEdgeGaugePointsFound[i].Add(true);
                                }
                                else
                                {
                                    m_arrPadEdgeGaugePoints[i].Add(new PointF(m_arrPadPointGaugeStartX[i][0], m_arrPadPointGaugeStartY[i][0])); //objROI.ref_ROI.TotalOrgX + fLimitCenterX, objROI.ref_ROI.TotalOrgY + fLimitCenterY - fHeight / 2
                                    m_arrPadEdgeGaugePointsFound[i].Add(false);
                                }

                                //if (pfEnd[1].X >= 0 && pfEnd[1].Y >= 0)
                                if (pfEnd[1].X >= m_intPadEdgeGaugePointToPackageEdgeTolerance && pfEnd[1].Y >= m_intPadEdgeGaugePointToPackageEdgeTolerance)
                                {
                                    m_arrPadEdgeGaugePoints[i].Add(new PointF(objROI.ref_ROI.TotalOrgX + pfEnd[1].X, objROI.ref_ROI.TotalOrgY + pfEnd[1].Y));
                                    m_arrPadEdgeGaugePointsFound[i].Add(true);
                                }
                                else
                                {
                                    m_arrPadEdgeGaugePoints[i].Add(new PointF(m_arrPadPointGaugeStartX[i][1], m_arrPadPointGaugeStartY[i][1])); //objROI.ref_ROI.TotalOrgX + fLimitCenterX + fWidth / 2, objROI.ref_ROI.TotalOrgY + fLimitCenterY
                                    m_arrPadEdgeGaugePointsFound[i].Add(false);
                                }

                                //if (pfEnd[0].X >= 0 && pfEnd[0].Y >= 0)
                                if (pfEnd[0].X >= m_intPadEdgeGaugePointToPackageEdgeTolerance && pfEnd[0].Y >= m_intPadEdgeGaugePointToPackageEdgeTolerance)
                                {
                                    m_arrPadEdgeGaugePoints[i].Add(new PointF(objROI.ref_ROI.TotalOrgX + pfEnd[0].X, objROI.ref_ROI.TotalOrgY + pfEnd[0].Y));
                                    m_arrPadEdgeGaugePointsFound[i].Add(true);
                                }
                                else
                                {
                                    m_arrPadEdgeGaugePoints[i].Add(new PointF(m_arrPadPointGaugeStartX[i][2], m_arrPadPointGaugeStartY[i][2])); //objROI.ref_ROI.TotalOrgX + fLimitCenterX, objROI.ref_ROI.TotalOrgY + fLimitCenterY + fHeight / 2
                                    m_arrPadEdgeGaugePointsFound[i].Add(false);
                                }

                                //if (pfStart[1].X >= 0 && pfStart[1].Y >= 0)
                                if (pfStart[1].X >= m_intPadEdgeGaugePointToPackageEdgeTolerance && pfStart[1].Y >= m_intPadEdgeGaugePointToPackageEdgeTolerance)
                                {
                                    m_arrPadEdgeGaugePoints[i].Add(new PointF(objROI.ref_ROI.TotalOrgX + pfStart[1].X, objROI.ref_ROI.TotalOrgY + pfStart[1].Y));
                                    m_arrPadEdgeGaugePointsFound[i].Add(true);
                                }
                                else
                                {
                                    m_arrPadEdgeGaugePoints[i].Add(new PointF(m_arrPadPointGaugeStartX[i][3], m_arrPadPointGaugeStartY[i][3])); //objROI.ref_ROI.TotalOrgX + fLimitCenterX - fWidth / 2, objROI.ref_ROI.TotalOrgY + fLimitCenterY
                                    m_arrPadEdgeGaugePointsFound[i].Add(false);
                                }
                            }
                            else
                            {
                                /*
                                 *          0=start1
                                 * 3=start0           1=end0
                                 *          2=End1
                                 */
                                //if (pfStart[1].X >= 0 && pfStart[1].Y >= 0)
                                if (pfStart[1].X >= m_intPadEdgeGaugePointToPackageEdgeTolerance && pfStart[1].Y >= m_intPadEdgeGaugePointToPackageEdgeTolerance)
                                {
                                    m_arrPadEdgeGaugePoints[i].Add(new PointF(objROI.ref_ROI.TotalOrgX + pfStart[1].X, objROI.ref_ROI.TotalOrgY + pfStart[1].Y));
                                    m_arrPadEdgeGaugePointsFound[i].Add(true);
                                }
                                else
                                {
                                    m_arrPadEdgeGaugePoints[i].Add(new PointF(m_arrPadPointGaugeStartX[i][0], m_arrPadPointGaugeStartY[i][0])); //objROI.ref_ROI.TotalOrgX + fLimitCenterX, objROI.ref_ROI.TotalOrgY + fLimitCenterY - fHeight / 2
                                    m_arrPadEdgeGaugePointsFound[i].Add(false);
                                }

                                //if (pfEnd[0].X >= 0 && pfEnd[0].Y >= 0)
                                if (pfEnd[0].X >= m_intPadEdgeGaugePointToPackageEdgeTolerance && pfEnd[0].Y >= m_intPadEdgeGaugePointToPackageEdgeTolerance)
                                {
                                    m_arrPadEdgeGaugePoints[i].Add(new PointF(objROI.ref_ROI.TotalOrgX + pfEnd[0].X, objROI.ref_ROI.TotalOrgY + pfEnd[0].Y));
                                    m_arrPadEdgeGaugePointsFound[i].Add(true);
                                }
                                else
                                {
                                    m_arrPadEdgeGaugePoints[i].Add(new PointF(m_arrPadPointGaugeStartX[i][1], m_arrPadPointGaugeStartY[i][1])); //objROI.ref_ROI.TotalOrgX + fLimitCenterX + fWidth / 2, objROI.ref_ROI.TotalOrgY + fLimitCenterY
                                    m_arrPadEdgeGaugePointsFound[i].Add(false);
                                }

                                //if (pfEnd[1].X >= 0 && pfEnd[1].Y >= 0)
                                if (pfEnd[1].X >= m_intPadEdgeGaugePointToPackageEdgeTolerance && pfEnd[1].Y >= m_intPadEdgeGaugePointToPackageEdgeTolerance)
                                {
                                    m_arrPadEdgeGaugePoints[i].Add(new PointF(objROI.ref_ROI.TotalOrgX + pfEnd[1].X, objROI.ref_ROI.TotalOrgY + pfEnd[1].Y));
                                    m_arrPadEdgeGaugePointsFound[i].Add(true);
                                }
                                else
                                {
                                    m_arrPadEdgeGaugePoints[i].Add(new PointF(m_arrPadPointGaugeStartX[i][2], m_arrPadPointGaugeStartY[i][2])); //objROI.ref_ROI.TotalOrgX + fLimitCenterX, objROI.ref_ROI.TotalOrgY + fLimitCenterY + fHeight / 2
                                    m_arrPadEdgeGaugePointsFound[i].Add(false);
                                }

                                //if (pfStart[0].X >= 0 && pfStart[0].Y >= 0)
                                if (pfStart[0].X >= m_intPadEdgeGaugePointToPackageEdgeTolerance && pfStart[0].Y >= m_intPadEdgeGaugePointToPackageEdgeTolerance)
                                {
                                    m_arrPadEdgeGaugePoints[i].Add(new PointF(objROI.ref_ROI.TotalOrgX + pfStart[0].X, objROI.ref_ROI.TotalOrgY + pfStart[0].Y));
                                    m_arrPadEdgeGaugePointsFound[i].Add(true);
                                }
                                else
                                {
                                    m_arrPadEdgeGaugePoints[i].Add(new PointF(m_arrPadPointGaugeStartX[i][3], m_arrPadPointGaugeStartY[i][3])); //objROI.ref_ROI.TotalOrgX + fLimitCenterX - fWidth / 2, objROI.ref_ROI.TotalOrgY + fLimitCenterY
                                    m_arrPadEdgeGaugePointsFound[i].Add(false);
                                }
                            }
                        }
                    }
                    // Add calibrate off set value to measurement
                    m_stcBlobPad = (BlobsFeatures)m_arrTemplateBlobPads[i];

                    // 2019 08 26 - CCENG: Dimension offset not need apply to drawing. 
                    // 05-07-2019 ZJYEOH : Include offset in width and height
                    //m_fOffSetX = m_stcBlobPad.fWidthOffset * m_fMMToPixelXValue;
                    //m_fOffSetY = m_stcBlobPad.fHeightOffset * m_fMMToPixelYValue;

                    //if (m_stcBlobPad.intLengthMode == 1)
                    //{
                    //    if (m_fOffSetX != 0)
                    //        fWidth += m_fOffSetX;
                    //    if (m_fOffSetY != 0)
                    //        fHeight += m_fOffSetY;
                    //}
                    //else
                    //{
                    //    if (m_fOffSetY != 0)
                    //        fWidth += m_fOffSetY;
                    //    if (m_fOffSetX != 0)
                    //        fHeight += m_fOffSetX;
                    //}

                    // Check Area
                    if ((m_intFailOptionMask & 0x20) > 0)
                    {
                        if (((BlobsFeatures)m_arrTemplateBlobPads[i]).blnEnable)
                        {
                            fArea = fArea / m_fMMtoPixelAreaValue;
                            if (!MatchTemplateObjectsArea(i, fArea))
                            {

                                m_arrSampleBlobPads[i].intFailMask |= 0x20;
                                m_intFailResultMask |= 0x20;
                            }
                        }
                    }




                    // Check Width
                    fWidthMM = fWidth / m_fMMToPixelXValue;
                    
                    if (m_stcBlobPad.blnFeretActivated)
                    {
                        if (m_stcBlobPad.fWidthOffset != 0)
                            fWidthMM += m_stcBlobPad.fWidthOffset;
                    }
                    else
                    {
                        if (m_stcBlobPad.intLengthMode == 1)
                        {
                            if (m_stcBlobPad.fWidthOffset != 0)
                                fWidthMM += m_stcBlobPad.fWidthOffset;
                        }
                        else
                        {
                            if (m_stcBlobPad.fHeightOffset != 0)
                                fWidthMM += m_stcBlobPad.fHeightOffset;
                        }
                    }
                    
                    if ((m_intFailOptionMask & 0x40) > 0)
                    {
                        if (((BlobsFeatures)m_arrTemplateBlobPads[i]).blnEnable)
                        {
                            if (!MatchTemplateObjectsWidth(i, fWidthMM))
                            {
                                m_arrSampleBlobPads[i].intFailMask |= 0x40;
                                m_intFailResultMask |= 0x40;
                            }
                        }
                    }


                    // Check Height
                    fHeightMM = fHeight / m_fMMToPixelYValue;
                    
                    if (m_stcBlobPad.blnFeretActivated)
                    {
                        if (m_stcBlobPad.fHeightOffset != 0)
                            fHeightMM += m_stcBlobPad.fHeightOffset;
                    }
                    else
                    {
                        if (m_stcBlobPad.intLengthMode == 1)
                        {
                            if (m_stcBlobPad.fHeightOffset != 0)
                                fHeightMM += m_stcBlobPad.fHeightOffset;
                        }
                        else
                        {
                            if (m_stcBlobPad.fWidthOffset != 0)
                                fHeightMM += m_stcBlobPad.fWidthOffset;
                        }
                    }
                    if ((m_intFailOptionMask & 0x80) > 0)
                    {
                        if (((BlobsFeatures)m_arrTemplateBlobPads[i]).blnEnable)
                        {
                            if (!MatchTemplateObjectsHeight(i, fHeightMM))
                            {
                                m_arrSampleBlobPads[i].intFailMask |= 0x80;
                                m_intFailResultMask |= 0x80;
                            }
                        }
                    }

                    // Check Line 3
                    if (((m_intFailOptionMask & 0xC0) > 0) && ((BlobsFeatures)m_arrTemplateBlobPads[i]).intLineCount > 2)
                    {
                        if (((BlobsFeatures)m_arrTemplateBlobPads[i]).blnEnable)// && fLine3MM >= 0)
                        {
                            if (!MatchTemplateObjectsLength(i, fLine3MM, 3))
                            {
                                m_arrSampleBlobPads[i].intFailMask |= 0x10000;
                                m_intFailResultMask |= 0x10000;
                            }
                        }
                    }

                    // Check Line 4
                    if (((m_intFailOptionMask & 0xC0) > 0) && ((BlobsFeatures)m_arrTemplateBlobPads[i]).intLineCount > 3)
                    {
                        if (((BlobsFeatures)m_arrTemplateBlobPads[i]).blnEnable)// && fLine4MM >= 0)
                        {
                            if (!MatchTemplateObjectsLength(i, fLine4MM, 4))
                            {
                                m_arrSampleBlobPads[i].intFailMask |= 0x20000;
                                m_intFailResultMask |= 0x20000;
                            }
                        }
                    }

                    // Check Line 5
                    if (((m_intFailOptionMask & 0xC0) > 0) && ((BlobsFeatures)m_arrTemplateBlobPads[i]).intLineCount > 4)
                    {
                        if (((BlobsFeatures)m_arrTemplateBlobPads[i]).blnEnable)// && fLine5MM >= 0)
                        {
                            if (!MatchTemplateObjectsLength(i, fLine5MM, 5))
                            {
                                m_arrSampleBlobPads[i].intFailMask |= 0x40000;
                                m_intFailResultMask |= 0x40000;
                            }
                        }
                    }

                    // Check Line 6
                    if (((m_intFailOptionMask & 0xC0) > 0) && ((BlobsFeatures)m_arrTemplateBlobPads[i]).intLineCount > 5)
                    {
                        if (((BlobsFeatures)m_arrTemplateBlobPads[i]).blnEnable)// && fLine6MM >= 0)
                        {
                            if (!MatchTemplateObjectsLength(i, fLine6MM, 6))
                            {
                                m_arrSampleBlobPads[i].intFailMask |= 0x80000;
                                m_intFailResultMask |= 0x80000;
                            }
                        }
                    }

                    // Check Line 7
                    if (((m_intFailOptionMask & 0xC0) > 0) && ((BlobsFeatures)m_arrTemplateBlobPads[i]).intLineCount > 6)
                    {
                        if (((BlobsFeatures)m_arrTemplateBlobPads[i]).blnEnable)// && fLine7MM >= 0)
                        {
                            if (!MatchTemplateObjectsLength(i, fLine7MM, 7))
                            {
                                m_arrSampleBlobPads[i].intFailMask |= 0x100000;
                                m_intFailResultMask |= 0x100000;
                            }
                        }
                    }

                    // Check Line 8
                    if (((m_intFailOptionMask & 0xC0) > 0) && ((BlobsFeatures)m_arrTemplateBlobPads[i]).intLineCount > 7)
                    {
                        if (((BlobsFeatures)m_arrTemplateBlobPads[i]).blnEnable)// && fLine8MM >= 0)
                        {
                            if (!MatchTemplateObjectsLength(i, fLine8MM, 8))
                            {
                                m_arrSampleBlobPads[i].intFailMask |= 0x800000000;
                                m_intFailResultMask |= 0x800000000;
                            }
                        }
                    }

                    // Check Line 9
                    if (((m_intFailOptionMask & 0xC0) > 0) && ((BlobsFeatures)m_arrTemplateBlobPads[i]).intLineCount > 9)
                    {
                        if (((BlobsFeatures)m_arrTemplateBlobPads[i]).blnEnable)// && fLine9MM >= 0)
                        {
                            if (!MatchTemplateObjectsLength(i, fLine9MM, 9))
                            {
                                m_arrSampleBlobPads[i].intFailMask |= 0x1000000000;
                                m_intFailResultMask |= 0x1000000000;
                            }
                        }
                    }

                    // Check Line 10
                    if (((m_intFailOptionMask & 0xC0) > 0) && ((BlobsFeatures)m_arrTemplateBlobPads[i]).intLineCount > 10)
                    {
                        if (((BlobsFeatures)m_arrTemplateBlobPads[i]).blnEnable)// && fLine10MM >= 0)
                        {
                            if (!MatchTemplateObjectsLength(i, fLine10MM, 10))
                            {
                                m_arrSampleBlobPads[i].intFailMask |= 0x2000000000;
                                m_intFailResultMask |= 0x2000000000;
                            }
                        }
                    }

                    // Check Line 11
                    if (((m_intFailOptionMask & 0xC0) > 0) && ((BlobsFeatures)m_arrTemplateBlobPads[i]).intLineCount > 11)
                    {
                        if (((BlobsFeatures)m_arrTemplateBlobPads[i]).blnEnable)// && fLine11MM >= 0)
                        {
                            if (!MatchTemplateObjectsLength(i, fLine11MM, 11))
                            {
                                m_arrSampleBlobPads[i].intFailMask |= 0x4000000000;
                                m_intFailResultMask |= 0x4000000000;
                            }
                        }
                    }

                    // Check Line 12
                    if (((m_intFailOptionMask & 0xC0) > 0) && ((BlobsFeatures)m_arrTemplateBlobPads[i]).intLineCount > 12)
                    {
                        if (((BlobsFeatures)m_arrTemplateBlobPads[i]).blnEnable)// && fLine12MM >= 0)
                        {
                            if (!MatchTemplateObjectsLength(i, fLine12MM, 12))
                            {
                                m_arrSampleBlobPads[i].intFailMask |= 0x8000000000;
                                m_intFailResultMask |= 0x8000000000;
                            }
                        }
                    }

                    // Off Set
                    if ((m_intFailOptionMask & 0x100) > 0)
                    {
                        // Check Off Set
                        //float fMaxOffSet = Math.Max (Math.Abs(m_stcBlobPad.fCenterX - fLimitCenterX) / m_fMMToPixelXValue ,
                        //    Math.Abs(m_stcBlobPad.fCenterY - fLimitCenterY) / m_fMMToPixelYValue);

                        m_stcBlobPad = (BlobsFeatures)m_arrTemplateBlobPads[i];
                        if (GetOverallWantGaugeMeasurePkgSize(false))
                        {
                            if (m_blnWantUseBorderLimitAsOffset)
                            {
                                float fBorderLeft = GetResultCenterPoint_RectGauge4L().X - GetResultWidth_RectGauge4L(0) / 2 - objROI.ref_ROITotalX;
                                float fBorderTop = GetResultCenterPoint_RectGauge4L().Y - GetResultHeight_RectGauge4L(0) / 2 - objROI.ref_ROITotalY;
                                float fBorderRight = GetResultCenterPoint_RectGauge4L().X + GetResultWidth_RectGauge4L(0) / 2 - objROI.ref_ROITotalX;
                                float fBorderBottom = GetResultCenterPoint_RectGauge4L().Y + GetResultHeight_RectGauge4L(0) / 2 - objROI.ref_ROITotalY;

                                float fPadLeft = fNewCenterX - fWidth / 2;
                                float fPadTop = fNewCenterY - fHeight / 2;
                                float fPadRight = fNewCenterX + fWidth / 2;
                                float fPadBottom = fNewCenterY + fHeight / 2;

                                fMinOffset = (fPadLeft - fBorderLeft) / m_fMMToPixelXValue;
                                fMinOffset = Math.Min(fMinOffset, (fPadTop - fBorderTop) / m_fMMToPixelYValue);
                                fMinOffset = Math.Min(fMinOffset, (fBorderRight - fPadRight) / m_fMMToPixelXValue);
                                fMinOffset = Math.Min(fMinOffset, (fBorderBottom - fPadBottom) / m_fMMToPixelYValue);
                            }
                            else
                            {
                                if (m_stcBlobPad.fTemplateROICenterX == 0 && m_stcBlobPad.fTemplateROICenterY == 0 && m_stcBlobPad.fTemplateROITopLeftCornerX == 0 && m_stcBlobPad.fTemplateROITopLeftCornerY == 0)
                                {
                                    fMaxOffSet = Math.Max(Math.Abs(m_stcBlobPad.fXDistance - (objROI.ref_ROITotalX + fNewCenterX - GetResultCenterPoint_RectGauge4L().X)) / m_fMMToPixelXValue,
                                                                Math.Abs(m_stcBlobPad.fYDistance - (objROI.ref_ROITotalY + fNewCenterY - GetResultCenterPoint_RectGauge4L().Y)) / m_fMMToPixelYValue);
                                }
                                else
                                {
                                    if (m_intPadOffsetReferencePoint == 0)
                                    {
                                        fMaxOffSet = Math.Max(Math.Abs((m_stcBlobPad.fLimitCenterX - m_stcBlobPad.fTemplateROICenterX) - (objROI.ref_ROITotalX + fNewCenterX - GetResultCenterPoint_RectGauge4L().X)) / m_fMMToPixelXValue,
                                                                Math.Abs((m_stcBlobPad.fLimitCenterY - m_stcBlobPad.fTemplateROICenterY) - (objROI.ref_ROITotalY + fNewCenterY - GetResultCenterPoint_RectGauge4L().Y)) / m_fMMToPixelYValue);
                                    }
                                    else
                                    {
                                        fMaxOffSet = Math.Max(Math.Abs((m_stcBlobPad.fLimitCenterX - m_stcBlobPad.fTemplateROITopLeftCornerX) - (objROI.ref_ROITotalX + fNewCenterX - GetResultTopLeftCornerPoint_RectGauge4L().X)) / m_fMMToPixelXValue,
                                                                Math.Abs((m_stcBlobPad.fLimitCenterY - m_stcBlobPad.fTemplateROITopLeftCornerY) - (objROI.ref_ROITotalY + fNewCenterY - GetResultTopLeftCornerPoint_RectGauge4L().Y)) / m_fMMToPixelYValue);
                                    }
                                }
                            }
                        }
                        else
                        {
                            if (m_stcBlobPad.fTemplateROICenterX_Pattern == 0 && m_stcBlobPad.fTemplateROICenterY_Pattern == 0 && m_stcBlobPad.fTemplateROITopLeftCornerX_Pattern == 0 && m_stcBlobPad.fTemplateROITopLeftCornerY_Pattern == 0)
                            {
                                fMaxOffSet = Math.Max(Math.Abs(m_stcBlobPad.fXDistance_Pattern - (objROI.ref_ROITotalX + fNewCenterX - m_pUnitCenterPoint.X)) / m_fMMToPixelXValue,
                                                            Math.Abs(m_stcBlobPad.fYDistance_Pattern - (objROI.ref_ROITotalY + fNewCenterY - m_pUnitCenterPoint.Y)) / m_fMMToPixelYValue);
                            }
                            else
                            {
                                if (m_intPadOffsetReferencePoint == 0)
                                {
                                    fMaxOffSet = Math.Max(Math.Abs((m_stcBlobPad.fLimitCenterX - m_stcBlobPad.fTemplateROICenterX_Pattern) - (objROI.ref_ROITotalX + fNewCenterX - m_pUnitCenterPoint.X)) / m_fMMToPixelXValue,
                                                            Math.Abs((m_stcBlobPad.fLimitCenterY - m_stcBlobPad.fTemplateROICenterY_Pattern) - (objROI.ref_ROITotalY + fNewCenterY - m_pUnitCenterPoint.Y)) / m_fMMToPixelYValue);
                                }
                                else
                                {
                                    fMaxOffSet = Math.Max(Math.Abs((m_stcBlobPad.fLimitCenterX - m_stcBlobPad.fTemplateROITopLeftCornerX_Pattern) - (objROI.ref_ROITotalX + fNewCenterX - GetResultTopLeftCornerPoint_UnitMatcher().X)) / m_fMMToPixelXValue,
                                                            Math.Abs((m_stcBlobPad.fLimitCenterY - m_stcBlobPad.fTemplateROITopLeftCornerY_Pattern) - (objROI.ref_ROITotalY + fNewCenterY - GetResultTopLeftCornerPoint_UnitMatcher().Y)) / m_fMMToPixelYValue);
                                }
                            }
                        }
                        
                        if (m_stcBlobPad.fOffsetOffSet != 0)
                        {
                            fMinOffset += m_stcBlobPad.fOffsetOffSet;
                            fMaxOffSet += m_stcBlobPad.fOffsetOffSet;

                            if (fMinOffset < 0 && !m_blnWantUseBorderLimitAsOffset)
                                fMinOffset = 0;
                            if (fMaxOffSet < 0 && !m_blnWantUseBorderLimitAsOffset)
                                fMaxOffSet = 0;
                        }

                        if (((BlobsFeatures)m_arrTemplateBlobPads[i]).blnEnable)
                        {
                            if (m_blnWantUseGroupToleranceSetting)
                            {
                                int intGroupNo = ((BlobsFeatures)m_arrTemplateBlobPads[i]).intGroupID;
                                m_stcBlobPad = (BlobsFeatures)m_arrGroupTemplateBlobPads[intGroupNo];
                            }
                            else
                            {
                                m_stcBlobPad = (BlobsFeatures)m_arrTemplateBlobPads[i];
                            }

                            if (m_blnWantUseBorderLimitAsOffset)
                            {
                                if (fMinOffset < m_stcBlobPad.fOffSet)
                                {

                                    m_arrSampleBlobPads[i].intFailMask |= 0x100;
                                    m_intFailResultMask |= 0x100;
                                }
                            }
                            else
                            {
                                if (fMaxOffSet > m_stcBlobPad.fOffSet)
                                {

                                    m_arrSampleBlobPads[i].intFailMask |= 0x100;
                                    m_intFailResultMask |= 0x100;
                                }
                            }
                        }
                    }

                    if (m_blnWantUseBorderLimitAsOffset)
                        m_arrSampleBlobPads[i].fOffSetMM = fMinOffset;
                    else
                        m_arrSampleBlobPads[i].fOffSetMM = fMaxOffSet;
                    m_arrSampleBlobPads[i].fAreaMM = fArea;
                    m_arrSampleBlobPads[i].fWidthMM = fWidthMM;
                    m_arrSampleBlobPads[i].fHeightMM = fHeightMM;
                    m_arrSampleBlobPads[i].fCenterX = fNewCenterX;
                    m_arrSampleBlobPads[i].fCenterY = fNewCenterY;
                    m_arrSampleBlobPads[i].fStartX = fNewCenterX - fWidth / 2;
                    m_arrSampleBlobPads[i].fStartY = fNewCenterY - fHeight / 2;
                    m_arrSampleBlobPads[i].fEndX = fNewCenterX + fWidth / 2;
                    m_arrSampleBlobPads[i].fEndY = fNewCenterY + fHeight / 2;
                    // 05-07-2019 ZJYEOH : Update Width and Height so that pitch gap inspection and drawing correct
                    m_arrSampleBlobPads[i].fWidth = fWidth;
                    m_arrSampleBlobPads[i].fHeight = fHeight;


                    // Collect Pad range data
                    if (m_fSamplePadRangeStartX == -999 || m_arrSampleBlobPads[i].fStartX < m_fSamplePadRangeStartX)
                        m_fSamplePadRangeStartX = m_arrSampleBlobPads[i].fStartX;
                    if (m_fSamplePadRangeStartY == -999 || m_arrSampleBlobPads[i].fStartY < m_fSamplePadRangeStartY)
                        m_fSamplePadRangeStartY = m_arrSampleBlobPads[i].fStartY;
                    if (m_fSamplePadRangeEndX == -999 || m_arrSampleBlobPads[i].fEndX > m_fSamplePadRangeEndX)
                        m_fSamplePadRangeEndX = m_arrSampleBlobPads[i].fEndX;
                    if (m_fSamplePadRangeEndY == -999 || m_arrSampleBlobPads[i].fEndY > m_fSamplePadRangeEndY)
                        m_fSamplePadRangeEndY = m_arrSampleBlobPads[i].fEndY;

                    //2021-12-07 ZJYEOH : Scan outest point of every extra line for Span calculation
                    if(((BlobsFeatures)m_arrTemplateBlobPads[i]).intLineCount > 2)
                    {
                        if (m_fSamplePadRangeStartX == -999 || m_arrSampleBlobPads[i].fStartXLine3 < m_fSamplePadRangeStartX)
                            m_fSamplePadRangeStartX = m_arrSampleBlobPads[i].fStartXLine3;
                        if (m_fSamplePadRangeStartY == -999 || m_arrSampleBlobPads[i].fStartYLine3 < m_fSamplePadRangeStartY)
                            m_fSamplePadRangeStartY = m_arrSampleBlobPads[i].fStartYLine3;
                        if (m_fSamplePadRangeEndX == -999 || m_arrSampleBlobPads[i].fEndXLine3 > m_fSamplePadRangeEndX)
                            m_fSamplePadRangeEndX = m_arrSampleBlobPads[i].fEndXLine3;
                        if (m_fSamplePadRangeEndY == -999 || m_arrSampleBlobPads[i].fEndYLine3 > m_fSamplePadRangeEndY)
                            m_fSamplePadRangeEndY = m_arrSampleBlobPads[i].fEndYLine3;
                    }
                    if (((BlobsFeatures)m_arrTemplateBlobPads[i]).intLineCount > 3)
                    {
                        if (m_fSamplePadRangeStartX == -999 || m_arrSampleBlobPads[i].fStartXLine4 < m_fSamplePadRangeStartX)
                            m_fSamplePadRangeStartX = m_arrSampleBlobPads[i].fStartXLine4;
                        if (m_fSamplePadRangeStartY == -999 || m_arrSampleBlobPads[i].fStartYLine4 < m_fSamplePadRangeStartY)
                            m_fSamplePadRangeStartY = m_arrSampleBlobPads[i].fStartYLine4;
                        if (m_fSamplePadRangeEndX == -999 || m_arrSampleBlobPads[i].fEndXLine4 > m_fSamplePadRangeEndX)
                            m_fSamplePadRangeEndX = m_arrSampleBlobPads[i].fEndXLine4;
                        if (m_fSamplePadRangeEndY == -999 || m_arrSampleBlobPads[i].fEndYLine4 > m_fSamplePadRangeEndY)
                            m_fSamplePadRangeEndY = m_arrSampleBlobPads[i].fEndYLine4;
                    }
                    if (((BlobsFeatures)m_arrTemplateBlobPads[i]).intLineCount > 4)
                    {
                        if (m_fSamplePadRangeStartX == -999 || m_arrSampleBlobPads[i].fStartXLine5 < m_fSamplePadRangeStartX)
                            m_fSamplePadRangeStartX = m_arrSampleBlobPads[i].fStartXLine5;
                        if (m_fSamplePadRangeStartY == -999 || m_arrSampleBlobPads[i].fStartYLine5 < m_fSamplePadRangeStartY)
                            m_fSamplePadRangeStartY = m_arrSampleBlobPads[i].fStartYLine5;
                        if (m_fSamplePadRangeEndX == -999 || m_arrSampleBlobPads[i].fEndXLine5 > m_fSamplePadRangeEndX)
                            m_fSamplePadRangeEndX = m_arrSampleBlobPads[i].fEndXLine5;
                        if (m_fSamplePadRangeEndY == -999 || m_arrSampleBlobPads[i].fEndYLine5 > m_fSamplePadRangeEndY)
                            m_fSamplePadRangeEndY = m_arrSampleBlobPads[i].fEndYLine5;
                    }
                    if (((BlobsFeatures)m_arrTemplateBlobPads[i]).intLineCount > 5)
                    {
                        if (m_fSamplePadRangeStartX == -999 || m_arrSampleBlobPads[i].fStartXLine6 < m_fSamplePadRangeStartX)
                            m_fSamplePadRangeStartX = m_arrSampleBlobPads[i].fStartXLine6;
                        if (m_fSamplePadRangeStartY == -999 || m_arrSampleBlobPads[i].fStartYLine6 < m_fSamplePadRangeStartY)
                            m_fSamplePadRangeStartY = m_arrSampleBlobPads[i].fStartYLine6;
                        if (m_fSamplePadRangeEndX == -999 || m_arrSampleBlobPads[i].fEndXLine6 > m_fSamplePadRangeEndX)
                            m_fSamplePadRangeEndX = m_arrSampleBlobPads[i].fEndXLine6;
                        if (m_fSamplePadRangeEndY == -999 || m_arrSampleBlobPads[i].fEndYLine6 > m_fSamplePadRangeEndY)
                            m_fSamplePadRangeEndY = m_arrSampleBlobPads[i].fEndYLine6;
                    }
                    if (((BlobsFeatures)m_arrTemplateBlobPads[i]).intLineCount > 6)
                    {
                        if (m_fSamplePadRangeStartX == -999 || m_arrSampleBlobPads[i].fStartXLine7 < m_fSamplePadRangeStartX)
                            m_fSamplePadRangeStartX = m_arrSampleBlobPads[i].fStartXLine7;
                        if (m_fSamplePadRangeStartY == -999 || m_arrSampleBlobPads[i].fStartYLine7 < m_fSamplePadRangeStartY)
                            m_fSamplePadRangeStartY = m_arrSampleBlobPads[i].fStartYLine7;
                        if (m_fSamplePadRangeEndX == -999 || m_arrSampleBlobPads[i].fEndXLine7 > m_fSamplePadRangeEndX)
                            m_fSamplePadRangeEndX = m_arrSampleBlobPads[i].fEndXLine7;
                        if (m_fSamplePadRangeEndY == -999 || m_arrSampleBlobPads[i].fEndYLine7 > m_fSamplePadRangeEndY)
                            m_fSamplePadRangeEndY = m_arrSampleBlobPads[i].fEndYLine7;
                    }
                    if (((BlobsFeatures)m_arrTemplateBlobPads[i]).intLineCount > 7)
                    {
                        if (m_fSamplePadRangeStartX == -999 || m_arrSampleBlobPads[i].fStartXLine8 < m_fSamplePadRangeStartX)
                            m_fSamplePadRangeStartX = m_arrSampleBlobPads[i].fStartXLine8;
                        if (m_fSamplePadRangeStartY == -999 || m_arrSampleBlobPads[i].fStartYLine8 < m_fSamplePadRangeStartY)
                            m_fSamplePadRangeStartY = m_arrSampleBlobPads[i].fStartYLine8;
                        if (m_fSamplePadRangeEndX == -999 || m_arrSampleBlobPads[i].fEndXLine8 > m_fSamplePadRangeEndX)
                            m_fSamplePadRangeEndX = m_arrSampleBlobPads[i].fEndXLine8;
                        if (m_fSamplePadRangeEndY == -999 || m_arrSampleBlobPads[i].fEndYLine8 > m_fSamplePadRangeEndY)
                            m_fSamplePadRangeEndY = m_arrSampleBlobPads[i].fEndYLine8;
                    }
                    if (((BlobsFeatures)m_arrTemplateBlobPads[i]).intLineCount > 8)
                    {
                        if (m_fSamplePadRangeStartX == -999 || m_arrSampleBlobPads[i].fStartXLine9 < m_fSamplePadRangeStartX)
                            m_fSamplePadRangeStartX = m_arrSampleBlobPads[i].fStartXLine9;
                        if (m_fSamplePadRangeStartY == -999 || m_arrSampleBlobPads[i].fStartYLine9 < m_fSamplePadRangeStartY)
                            m_fSamplePadRangeStartY = m_arrSampleBlobPads[i].fStartYLine9;
                        if (m_fSamplePadRangeEndX == -999 || m_arrSampleBlobPads[i].fEndXLine9 > m_fSamplePadRangeEndX)
                            m_fSamplePadRangeEndX = m_arrSampleBlobPads[i].fEndXLine9;
                        if (m_fSamplePadRangeEndY == -999 || m_arrSampleBlobPads[i].fEndYLine9 > m_fSamplePadRangeEndY)
                            m_fSamplePadRangeEndY = m_arrSampleBlobPads[i].fEndYLine9;
                    }
                    if (((BlobsFeatures)m_arrTemplateBlobPads[i]).intLineCount > 9)
                    {
                        if (m_fSamplePadRangeStartX == -999 || m_arrSampleBlobPads[i].fStartXLine10 < m_fSamplePadRangeStartX)
                            m_fSamplePadRangeStartX = m_arrSampleBlobPads[i].fStartXLine10;
                        if (m_fSamplePadRangeStartY == -999 || m_arrSampleBlobPads[i].fStartYLine10 < m_fSamplePadRangeStartY)
                            m_fSamplePadRangeStartY = m_arrSampleBlobPads[i].fStartYLine10;
                        if (m_fSamplePadRangeEndX == -999 || m_arrSampleBlobPads[i].fEndXLine10 > m_fSamplePadRangeEndX)
                            m_fSamplePadRangeEndX = m_arrSampleBlobPads[i].fEndXLine10;
                        if (m_fSamplePadRangeEndY == -999 || m_arrSampleBlobPads[i].fEndYLine10 > m_fSamplePadRangeEndY)
                            m_fSamplePadRangeEndY = m_arrSampleBlobPads[i].fEndYLine10;
                    }
                    if (((BlobsFeatures)m_arrTemplateBlobPads[i]).intLineCount > 10)
                    {
                        if (m_fSamplePadRangeStartX == -999 || m_arrSampleBlobPads[i].fStartXLine11 < m_fSamplePadRangeStartX)
                            m_fSamplePadRangeStartX = m_arrSampleBlobPads[i].fStartXLine11;
                        if (m_fSamplePadRangeStartY == -999 || m_arrSampleBlobPads[i].fStartYLine11 < m_fSamplePadRangeStartY)
                            m_fSamplePadRangeStartY = m_arrSampleBlobPads[i].fStartYLine11;
                        if (m_fSamplePadRangeEndX == -999 || m_arrSampleBlobPads[i].fEndXLine11 > m_fSamplePadRangeEndX)
                            m_fSamplePadRangeEndX = m_arrSampleBlobPads[i].fEndXLine11;
                        if (m_fSamplePadRangeEndY == -999 || m_arrSampleBlobPads[i].fEndYLine11 > m_fSamplePadRangeEndY)
                            m_fSamplePadRangeEndY = m_arrSampleBlobPads[i].fEndYLine11;
                    }
                    if (((BlobsFeatures)m_arrTemplateBlobPads[i]).intLineCount > 11)
                    {
                        if (m_fSamplePadRangeStartX == -999 || m_arrSampleBlobPads[i].fStartXLine12 < m_fSamplePadRangeStartX)
                            m_fSamplePadRangeStartX = m_arrSampleBlobPads[i].fStartXLine12;
                        if (m_fSamplePadRangeStartY == -999 || m_arrSampleBlobPads[i].fStartYLine12 < m_fSamplePadRangeStartY)
                            m_fSamplePadRangeStartY = m_arrSampleBlobPads[i].fStartYLine12;
                        if (m_fSamplePadRangeEndX == -999 || m_arrSampleBlobPads[i].fEndXLine12 > m_fSamplePadRangeEndX)
                            m_fSamplePadRangeEndX = m_arrSampleBlobPads[i].fEndXLine12;
                        if (m_fSamplePadRangeEndY == -999 || m_arrSampleBlobPads[i].fEndYLine12 > m_fSamplePadRangeEndY)
                            m_fSamplePadRangeEndY = m_arrSampleBlobPads[i].fEndYLine12;
                    }
                }
            }
            #endregion
        }
        private void CheckSpan()
        {
            if (!m_blnWantSpan_Pad)
                return;

            if ((m_intFailOptionMask & 0x20000) > 0)
            {
                m_fResultPadSpanX = m_fSamplePadRangeEndX - m_fSamplePadRangeStartX;
                if (m_fResultPadSpanX < (m_fMinSpanX / m_fMMPerPixelX) || m_fResultPadSpanX > (m_fMaxSpanX / m_fMMPerPixelX))
                {
                    m_intFailResultMask |= 0x200000000;
                }
                m_fResultPadSpanX *= m_fMMPerPixelX;
            }

            if ((m_intFailOptionMask & 0x40000) > 0)
            {
                m_fResultPadSpanY = m_fSamplePadRangeEndY - m_fSamplePadRangeStartY;
                if (m_fResultPadSpanY < (m_fMinSpanY / m_fMMPerPixelY) || m_fResultPadSpanY > (m_fMaxSpanY / m_fMMPerPixelY))
                {
                    m_intFailResultMask |= 0x400000000;
                }
                m_fResultPadSpanY *= m_fMMPerPixelY;
            }
        }
        private void CheckBrokenMissingPad(ROI objROI, int intNumSelectedObject)
        {
            /*
             * Using Math.Round to convert blobs dimension into Virtual value 
             * 
             */

            #region ----- Check Missing Pad, Broken Pad/Build Virtual Objects -----
            float fLimitCenterX, fLimitCenterY, fWidth, fHeight;
            int intArea;

            for (int i = 0; i < m_arrTemplateBlobPads.Count; i++)
            {
                if (m_intTemplateMatchStatus[i] == 0)
                {
                    // Missing Pad (Must check)
                    //if ((m_intFailOptionMask & 0x04) > 0)
                    {
                        if (((BlobsFeatures)m_arrTemplateBlobPads[i]).blnEnable)
                        {
                            m_intFailResultMask |= 0x04;
                            m_arrSampleBlobPads[i].intFailMask |= 0x04;
                        }
                    }
                }
                else if (m_intTemplateMatchStatus[i] >= 2)
                {
                    // Broken Pad
                    //if (m_arrSampleBlobPads[i].intFailMask == 0)
                    //{
                    //    if ((m_intFailOptionMask & 0x08) > 0)
                    //    {
                    //        m_intFailResultMask |= 0x08;
                    //        m_arrSampleBlobPads[i].intFailMask |= 0x08;
                    //    }
                    //}

                    // group all sample data from same template area, then store in virtual storage as 1 big complate sample
                    int intVirArea, intVirStartX, intVirStartY, intVirEndX, intVirEndY;
                    int intStartX, intStartY, intEndX, intEndY;
                    intVirArea = intVirStartX = intVirStartY = intVirEndX = intVirEndY = 0;
                    intStartX = intStartY = intEndX = intEndY = 0;

                    bool bFirstTime = true;
                    for (int j = 0; j < intNumSelectedObject; j++)
                    {
                        // sample match number same with i (template number)
                        if (m_intSampleMatchNumber[j] == i)
                        {
                            fLimitCenterX = fLimitCenterY = fWidth = fHeight = 0;
                            intArea = 0;

                            // Get sample data
                            intArea = m_objEBlobs.ref_arrArea[j];
                            fLimitCenterX = m_objEBlobs.ref_arrLimitCenterX[j];
                            fLimitCenterY = m_objEBlobs.ref_arrLimitCenterY[j];
                            fWidth = m_objEBlobs.ref_arrWidth[j];
                            fHeight = m_objEBlobs.ref_arrHeight[j];

                            // Group sample data
                            intVirArea += intArea;
                            if (bFirstTime)
                            {
                                bFirstTime = false;
                                intVirStartX = (int)Math.Round(fLimitCenterX - (fWidth / 2), 0, MidpointRounding.AwayFromZero);
                                intVirStartY = (int)Math.Round(fLimitCenterY - (fHeight / 2), 0, MidpointRounding.AwayFromZero);
                                intVirEndX = (int)Math.Round(fLimitCenterX + (fWidth / 2), 0, MidpointRounding.AwayFromZero);
                                intVirEndY = (int)Math.Round(fLimitCenterY + (fHeight / 2), 0, MidpointRounding.AwayFromZero);
                            }
                            else
                            {
                                intStartX = (int)Math.Round(fLimitCenterX - (fWidth / 2), 0, MidpointRounding.AwayFromZero);
                                intStartY = (int)Math.Round(fLimitCenterY - (fHeight / 2), 0, MidpointRounding.AwayFromZero);
                                intEndX = (int)Math.Round(fLimitCenterX + (fWidth / 2), 0, MidpointRounding.AwayFromZero);
                                intEndY = (int)Math.Round(fLimitCenterY + (fHeight / 2), 0, MidpointRounding.AwayFromZero);

                                if (intStartX < intVirStartX)
                                    intVirStartX = intStartX;
                                if (intStartY < intVirStartY)
                                    intVirStartY = intStartY;
                                if (intEndX > intVirEndX)
                                    intVirEndX = intEndX;
                                if (intEndY > intVirEndY)
                                    intVirEndY = intEndY;
                            }
                        }
                    }

                    m_arrSampleBlobPads[i].fStartX = intVirStartX;
                    m_arrSampleBlobPads[i].fStartY = intVirStartY;
                    m_arrSampleBlobPads[i].fEndX = intVirEndX;
                    m_arrSampleBlobPads[i].fEndY = intVirEndY;
                    m_arrSampleBlobPads[i].fWidth = intVirEndX - intVirStartX;
                    m_arrSampleBlobPads[i].fHeight = intVirEndY - intVirStartY;
                    m_arrSampleBlobPads[i].fCenterX = (intVirStartX + intVirEndX) / 2;
                    m_arrSampleBlobPads[i].fCenterY = (intVirStartY + intVirEndY) / 2;
                    m_arrSampleBlobPads[i].fArea = (float)intVirArea;
                }
            }
            #endregion

        }

        private void CheckBrokenMissingPad2(ROI objROI, int intNumSelectedObject, bool blnCheckContamination)
        {
            try
            {
                /*
                 *  Virtual value will store float value 
                 * 
                 */

                #region ----- Check Missing Pad, Broken Pad/Build Virtual Objects -----
                float fLimitCenterX, fLimitCenterY, fWidth, fHeight;
                int intArea;

                for (int i = 0; i < m_arrTemplateBlobPads.Count; i++)
                {
                    if (m_intTemplateMatchStatus[i] == 0)
                    {
                        // Missing Pad (Must check)
                        //if ((m_intFailOptionMask & 0x04) > 0)
                        {
                            if (((BlobsFeatures)m_arrTemplateBlobPads[i]).blnEnable && WantPadReturnFailResultOrShowDrawing(blnCheckContamination))
                            {
                                m_intFailResultMask |= 0x04;
                                m_arrSampleBlobPads[i].intFailMask |= 0x04;
                            }
                        }
                    }
                    else if (m_intTemplateMatchStatus[i] >= 2)
                    {
                        // Broken Pad
                        //if (m_arrSampleBlobPads[i].intFailMask == 0)
                        //{
                        //    if ((m_intFailOptionMask & 0x08) > 0)
                        //    {
                        //        m_intFailResultMask |= 0x08;
                        //        m_arrSampleBlobPads[i].intFailMask |= 0x08;
                        //    }
                        //}

                        // group all sample data from same template area, then store in virtual storage as 1 big complate sample
                        int intVirArea;
                        float fVirStartX, fVirStartY, fVirEndX, fVirEndY;
                        float fStartX, fStartY, fEndX, fEndY;
                        intVirArea = 0;
                        fVirStartX = fVirStartY = fVirEndX = fVirEndY = 0f;
                        fStartX = fStartY = fEndX = fEndY = 0f;

                        bool bFirstTime = true;
                        for (int j = 0; j < intNumSelectedObject; j++)
                        {
                            // sample match number same with i (template number)
                            if (m_intSampleMatchNumber[j] == i)
                            {
                                fLimitCenterX = fLimitCenterY = fWidth = fHeight = 0;
                                intArea = 0;

                                // Get sample data
                                intArea = m_objEBlobs.ref_arrArea[j];
                                fLimitCenterX = m_objEBlobs.ref_arrLimitCenterX[j];
                                fLimitCenterY = m_objEBlobs.ref_arrLimitCenterY[j];
                                fWidth = m_objEBlobs.ref_arrWidth[j];
                                fHeight = m_objEBlobs.ref_arrHeight[j];

                                // Group sample data
                                intVirArea += intArea;
                                if (bFirstTime)
                                {
                                    bFirstTime = false;
                                    fVirStartX = fLimitCenterX - (fWidth / 2);
                                    fVirStartY = fLimitCenterY - (fHeight / 2);
                                    fVirEndX = fLimitCenterX + (fWidth / 2);
                                    fVirEndY = fLimitCenterY + (fHeight / 2);
                                }
                                else
                                {
                                    fStartX = fLimitCenterX - (fWidth / 2);
                                    fStartY = fLimitCenterY - (fHeight / 2);
                                    fEndX = fLimitCenterX + (fWidth / 2);
                                    fEndY = fLimitCenterY + (fHeight / 2);

                                    if (fStartX < fVirStartX)
                                        fVirStartX = fStartX;
                                    if (fStartY < fVirStartY)
                                        fVirStartY = fStartY;
                                    if (fEndX > fVirEndX)
                                        fVirEndX = fEndX;
                                    if (fEndY > fVirEndY)
                                        fVirEndY = fEndY;
                                }
                            }
                        }

                        m_arrSampleBlobPads[i].fStartX = fVirStartX;
                        m_arrSampleBlobPads[i].fStartY = fVirStartY;
                        m_arrSampleBlobPads[i].fEndX = fVirEndX;
                        m_arrSampleBlobPads[i].fEndY = fVirEndY;
                        m_arrSampleBlobPads[i].fWidth = fVirEndX - fVirStartX;
                        m_arrSampleBlobPads[i].fHeight = fVirEndY - fVirStartY;
                        m_arrSampleBlobPads[i].fCenterX = (fVirStartX + fVirEndX) / 2;
                        m_arrSampleBlobPads[i].fCenterY = (fVirStartY + fVirEndY) / 2;
                        m_arrSampleBlobPads[i].fArea = (float)intVirArea;
                    }
                }
                #endregion
            }
            catch
            {
            }
        }

        private void CheckBrokenMissingPad2_EBlob(ROI objROI, int intNumSelectedObject, bool blnCheckContamination)
        {
            try
            {
                /*
                 *  Virtual value will store float value 
                 * 
                 */

                #region ----- Check Missing Pad, Broken Pad/Build Virtual Objects -----
                float fLimitCenterX, fLimitCenterY, fWidth, fHeight;
                int intArea;

                for (int i = 0; i < m_arrTemplateBlobPads.Count; i++)
                {
                    if (m_intTemplateMatchStatus[i] == 0)
                    {
                        // Missing Pad (Must check)
                        //if ((m_intFailOptionMask & 0x04) > 0)
                        {
                            if (((BlobsFeatures)m_arrTemplateBlobPads[i]).blnEnable && WantPadReturnFailResultOrShowDrawing(blnCheckContamination))
                            {
                                m_intFailResultMask |= 0x04;
                                m_arrSampleBlobPads[i].intFailMask |= 0x04;
                            }
                        }
                    }
                    else if (m_intTemplateMatchStatus[i] >= 2)
                    {
                        // Broken Pad
                        //if (m_arrSampleBlobPads[i].intFailMask == 0)
                        //{
                        //    if ((m_intFailOptionMask & 0x08) > 0)
                        //    {
                        //        m_intFailResultMask |= 0x08;
                        //        m_arrSampleBlobPads[i].intFailMask |= 0x08;
                        //    }
                        //}

                        // group all sample data from same template area, then store in virtual storage as 1 big complate sample
                        int intVirArea;
                        float fVirStartX, fVirStartY, fVirEndX, fVirEndY;
                        float fStartX, fStartY, fEndX, fEndY;
                        intVirArea = 0;
                        fVirStartX = fVirStartY = fVirEndX = fVirEndY = 0f;
                        fStartX = fStartY = fEndX = fEndY = 0f;

                        bool bFirstTime = true;
                        for (int j = 0; j < intNumSelectedObject; j++)
                        {
                            // sample match number same with i (template number)
                            if (m_intSampleMatchNumber[j] == i)
                            {
                                fLimitCenterX = fLimitCenterY = fWidth = fHeight = 0;
                                intArea = 0;

                                // Get sample data
                                intArea = m_objEBlobs.ref_arrArea[j];
                                fLimitCenterX = m_objEBlobs.ref_arrLimitCenterX[j];
                                fLimitCenterY = m_objEBlobs.ref_arrLimitCenterY[j];
                                fWidth = m_objEBlobs.ref_arrWidth[j];
                                fHeight = m_objEBlobs.ref_arrHeight[j];

                                // Group sample data
                                intVirArea += intArea;
                                if (bFirstTime)
                                {
                                    bFirstTime = false;
                                    fVirStartX = fLimitCenterX - (fWidth / 2);
                                    fVirStartY = fLimitCenterY - (fHeight / 2);
                                    fVirEndX = fLimitCenterX + (fWidth / 2);
                                    fVirEndY = fLimitCenterY + (fHeight / 2);
                                }
                                else
                                {
                                    fStartX = fLimitCenterX - (fWidth / 2);
                                    fStartY = fLimitCenterY - (fHeight / 2);
                                    fEndX = fLimitCenterX + (fWidth / 2);
                                    fEndY = fLimitCenterY + (fHeight / 2);

                                    if (fStartX < fVirStartX)
                                        fVirStartX = fStartX;
                                    if (fStartY < fVirStartY)
                                        fVirStartY = fStartY;
                                    if (fEndX > fVirEndX)
                                        fVirEndX = fEndX;
                                    if (fEndY > fVirEndY)
                                        fVirEndY = fEndY;
                                }
                            }
                        }

                        m_arrSampleBlobPads[i].fStartX = fVirStartX;
                        m_arrSampleBlobPads[i].fStartY = fVirStartY;
                        m_arrSampleBlobPads[i].fEndX = fVirEndX;
                        m_arrSampleBlobPads[i].fEndY = fVirEndY;
                        m_arrSampleBlobPads[i].fWidth = fVirEndX - fVirStartX;
                        m_arrSampleBlobPads[i].fHeight = fVirEndY - fVirStartY;
                        m_arrSampleBlobPads[i].fCenterX = (fVirStartX + fVirEndX) / 2;
                        m_arrSampleBlobPads[i].fCenterY = (fVirStartY + fVirEndY) / 2;
                        m_arrSampleBlobPads[i].fArea = (float)intVirArea;
                    }
                }
                #endregion
            }
            catch
            {
            }
        }

        private void CheckPadHole(ROI objROI, int intNumSelectedObject)
        {
            #region ----- Check Hole Pad -----

            //if ((m_intFailOptionMask & 0x10) > 0)
            //{
            //    m_objBlobs.SetFirstListBlobs();

            //    for (int i = 0; i < intNumSelectedObject; i++)
            //    {
            //        if (m_intSampleMatchNumber[i] >= 0)
            //        {
            //            // Hole in Pad
            //            int intHoleMinArea = 0;
            //            int intHoleMaxArea = 0;
            //            int intNumberHolePresent = 0;
            //            List<int> arrDefectArea = new List<int>();
            //            List<float> arrDefectCenterX = new List<float>();
            //            List<float> arrDefectCenterY = new List<float>();
            //            List<float> arrDefectWidth = new List<float>();
            //            List<float> arrDefectHeight = new List<float>();
            //            m_objBlobs.GetNumberHolePresent2(((BlobsFeatures)m_arrTemplateBlobPads[m_intSampleMatchNumber[i]]).fMaxBroken,
            //                out intNumberHolePresent, out intHoleMinArea, out intHoleMaxArea,
            //                arrDefectArea, arrDefectCenterX, arrDefectCenterY, arrDefectWidth, arrDefectHeight);

            //            if (intNumberHolePresent > 0)
            //            {
            //                // Broken
            //                float fSmallestSetBrokenArea = float.MaxValue;
            //                for (int j = 0; j < m_arrTemplateBlobPads.Count; j++)
            //                {
            //                    if (fSmallestSetBrokenArea > ((BlobsFeatures)m_arrTemplateBlobPads[j]).fMaxBroken)
            //                        fSmallestSetBrokenArea = ((BlobsFeatures)m_arrTemplateBlobPads[j]).fMaxBroken;
            //                }

            //                float fHoleMaxArea = (int)intHoleMaxArea / m_fMMtoPixelAreaValue;
            //                if (fHoleMaxArea > fSmallestSetBrokenArea)
            //                {
            //                    // Fail hole
            //                    if (m_arrSampleBlobPads[m_intSampleMatchNumber[i]].intFailMask == 0)
            //                    {
            //                        for (int d = 0; d < intNumberHolePresent; d++)
            //                        {
            //                            Defect objDefect = new Defect();
            //                            objDefect.ref_fArea = Convert.ToSingle(arrDefectArea[d]);
            //                            objDefect.ref_fCenterX = objROI.ref_ROITotalX + arrDefectCenterX[d];
            //                            objDefect.ref_fCenterY = objROI.ref_ROITotalY + arrDefectCenterY[d];
            //                            objDefect.ref_fWidth = arrDefectWidth[d];
            //                            objDefect.ref_fHeight = arrDefectHeight[d];
            //                            m_arrPadDefectList.Add(objDefect);
            //                        }

            //                        m_intFailResultMask |= 0x10;
            //                        m_arrSampleBlobPads[m_intSampleMatchNumber[i]].intFailMask |= 0x10;

            //                        float fHoleMinArea = (int)intHoleMaxArea / m_fMMtoPixelAreaValue;
            //                        // Collect hole min and max area for display error message
            //                        if ((m_fResultBrokenMinArea == -1) || (intHoleMinArea < m_fResultBrokenMinArea))
            //                        {
            //                            m_fResultBrokenMinArea = intHoleMinArea;
            //                        }

            //                        if ((m_fResultBrokenMaxArea == -1) || (fHoleMaxArea > m_fResultBrokenMaxArea))
            //                        {
            //                            m_fResultBrokenMaxArea = fHoleMaxArea;
            //                        }

            //                    }
            //                }
            //            }
            //        }

            //        m_objBlobs.SetListBlobsToNext();
            //    }
            //}


            #endregion

        }

        private void FillDarkColorToCorner(ImageDrawing objImage,
            int intChippedOffToleranceX, int intChippedOffToleranceY, ROI objROI)
        {
            int intStartX1 = objROI.ref_ROITotalX;
            int intStartY1 = objROI.ref_ROITotalY;
            int intEndX1 = objROI.ref_ROITotalX + objROI.ref_ROIWidth;
            int intEndY1 = objROI.ref_ROITotalY + objROI.ref_ROIHeight;

            int intStartX2 = objROI.ref_ROITotalX + intChippedOffToleranceX;
            int intStartY2 = objROI.ref_ROITotalY + intChippedOffToleranceY;
            int intEndX2 = objROI.ref_ROITotalX + objROI.ref_ROIWidth - intChippedOffToleranceX;
            int intEndY2 = objROI.ref_ROITotalY + objROI.ref_ROIHeight - intChippedOffToleranceY;

            Line objLine1 = new Line();
            Line objLine2 = new Line();
            Line objLine3 = new Line();
            Line objLine4 = new Line();
            objLine1.CalculateStraightLine(new PointF(intStartX1, intStartY1), new PointF(intStartX2, intStartY2));
            objLine2.CalculateStraightLine(new PointF(intEndX1, intStartY1), new PointF(intEndX2, intStartY2));
            objLine3.CalculateStraightLine(new PointF(intStartX1, intEndY1), new PointF(intStartX2, intEndY2));
            objLine4.CalculateStraightLine(new PointF(intEndX1, intEndY1), new PointF(intEndX2, intEndY2));
            int x, y;
            EBW8 darkPixel = new EBW8();
            darkPixel.Value = 100;

            // -------- separate corner with dark line -------------------------------------------
            for (x = intStartX1; x < intStartX2; x++)
            {
                y = (int)Math.Round(objLine1.GetPointY(x), 0, MidpointRounding.AwayFromZero);
                objImage.ref_objMainImage.SetPixel(darkPixel, x, y);
            }
            for (x = intEndX2; x < intEndX1; x++)
            {
                y = (int)Math.Round(objLine2.GetPointY(x), 0, MidpointRounding.AwayFromZero);
                objImage.ref_objMainImage.SetPixel(darkPixel, x, y);
            }
            for (x = intStartX1; x < intStartX2; x++)
            {
                y = (int)Math.Round(objLine3.GetPointY(x), 0, MidpointRounding.AwayFromZero);
                objImage.ref_objMainImage.SetPixel(darkPixel, x, y);
            }
            for (x = intEndX2; x < intEndX1; x++)
            {
                y = (int)Math.Round(objLine4.GetPointY(x), 0, MidpointRounding.AwayFromZero);
                objImage.ref_objMainImage.SetPixel(darkPixel, x, y);
            }

            // ------------------- Set limit with dark pixel --------------------------------------------------
            for (x = intStartX2; x < intEndX2; x++)
            {
                objImage.ref_objMainImage.SetPixel(darkPixel, x, intStartY2);
            }
            for (x = intStartX2; x < intEndX2; x++)
            {
                objImage.ref_objMainImage.SetPixel(darkPixel, x, intEndY2);
            }
            for (y = intStartY2; y < intEndY2; y++)
            {
                objImage.ref_objMainImage.SetPixel(darkPixel, intStartX2, y);
            }
            for (y = intStartY2; y < intEndY2; y++)
            {
                objImage.ref_objMainImage.SetPixel(darkPixel, intEndX2, y);
            }

            // -------- fill corner with dark pixel -------------------------------------------
            int intStartoffSet = 1;
            int intEndOffSet = 1;
            int intLoopEndX = intStartX1 + intStartoffSet;
            int intLoopEndY = intStartY1 + intStartoffSet;
            for (x = intStartX1; x < intLoopEndX; x++)
            {
                for (y = intStartY1; y < intLoopEndY; y++)
                    objImage.ref_objMainImage.SetPixel(darkPixel, x, y);
            }
            for (x = intStartX1; x < intLoopEndX; x++)
            {
                for (y = intEndY1 - intEndOffSet; y < intEndY1; y++)
                    objImage.ref_objMainImage.SetPixel(darkPixel, x, y);
            }
            for (x = intEndX1 - intEndOffSet; x < intEndX1; x++)
            {
                for (y = intStartY1; y < intLoopEndY; y++)
                    objImage.ref_objMainImage.SetPixel(darkPixel, x, y);
            }
            for (x = intEndX1 - intEndOffSet; x < intEndX1; x++)
            {
                for (y = intEndY1 - intEndOffSet; y < intEndY1; y++)
                    objImage.ref_objMainImage.SetPixel(darkPixel, x, y);
            }
        }

        public void AddImage2PadToImage1(ROI objROI, ImageDrawing objImage2, int intPadIndex)
        {
            if (m_objEBlobs.ref_intNumSelectedObject == 0)
                return;

            int intOuterTolerance = 0;
            ROI objPadROI = new ROI();
            objPadROI.AttachImage(objROI);
            ROI objmage2ROI = new ROI();
            objmage2ROI.AttachImage(objImage2);
            objmage2ROI.LoadROISetting(objROI.ref_ROITotalX, objROI.ref_ROITotalY, objROI.ref_ROIWidth, objROI.ref_ROIHeight);
            ROI objPadImage2ROI = new ROI();
            objPadImage2ROI.AttachImage(objmage2ROI);

            BlobsFeatures stcBlobsFeatures;
            float fLimitCenterX = 0, fLimitCenterY = 0, fWidth = 0, fHeight = 0;
            float fStartX, fStartY, fEndX, fEndY;
            float fLimitCenterX2 = 0, fLimitCenterY2 = 0, fWidth2 = 0, fHeight2 = 0;
            float fStartX2, fStartY2, fEndX2, fEndY2;
            bool[] arrMatched = new bool[m_arrTemplateBlobPads.Count];
            for (int i = 0; i < m_objEBlobs.ref_intNumSelectedObject; i++)
            {
                intOuterTolerance = 0;
                fLimitCenterX = m_objEBlobs.ref_arrLimitCenterX[i];
                fLimitCenterY = m_objEBlobs.ref_arrLimitCenterY[i];
                fWidth = m_objEBlobs.ref_arrWidth[i];
                fHeight = m_objEBlobs.ref_arrHeight[i];

                // Get object start point and end point
                fStartX = fLimitCenterX - (fWidth / 2);
                fStartY = fLimitCenterY - (fHeight / 2);
                fEndX = fLimitCenterX + (fWidth / 2);
                fEndY = fLimitCenterY + (fHeight / 2);

                List<int> arrMatch = MatchTemplateObjects(fStartX, fStartY, fEndX, fEndY, fLimitCenterX, fLimitCenterY);

                if (arrMatch.Count == 1)
                {
                    stcBlobsFeatures = (BlobsFeatures)m_arrTemplateBlobPads[arrMatch[0]];

                    if (((fWidth / stcBlobsFeatures.fWidth) > 0.75) && ((fHeight / stcBlobsFeatures.fHeight) > 0.75))
                    {
                        arrMatched[arrMatch[0]] = true;

                        switch (intPadIndex)
                        {
                            case 1:
                                fWidth *= 1.5f;
                                fStartX = fLimitCenterX - (fWidth / 2);
                                // objPadROI.ref_ROI.Parent.Save("D:\\TS\\Parent.bmp");

                                objPadROI.LoadROISetting((int)fStartX, (int)fStartY + intOuterTolerance, (int)fWidth, (int)fHeight - intOuterTolerance);
                                //objPadImage2ROI.ref_ROI.Parent.Save("D:\\TS\\Parent2.bmp");
                                objPadImage2ROI.LoadROISetting((int)fStartX, (int)fStartY + intOuterTolerance, (int)fWidth, (int)fHeight - intOuterTolerance);
                                break;
                            case 2:
                                fHeight *= 1.5f;
                                fStartY = fLimitCenterY - (fHeight / 2);
                                objPadROI.LoadROISetting((int)fStartX, (int)fStartY, (int)fWidth - intOuterTolerance, (int)fHeight);
                                objPadImage2ROI.LoadROISetting((int)fStartX, (int)fStartY, (int)fWidth - intOuterTolerance, (int)fHeight);
                                break;
                            case 3:
                                fWidth *= 1.5f;
                                fStartX = fLimitCenterX - (fWidth / 2);
                                objPadROI.LoadROISetting((int)fStartX, (int)fStartY, (int)fWidth, (int)fHeight - intOuterTolerance);
                                objPadImage2ROI.LoadROISetting((int)fStartX, (int)fStartY, (int)fWidth, (int)fHeight - intOuterTolerance);
                                break;
                            case 4:
                                fHeight *= 1.5f;
                                fStartY = fLimitCenterY - (fHeight / 2);
                                objPadROI.LoadROISetting((int)fStartX + intOuterTolerance, (int)fStartY, (int)fWidth - intOuterTolerance, (int)fHeight);
                                objPadImage2ROI.LoadROISetting((int)fStartX + intOuterTolerance, (int)fStartY, (int)fWidth - intOuterTolerance, (int)fHeight);
                                break;
                        }

                        // Get tolerance from edge (intOuterTolerance value)
                        //=================================================================================================================

                        // Create small ROI for the extra area
                        m_objExtraPadEBlobs.BuildObjects_Filter_GetElement(objPadImage2ROI, !m_blnWhiteOnBlack, true, 0,
                            m_objEBlobs.ref_intAbsoluteThreshold, 1, m_objEBlobs.ref_intMaxAreaLimit,
                            false, 0x0C);


                        int intValue = 0;
                        if (m_objExtraPadEBlobs.ref_intNumSelectedObject > 0)
                        {
                            for (int j = 0; j < 1; j++)
                            {
                                // get the object dimension from small ROI and reset this new dimension to the extra area dimension
                                fLimitCenterX2 = m_objExtraPadEBlobs.ref_arrLimitCenterX[j];
                                fLimitCenterY2 = m_objExtraPadEBlobs.ref_arrLimitCenterY[j];
                                fWidth2 = m_objExtraPadEBlobs.ref_arrWidth[j];
                                fHeight2 = m_objExtraPadEBlobs.ref_arrHeight[j];

                                switch (intPadIndex)
                                {
                                    case 1:
                                        fStartY2 = fLimitCenterY2 - (fHeight2 / 2);
                                        intValue = (int)Math.Ceiling(fStartY2) + 2;
                                        if (j == 0 || intOuterTolerance > intValue)
                                            intOuterTolerance = intValue;
                                        break;
                                    case 2:
                                        fEndX2 = fLimitCenterX2 + (fWidth2 / 2);
                                        intValue = objPadROI.ref_ROIWidth - (int)Math.Floor(fEndX2) + 2;
                                        if (j == 0 || intOuterTolerance > intValue)
                                            intOuterTolerance = intValue;
                                        break;
                                    case 3:
                                        fEndY2 = fLimitCenterY2 + (fHeight2 / 2);
                                        intValue = objPadROI.ref_ROIHeight - (int)Math.Floor(fEndY2) + 2;
                                        if (j == 0 || intOuterTolerance > intValue)
                                            intOuterTolerance = intValue;
                                        break;
                                    case 4:
                                        fStartX2 = fLimitCenterX2 - (fWidth2 / 2);
                                        intValue = (int)Math.Ceiling(fStartX2) + 2;
                                        if (j == 0 || intOuterTolerance > intValue)
                                            intOuterTolerance = intValue;
                                        break;
                                }
                            }
                        }
                        if (m_objExtraPadEBlobs.ref_intNumSelectedObject > 0)
                        {
                            if (intOuterTolerance > 10)
                                intOuterTolerance = 10;
                            switch (intPadIndex)
                            {
                                case 1:
                                    objPadROI.LoadROISetting((int)fStartX, (int)fStartY + intOuterTolerance, (int)fWidth, (int)fHeight - intOuterTolerance);
                                    objPadImage2ROI.LoadROISetting((int)fStartX, (int)fStartY + intOuterTolerance, (int)fWidth, (int)fHeight - intOuterTolerance);
                                    break;
                                case 2:
                                    objPadROI.LoadROISetting((int)fStartX, (int)fStartY, (int)fWidth - intOuterTolerance, (int)fHeight);
                                    objPadImage2ROI.LoadROISetting((int)fStartX, (int)fStartY, (int)fWidth - intOuterTolerance, (int)fHeight);
                                    break;
                                case 3:
                                    objPadROI.LoadROISetting((int)fStartX, (int)fStartY, (int)fWidth, (int)fHeight - intOuterTolerance);
                                    objPadImage2ROI.LoadROISetting((int)fStartX, (int)fStartY, (int)fWidth, (int)fHeight - intOuterTolerance); break;
                                case 4:
                                    objPadROI.LoadROISetting((int)fStartX + intOuterTolerance, (int)fStartY, (int)fWidth - intOuterTolerance, (int)fHeight);
                                    objPadImage2ROI.LoadROISetting((int)fStartX + intOuterTolerance, (int)fStartY, (int)fWidth - intOuterTolerance, (int)fHeight);
                                    break;
                            }
                        }

                        //=================================================================================================================

                        EasyImage.Oper(EArithmeticLogicOperation.Max, objPadROI.ref_ROI, objPadImage2ROI.ref_ROI, objPadROI.ref_ROI);
                    }
                    else
                    {

                    }
                }
                else
                {
                }
            }

            for (int i = 0; i < m_arrTemplateBlobPads.Count; i++)
            {
                if (!arrMatched[i])
                {
                    intOuterTolerance = 0;

                    stcBlobsFeatures = (BlobsFeatures)m_arrTemplateBlobPads[i];

                    if (intPadIndex == 1 || intPadIndex == 3)
                    {
                        fWidth = stcBlobsFeatures.fWidth * 1.5f;
                        fHeight = stcBlobsFeatures.fHeight;
                    }
                    else
                    {
                        fWidth = stcBlobsFeatures.fWidth;
                        fHeight = stcBlobsFeatures.fHeight * 1.5f;
                    }
                    int intPossibleStartX;
                    int intPossibleStartY;
                    if (GetOverallWantGaugeMeasurePkgSize(false))
                    {
                        if (stcBlobsFeatures.fTemplateROICenterX == 0 && stcBlobsFeatures.fTemplateROICenterY == 0 && stcBlobsFeatures.fTemplateROITopLeftCornerX == 0 && stcBlobsFeatures.fTemplateROITopLeftCornerY == 0)
                        {
                            intPossibleStartX = (int)Math.Round(GetResultCenterPoint_RectGauge4L().X - objROI.ref_ROITotalX + stcBlobsFeatures.fXDistance - fWidth / 2, 0, MidpointRounding.AwayFromZero);
                            intPossibleStartY = (int)Math.Round(GetResultCenterPoint_RectGauge4L().Y - objROI.ref_ROITotalY + stcBlobsFeatures.fYDistance - fHeight / 2, 0, MidpointRounding.AwayFromZero);
                        }
                        else
                        {
                            if (m_intPadOffsetReferencePoint == 0)
                            {
                                intPossibleStartX = (int)Math.Round(GetResultCenterPoint_RectGauge4L().X - objROI.ref_ROITotalX + (stcBlobsFeatures.fLimitCenterX - stcBlobsFeatures.fTemplateROICenterX) - fWidth / 2, 0, MidpointRounding.AwayFromZero);
                                intPossibleStartY = (int)Math.Round(GetResultCenterPoint_RectGauge4L().Y - objROI.ref_ROITotalY + (stcBlobsFeatures.fLimitCenterY - stcBlobsFeatures.fTemplateROICenterY) - fHeight / 2, 0, MidpointRounding.AwayFromZero);
                            }
                            else
                            {
                                intPossibleStartX = (int)Math.Round(GetResultTopLeftCornerPoint_RectGauge4L().X - objROI.ref_ROITotalX + (stcBlobsFeatures.fLimitCenterX - stcBlobsFeatures.fTemplateROITopLeftCornerX) - fWidth / 2, 0, MidpointRounding.AwayFromZero);
                                intPossibleStartY = (int)Math.Round(GetResultTopLeftCornerPoint_RectGauge4L().Y - objROI.ref_ROITotalY + (stcBlobsFeatures.fLimitCenterY - stcBlobsFeatures.fTemplateROITopLeftCornerY) - fHeight / 2, 0, MidpointRounding.AwayFromZero);
                            }
                        }
                    }
                    else
                    {
                        if (stcBlobsFeatures.fTemplateROICenterX_Pattern == 0 && stcBlobsFeatures.fTemplateROICenterY_Pattern == 0 && stcBlobsFeatures.fTemplateROITopLeftCornerX_Pattern == 0 && stcBlobsFeatures.fTemplateROITopLeftCornerY_Pattern == 0)
                        {
                            intPossibleStartX = (int)Math.Round(m_pUnitCenterPoint.X - objROI.ref_ROITotalX + stcBlobsFeatures.fXDistance_Pattern - fWidth / 2, 0, MidpointRounding.AwayFromZero);
                            intPossibleStartY = (int)Math.Round(m_pUnitCenterPoint.Y - objROI.ref_ROITotalY + stcBlobsFeatures.fYDistance_Pattern - fHeight / 2, 0, MidpointRounding.AwayFromZero);
                        }
                        else
                        {
                            if (m_intPadOffsetReferencePoint == 0)
                            {
                                intPossibleStartX = (int)Math.Round(m_pUnitCenterPoint.X - objROI.ref_ROITotalX + (stcBlobsFeatures.fLimitCenterX - stcBlobsFeatures.fTemplateROICenterX_Pattern) - fWidth / 2, 0, MidpointRounding.AwayFromZero);
                                intPossibleStartY = (int)Math.Round(m_pUnitCenterPoint.Y - objROI.ref_ROITotalY + (stcBlobsFeatures.fLimitCenterY - stcBlobsFeatures.fTemplateROICenterY_Pattern) - fHeight / 2, 0, MidpointRounding.AwayFromZero);
                            }
                            else
                            {
                                intPossibleStartX = (int)Math.Round(GetResultTopLeftCornerPoint_UnitMatcher().X - objROI.ref_ROITotalX + (stcBlobsFeatures.fLimitCenterX - stcBlobsFeatures.fTemplateROITopLeftCornerX_Pattern) - fWidth / 2, 0, MidpointRounding.AwayFromZero);
                                intPossibleStartY = (int)Math.Round(GetResultTopLeftCornerPoint_UnitMatcher().Y - objROI.ref_ROITotalY + (stcBlobsFeatures.fLimitCenterY - stcBlobsFeatures.fTemplateROITopLeftCornerY_Pattern) - fHeight / 2, 0, MidpointRounding.AwayFromZero);
                            }
                        }
                    }
                   
                    switch (intPadIndex)
                    {
                        case 1:
                            objPadROI.LoadROISetting(intPossibleStartX, intPossibleStartY + intOuterTolerance, (int)fWidth, (int)fHeight - intOuterTolerance);
                            objPadImage2ROI.LoadROISetting(intPossibleStartX, intPossibleStartY + intOuterTolerance, (int)fWidth, (int)fHeight - intOuterTolerance);
                            break;
                        case 2:
                            objPadROI.LoadROISetting(intPossibleStartX, intPossibleStartY, (int)fWidth - intOuterTolerance, (int)fHeight);
                            objPadImage2ROI.LoadROISetting(intPossibleStartX, intPossibleStartY, (int)fWidth - intOuterTolerance, (int)fHeight);
                            break;
                        case 3:
                            objPadROI.LoadROISetting(intPossibleStartX, intPossibleStartY, (int)fWidth, (int)fHeight - intOuterTolerance);
                            objPadImage2ROI.LoadROISetting(intPossibleStartX, intPossibleStartY, (int)fWidth, (int)fHeight - intOuterTolerance);
                            break;
                        case 4:
                            objPadROI.LoadROISetting(intPossibleStartX + intOuterTolerance, intPossibleStartY, (int)fWidth - intOuterTolerance, (int)fHeight);
                            objPadImage2ROI.LoadROISetting(intPossibleStartX + intOuterTolerance, intPossibleStartY, (int)fWidth - intOuterTolerance, (int)fHeight);
                            break;
                    }

                    // Get tolerance from edge (intOuterTolerance value)
                    //=================================================================================================================

                    // Create small ROI for the extra area
                    m_objExtraPadEBlobs.BuildObjects_Filter_GetElement(objPadImage2ROI, !m_blnWhiteOnBlack, true, 0,
                        m_objEBlobs.ref_intAbsoluteThreshold, 1, m_objEBlobs.ref_intMaxAreaLimit,
                        false, 0x0C);


                    int intValue = 0;
                    for (int j = 0; j < 1; j++)
                    {
                        // get the object dimension from small ROI and reset this new dimension to the extra area dimension
                        fLimitCenterX2 = m_objExtraPadEBlobs.ref_arrLimitCenterX[j];
                        fLimitCenterY2 = m_objExtraPadEBlobs.ref_arrLimitCenterY[j];
                        fWidth2 = m_objExtraPadEBlobs.ref_arrWidth[j];
                        fHeight2 = m_objExtraPadEBlobs.ref_arrHeight[j];

                        switch (intPadIndex)
                        {
                            case 1:
                                fStartY2 = fLimitCenterY2 - (fHeight2 / 2);
                                intValue = (int)Math.Ceiling(fStartY2) + 2;
                                if (j == 0 || intOuterTolerance > intValue)
                                    intOuterTolerance = intValue;
                                break;
                            case 2:
                                fEndX2 = fLimitCenterX2 + (fWidth2 / 2);
                                intValue = objPadROI.ref_ROIWidth - (int)Math.Floor(fEndX2) + 2;
                                if (j == 0 || intOuterTolerance > intValue)
                                    intOuterTolerance = intValue;
                                break;
                            case 3:
                                fEndY2 = fLimitCenterY2 + (fHeight2 / 2);
                                intValue = objPadROI.ref_ROIHeight - (int)Math.Floor(fEndY2) + 2;
                                if (j == 0 || intOuterTolerance > intValue)
                                    intOuterTolerance = intValue;
                                break;
                            case 4:
                                fStartX2 = fLimitCenterX2 - (fWidth2 / 2);
                                intValue = (int)Math.Ceiling(fStartX2) + 2;
                                if (j == 0 || intOuterTolerance > intValue)
                                    intOuterTolerance = intValue;
                                break;
                        }
                    }

                    if (m_objExtraPadEBlobs.ref_intNumSelectedObject > 0)
                    {
                        switch (intPadIndex)
                        {
                            case 1:
                                objPadROI.LoadROISetting(intPossibleStartX, intPossibleStartY + intOuterTolerance, (int)stcBlobsFeatures.fWidth, (int)stcBlobsFeatures.fHeight - intOuterTolerance);
                                objPadImage2ROI.LoadROISetting(intPossibleStartX, intPossibleStartY + intOuterTolerance, (int)stcBlobsFeatures.fWidth, (int)stcBlobsFeatures.fHeight - intOuterTolerance);
                                break;
                            case 2:
                                objPadROI.LoadROISetting(intPossibleStartX, intPossibleStartY, (int)stcBlobsFeatures.fWidth - intOuterTolerance, (int)stcBlobsFeatures.fHeight);
                                objPadImage2ROI.LoadROISetting(intPossibleStartX, intPossibleStartY, (int)stcBlobsFeatures.fWidth - intOuterTolerance, (int)stcBlobsFeatures.fHeight); break;
                                break;
                            case 3:
                                objPadROI.LoadROISetting(intPossibleStartX, intPossibleStartY, (int)stcBlobsFeatures.fWidth, (int)stcBlobsFeatures.fHeight - intOuterTolerance);
                                objPadImage2ROI.LoadROISetting(intPossibleStartX, intPossibleStartY, (int)stcBlobsFeatures.fWidth, (int)stcBlobsFeatures.fHeight - intOuterTolerance);
                                break;
                            case 4:
                                objPadROI.LoadROISetting(intPossibleStartX + intOuterTolerance, intPossibleStartY, (int)stcBlobsFeatures.fWidth - intOuterTolerance, (int)stcBlobsFeatures.fHeight);
                                objPadImage2ROI.LoadROISetting(intPossibleStartX + intOuterTolerance, intPossibleStartY, (int)stcBlobsFeatures.fWidth - intOuterTolerance, (int)stcBlobsFeatures.fHeight);
                                break;
                        }
                    }

                    //=================================================================================================================

                    EasyImage.Oper(EArithmeticLogicOperation.Max, objPadROI.ref_ROI, objPadImage2ROI.ref_ROI, objPadROI.ref_ROI);
                }
            }

            objPadROI.Dispose();
            objmage2ROI.Dispose();
            objPadImage2ROI.Dispose();
        }

        public void AddMorphologyOpenToOuterEdge(ROI objROI, ROI objUnitSurfaceROI, int intPadIndex)
        {

            ROI objOuterEdgeROI = new ROI();
            objOuterEdgeROI.AttachImage(objROI);

            int intToleranceFromEdge = 15;
            switch (intPadIndex)
            {
                case 1: // Top Pad
                    objOuterEdgeROI.LoadROISetting(0, 0, objROI.ref_ROIWidth, intToleranceFromEdge);
                    break;
                case 2: // Right Pad
                    objOuterEdgeROI.LoadROISetting(objROI.ref_ROIWidth - intToleranceFromEdge, 0, intToleranceFromEdge, objROI.ref_ROIHeight);
                    break;
                case 3: // Bottom Pad
                    objOuterEdgeROI.LoadROISetting(0, objROI.ref_ROIHeight - intToleranceFromEdge, objROI.ref_ROIWidth, intToleranceFromEdge);
                    break;
                case 4: // Left Pad
                    objOuterEdgeROI.LoadROISetting(0, 0, intToleranceFromEdge, objROI.ref_ROIHeight);
                    break;
            }

            //switch (intPadIndex)
            //{
            //    case 1: // Top Pad
            //        objOuterEdgeROI.LoadROISetting(0, 0, objUnitSurfaceROI.ref_ROIWidth, intToleranceFromEdge);
            //        break;
            //    case 2: // Right Pad
            //        objOuterEdgeROI.LoadROISetting(objUnitSurfaceROI.ref_ROIWidth - intToleranceFromEdge, 0, intToleranceFromEdge, objUnitSurfaceROI.ref_ROIHeight);
            //        break;
            //    case 3: // Bottom Pad
            //        objOuterEdgeROI.LoadROISetting(0, objUnitSurfaceROI.ref_ROIHeight - intToleranceFromEdge, objUnitSurfaceROI.ref_ROIWidth, intToleranceFromEdge);
            //        break;
            //    case 4: // Left Pad
            //        objOuterEdgeROI.LoadROISetting(0, 0, intToleranceFromEdge, objUnitSurfaceROI.ref_ROIHeight);
            //        break;
            //}

            //            objROI.SaveImage("D:\\TS\\objROI.bmp");
            //            objUnitSurfaceROI.SaveImage("D:\\TS\\UnitSurfaceROI.bmp");
            //            objOuterEdgeROI.SaveImage("D:\\TS\\OuterEdgeROI.bmp");
            EasyImage.OpenBox(objOuterEdgeROI.ref_ROI);

            objOuterEdgeROI.Dispose();
        }


        public void DefineBlobsMinArea()
        {
            float fBlobsMinAreaMM = float.MaxValue;

            // comparison in mm
            //if (fBlobsMinAreaMM > m_fExtraPadSetArea)
            //    fBlobsMinAreaMM = m_fExtraPadSetArea;

            //if (fBlobsMinAreaMM > m_fExcessPadSetArea)
            //    fBlobsMinAreaMM = m_fExcessPadSetArea;

            // Broken
            float fSmallestSetBrokenArea = float.MaxValue;
            float fSmallestSetBrokenLength = float.MaxValue;
            for (int i = 0; i < m_arrTemplateBlobPads.Count; i++)
            {
                if (fSmallestSetBrokenArea > ((BlobsFeatures)m_arrTemplateBlobPads[i]).fMaxBroken)
                    fSmallestSetBrokenArea = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fMaxBroken;

                if (fSmallestSetBrokenLength > ((BlobsFeatures)m_arrTemplateBlobPads[i]).fMaxBrokenLength)
                    fSmallestSetBrokenLength = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fMaxBrokenLength;
            }
            if (fBlobsMinAreaMM > fSmallestSetBrokenArea)
                fBlobsMinAreaMM = fSmallestSetBrokenArea;

            // Change to pixel unit
            m_fBlobsMinArea = fBlobsMinAreaMM * m_fMMtoPixelAreaValue;

            if (m_fBlobsMinArea > fSmallestSetBrokenLength)
                m_fBlobsMinArea = fSmallestSetBrokenLength;

            if (m_fBlobsMinArea > (m_fScratchLength * Math.Min(m_fMMToPixelXValue, m_fMMToPixelYValue)))
                m_fBlobsMinArea = (m_fScratchLength * Math.Min(m_fMMToPixelXValue, m_fMMToPixelYValue));

            if (m_fBlobsMinArea > (m_fExcessPadSetLength * Math.Min(m_fMMToPixelXValue, m_fMMToPixelYValue)))
                m_fBlobsMinArea = (m_fExcessPadSetLength * Math.Min(m_fMMToPixelXValue, m_fMMToPixelYValue));

            if (m_fBlobsMinArea > (m_fExtraPadSetLength * Math.Min(m_fMMToPixelXValue, m_fMMToPixelYValue)))
                m_fBlobsMinArea = (m_fExtraPadSetLength * Math.Min(m_fMMToPixelXValue, m_fMMToPixelYValue));

            // Comparison in pixel
            if (m_fBlobsMinArea > m_fFilterMinArea)
            {
                m_fBlobsMinArea = m_fFilterMinArea; // Final Result
            }

            if (m_fBlobsMinArea < 1f)
                m_fBlobsMinArea = 1f;

        }


        // ------------------ Save Load Data ---------------------------------------------------------------------
        public void SaveColorPad(string strPath, bool blnNewFile, string strSectionName, bool blnNewSection)
        {
            XmlParser objFile = new XmlParser(strPath, blnNewFile);

            objFile.WriteSectionElement(strSectionName, blnNewSection);

            // Save PadSetting
            objFile.WriteElement1Value("ColorPadSetting", "");
            objFile.WriteElement2Value("ColorDefectLinkMethod", m_intColorDefectLinkMethod);
            objFile.WriteElement2Value("ColorDefectLinkTolerance", m_intColorDefectLinkTolerance);
            objFile.WriteElement2Value("ColorPadGroupIndex", m_intColorPadGroupIndex);
            objFile.WriteElement2Value("FailColorMask", m_intFailColorOptionMask);
            objFile.WriteElement2Value("ColorDefectCount", m_arrDefectColorThresName.Count);
            for (int v = 0; v < m_arrDefectColorThresName.Count; v++)
            {
                objFile.WriteElement1Value("ColorDefect" + v, "");
                objFile.WriteElement2Value("DefectColorThresName", m_arrDefectColorThresName[v]);
                objFile.WriteElement2Value("DefectColorSystem", m_arrDefectColorSystem[v]);
                objFile.WriteElement2Value("DefectCloseIteration", m_arrDefectCloseIteration[v]);
                objFile.WriteElement2Value("DefectInvertBlackWhite", m_arrDefectInvertBlackWhite[v]);
                objFile.WriteElement2Value("DefectColor0", m_arrDefectColor[v][0]);
                objFile.WriteElement2Value("DefectColor1", m_arrDefectColor[v][1]);
                objFile.WriteElement2Value("DefectColor2", m_arrDefectColor[v][2]);
                objFile.WriteElement2Value("DefectColorTolerance0", m_arrDefectColorTolerance[v][0]);
                objFile.WriteElement2Value("DefectColorTolerance1", m_arrDefectColorTolerance[v][1]);
                objFile.WriteElement2Value("DefectColorTolerance2", m_arrDefectColorTolerance[v][2]);
                objFile.WriteElement2Value("DefectColorMinArea", m_arrDefectColorMinArea[v]);
                objFile.WriteElement2Value("DefectType", m_arrDefectType[v]);
                objFile.WriteElement2Value("DefectImageNo", m_arrDefectImageNo[v]);
                objFile.WriteElement2Value("DefectDontCareMode", m_arrDefectDontCareMode[v]);
                objFile.WriteElement2Value("DefectColorInspection_Top", m_arrDefectColorInspection_Top[v]);
                objFile.WriteElement2Value("DefectColorInspection_Right", m_arrDefectColorInspection_Right[v]);
                objFile.WriteElement2Value("DefectColorInspection_Bottom", m_arrDefectColorInspection_Bottom[v]);
                objFile.WriteElement2Value("DefectColorInspection_Left", m_arrDefectColorInspection_Left[v]);
                objFile.WriteElement2Value("DefectColorInspectionFailCondition", m_arrDefectColorInspectionFailCondition[v]);
                objFile.WriteElement2Value("DefectColorInspectionWidth", m_arrDefectColorInspectionWidth[v]);
                objFile.WriteElement2Value("DefectColorInspectionLength", m_arrDefectColorInspectionLength[v]);
                objFile.WriteElement2Value("DefectColorInspectionMinArea", m_arrDefectColorInspectionMinArea[v]);
                objFile.WriteElement2Value("DefectColorInspectionMaxArea", m_arrDefectColorInspectionMaxArea[v]);
                objFile.WriteElement2Value("DefectColorInspectionTotalArea", m_arrDefectColorInspectionTotalArea[v]);
            }


            objFile.WriteEndElement();

        }
        public void SavePad(string strPath, bool blnNewFile, string strSectionName, bool blnNewSection)
        {
            XmlParser objFile = new XmlParser(strPath, blnNewFile);

            objFile.WriteSectionElement(strSectionName, blnNewSection);

            ////objFile.WriteElement1Value("OrientSetting", true);
            ////objFile.WriteElement2Value("MatchMinScore", m_smVisionInfo.g_arrPadOrient[i].ref_fMinScore);

            // Save PadSetting
            objFile.WriteElement1Value("PadSetting", "");
            objFile.WriteElement2Value("UnitMatcherTemplateCenterX", m_fUnitMatcherTemplateCenterX);
            objFile.WriteElement2Value("UnitMatcherTemplateCenterY", m_fUnitMatcherTemplateCenterY);
            objFile.WriteElement2Value("OrientDirections", m_intOrientDirections);
            objFile.WriteElement2Value("AngleTolerance", m_fAngleTolerance);
            objFile.WriteElement2Value("XTolerance", m_fXTolerance);
            objFile.WriteElement2Value("YTolerance", m_fYTolerance);
            objFile.WriteElement2Value("ThresholdValue", m_intThresholdValue);
            objFile.WriteElement2Value("CopperThresholdValue", m_intCopperThresholdValue);
            //objFile.WriteElement2Value("ImageMerge2ThresholdValue", m_intImageMerge2ThresholdValue);
            objFile.WriteElement2Value("ImageMerge2ThresholdHighValue", m_intImageMerge2ThresholdHighValue);
            objFile.WriteElement2Value("ImageMerge2ThresholdLowValue", m_intImageMerge2ThresholdLowValue);
            objFile.WriteElement2Value("InterPadThresholdValue", m_intInterPadThresholdValue);
            objFile.WriteElement2Value("SurfaceThresholdValue", m_intSurfaceThresholdValue);
            objFile.WriteElement2Value("SurfaceLowThresholdValue", m_intSurfaceLowThresholdValue);
            objFile.WriteElement2Value("MinSpanX", m_fMinSpanX);
            objFile.WriteElement2Value("MaxSpanX", m_fMaxSpanX);
            objFile.WriteElement2Value("MinSpanY", m_fMinSpanY);
            objFile.WriteElement2Value("MaxSpanY", m_fMaxSpanY);
            objFile.WriteElement2Value("EdgeDistanceMin_Top", m_fEdgeDistanceMin_Top);
            objFile.WriteElement2Value("EdgeDistanceMax_Top", m_fEdgeDistanceMax_Top);
            objFile.WriteElement2Value("EdgeDistanceMin_Right", m_fEdgeDistanceMin_Right);
            objFile.WriteElement2Value("EdgeDistanceMax_Right", m_fEdgeDistanceMax_Right);
            objFile.WriteElement2Value("EdgeDistanceMin_Bottom", m_fEdgeDistanceMin_Bottom);
            objFile.WriteElement2Value("EdgeDistanceMax_Bottom", m_fEdgeDistanceMax_Bottom);
            objFile.WriteElement2Value("EdgeDistanceMin_Left", m_fEdgeDistanceMin_Left);
            objFile.WriteElement2Value("EdgeDistanceMax_Left", m_fEdgeDistanceMax_Left);
            objFile.WriteElement2Value("ExtraPadMinArea", m_fExtraPadSetArea);
            objFile.WriteElement2Value("TotalExtraPadMinArea", m_fTotalExtraPadSetArea);
            objFile.WriteElement2Value("ExcessPadMinArea", m_fExcessPadSetArea);
            objFile.WriteElement2Value("ExtraPadSetLength", m_fExtraPadSetLength);
            objFile.WriteElement2Value("ExcessPadSetLength", m_fExcessPadSetLength);
            objFile.WriteElement2Value("SmearLength", m_fSmearLength);
            objFile.WriteElement2Value("MinArea", m_fFilterMinArea);
            objFile.WriteElement2Value("InspectionMinArea", m_fBlobsMinArea);
            objFile.WriteElement2Value("InspectionImageMerge2MinArea", m_fImageMerge2BlobsMinArea);
            objFile.WriteElement2Value("SurfaceMinArea", m_fSurfaceMinArea);
            objFile.WriteElement2Value("Image2SurfaceMinArea", m_fImage2SurfaceMinArea);
            objFile.WriteElement2Value("MoldFlashMinArea", m_fMoldFlashMinArea);
            objFile.WriteElement2Value("VoidMinArea", m_fVoidMinArea);
            objFile.WriteElement2Value("CrackMinArea", m_fCrackMinArea);
            objFile.WriteElement2Value("ForeignMaterialBrightFieldMinArea", m_intForeignMaterialBrightFieldMinArea);
            objFile.WriteElement2Value("BrightFieldMinArea", m_intBrightFieldMinArea);
            objFile.WriteElement2Value("DarkFieldMinArea", m_intDarkFieldMinArea);

            objFile.WriteElement2Value("PadWidthLengthMode", m_intPadWidthLengthMode);
            objFile.WriteElement2Value("PadLabelRefCorner", m_intPadLabelRefCorner);
            objFile.WriteElement2Value("PadLabelDirection", m_intPadLabelDirection);
            objFile.WriteElement2Value("PadStartX", m_fPadRangeStartX);
            objFile.WriteElement2Value("PadStartY", m_fPadRangeStartY);
            objFile.WriteElement2Value("PadEndX", m_fPadRangeEndX);
            objFile.WriteElement2Value("PadEndY", m_fPadRangeEndY);
            objFile.WriteElement2Value("FailMask", m_intFailOptionMask);
            objFile.WriteElement2Value("FailPkgMask", m_intFailPkgOptionMask);
            objFile.WriteElement2Value("WantInspectPackage", m_blnInspectPackage);
            objFile.WriteElement2Value("WhiteOnBlack", m_blnWhiteOnBlack);
            objFile.WriteElement2Value("DefaultPixelTolerance", m_fDefaultPixelTolerance);
            //objFile.WriteElement2Value("PadSizeHalfWidthTolerance", m_intPadSizeHalfWidthTolerance);  // 2019 08 27 - CCENG : No longer use. Replaced by m_intMPErodeHalfWidth and m_intMPDilateHalfWidth
            objFile.WriteElement2Value("TightSettingThresholdTolerance", m_intTightSettingThresholdTolerance);
            objFile.WriteElement2Value("TightSettingTolerance", m_fTightSettingTolerance);
            objFile.WriteElement2Value("SensitivityOnPadMethod", m_intSensitivityOnPadMethod);
            objFile.WriteElement2Value("SensitivityOnPadValue", m_intSensitivityOnPadValue);
            objFile.WriteElement2Value("InspectPadMode", m_intInspectPadMode);
            objFile.WriteElement2Value("EmptyMinScore", m_fEmptyMinScore);
            objFile.WriteElement2Value("UseEmtpyUnitThreshold", m_bUseEmptyUnitThreshold);
            objFile.WriteElement2Value("WantGaugeMeasurePkgSize", m_blnWantGaugeMeasurePkgSize);
            objFile.WriteElement2Value("MeasureCenterPkgSizeUsingSidePkg", m_blnMeasureCenterPkgSizeUsingSidePkg);
            objFile.WriteElement2Value("UseDetailDefectCriteria", m_blnUseDetailDefectCriteria);
            objFile.WriteElement2Value("EmptyAreaLimit", m_intEmptyAreaLimit);
            objFile.WriteElement2Value("EmptyThreshold", m_intEmptyThreshold);
            objFile.WriteElement2Value("EmptyAreaColorTransition", m_intEmptyAreaColorTransition);
            objFile.WriteElement2Value("PadPRSScore", m_fPadPRSScore);
            objFile.WriteElement2Value("UnitAngleLimit", m_fUnitAngleLimit);
            objFile.WriteElement2Value("PosToleranceX", m_fPosToleranceX);
            objFile.WriteElement2Value("PosToleranceY", m_fPosToleranceY);
            objFile.WriteElement2Value("ImageGain", m_fImageGain);
            objFile.WriteElement2Value("GaugeSizeImageIndex", m_intGaugeSizeImageIndex);
            objFile.WriteElement2Value("CheckPadDimensionImageIndex", m_intCheckPadDimensionImageIndex);
            objFile.WriteElement2Value("PadROISizeTolerance", m_intPadROISizeTolerance);
            objFile.WriteElement2Value("PadROISizeToleranceADV", m_intPadROISizeToleranceADV);
            objFile.WriteElement2Value("BrokenPadImageViewNo", m_intBrokenPadImageViewNo);
            objFile.WriteElement2Value("WantUseBorderLimitAsOffset", m_blnWantUseBorderLimitAsOffset);
            objFile.WriteElement2Value("WantIndividualSideThickness", m_blnWantIndividualSideThickness);

            objFile.WriteElement2Value("WantTightSetting", m_blnWantTightSetting);
            objFile.WriteElement2Value("WantConsiderPadImage2", m_blnWantConsiderPadImage2);
            objFile.WriteElement2Value("WantPRUnitLocationBeforeGauge", m_blnWantPRUnitLocationBeforeGauge);
            objFile.WriteElement2Value("WantUseGaugeMeasureDimension", m_blnWantUseGaugeMeasureDimension);
            objFile.WriteElement2Value("WantUseClosestSizeDefineTolerance", m_blnWantUseClosestSizeDefineTolerance);
            objFile.WriteElement2Value("WantAutoGauge", m_blnWantAutoGauge);
            objFile.WriteElement2Value("WantRotateSidePadImage", m_blnWantRotateSidePadImage);
            objFile.WriteElement2Value("WantLinkDifferentGroupPitchGap", m_blnWantLinkDifferentGroupPitchGap);
            objFile.WriteElement2Value("WantShowUseGaugeCheckBox", m_blnWantShowUseGaugeCheckBox);
            objFile.WriteElement2Value("WantSeparateBrokenPadThresholdSetting", m_blnWantSeparateBrokenPadThresholdSetting); 
            objFile.WriteElement2Value("WantUseGroupToleranceSetting", m_blnWantUseGroupToleranceSetting);
            objFile.WriteElement2Value("WantViewCheckForeignMaterialOptionWhenPackageON", m_blnWantViewCheckForeignMaterialOptionWhenPackageON);

            objFile.WriteElement2Value("WantCheckExtraPadLength", m_blnWantCheckExtraPadLength);
            objFile.WriteElement2Value("WantCheckExtraPadArea", m_blnWantCheckExtraPadArea);
            objFile.WriteElement2Value("WantCheckBrokenPadLength", m_blnWantCheckBrokenPadLength);
            objFile.WriteElement2Value("WantCheckBrokenPadArea", m_blnWantCheckBrokenPadArea);
            objFile.WriteElement2Value("WantCheckSmearPadLength", m_blnWantCheckSmearPadLength);
            objFile.WriteElement2Value("WantCheckPadEdgeLimit", m_blnWantCheckPadEdgeLimit);
            objFile.WriteElement2Value("WantCheckPadEdgeDistance", m_blnWantCheckPadEdgeDistance);
            objFile.WriteElement2Value("WantCheckPadSpanX", m_blnWantCheckPadSpanX);
            objFile.WriteElement2Value("WantCheckPadSpanY", m_blnWantCheckPadSpanY);
            objFile.WriteElement2Value("WantCheckPadStandOff", m_blnWantCheckPadStandOff); 
            objFile.WriteElement2Value("WantCheckExcessPadLength", m_blnWantCheckExcessPadLength);
            objFile.WriteElement2Value("WantCheckExcessPadArea", m_blnWantCheckExcessPadArea);

            objFile.WriteElement2Value("PadROIStartPixelFromTop", m_intPadROIStartPixelFromTop);
            objFile.WriteElement2Value("PadROIStartPixelFromRight", m_intPadROIStartPixelFromRight);
            objFile.WriteElement2Value("PadROIStartPixelFromBottom", m_intPadROIStartPixelFromBottom);
            objFile.WriteElement2Value("PadROIStartPixelFromLeft", m_intPadROIStartPixelFromLeft);

            int intBlobsCount = GetBlobsFeaturesNumber();
            objFile.WriteElement2Value("BlobsFeaturesCount", intBlobsCount);
            objFile.WriteElement2Value("GroupBlobsFeaturesCount", m_arrGroupTemplateBlobPads.Count);
            int intTotalPitchGap = GetTotalPitchGap();
            objFile.WriteElement2Value("PitchGapCount", intTotalPitchGap);

            objFile.WriteElement1Value("ColorPadSetting", "");
            objFile.WriteElement2Value("ColorDefectLinkMethod", m_intColorDefectLinkMethod);
            objFile.WriteElement2Value("ColorDefectLinkTolerance", m_intColorDefectLinkTolerance);
            objFile.WriteElement2Value("ColorPadGroupIndex", m_intColorPadGroupIndex);
            objFile.WriteElement2Value("FailColorMask", m_intFailColorOptionMask);
            objFile.WriteElement2Value("ColorDefectCount", m_arrDefectColorThresName.Count);
            for (int v = 0; v < m_arrDefectColorThresName.Count; v++)
            {
                objFile.WriteElement1Value("ColorDefect" + v, "");
                objFile.WriteElement2Value("DefectColorThresName", m_arrDefectColorThresName[v]);
                objFile.WriteElement2Value("DefectColorSystem", m_arrDefectColorSystem[v]);
                objFile.WriteElement2Value("DefectCloseIteration", m_arrDefectCloseIteration[v]);
                objFile.WriteElement2Value("DefectInvertBlackWhite", m_arrDefectInvertBlackWhite[v]);
                objFile.WriteElement2Value("DefectColor0", m_arrDefectColor[v][0]);
                objFile.WriteElement2Value("DefectColor1", m_arrDefectColor[v][1]);
                objFile.WriteElement2Value("DefectColor2", m_arrDefectColor[v][2]);
                objFile.WriteElement2Value("DefectColorTolerance0", m_arrDefectColorTolerance[v][0]);
                objFile.WriteElement2Value("DefectColorTolerance1", m_arrDefectColorTolerance[v][1]);
                objFile.WriteElement2Value("DefectColorTolerance2", m_arrDefectColorTolerance[v][2]);
                objFile.WriteElement2Value("DefectColorMinArea", m_arrDefectColorMinArea[v]);
                objFile.WriteElement2Value("DefectType", m_arrDefectType[v]);
                objFile.WriteElement2Value("DefectImageNo", m_arrDefectImageNo[v]);
                objFile.WriteElement2Value("DefectDontCareMode", m_arrDefectDontCareMode[v]);
                objFile.WriteElement2Value("DefectColorInspection_Top", m_arrDefectColorInspection_Top[v]);
                objFile.WriteElement2Value("DefectColorInspection_Right", m_arrDefectColorInspection_Right[v]);
                objFile.WriteElement2Value("DefectColorInspection_Bottom", m_arrDefectColorInspection_Bottom[v]);
                objFile.WriteElement2Value("DefectColorInspection_Left", m_arrDefectColorInspection_Left[v]);
                objFile.WriteElement2Value("DefectColorInspectionFailCondition", m_arrDefectColorInspectionFailCondition[v]);
                objFile.WriteElement2Value("DefectColorInspectionWidth", m_arrDefectColorInspectionWidth[v]);
                objFile.WriteElement2Value("DefectColorInspectionLength", m_arrDefectColorInspectionLength[v]);
                objFile.WriteElement2Value("DefectColorInspectionMinArea", m_arrDefectColorInspectionMinArea[v]);
                objFile.WriteElement2Value("DefectColorInspectionMaxArea", m_arrDefectColorInspectionMaxArea[v]);
                objFile.WriteElement2Value("DefectColorInspectionTotalArea", m_arrDefectColorInspectionTotalArea[v]);
            }

            // Save BlobsFeatures
            string strBlobsFeatures = GetBlobsFeaturesAllData();
            string[] strFeature = strBlobsFeatures.Split('#');

            int intFeatureIndex = 0;
            for (int v = 0; v < intBlobsCount; v++)
            {
                int intNoID = Convert.ToInt32(strFeature[intFeatureIndex]);
                objFile.WriteElement1Value("BlobsFeatures" + v, "");
                objFile.WriteElement2Value("NoID", strFeature[intFeatureIndex++], "Pad " + intNoID.ToString(), true);
                objFile.WriteElement2Value("GroupNo", strFeature[intFeatureIndex++], "Pad " + intNoID.ToString(), true);
                objFile.WriteElement2Value("Area", strFeature[intFeatureIndex++], "Pad " + intNoID.ToString(), true);
                objFile.WriteElement2Value("LengthMode", strFeature[intFeatureIndex++], "Pad " + intNoID.ToString(), true);
                objFile.WriteElement2Value("ContourX", strFeature[intFeatureIndex++], "Pad " + intNoID.ToString(), true);
                objFile.WriteElement2Value("ContourY", strFeature[intFeatureIndex++], "Pad " + intNoID.ToString(), true);
                objFile.WriteElement2Value("StartX", strFeature[intFeatureIndex++], "Pad " + intNoID.ToString(), true);
                objFile.WriteElement2Value("StartY", strFeature[intFeatureIndex++], "Pad " + intNoID.ToString(), true);
                objFile.WriteElement2Value("EndX", strFeature[intFeatureIndex++], "Pad " + intNoID.ToString(), true);
                objFile.WriteElement2Value("EndY", strFeature[intFeatureIndex++], "Pad " + intNoID.ToString(), true);
                objFile.WriteElement2Value("fStartX", strFeature[intFeatureIndex++], "Pad " + intNoID.ToString(), true);
                objFile.WriteElement2Value("fStartY", strFeature[intFeatureIndex++], "Pad " + intNoID.ToString(), true);
                objFile.WriteElement2Value("fEndX", strFeature[intFeatureIndex++], "Pad " + intNoID.ToString(), true);
                objFile.WriteElement2Value("fEndY", strFeature[intFeatureIndex++], "Pad " + intNoID.ToString(), true);
                objFile.WriteElement2Value("Direction", strFeature[intFeatureIndex++], "Pad " + intNoID.ToString(), true);
                objFile.WriteElement2Value("PadSide", strFeature[intFeatureIndex++], "Pad " + intNoID.ToString(), true);
                objFile.WriteElement2Value("SmearSide", strFeature[intFeatureIndex++], "Pad " + intNoID.ToString(), true);
                objFile.WriteElement2Value("GravityCenterX", strFeature[intFeatureIndex++], "Pad " + intNoID.ToString(), true);
                objFile.WriteElement2Value("GravityCenterY", strFeature[intFeatureIndex++], "Pad " + intNoID.ToString(), true);
                objFile.WriteElement2Value("LimitCenterX", strFeature[intFeatureIndex++], "Pad " + intNoID.ToString(), true);
                objFile.WriteElement2Value("LimitCenterY", strFeature[intFeatureIndex++], "Pad " + intNoID.ToString(), true);
                objFile.WriteElement2Value("Width", strFeature[intFeatureIndex++], "Pad " + intNoID.ToString(), true);
                objFile.WriteElement2Value("Height", strFeature[intFeatureIndex++], "Pad " + intNoID.ToString(), true);

                objFile.WriteElement2Value("PercentWidthStart1", strFeature[intFeatureIndex++], "Pad " + intNoID.ToString(), true);
                objFile.WriteElement2Value("PercentHeightStart1", strFeature[intFeatureIndex++], "Pad " + intNoID.ToString(), true);
                objFile.WriteElement2Value("PercentWidthEnd1", strFeature[intFeatureIndex++], "Pad " + intNoID.ToString(), true);
                objFile.WriteElement2Value("PercentHeightEnd1", strFeature[intFeatureIndex++], "Pad " + intNoID.ToString(), true);
                objFile.WriteElement2Value("PercentWidthStart2", strFeature[intFeatureIndex++], "Pad " + intNoID.ToString(), true);
                objFile.WriteElement2Value("PercentHeightStart2", strFeature[intFeatureIndex++], "Pad " + intNoID.ToString(), true);
                objFile.WriteElement2Value("PercentWidthEnd2", strFeature[intFeatureIndex++], "Pad " + intNoID.ToString(), true);
                objFile.WriteElement2Value("PercentHeightEnd2", strFeature[intFeatureIndex++], "Pad " + intNoID.ToString(), true);
                objFile.WriteElement2Value("PercentWidthStart3", strFeature[intFeatureIndex++], "Pad " + intNoID.ToString(), true);
                objFile.WriteElement2Value("PercentHeightStart3", strFeature[intFeatureIndex++], "Pad " + intNoID.ToString(), true);
                objFile.WriteElement2Value("PercentWidthEnd3", strFeature[intFeatureIndex++], "Pad " + intNoID.ToString(), true);
                objFile.WriteElement2Value("PercentHeightEnd3", strFeature[intFeatureIndex++], "Pad " + intNoID.ToString(), true);
                objFile.WriteElement2Value("PercentWidthStart4", strFeature[intFeatureIndex++], "Pad " + intNoID.ToString(), true);
                objFile.WriteElement2Value("PercentHeightStart4", strFeature[intFeatureIndex++], "Pad " + intNoID.ToString(), true);
                objFile.WriteElement2Value("PercentWidthEnd4", strFeature[intFeatureIndex++], "Pad " + intNoID.ToString(), true);
                objFile.WriteElement2Value("PercentHeightEnd4", strFeature[intFeatureIndex++], "Pad " + intNoID.ToString(), true);
                objFile.WriteElement2Value("PercentWidthStart5", strFeature[intFeatureIndex++], "Pad " + intNoID.ToString(), true);
                objFile.WriteElement2Value("PercentHeightStart5", strFeature[intFeatureIndex++], "Pad " + intNoID.ToString(), true);
                objFile.WriteElement2Value("PercentWidthEnd5", strFeature[intFeatureIndex++], "Pad " + intNoID.ToString(), true);
                objFile.WriteElement2Value("PercentHeightEnd5", strFeature[intFeatureIndex++], "Pad " + intNoID.ToString(), true);
                objFile.WriteElement2Value("PercentWidthStart6", strFeature[intFeatureIndex++], "Pad " + intNoID.ToString(), true);
                objFile.WriteElement2Value("PercentHeightStart6", strFeature[intFeatureIndex++], "Pad " + intNoID.ToString(), true);
                objFile.WriteElement2Value("PercentWidthEnd6", strFeature[intFeatureIndex++], "Pad " + intNoID.ToString(), true);
                objFile.WriteElement2Value("PercentHeightEnd6", strFeature[intFeatureIndex++], "Pad " + intNoID.ToString(), true);
                objFile.WriteElement2Value("PercentWidthStart7", strFeature[intFeatureIndex++], "Pad " + intNoID.ToString(), true);
                objFile.WriteElement2Value("PercentHeightStart7", strFeature[intFeatureIndex++], "Pad " + intNoID.ToString(), true);
                objFile.WriteElement2Value("PercentWidthEnd7", strFeature[intFeatureIndex++], "Pad " + intNoID.ToString(), true);
                objFile.WriteElement2Value("PercentHeightEnd7", strFeature[intFeatureIndex++], "Pad " + intNoID.ToString(), true);
                objFile.WriteElement2Value("PercentWidthStart8", strFeature[intFeatureIndex++], "Pad " + intNoID.ToString(), true);
                objFile.WriteElement2Value("PercentHeightStart8", strFeature[intFeatureIndex++], "Pad " + intNoID.ToString(), true);
                objFile.WriteElement2Value("PercentWidthEnd8", strFeature[intFeatureIndex++], "Pad " + intNoID.ToString(), true);
                objFile.WriteElement2Value("PercentHeightEnd8", strFeature[intFeatureIndex++], "Pad " + intNoID.ToString(), true);
                objFile.WriteElement2Value("PercentWidthStart9", strFeature[intFeatureIndex++], "Pad " + intNoID.ToString(), true);
                objFile.WriteElement2Value("PercentHeightStart9", strFeature[intFeatureIndex++], "Pad " + intNoID.ToString(), true);
                objFile.WriteElement2Value("PercentWidthEnd9", strFeature[intFeatureIndex++], "Pad " + intNoID.ToString(), true);
                objFile.WriteElement2Value("PercentHeightEnd9", strFeature[intFeatureIndex++], "Pad " + intNoID.ToString(), true);
                objFile.WriteElement2Value("PercentWidthStart10", strFeature[intFeatureIndex++], "Pad " + intNoID.ToString(), true);
                objFile.WriteElement2Value("PercentHeightStart10", strFeature[intFeatureIndex++], "Pad " + intNoID.ToString(), true);
                objFile.WriteElement2Value("PercentWidthEnd10", strFeature[intFeatureIndex++], "Pad " + intNoID.ToString(), true);
                objFile.WriteElement2Value("PercentHeightEnd10", strFeature[intFeatureIndex++], "Pad " + intNoID.ToString(), true);
                objFile.WriteElement2Value("PercentWidthStart11", strFeature[intFeatureIndex++], "Pad " + intNoID.ToString(), true);
                objFile.WriteElement2Value("PercentHeightStart11", strFeature[intFeatureIndex++], "Pad " + intNoID.ToString(), true);
                objFile.WriteElement2Value("PercentWidthEnd11", strFeature[intFeatureIndex++], "Pad " + intNoID.ToString(), true);
                objFile.WriteElement2Value("PercentHeightEnd11", strFeature[intFeatureIndex++], "Pad " + intNoID.ToString(), true);
                objFile.WriteElement2Value("PercentWidthStart12", strFeature[intFeatureIndex++], "Pad " + intNoID.ToString(), true);
                objFile.WriteElement2Value("PercentHeightStart12", strFeature[intFeatureIndex++], "Pad " + intNoID.ToString(), true);
                objFile.WriteElement2Value("PercentWidthEnd12", strFeature[intFeatureIndex++], "Pad " + intNoID.ToString(), true);
                objFile.WriteElement2Value("PercentHeightEnd12", strFeature[intFeatureIndex++], "Pad " + intNoID.ToString(), true);

                objFile.WriteElement2Value("InwardPercentStart1", strFeature[intFeatureIndex++], "Pad " + intNoID.ToString(), true);
                objFile.WriteElement2Value("InwardPercentEnd1", strFeature[intFeatureIndex++], "Pad " + intNoID.ToString(), true);
                objFile.WriteElement2Value("InwardPercentStart2", strFeature[intFeatureIndex++], "Pad " + intNoID.ToString(), true);
                objFile.WriteElement2Value("InwardPercentEnd2", strFeature[intFeatureIndex++], "Pad " + intNoID.ToString(), true);
                objFile.WriteElement2Value("InwardPercentStart3", strFeature[intFeatureIndex++], "Pad " + intNoID.ToString(), true);
                objFile.WriteElement2Value("InwardPercentEnd3", strFeature[intFeatureIndex++], "Pad " + intNoID.ToString(), true);
                objFile.WriteElement2Value("InwardPercentStart4", strFeature[intFeatureIndex++], "Pad " + intNoID.ToString(), true);
                objFile.WriteElement2Value("InwardPercentEnd4", strFeature[intFeatureIndex++], "Pad " + intNoID.ToString(), true);
                objFile.WriteElement2Value("InwardPercentStart5", strFeature[intFeatureIndex++], "Pad " + intNoID.ToString(), true);
                objFile.WriteElement2Value("InwardPercentEnd5", strFeature[intFeatureIndex++], "Pad " + intNoID.ToString(), true);
                objFile.WriteElement2Value("InwardPercentStart6", strFeature[intFeatureIndex++], "Pad " + intNoID.ToString(), true);
                objFile.WriteElement2Value("InwardPercentEnd6", strFeature[intFeatureIndex++], "Pad " + intNoID.ToString(), true);
                objFile.WriteElement2Value("InwardPercentStart7", strFeature[intFeatureIndex++], "Pad " + intNoID.ToString(), true);
                objFile.WriteElement2Value("InwardPercentEnd7", strFeature[intFeatureIndex++], "Pad " + intNoID.ToString(), true);
                objFile.WriteElement2Value("InwardPercentStart8", strFeature[intFeatureIndex++], "Pad " + intNoID.ToString(), true);
                objFile.WriteElement2Value("InwardPercentEnd8", strFeature[intFeatureIndex++], "Pad " + intNoID.ToString(), true);
                objFile.WriteElement2Value("InwardPercentStart9", strFeature[intFeatureIndex++], "Pad " + intNoID.ToString(), true);
                objFile.WriteElement2Value("InwardPercentEnd9", strFeature[intFeatureIndex++], "Pad " + intNoID.ToString(), true);
                objFile.WriteElement2Value("InwardPercentStart10", strFeature[intFeatureIndex++], "Pad " + intNoID.ToString(), true);
                objFile.WriteElement2Value("InwardPercentEnd10", strFeature[intFeatureIndex++], "Pad " + intNoID.ToString(), true);
                objFile.WriteElement2Value("InwardPercentStart11", strFeature[intFeatureIndex++], "Pad " + intNoID.ToString(), true);
                objFile.WriteElement2Value("InwardPercentEnd11", strFeature[intFeatureIndex++], "Pad " + intNoID.ToString(), true);
                objFile.WriteElement2Value("InwardPercentStart12", strFeature[intFeatureIndex++], "Pad " + intNoID.ToString(), true);
                objFile.WriteElement2Value("InwardPercentEnd12", strFeature[intFeatureIndex++], "Pad " + intNoID.ToString(), true);

                objFile.WriteElement2Value("MeasureMethod1", strFeature[intFeatureIndex++], "Pad " + intNoID.ToString(), true);
                objFile.WriteElement2Value("MeasureMethod2", strFeature[intFeatureIndex++], "Pad " + intNoID.ToString(), true);
                objFile.WriteElement2Value("MeasureMethod3", strFeature[intFeatureIndex++], "Pad " + intNoID.ToString(), true);
                objFile.WriteElement2Value("MeasureMethod4", strFeature[intFeatureIndex++], "Pad " + intNoID.ToString(), true);
                objFile.WriteElement2Value("MeasureMethod5", strFeature[intFeatureIndex++], "Pad " + intNoID.ToString(), true);
                objFile.WriteElement2Value("MeasureMethod6", strFeature[intFeatureIndex++], "Pad " + intNoID.ToString(), true);
                objFile.WriteElement2Value("MeasureMethod7", strFeature[intFeatureIndex++], "Pad " + intNoID.ToString(), true);
                objFile.WriteElement2Value("MeasureMethod8", strFeature[intFeatureIndex++], "Pad " + intNoID.ToString(), true);
                objFile.WriteElement2Value("MeasureMethod9", strFeature[intFeatureIndex++], "Pad " + intNoID.ToString(), true);
                objFile.WriteElement2Value("MeasureMethod10", strFeature[intFeatureIndex++], "Pad " + intNoID.ToString(), true);
                objFile.WriteElement2Value("MeasureMethod11", strFeature[intFeatureIndex++], "Pad " + intNoID.ToString(), true);
                objFile.WriteElement2Value("MeasureMethod12", strFeature[intFeatureIndex++], "Pad " + intNoID.ToString(), true);

                objFile.WriteElement2Value("Angle", strFeature[intFeatureIndex++], "Pad " + intNoID.ToString(), true);

                objFile.WriteElement2Value("LineCount", strFeature[intFeatureIndex++], "Pad " + intNoID.ToString(), true);

                objFile.WriteElement2Value("FeretWidth", strFeature[intFeatureIndex++], "Pad " + intNoID.ToString(), true);
                objFile.WriteElement2Value("FeretHeight", strFeature[intFeatureIndex++], "Pad " + intNoID.ToString(), true);
                objFile.WriteElement2Value("FeretCenterX", strFeature[intFeatureIndex++], "Pad " + intNoID.ToString(), true);
                objFile.WriteElement2Value("FeretCenterY", strFeature[intFeatureIndex++], "Pad " + intNoID.ToString(), true);
                objFile.WriteElement2Value("FeretAngle", strFeature[intFeatureIndex++], "Pad " + intNoID.ToString(), true);
                objFile.WriteElement2Value("FeretLengthMode", strFeature[intFeatureIndex++], "Pad " + intNoID.ToString(), true);
                if (strFeature[intFeatureIndex++] == "True")
                    objFile.WriteElement2Value("FeretActivated", true, "Pad " + intNoID.ToString(), true);
                else
                    objFile.WriteElement2Value("FeretActivated", false, "Pad " + intNoID.ToString(), true);
                // objFile.WriteElement2Value("FeretActivated", strFeature[intFeatureIndex++]);


                objFile.WriteElement2Value("P1X", strFeature[intFeatureIndex++], "Pad " + intNoID.ToString(), true);
                objFile.WriteElement2Value("P1Y", strFeature[intFeatureIndex++], "Pad " + intNoID.ToString(), true);
                objFile.WriteElement2Value("P2X", strFeature[intFeatureIndex++], "Pad " + intNoID.ToString(), true);
                objFile.WriteElement2Value("P2Y", strFeature[intFeatureIndex++], "Pad " + intNoID.ToString(), true);
                objFile.WriteElement2Value("P3X", strFeature[intFeatureIndex++], "Pad " + intNoID.ToString(), true);
                objFile.WriteElement2Value("P3Y", strFeature[intFeatureIndex++], "Pad " + intNoID.ToString(), true);
                objFile.WriteElement2Value("P4X", strFeature[intFeatureIndex++], "Pad " + intNoID.ToString(), true);
                objFile.WriteElement2Value("P4Y", strFeature[intFeatureIndex++], "Pad " + intNoID.ToString(), true);



                if (strFeature[intFeatureIndex++] == "True")
                    objFile.WriteElement2Value("Selected", true, "Pad " + intNoID.ToString(), true);
                else
                    objFile.WriteElement2Value("Selected", false, "Pad " + intNoID.ToString(), true);

                if (strFeature[intFeatureIndex++] == "True")
                    objFile.WriteElement2Value("Enable", true, "Pad " + intNoID.ToString(), true);
                else
                    objFile.WriteElement2Value("Enable", false, "Pad " + intNoID.ToString(), true);
                objFile.WriteElement2Value("LeftDistance", strFeature[intFeatureIndex++], "Pad " + intNoID.ToString(), true);
                objFile.WriteElement2Value("RightDistance", strFeature[intFeatureIndex++], "Pad " + intNoID.ToString(), true);
                objFile.WriteElement2Value("TopDistance", strFeature[intFeatureIndex++], "Pad " + intNoID.ToString(), true);
                objFile.WriteElement2Value("BottomDistance", strFeature[intFeatureIndex++], "Pad " + intNoID.ToString(), true);
                objFile.WriteElement2Value("XDistance", strFeature[intFeatureIndex++], "Pad " + intNoID.ToString(), true);
                objFile.WriteElement2Value("YDistance", strFeature[intFeatureIndex++], "Pad " + intNoID.ToString(), true);
                objFile.WriteElement2Value("TemplateROICenterX", strFeature[intFeatureIndex++], "Pad " + intNoID.ToString(), true);
                objFile.WriteElement2Value("TemplateROICenterY", strFeature[intFeatureIndex++], "Pad " + intNoID.ToString(), true);
                objFile.WriteElement2Value("TemplateROITopLeftCornerX", strFeature[intFeatureIndex++], "Pad " + intNoID.ToString(), true);
                objFile.WriteElement2Value("TemplateROITopLeftCornerY", strFeature[intFeatureIndex++], "Pad " + intNoID.ToString(), true);
                objFile.WriteElement2Value("XDistance_Pattern", strFeature[intFeatureIndex++], "Pad " + intNoID.ToString(), true);
                objFile.WriteElement2Value("YDistance_Pattern", strFeature[intFeatureIndex++], "Pad " + intNoID.ToString(), true);
                objFile.WriteElement2Value("TemplateROICenterX_Pattern", strFeature[intFeatureIndex++], "Pad " + intNoID.ToString(), true);
                objFile.WriteElement2Value("TemplateROICenterY_Pattern", strFeature[intFeatureIndex++], "Pad " + intNoID.ToString(), true);
                objFile.WriteElement2Value("TemplateROITopLeftCornerX_Pattern", strFeature[intFeatureIndex++], "Pad " + intNoID.ToString(), true);
                objFile.WriteElement2Value("TemplateROITopLeftCornerY_Pattern", strFeature[intFeatureIndex++], "Pad " + intNoID.ToString(), true);
                objFile.WriteElement2Value("Pitch", strFeature[intFeatureIndex++], "Pad " + intNoID.ToString(), true);
                objFile.WriteElement2Value("Gap", strFeature[intFeatureIndex++], "Pad " + intNoID.ToString(), true);

                objFile.WriteElement2Value("OffSet", strFeature[intFeatureIndex++], "Pad " + intNoID.ToString(), true);
                objFile.WriteElement2Value("MinArea", strFeature[intFeatureIndex++], "Pad " + intNoID.ToString(), true);
                objFile.WriteElement2Value("MaxArea", strFeature[intFeatureIndex++], "Pad " + intNoID.ToString(), true);
                objFile.WriteElement2Value("MinWidth", strFeature[intFeatureIndex++], "Pad " + intNoID.ToString(), true);
                objFile.WriteElement2Value("MaxWidth", strFeature[intFeatureIndex++], "Pad " + intNoID.ToString(), true);
                objFile.WriteElement2Value("MinHeight", strFeature[intFeatureIndex++], "Pad " + intNoID.ToString(), true);
                objFile.WriteElement2Value("MaxHeight", strFeature[intFeatureIndex++], "Pad " + intNoID.ToString(), true);
                objFile.WriteElement2Value("MinPitch", strFeature[intFeatureIndex++], "Pad " + intNoID.ToString(), true);
                objFile.WriteElement2Value("MaxPitch", strFeature[intFeatureIndex++], "Pad " + intNoID.ToString(), true);
                objFile.WriteElement2Value("MinGap", strFeature[intFeatureIndex++], "Pad " + intNoID.ToString(), true);
                objFile.WriteElement2Value("MaxGap", strFeature[intFeatureIndex++], "Pad " + intNoID.ToString(), true);
                objFile.WriteElement2Value("MaxHole", strFeature[intFeatureIndex++], "Pad " + intNoID.ToString(), true);   // == MaxBroken
                objFile.WriteElement2Value("MaxBrokenLength", strFeature[intFeatureIndex++], "Pad " + intNoID.ToString(), true);
                objFile.WriteElement2Value("MaxExcess", strFeature[intFeatureIndex++], "Pad " + intNoID.ToString(), true);
                objFile.WriteElement2Value("MaxSmearLength", strFeature[intFeatureIndex++], "Pad " + intNoID.ToString(), true);

                objFile.WriteElement2Value("MaxEdgeLimitTop", strFeature[intFeatureIndex++], "Pad " + intNoID.ToString(), true);
                objFile.WriteElement2Value("MaxEdgeLimitRight", strFeature[intFeatureIndex++], "Pad " + intNoID.ToString(), true);
                objFile.WriteElement2Value("MaxEdgeLimitBottom", strFeature[intFeatureIndex++], "Pad " + intNoID.ToString(), true);
                objFile.WriteElement2Value("MaxEdgeLimitLeft", strFeature[intFeatureIndex++], "Pad " + intNoID.ToString(), true);

                objFile.WriteElement2Value("MaxStandOffTop", strFeature[intFeatureIndex++], "Pad " + intNoID.ToString(), true);
                objFile.WriteElement2Value("MaxStandOffBottom", strFeature[intFeatureIndex++], "Pad " + intNoID.ToString(), true);
                objFile.WriteElement2Value("MaxStandOffLeft", strFeature[intFeatureIndex++], "Pad " + intNoID.ToString(), true);
                objFile.WriteElement2Value("MaxStandOffRight", strFeature[intFeatureIndex++], "Pad " + intNoID.ToString(), true);

                objFile.WriteElement2Value("OffsetOffset", strFeature[intFeatureIndex++], "Pad " + intNoID.ToString(), true);
                objFile.WriteElement2Value("WidthOffset", strFeature[intFeatureIndex++], "Pad " + intNoID.ToString(), true);
                objFile.WriteElement2Value("HeightOffset", strFeature[intFeatureIndex++], "Pad " + intNoID.ToString(), true);
                objFile.WriteElement2Value("PitchOffset", strFeature[intFeatureIndex++], "Pad " + intNoID.ToString(), true);
                objFile.WriteElement2Value("GapOffset", strFeature[intFeatureIndex++], "Pad " + intNoID.ToString(), true);

                objFile.WriteElement2Value("EdgeDistanceTopOffset", strFeature[intFeatureIndex++], "Pad " + intNoID.ToString(), true);
                objFile.WriteElement2Value("EdgeDistanceRightOffset", strFeature[intFeatureIndex++], "Pad " + intNoID.ToString(), true);
                objFile.WriteElement2Value("EdgeDistanceBottomOffset", strFeature[intFeatureIndex++], "Pad " + intNoID.ToString(), true);
                objFile.WriteElement2Value("EdgeDistanceLeftOffset", strFeature[intFeatureIndex++], "Pad " + intNoID.ToString(), true);

                objFile.WriteElement2Value("EdgeLimitTopOffset", strFeature[intFeatureIndex++], "Pad " + intNoID.ToString(), true);
                objFile.WriteElement2Value("EdgeLimitRightOffset", strFeature[intFeatureIndex++], "Pad " + intNoID.ToString(), true);
                objFile.WriteElement2Value("EdgeLimitBottomOffset", strFeature[intFeatureIndex++], "Pad " + intNoID.ToString(), true);
                objFile.WriteElement2Value("EdgeLimitLeftOffset", strFeature[intFeatureIndex++], "Pad " + intNoID.ToString(), true);

                objFile.WriteElement2Value("StandOffTopOffset", strFeature[intFeatureIndex++], "Pad " + intNoID.ToString(), true);
                objFile.WriteElement2Value("StandOffBottomOffset", strFeature[intFeatureIndex++], "Pad " + intNoID.ToString(), true);
                objFile.WriteElement2Value("StandOffLeftOffset", strFeature[intFeatureIndex++], "Pad " + intNoID.ToString(), true);
                objFile.WriteElement2Value("StandOffRightOffset", strFeature[intFeatureIndex++], "Pad " + intNoID.ToString(), true);
                
                objFile.WriteElement2Value("MinLine3", strFeature[intFeatureIndex++], "Pad " + intNoID.ToString(), true);
                objFile.WriteElement2Value("MaxLine3", strFeature[intFeatureIndex++], "Pad " + intNoID.ToString(), true);
                objFile.WriteElement2Value("MinLine4", strFeature[intFeatureIndex++], "Pad " + intNoID.ToString(), true);
                objFile.WriteElement2Value("MaxLine4", strFeature[intFeatureIndex++], "Pad " + intNoID.ToString(), true);
                objFile.WriteElement2Value("MinLine5", strFeature[intFeatureIndex++], "Pad " + intNoID.ToString(), true);
                objFile.WriteElement2Value("MaxLine5", strFeature[intFeatureIndex++], "Pad " + intNoID.ToString(), true);
                objFile.WriteElement2Value("MinLine6", strFeature[intFeatureIndex++], "Pad " + intNoID.ToString(), true);
                objFile.WriteElement2Value("MaxLine6", strFeature[intFeatureIndex++], "Pad " + intNoID.ToString(), true);
                objFile.WriteElement2Value("MinLine7", strFeature[intFeatureIndex++], "Pad " + intNoID.ToString(), true);
                objFile.WriteElement2Value("MaxLine7", strFeature[intFeatureIndex++], "Pad " + intNoID.ToString(), true);
                objFile.WriteElement2Value("MinLine8", strFeature[intFeatureIndex++], "Pad " + intNoID.ToString(), true);
                objFile.WriteElement2Value("MaxLine8", strFeature[intFeatureIndex++], "Pad " + intNoID.ToString(), true);
                objFile.WriteElement2Value("MinLine9", strFeature[intFeatureIndex++], "Pad " + intNoID.ToString(), true);
                objFile.WriteElement2Value("MaxLine9", strFeature[intFeatureIndex++], "Pad " + intNoID.ToString(), true);
                objFile.WriteElement2Value("MinLine10", strFeature[intFeatureIndex++], "Pad " + intNoID.ToString(), true);
                objFile.WriteElement2Value("MaxLine10", strFeature[intFeatureIndex++], "Pad " + intNoID.ToString(), true);
                objFile.WriteElement2Value("MinLine11", strFeature[intFeatureIndex++], "Pad " + intNoID.ToString(), true);
                objFile.WriteElement2Value("MaxLine11", strFeature[intFeatureIndex++], "Pad " + intNoID.ToString(), true);
                objFile.WriteElement2Value("MinLine12", strFeature[intFeatureIndex++], "Pad " + intNoID.ToString(), true);
                objFile.WriteElement2Value("MaxLine12", strFeature[intFeatureIndex++], "Pad " + intNoID.ToString(), true);

                objFile.WriteElement2Value("PadInspectionAreaFromTop", strFeature[intFeatureIndex++], "Pad " + intNoID.ToString(), true);
                objFile.WriteElement2Value("PadInspectionAreaFromRight", strFeature[intFeatureIndex++], "Pad " + intNoID.ToString(), true);
                objFile.WriteElement2Value("PadInspectionAreaFromBottom", strFeature[intFeatureIndex++], "Pad " + intNoID.ToString(), true);
                objFile.WriteElement2Value("PadInspectionAreaFromLeft", strFeature[intFeatureIndex++], "Pad " + intNoID.ToString(), true);

                objFile.WriteElement2Value("ReferTopBottom", strFeature[intFeatureIndex++], "Pad " + intNoID.ToString(), true);

                if (strFeature[intFeatureIndex++] == "True")
                    objFile.WriteElement2Value("CheckTop", true, "Pad " + intNoID.ToString(), true);
                else
                    objFile.WriteElement2Value("CheckTop", false, "Pad " + intNoID.ToString(), true);

                if (strFeature[intFeatureIndex++] == "True")
                    objFile.WriteElement2Value("CheckBottom", true, "Pad " + intNoID.ToString(), true);
                else
                    objFile.WriteElement2Value("CheckBottom", false, "Pad " + intNoID.ToString(), true);
                
                objFile.WriteElement2Value("ReferLeftRight", strFeature[intFeatureIndex++], "Pad " + intNoID.ToString(), true);
                
                if (strFeature[intFeatureIndex++] == "True")
                    objFile.WriteElement2Value("CheckLeft", true, "Pad " + intNoID.ToString(), true);
                else
                    objFile.WriteElement2Value("CheckLeft", false, "Pad " + intNoID.ToString(), true);

                if (strFeature[intFeatureIndex++] == "True")
                    objFile.WriteElement2Value("CheckRight", true, "Pad " + intNoID.ToString(), true);
                else
                    objFile.WriteElement2Value("CheckRight", false, "Pad " + intNoID.ToString(), true);
            }

            int intIndex = 0;
            string strPitchGapData;
            string[] strPitchGapDataRow;
            for (int q = 0; q < intTotalPitchGap; q++)
            {
                intIndex = 0;
                strPitchGapData = GetMicronPitchGapData(q);
                strPitchGapDataRow = strPitchGapData.Split('#');

                objFile.WriteElement1Value("PitchGap" + q, "");
                objFile.WriteElement2Value("FromPadNo", strPitchGapDataRow[intIndex++]);
                objFile.WriteElement2Value("ToPadNo", strPitchGapDataRow[intIndex++]);
                objFile.WriteElement2Value("MinPitch", strPitchGapDataRow[intIndex++]);
                objFile.WriteElement2Value("MaxPitch", strPitchGapDataRow[intIndex++]);
                objFile.WriteElement2Value("MinGap", strPitchGapDataRow[intIndex++]);
                objFile.WriteElement2Value("MaxGap", strPitchGapDataRow[intIndex++]);
                objFile.WriteElement2Value("Gap", strPitchGapDataRow[intIndex++]);
                objFile.WriteElement2Value("Pitch", strPitchGapDataRow[intIndex++]);
                objFile.WriteElement2Value("StartX", strPitchGapDataRow[intIndex++]);
                objFile.WriteElement2Value("StartY", strPitchGapDataRow[intIndex++]);
                objFile.WriteElement2Value("EndX", strPitchGapDataRow[intIndex++]);
                objFile.WriteElement2Value("EndY", strPitchGapDataRow[intIndex++]);
                objFile.WriteElement2Value("Direction", strPitchGapDataRow[intIndex++]);
            }

            // Save Group BlobsFeatures
            for (int i = 0; i < m_arrGroupTemplateBlobPads.Count; i++)
            {
                BlobsFeatures m_stcBlobPad = (BlobsFeatures)m_arrGroupTemplateBlobPads[i];

                objFile.WriteElement1Value("GroupBlobsFeatures" + i, "");
                objFile.WriteElement2Value("NoID", m_stcBlobPad.intNoID, "Pad Group " + (m_stcBlobPad.intGroupID).ToString(), true);
                objFile.WriteElement2Value("GroupNo", m_stcBlobPad.intGroupID, "Pad Group " + (m_stcBlobPad.intGroupID).ToString(), true);
                objFile.WriteElement2Value("Area", m_stcBlobPad.fArea, "Pad Group " + (m_stcBlobPad.intGroupID).ToString(), true);
                objFile.WriteElement2Value("LengthMode", m_stcBlobPad.intLengthMode, "Pad Group " + (m_stcBlobPad.intGroupID).ToString(), true);
                objFile.WriteElement2Value("ContourX", m_stcBlobPad.intContourX, "Pad Group " + (m_stcBlobPad.intGroupID).ToString(), true);
                objFile.WriteElement2Value("ContourY", m_stcBlobPad.intContourY, "Pad Group " + (m_stcBlobPad.intGroupID).ToString(), true);
                objFile.WriteElement2Value("StartX", m_stcBlobPad.intStartX, "Pad Group " + (m_stcBlobPad.intGroupID).ToString(), true);
                objFile.WriteElement2Value("StartY", m_stcBlobPad.intStartY, "Pad Group " + (m_stcBlobPad.intGroupID).ToString(), true);
                objFile.WriteElement2Value("EndX", m_stcBlobPad.intEndX, "Pad Group " + (m_stcBlobPad.intGroupID).ToString(), true);
                objFile.WriteElement2Value("EndY", m_stcBlobPad.intEndY, "Pad Group " + (m_stcBlobPad.intGroupID).ToString(), true);
                objFile.WriteElement2Value("fStartX", m_stcBlobPad.fStartX, "Pad Group " + (m_stcBlobPad.intGroupID).ToString(), true);
                objFile.WriteElement2Value("fStartY", m_stcBlobPad.fStartY, "Pad Group " + (m_stcBlobPad.intGroupID).ToString(), true);
                objFile.WriteElement2Value("fEndX", m_stcBlobPad.fEndX, "Pad Group " + (m_stcBlobPad.intGroupID).ToString(), true);
                objFile.WriteElement2Value("fEndY", m_stcBlobPad.fEndY, "Pad Group " + (m_stcBlobPad.intGroupID).ToString(), true);
                objFile.WriteElement2Value("Direction", m_stcBlobPad.intDirection, "Pad Group " + (m_stcBlobPad.intGroupID).ToString(), true);
                objFile.WriteElement2Value("PadSide", m_stcBlobPad.intSide, "Pad Group " + (m_stcBlobPad.intGroupID).ToString(), true);
                objFile.WriteElement2Value("SmearSide", m_stcBlobPad.intSmearSide, "Pad Group " + (m_stcBlobPad.intGroupID).ToString(), true);
                objFile.WriteElement2Value("GravityCenterX", m_stcBlobPad.fCenterX, "Pad Group " + (m_stcBlobPad.intGroupID).ToString(), true);
                objFile.WriteElement2Value("GravityCenterY", m_stcBlobPad.fCenterY, "Pad Group " + (m_stcBlobPad.intGroupID).ToString(), true);
                objFile.WriteElement2Value("LimitCenterX", m_stcBlobPad.fLimitCenterX, "Pad Group " + (m_stcBlobPad.intGroupID).ToString(), true);
                objFile.WriteElement2Value("LimitCenterY", m_stcBlobPad.fLimitCenterY, "Pad Group " + (m_stcBlobPad.intGroupID).ToString(), true);
                objFile.WriteElement2Value("Width", m_stcBlobPad.fWidth, "Pad Group " + (m_stcBlobPad.intGroupID).ToString(), true);
                objFile.WriteElement2Value("Height", m_stcBlobPad.fHeight, "Pad Group " + (m_stcBlobPad.intGroupID).ToString(), true);
                objFile.WriteElement2Value("Selected", m_stcBlobPad.blnSelected, "Pad Group " + (m_stcBlobPad.intGroupID).ToString(), true);
                objFile.WriteElement2Value("Enable", m_stcBlobPad.blnEnable, "Pad Group " + (m_stcBlobPad.intGroupID).ToString(), true);
                objFile.WriteElement2Value("LeftDistance", m_stcBlobPad.fLeftDistance, "Pad Group " + (m_stcBlobPad.intGroupID).ToString(), true);
                objFile.WriteElement2Value("RightDistance", m_stcBlobPad.fRightDistance, "Pad Group " + (m_stcBlobPad.intGroupID).ToString(), true);
                objFile.WriteElement2Value("TopDistance", m_stcBlobPad.fTopDistance, "Pad Group " + (m_stcBlobPad.intGroupID).ToString(), true);
                objFile.WriteElement2Value("BottomDistance", m_stcBlobPad.fBottomDistance, "Pad Group " + (m_stcBlobPad.intGroupID).ToString(), true);
                objFile.WriteElement2Value("XDistance", m_stcBlobPad.fXDistance, "Pad Group " + (m_stcBlobPad.intGroupID).ToString(), true);
                objFile.WriteElement2Value("YDistance", m_stcBlobPad.fYDistance, "Pad Group " + (m_stcBlobPad.intGroupID).ToString(), true);
                objFile.WriteElement2Value("TemplateROICenterX", m_stcBlobPad.fTemplateROICenterX, "Pad Group " + (m_stcBlobPad.intGroupID).ToString(), true);
                objFile.WriteElement2Value("TemplateROICenterY", m_stcBlobPad.fTemplateROICenterY, "Pad Group " + (m_stcBlobPad.intGroupID).ToString(), true);
                objFile.WriteElement2Value("TemplateROITopLeftCornerX", m_stcBlobPad.fTemplateROITopLeftCornerX, "Pad Group " + (m_stcBlobPad.intGroupID).ToString(), true);
                objFile.WriteElement2Value("TemplateROITopLeftCornerY", m_stcBlobPad.fTemplateROITopLeftCornerY, "Pad Group " + (m_stcBlobPad.intGroupID).ToString(), true);
                objFile.WriteElement2Value("XDistance_Pattern", m_stcBlobPad.fXDistance_Pattern, "Pad Group " + (m_stcBlobPad.intGroupID).ToString(), true);
                objFile.WriteElement2Value("YDistance_Pattern", m_stcBlobPad.fYDistance_Pattern, "Pad Group " + (m_stcBlobPad.intGroupID).ToString(), true);
                objFile.WriteElement2Value("TemplateROICenterX_Pattern", m_stcBlobPad.fTemplateROICenterX_Pattern, "Pad Group " + (m_stcBlobPad.intGroupID).ToString(), true);
                objFile.WriteElement2Value("TemplateROICenterY_Pattern", m_stcBlobPad.fTemplateROICenterY_Pattern, "Pad Group " + (m_stcBlobPad.intGroupID).ToString(), true);
                objFile.WriteElement2Value("TemplateROITopLeftCornerX_Pattern", m_stcBlobPad.fTemplateROITopLeftCornerX_Pattern, "Pad Group " + (m_stcBlobPad.intGroupID).ToString(), true);
                objFile.WriteElement2Value("TemplateROITopLeftCornerY_Pattern", m_stcBlobPad.fTemplateROITopLeftCornerY_Pattern, "Pad Group " + (m_stcBlobPad.intGroupID).ToString(), true);
                objFile.WriteElement2Value("Pitch", m_stcBlobPad.fPitch, "Pad Group " + (m_stcBlobPad.intGroupID).ToString(), true);
                objFile.WriteElement2Value("Gap", m_stcBlobPad.fGap, "Pad Group " + (m_stcBlobPad.intGroupID).ToString(), true);

                objFile.WriteElement2Value("OffSet", m_stcBlobPad.fOffSet, "Pad Group " + (m_stcBlobPad.intGroupID).ToString(), true);
                objFile.WriteElement2Value("MinArea", m_stcBlobPad.fMinArea, "Pad Group " + (m_stcBlobPad.intGroupID).ToString(), true);
                objFile.WriteElement2Value("MaxArea", m_stcBlobPad.fMaxArea, "Pad Group " + (m_stcBlobPad.intGroupID).ToString(), true);
                objFile.WriteElement2Value("MinWidth", m_stcBlobPad.fMinWidth, "Pad Group " + (m_stcBlobPad.intGroupID).ToString(), true);
                objFile.WriteElement2Value("MaxWidth", m_stcBlobPad.fMaxWidth, "Pad Group " + (m_stcBlobPad.intGroupID).ToString(), true);
                objFile.WriteElement2Value("MinHeight", m_stcBlobPad.fMinLength, "Pad Group " + (m_stcBlobPad.intGroupID).ToString(), true);
                objFile.WriteElement2Value("MaxHeight", m_stcBlobPad.fMaxLength, "Pad Group " + (m_stcBlobPad.intGroupID).ToString(), true);
                objFile.WriteElement2Value("MinPitch", m_stcBlobPad.fMinPitch, "Pad Group " + (m_stcBlobPad.intGroupID).ToString(), true);
                objFile.WriteElement2Value("MaxPitch", m_stcBlobPad.fMaxPitch, "Pad Group " + (m_stcBlobPad.intGroupID).ToString(), true);
                objFile.WriteElement2Value("MinGap", m_stcBlobPad.fMinGap, "Pad Group " + (m_stcBlobPad.intGroupID).ToString(), true);
                objFile.WriteElement2Value("MaxGap", m_stcBlobPad.fMaxGap, "Pad Group " + (m_stcBlobPad.intGroupID).ToString(), true);
                objFile.WriteElement2Value("MaxHole", m_stcBlobPad.fMaxBroken, "Pad Group " + (m_stcBlobPad.intGroupID).ToString(), true);   // == MaxBroken
                objFile.WriteElement2Value("MaxBrokenLength", m_stcBlobPad.fMaxBrokenLength, "Pad Group " + (m_stcBlobPad.intGroupID).ToString(), true);
                objFile.WriteElement2Value("MaxExcess", m_stcBlobPad.fMaxExcess, "Pad Group " + (m_stcBlobPad.intGroupID).ToString(), true);
                objFile.WriteElement2Value("MaxSmearLength", m_stcBlobPad.fMaxSmearLength, "Pad Group " + (m_stcBlobPad.intGroupID).ToString(), true);

                objFile.WriteElement2Value("MaxEdgeLimitTop", m_stcBlobPad.fEdgeLimitTop, "Pad Group " + (m_stcBlobPad.intGroupID).ToString(), true);
                objFile.WriteElement2Value("MaxEdgeLimitRight", m_stcBlobPad.fEdgeLimitRight, "Pad Group " + (m_stcBlobPad.intGroupID).ToString(), true);
                objFile.WriteElement2Value("MaxEdgeLimitBottom", m_stcBlobPad.fEdgeLimitBottom, "Pad Group " + (m_stcBlobPad.intGroupID).ToString(), true);
                objFile.WriteElement2Value("MaxEdgeLimitLeft", m_stcBlobPad.fEdgeLimitLeft, "Pad Group " + (m_stcBlobPad.intGroupID).ToString(), true);

                objFile.WriteElement2Value("MaxStandOffTop", m_stcBlobPad.fMaxStandOffTop, "Pad Group " + (m_stcBlobPad.intGroupID).ToString(), true);
                objFile.WriteElement2Value("MaxStandOffBottom", m_stcBlobPad.fMaxStandOffBottom, "Pad Group " + (m_stcBlobPad.intGroupID).ToString(), true);
                objFile.WriteElement2Value("MaxStandOffLeft", m_stcBlobPad.fMaxStandOffLeft, "Pad Group " + (m_stcBlobPad.intGroupID).ToString(), true);
                objFile.WriteElement2Value("MaxStandOffRight", m_stcBlobPad.fMaxStandOffRight, "Pad Group " + (m_stcBlobPad.intGroupID).ToString(), true);
                
                objFile.WriteElement2Value("OffsetOffSet", m_stcBlobPad.fOffsetOffSet, "Pad Group " + (m_stcBlobPad.intGroupID).ToString(), true);
                objFile.WriteElement2Value("WidthOffset", m_stcBlobPad.fWidthOffset, "Pad Group " + (m_stcBlobPad.intGroupID).ToString(), true);
                objFile.WriteElement2Value("HeightOffset", m_stcBlobPad.fHeightOffset, "Pad Group " + (m_stcBlobPad.intGroupID).ToString(), true);
                objFile.WriteElement2Value("PitchOffset", m_stcBlobPad.fPitchOffset, "Pad Group " + (m_stcBlobPad.intGroupID).ToString(), true);
                objFile.WriteElement2Value("GapOffset", m_stcBlobPad.fGapOffset, "Pad Group " + (m_stcBlobPad.intGroupID).ToString(), true);

                objFile.WriteElement2Value("EdgeDistanceTopOffset", m_stcBlobPad.fEdgeDistanceLeftOffset, "Pad Group " + (m_stcBlobPad.intGroupID).ToString(), true);
                objFile.WriteElement2Value("EdgeDistanceRightOffset", m_stcBlobPad.fEdgeDistanceRightOffset, "Pad Group " + (m_stcBlobPad.intGroupID).ToString(), true);
                objFile.WriteElement2Value("EdgeDistanceBottomOffset", m_stcBlobPad.fEdgeDistanceBottomOffset, "Pad Group " + (m_stcBlobPad.intGroupID).ToString(), true);
                objFile.WriteElement2Value("EdgeDistanceLeftOffset", m_stcBlobPad.fEdgeDistanceLeftOffset, "Pad Group " + (m_stcBlobPad.intGroupID).ToString(), true);

                objFile.WriteElement2Value("EdgeLimitTopOffset", m_stcBlobPad.fEdgeLimitTopOffset, "Pad Group " + (m_stcBlobPad.intGroupID).ToString(), true);
                objFile.WriteElement2Value("EdgeLimitRightOffset", m_stcBlobPad.fEdgeLimitRightOffset, "Pad Group " + (m_stcBlobPad.intGroupID).ToString(), true);
                objFile.WriteElement2Value("EdgeLimitBottomOffset", m_stcBlobPad.fEdgeLimitBottomOffset, "Pad Group " + (m_stcBlobPad.intGroupID).ToString(), true);
                objFile.WriteElement2Value("EdgeLimitLeftOffset", m_stcBlobPad.fEdgeLimitLeftOffset, "Pad Group " + (m_stcBlobPad.intGroupID).ToString(), true);

                objFile.WriteElement2Value("StandOffTopOffset", m_stcBlobPad.fStandOffTopOffset, "Pad Group " + (m_stcBlobPad.intGroupID).ToString(), true);
                objFile.WriteElement2Value("StandOffBottomOffset", m_stcBlobPad.fStandOffBottomOffset, "Pad Group " + (m_stcBlobPad.intGroupID).ToString(), true);
                objFile.WriteElement2Value("StandOffLeftOffset", m_stcBlobPad.fStandOffLeftOffset, "Pad Group " + (m_stcBlobPad.intGroupID).ToString(), true);
                objFile.WriteElement2Value("StandOffRightOffset", m_stcBlobPad.fStandOffRightOffset, "Pad Group " + (m_stcBlobPad.intGroupID).ToString(), true);
                
                objFile.WriteElement2Value("MinLine3", m_stcBlobPad.fMinLine3, "Pad Group " + (m_stcBlobPad.intGroupID).ToString(), true);
                objFile.WriteElement2Value("MaxLine3", m_stcBlobPad.fMaxLine3, "Pad Group " + (m_stcBlobPad.intGroupID).ToString(), true);
                objFile.WriteElement2Value("MinLine4", m_stcBlobPad.fMinLine4, "Pad Group " + (m_stcBlobPad.intGroupID).ToString(), true);
                objFile.WriteElement2Value("MaxLine4", m_stcBlobPad.fMaxLine4, "Pad Group " + (m_stcBlobPad.intGroupID).ToString(), true);
                objFile.WriteElement2Value("MinLine5", m_stcBlobPad.fMinLine5, "Pad Group " + (m_stcBlobPad.intGroupID).ToString(), true);
                objFile.WriteElement2Value("MaxLine5", m_stcBlobPad.fMaxLine5, "Pad Group " + (m_stcBlobPad.intGroupID).ToString(), true);
                objFile.WriteElement2Value("MinLine6", m_stcBlobPad.fMinLine6, "Pad Group " + (m_stcBlobPad.intGroupID).ToString(), true);
                objFile.WriteElement2Value("MaxLine6", m_stcBlobPad.fMaxLine6, "Pad Group " + (m_stcBlobPad.intGroupID).ToString(), true);
                objFile.WriteElement2Value("MinLine7", m_stcBlobPad.fMinLine7, "Pad Group " + (m_stcBlobPad.intGroupID).ToString(), true);
                objFile.WriteElement2Value("MaxLine7", m_stcBlobPad.fMaxLine7, "Pad Group " + (m_stcBlobPad.intGroupID).ToString(), true);
                objFile.WriteElement2Value("MinLine8", m_stcBlobPad.fMinLine8, "Pad Group " + (m_stcBlobPad.intGroupID).ToString(), true);
                objFile.WriteElement2Value("MaxLine8", m_stcBlobPad.fMaxLine8, "Pad Group " + (m_stcBlobPad.intGroupID).ToString(), true);
                objFile.WriteElement2Value("MinLine9", m_stcBlobPad.fMinLine9, "Pad Group " + (m_stcBlobPad.intGroupID).ToString(), true);
                objFile.WriteElement2Value("MaxLine9", m_stcBlobPad.fMaxLine9, "Pad Group " + (m_stcBlobPad.intGroupID).ToString(), true);
                objFile.WriteElement2Value("MinLine10", m_stcBlobPad.fMinLine10, "Pad Group " + (m_stcBlobPad.intGroupID).ToString(), true);
                objFile.WriteElement2Value("MaxLine10", m_stcBlobPad.fMaxLine10, "Pad Group " + (m_stcBlobPad.intGroupID).ToString(), true);
                objFile.WriteElement2Value("MinLine11", m_stcBlobPad.fMinLine11, "Pad Group " + (m_stcBlobPad.intGroupID).ToString(), true);
                objFile.WriteElement2Value("MaxLine11", m_stcBlobPad.fMaxLine11, "Pad Group " + (m_stcBlobPad.intGroupID).ToString(), true);
                objFile.WriteElement2Value("MinLine12", m_stcBlobPad.fMinLine12, "Pad Group " + (m_stcBlobPad.intGroupID).ToString(), true);
                objFile.WriteElement2Value("MaxLine12", m_stcBlobPad.fMaxLine12, "Pad Group " + (m_stcBlobPad.intGroupID).ToString(), true);

                objFile.WriteElement2Value("PadInspectionAreaFromTop", m_stcBlobPad.fPadInspectionAreaFromTop, "Pad Group " + (m_stcBlobPad.intGroupID).ToString(), true);
                objFile.WriteElement2Value("PadInspectionAreaFromRight", m_stcBlobPad.fPadInspectionAreaFromRight, "Pad Group " + (m_stcBlobPad.intGroupID).ToString(), true);
                objFile.WriteElement2Value("PadInspectionAreaFromBottom", m_stcBlobPad.fPadInspectionAreaFromBottom, "Pad Group " + (m_stcBlobPad.intGroupID).ToString(), true);
                objFile.WriteElement2Value("PadInspectionAreaFromLeft", m_stcBlobPad.fPadInspectionAreaFromLeft, "Pad Group " + (m_stcBlobPad.intGroupID).ToString(), true);

                objFile.WriteElement2Value("ReferTopBottom", m_stcBlobPad.intReferTopBottom, "Pad Group " + (m_stcBlobPad.intGroupID).ToString(), true);
                objFile.WriteElement2Value("CheckTop", m_stcBlobPad.blnCheckTop, "Pad Group " + (m_stcBlobPad.intGroupID).ToString(), true);
                objFile.WriteElement2Value("CheckBottom", m_stcBlobPad.blnCheckBottom, "Pad Group " + (m_stcBlobPad.intGroupID).ToString(), true);
                objFile.WriteElement2Value("ReferLeftRight", m_stcBlobPad.intReferLeftRight, "Pad Group " + (m_stcBlobPad.intGroupID).ToString(), true);
                objFile.WriteElement2Value("CheckLeft", m_stcBlobPad.blnCheckLeft, "Pad Group " + (m_stcBlobPad.intGroupID).ToString(), true);
                objFile.WriteElement2Value("CheckRight", m_stcBlobPad.blnCheckRight, "Pad Group " + (m_stcBlobPad.intGroupID).ToString(), true);
            }

            // Save Package Setting
            objFile.WriteElement1Value("PackageSetting", "");
            objFile.WriteElement2Value("ChipStartPixelFromEdge", m_fChipStartPixelFromEdge);
            objFile.WriteElement2Value("ChipStartPixelFromRight", m_fChipStartPixelFromRight);
            objFile.WriteElement2Value("ChipStartPixelFromBottom", m_fChipStartPixelFromBottom);
            objFile.WriteElement2Value("ChipStartPixelFromLeft", m_fChipStartPixelFromLeft);
            objFile.WriteElement2Value("ChipStartPixelExtendFromEdge", m_fChipStartPixelExtendFromEdge);
            objFile.WriteElement2Value("ChipStartPixelExtendFromRight", m_fChipStartPixelExtendFromRight);
            objFile.WriteElement2Value("ChipStartPixelExtendFromBottom", m_fChipStartPixelExtendFromBottom);
            objFile.WriteElement2Value("ChipStartPixelExtendFromLeft", m_fChipStartPixelExtendFromLeft);
            objFile.WriteElement2Value("ChipStartPixelFromEdge_Dark", m_fChipStartPixelFromEdge_Dark);
            objFile.WriteElement2Value("ChipStartPixelFromRight_Dark", m_fChipStartPixelFromRight_Dark);
            objFile.WriteElement2Value("ChipStartPixelFromBottom_Dark", m_fChipStartPixelFromBottom_Dark);
            objFile.WriteElement2Value("ChipStartPixelFromLeft_Dark", m_fChipStartPixelFromLeft_Dark);
            objFile.WriteElement2Value("ChipStartPixelExtendFromEdge_Dark", m_fChipStartPixelExtendFromEdge_Dark);
            objFile.WriteElement2Value("ChipStartPixelExtendFromRight_Dark", m_fChipStartPixelExtendFromRight_Dark);
            objFile.WriteElement2Value("ChipStartPixelExtendFromBottom_Dark", m_fChipStartPixelExtendFromBottom_Dark);
            objFile.WriteElement2Value("ChipStartPixelExtendFromLeft_Dark", m_fChipStartPixelExtendFromLeft_Dark);
            objFile.WriteElement2Value("MoldStartPixelFromEdge", m_fMoldStartPixelFromEdge);
            objFile.WriteElement2Value("MoldStartPixelFromRight", m_fMoldStartPixelFromRight);
            objFile.WriteElement2Value("MoldStartPixelFromBottom", m_fMoldStartPixelFromBottom);
            objFile.WriteElement2Value("MoldStartPixelFromLeft", m_fMoldStartPixelFromLeft);
            objFile.WriteElement2Value("MoldStartPixelInnerFromEdge", m_fMoldStartPixelInnerFromEdge);
            objFile.WriteElement2Value("MoldStartPixelInnerFromRight", m_fMoldStartPixelInnerFromRight);
            objFile.WriteElement2Value("MoldStartPixelInnerFromBottom", m_fMoldStartPixelInnerFromBottom);
            objFile.WriteElement2Value("MoldStartPixelInnerFromLeft", m_fMoldStartPixelInnerFromLeft);
            objFile.WriteElement2Value("PkgStartPixelFromEdge", m_fPkgStartPixelFromEdge);
            objFile.WriteElement2Value("PkgStartPixelFromRight", m_fPkgStartPixelFromRight);
            objFile.WriteElement2Value("PkgStartPixelFromBottom", m_fPkgStartPixelFromBottom);
            objFile.WriteElement2Value("PkgStartPixelFromLeft", m_fPkgStartPixelFromLeft);
            objFile.WriteElement2Value("PkgStartPixelFromEdge_Dark", m_fPkgStartPixelFromEdge_Dark);
            objFile.WriteElement2Value("PkgStartPixelFromRight_Dark", m_fPkgStartPixelFromRight_Dark);
            objFile.WriteElement2Value("PkgStartPixelFromBottom_Dark", m_fPkgStartPixelFromBottom_Dark);
            objFile.WriteElement2Value("PkgStartPixelFromLeft_Dark", m_fPkgStartPixelFromLeft_Dark);
            objFile.WriteElement2Value("ForeignMaterialStartPixelFromEdge", m_fForeignMaterialStartPixelFromEdge);
            objFile.WriteElement2Value("ForeignMaterialStartPixelFromRight", m_fForeignMaterialStartPixelFromRight);
            objFile.WriteElement2Value("ForeignMaterialStartPixelFromBottom", m_fForeignMaterialStartPixelFromBottom);
            objFile.WriteElement2Value("ForeignMaterialStartPixelFromLeft", m_fForeignMaterialStartPixelFromLeft);
            objFile.WriteElement2Value("ForeignMaterialStartPixelFromEdge_Pad", m_fForeignMaterialStartPixelFromEdge_Pad);
            objFile.WriteElement2Value("ForeignMaterialStartPixelFromRight_Pad", m_fForeignMaterialStartPixelFromRight_Pad);
            objFile.WriteElement2Value("ForeignMaterialStartPixelFromBottom_Pad", m_fForeignMaterialStartPixelFromBottom_Pad);
            objFile.WriteElement2Value("ForeignMaterialStartPixelFromLeft_Pad", m_fForeignMaterialStartPixelFromLeft_Pad);
            objFile.WriteElement2Value("PkgImage1HighPadThreshold", m_intPkgImage1HighPadThreshold);
            objFile.WriteElement2Value("PkgImage1LowPadThreshold", m_intPkgImage1LowPadThreshold);
            objFile.WriteElement2Value("PkgImage1HighSurfaceThreshold", m_intPkgImage1HighSurfaceThreshold);
            objFile.WriteElement2Value("PkgImage1LowSurfaceThreshold", m_intPkgImage1LowSurfaceThreshold);
            objFile.WriteElement2Value("PkgImage1Gain", m_fPkgImage1Gain);
            objFile.WriteElement2Value("PkgImage2HighPadThreshold", m_intPkgImage2HighThreshold);
            objFile.WriteElement2Value("PkgImage2LowPadThreshold", m_intPkgImage2LowThreshold);
            objFile.WriteElement2Value("PkgImage3HighPadThreshold", m_intPkgImage3HighThreshold);
            objFile.WriteElement2Value("PkgImage3LowPadThreshold", m_intPkgImage3LowThreshold);
            objFile.WriteElement2Value("PkgImage1MoldFlashThreshold", m_intPkgImage1MoldFlashThreshold);
            objFile.WriteElement2Value("PkgImage2VoidThreshold", m_intPkgImage2VoidThreshold);
            objFile.WriteElement2Value("PkgImage2HighCrackThreshold", m_intPkgImage2HighCrackThreshold);
            objFile.WriteElement2Value("PkgImage2LowCrackThreshold", m_intPkgImage2LowCrackThreshold);
            objFile.WriteElement2Value("PkgImage1ChippedThreshold", m_intPkgImage1ChippedThreshold);
            objFile.WriteElement2Value("ForeignMaterialBrightFieldThreshold", m_intForeignMaterialBrightFieldThreshold);
            objFile.WriteElement2Value("BrightFieldLowThreshold", m_intBrightFieldLowThreshold);
            objFile.WriteElement2Value("BrightFieldHighThreshold", m_intBrightFieldHighThreshold);
            objFile.WriteElement2Value("DarkFieldLowThreshold", m_intDarkFieldLowThreshold);
            objFile.WriteElement2Value("DarkFieldImageGain", m_fDarkFieldImageGain);
            objFile.WriteElement2Value("PadImageGain", m_fPadImageGain); 
            objFile.WriteElement2Value("DarkFieldHighThreshold", m_intDarkFieldHighThreshold);

            //PackageSize Offset
            objFile.WriteElement2Value("PackageWidthOffsetMM", m_fPackageWidthOffsetMM);
            objFile.WriteElement2Value("PackageHeightOffsetMM", m_fPackageHeightOffsetMM);
            objFile.WriteElement2Value("PackageThicknessOffsetMM", m_fPackageThicknessOffsetMM);


            objFile.WriteElement2Value("UnitWidth", m_fUnitWidth);
            objFile.WriteElement2Value("UnitHeight", m_fUnitHeight);
            objFile.WriteElement2Value("UnitThickness", m_fUnitThickness);
            objFile.WriteElement2Value("UnitWidthMin", m_fUnitWidthMin);
            objFile.WriteElement2Value("UnitWidthMax", m_fUnitWidthMax);
            objFile.WriteElement2Value("UnitHeightMin", m_fUnitHeightMin);
            objFile.WriteElement2Value("UnitHeightMax", m_fUnitHeightMax);
            objFile.WriteElement2Value("UnitThicknessMin", m_fUnitThicknessMin);
            objFile.WriteElement2Value("UnitThicknessMax", m_fUnitThicknessMax);

            objFile.WriteElement2Value("UnitSizeLength", m_fUnitSizeLength);
            objFile.WriteElement2Value("CrackLength", m_fCrackLength);
            objFile.WriteElement2Value("ScratchLength", m_fScratchLength);
            objFile.WriteElement2Value("ScratchArea", m_fScratchArea);
            objFile.WriteElement2Value("ChipArea", m_fChipArea);
            objFile.WriteElement2Value("ContaminationLength", m_fContaminationLength);
            objFile.WriteElement2Value("SolderMeltLength", m_fSolderMeltLength);
            objFile.WriteElement2Value("VoidLength", m_fVoidLength);
            objFile.WriteElement2Value("VoidArea", m_fVoidArea);
            objFile.WriteElement2Value("CrackLength", m_fCrackLength);
            objFile.WriteElement2Value("CrackArea", m_fCrackArea);
            objFile.WriteElement2Value("ForeignMaterialArea", m_fForeignMaterialArea);
            objFile.WriteElement2Value("MoldFlashLength_Real", m_fMoldFlashLength);
            objFile.WriteElement2Value("MoldFlashWidth", m_fMoldFlashWidth);
            objFile.WriteElement2Value("MoldFlashLength", m_fMoldFlashArea);
            objFile.WriteElement2Value("MoldFlashTotalArea", m_fMoldFlashTotalArea);
            objFile.WriteElement2Value("InCompletePlateLength", m_fInCompletePlateLength);
            objFile.WriteElement2Value("PadBrokenLength", m_fPadBrokenLength);

            objFile.WriteElement2Value("MoldFlashDefectDimensionFailCondition", m_intMoldFlashDefectDimensionFailCondition);
            objFile.WriteElement2Value("BrightDefectDimensionFailCondition", m_intBrightDefectDimensionFailCondition);
            objFile.WriteElement2Value("ForeignMaterialBrightDefectDimensionFailCondition", m_intForeignMaterialBrightDefectDimensionFailCondition);
            objFile.WriteElement2Value("DarkDefectDimensionFailCondition", m_intDarkDefectDimensionFailCondition);
            objFile.WriteElement2Value("CrackDarkDefectDimensionFailCondition", m_intCrackDarkDefectDimensionFailCondition);

            objFile.WriteElement2Value("BrightLength", m_fBrightLength);
            objFile.WriteElement2Value("BrightWidth", m_fBrightWidth);
            objFile.WriteElement2Value("BrightArea", m_fBrightArea);
            objFile.WriteElement2Value("BrightTotalArea", m_fBrightTotalArea);
            objFile.WriteElement2Value("DarkLength", m_fDarkLength);
            objFile.WriteElement2Value("DarkWidth", m_fDarkWidth);
            objFile.WriteElement2Value("DarkArea", m_fDarkArea);
            objFile.WriteElement2Value("DarkTotalArea", m_fDarkTotalArea);
            objFile.WriteElement2Value("BrightChippedOffArea", m_fBrightChippedOffArea);
            objFile.WriteElement2Value("DarkChippedOffArea", m_fDarkChippedOffArea);
            objFile.WriteElement2Value("DarkVerticalCrack", m_fDarkVerticalCrack);
            objFile.WriteElement2Value("DarkHorizontalCrack", m_fDarkHorizontalCrack);
            objFile.WriteElement2Value("BrightVerticalForeignMaterial", m_fBrightVerticalForeignMaterial);
            objFile.WriteElement2Value("BrightHorizontalForeignMaterial", m_fBrightHorizontalForeignMaterial);

            objFile.WriteElement2Value("MPErodeHalfWidth", m_intMPErodeHalfWidth);
            objFile.WriteElement2Value("MPDilateHalfWidth", m_intMPDilateHalfWidth);

            objFile.WriteEndElement();

            if (m_objPosCrosshair != null)
                m_objPosCrosshair.SaveCrosshair(strPath, false, "PositionCrosshair", false);
        }

        public void SavePad_SECSGEM(string strPath, string strSectionName, string strVisionName, bool blnSECSGEMFileExist, int intSECSGEMMaxNoOfCoplanPad)
        {
            XmlParser objFile = new XmlParser(strPath, "SECSGEMData");
            objFile.WriteRootElement("SECSGEMData");

            // Save PadSetting
            objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_UnitMatcherTemplateCenterX", m_fUnitMatcherTemplateCenterX);
            objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_UnitMatcherTemplateCenterY", m_fUnitMatcherTemplateCenterY);
            objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_OrientDirections", m_intOrientDirections);
            objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_AngleTolerance", m_fAngleTolerance);
            objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_XTolerance", m_fXTolerance);
            objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_YTolerance", m_fYTolerance);
            objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_ThresholdValue", m_intThresholdValue);
            objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_CopperThresholdValue", m_intCopperThresholdValue);
            //objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_ImageMerge2ThresholdValue", m_intImageMerge2ThresholdValue);
            objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_ImageMerge2ThresholdHighValue", m_intImageMerge2ThresholdHighValue);
            objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_ImageMerge2ThresholdLowValue", m_intImageMerge2ThresholdLowValue);
            objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_InterPadThresholdValue", m_intInterPadThresholdValue);
            objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_SurfaceThresholdValue", m_intSurfaceThresholdValue);
            objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_SurfaceLowThresholdValue", m_intSurfaceLowThresholdValue);
            objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_MinSpanX", m_fMinSpanX);
            objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_MaxSpanX", m_fMaxSpanX);
            objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_MinSpanY", m_fMinSpanY);
            objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_MaxSpanY", m_fMaxSpanY);
            objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_EdgeDistanceMin_Top", m_fEdgeDistanceMin_Top);
            objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_EdgeDistanceMax_Top", m_fEdgeDistanceMax_Top);
            objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_EdgeDistanceMin_Right", m_fEdgeDistanceMin_Right);
            objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_EdgeDistanceMax_Right", m_fEdgeDistanceMax_Right);
            objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_EdgeDistanceMin_Bottom", m_fEdgeDistanceMin_Bottom);
            objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_EdgeDistanceMax_Bottom", m_fEdgeDistanceMax_Bottom);
            objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_EdgeDistanceMin_Left", m_fEdgeDistanceMin_Left);
            objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_EdgeDistanceMax_Left", m_fEdgeDistanceMax_Left);
            objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_ExtraPadMinArea", m_fExtraPadSetArea);
            objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_TotalExtraPadMinArea", m_fTotalExtraPadSetArea);
            objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_ExcessPadMinArea", m_fExcessPadSetArea);
            objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_ExtraPadSetLength", m_fExtraPadSetLength);
            objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_ExcessPadSetLength", m_fExcessPadSetLength);
            objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_SmearLength", m_fSmearLength);
            objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_MinArea", m_fFilterMinArea);
            objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_InspectionMinArea", m_fBlobsMinArea);
            objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_InspectionImageMerge2MinArea", m_fImageMerge2BlobsMinArea);
            objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_SurfaceMinArea", m_fSurfaceMinArea);
            objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_Image2SurfaceMinArea", m_fImage2SurfaceMinArea);
            objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_MoldFlashMinArea", m_fMoldFlashMinArea);
            objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_VoidMinArea", m_fVoidMinArea);
            objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_CrackMinArea", m_fCrackMinArea);
            objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_ForeignMaterialBrightFieldMinArea", m_intForeignMaterialBrightFieldMinArea);
            objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BrightFieldMinArea", m_intBrightFieldMinArea);
            objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_DarkFieldMinArea", m_intDarkFieldMinArea);

            objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_PadWidthLengthMode", m_intPadWidthLengthMode);
            objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_PadLabelRefCorner", m_intPadLabelRefCorner);
            objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_PadLabelDirection", m_intPadLabelDirection);
            objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_PadStartX", m_fPadRangeStartX);
            objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_PadStartY", m_fPadRangeStartY);
            objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_PadEndX", m_fPadRangeEndX);
            objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_PadEndY", m_fPadRangeEndY);
            objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_FailMask", m_intFailOptionMask);
            objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_FailPkgMask", m_intFailPkgOptionMask);
            objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_WantInspectPackage", m_blnInspectPackage);
            objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_WhiteOnBlack", m_blnWhiteOnBlack);
            objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_DefaultPixelTolerance", m_fDefaultPixelTolerance);
            //objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_PadSizeHalfWidthTolerance", m_intPadSizeHalfWidthTolerance);  // 2019 08 27 - CCENG : No longer use. Replaced by m_intMPErodeHalfWidth and m_intMPDilateHalfWidth
            objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_TightSettingThresholdTolerance", m_intTightSettingThresholdTolerance);
            objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_TightSettingTolerance", m_fTightSettingTolerance);
            objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_SensitivityOnPadMethod", m_intSensitivityOnPadMethod);
            objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_SensitivityOnPadValue", m_intSensitivityOnPadValue);
            objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_InspectPadMode", m_intInspectPadMode);
            objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_EmptyMinScore", m_fEmptyMinScore);
            objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_UseEmtpyUnitThreshold", m_bUseEmptyUnitThreshold);
            objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_WantGaugeMeasurePkgSize", m_blnWantGaugeMeasurePkgSize);
            objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_MeasureCenterPkgSizeUsingSidePkg", m_blnMeasureCenterPkgSizeUsingSidePkg);
            objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_UseDetailDefectCriteria", m_blnUseDetailDefectCriteria);
            objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_EmptyAreaLimit", m_intEmptyAreaLimit);
            objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_EmptyThreshold", m_intEmptyThreshold);
            objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_EmptyAreaColorTransition", m_intEmptyAreaColorTransition);
            objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_PadPRSScore", m_fPadPRSScore);
            objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_UnitAngleLimit", m_fUnitAngleLimit);
            objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_PosToleranceX", m_fPosToleranceX);
            objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_PosToleranceY", m_fPosToleranceY);
            objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_ImageGain", m_fImageGain);
            objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_GaugeSizeImageIndex", m_intGaugeSizeImageIndex);
            objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_CheckPadDimensionImageIndex", m_intCheckPadDimensionImageIndex);
            objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_PadROISizeTolerance", m_intPadROISizeTolerance);
            objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_PadROISizeToleranceADV", m_intPadROISizeToleranceADV);
            objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_WantTightSetting", m_blnWantTightSetting);
            objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_WantConsiderPadImage2", m_blnWantConsiderPadImage2);
            objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_WantPRUnitLocationBeforeGauge", m_blnWantPRUnitLocationBeforeGauge);
            objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_WantUseGaugeMeasureDimension", m_blnWantUseGaugeMeasureDimension);
            objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_WantUseClosestSizeDefineTolerance", m_blnWantUseClosestSizeDefineTolerance);
            objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_WantAutoGauge", m_blnWantAutoGauge);
            objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_WantRotateSidePadImage", m_blnWantRotateSidePadImage);
            objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_WantLinkDifferentGroupPitchGap", m_blnWantLinkDifferentGroupPitchGap);
            objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_WantShowUseGaugeCheckBox", m_blnWantShowUseGaugeCheckBox);
            objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_WantSeparateBrokenPadThresholdSetting", m_blnWantSeparateBrokenPadThresholdSetting); 
            objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_WantUseGroupToleranceSetting", m_blnWantUseGroupToleranceSetting);
            objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_WantViewCheckForeignMaterialOptionWhenPackageON", m_blnWantViewCheckForeignMaterialOptionWhenPackageON);

            objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_WantCheckExtraPadLength", m_blnWantCheckExtraPadLength);
            objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_WantCheckExtraPadArea", m_blnWantCheckExtraPadArea);
            objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_WantCheckBrokenPadLength", m_blnWantCheckBrokenPadLength);
            objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_WantCheckBrokenPadArea", m_blnWantCheckBrokenPadArea);
            objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_WantCheckSmearPadLength", m_blnWantCheckSmearPadLength);
            objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_WantCheckPadEdgeLimit", m_blnWantCheckPadEdgeLimit);
            objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_WantCheckPadEdgeDistance", m_blnWantCheckPadEdgeDistance);
            objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_WantCheckPadSpanX", m_blnWantCheckPadSpanX);
            objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_WantCheckPadSpanY", m_blnWantCheckPadSpanY);
            objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_WantCheckPadStandOff", m_blnWantCheckPadStandOff);
            objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_WantCheckExcessPadLength", m_blnWantCheckExcessPadLength);
            objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_WantCheckExcessPadArea", m_blnWantCheckExcessPadArea);

            int intBlobsCount = GetBlobsFeaturesNumber();
            objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeaturesCount", intBlobsCount);
            objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_GroupBlobsFeaturesCount", m_arrGroupTemplateBlobPads.Count);
            int intTotalPitchGap = GetTotalPitchGap();
            objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_PitchGapCount", intTotalPitchGap);

            // Save BlobsFeatures
            string strBlobsFeatures = GetBlobsFeaturesAllData();
            string[] strFeature = strBlobsFeatures.Split('#');

            int intFeatureIndex = 0;
            for (int v = 0; v < intSECSGEMMaxNoOfCoplanPad; v++)
            {
                if (intBlobsCount > v)
                {
                    //objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v, "");
                    objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_NoID", strFeature[intFeatureIndex++]);
                    objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_GroupNo", strFeature[intFeatureIndex++]);
                    //objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_Area", strFeature[intFeatureIndex++]);
                    objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_LengthMode", strFeature[intFeatureIndex++]);
                    //objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_ContourX", strFeature[intFeatureIndex++]);
                    //objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_ContourY", strFeature[intFeatureIndex++]);
                    //objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_StartX", strFeature[intFeatureIndex++]);
                    //objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_StartY", strFeature[intFeatureIndex++]);
                    //objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_EndX", strFeature[intFeatureIndex++]);
                    //objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_EndY", strFeature[intFeatureIndex++]);
                    //objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_fStartX", strFeature[intFeatureIndex++]);
                    //objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_fStartY", strFeature[intFeatureIndex++]);
                    //objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_fEndX", strFeature[intFeatureIndex++]);
                    //objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_fEndY", strFeature[intFeatureIndex++]);
                    objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_Direction", strFeature[intFeatureIndex++]);
                    objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_PadSide", strFeature[intFeatureIndex++]);
                    objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_SmearSide", strFeature[intFeatureIndex++]);
                    //objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_GravityCenterX", strFeature[intFeatureIndex++]);
                    //objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_GravityCenterY", strFeature[intFeatureIndex++]);
                    //objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_LimitCenterX", strFeature[intFeatureIndex++]);
                    //objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_LimitCenterY", strFeature[intFeatureIndex++]);
                    //objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_Width", strFeature[intFeatureIndex++]);
                    //objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_Height", strFeature[intFeatureIndex++]);

                    //objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_PercentWidthStart1", strFeature[intFeatureIndex++]);
                    //objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_PercentHeightStart1", strFeature[intFeatureIndex++]);
                    //objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_PercentWidthEnd1", strFeature[intFeatureIndex++]);
                    //objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_PercentHeightEnd1", strFeature[intFeatureIndex++]);
                    //objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_PercentWidthStart2", strFeature[intFeatureIndex++]);
                    //objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_PercentHeightStart2", strFeature[intFeatureIndex++]);
                    //objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_PercentWidthEnd2", strFeature[intFeatureIndex++]);
                    //objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_PercentHeightEnd2", strFeature[intFeatureIndex++]);
                    //objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_PercentWidthStart3", strFeature[intFeatureIndex++]);
                    //objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_PercentHeightStart3", strFeature[intFeatureIndex++]);
                    //objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_PercentWidthEnd3", strFeature[intFeatureIndex++]);
                    //objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_PercentHeightEnd3", strFeature[intFeatureIndex++]);
                    //objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_PercentWidthStart4", strFeature[intFeatureIndex++]);
                    //objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_PercentHeightStart4", strFeature[intFeatureIndex++]);
                    //objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_PercentWidthEnd4", strFeature[intFeatureIndex++]);
                    //objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_PercentHeightEnd4", strFeature[intFeatureIndex++]);
                    //objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_PercentWidthStart5", strFeature[intFeatureIndex++]);
                    //objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_PercentHeightStart5", strFeature[intFeatureIndex++]);
                    //objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_PercentWidthEnd5", strFeature[intFeatureIndex++]);
                    //objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_PercentHeightEnd5", strFeature[intFeatureIndex++]);
                    //objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_PercentWidthStart6", strFeature[intFeatureIndex++]);
                    //objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_PercentHeightStart6", strFeature[intFeatureIndex++]);
                    //objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_PercentWidthEnd6", strFeature[intFeatureIndex++]);
                    //objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_PercentHeightEnd6", strFeature[intFeatureIndex++]);
                    //objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_PercentWidthStart7", strFeature[intFeatureIndex++]);
                    //objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_PercentHeightStart7", strFeature[intFeatureIndex++]);
                    //objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_PercentWidthEnd7", strFeature[intFeatureIndex++]);
                    //objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_PercentHeightEnd7", strFeature[intFeatureIndex++]);

                    //objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_InwardPercentStart1", strFeature[intFeatureIndex++]);
                    //objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_InwardPercentEnd1", strFeature[intFeatureIndex++]);
                    //objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_InwardPercentStart2", strFeature[intFeatureIndex++]);
                    //objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_InwardPercentEnd2", strFeature[intFeatureIndex++]);
                    //objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_InwardPercentStart3", strFeature[intFeatureIndex++]);
                    //objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_InwardPercentEnd3", strFeature[intFeatureIndex++]);
                    //objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_InwardPercentStart4", strFeature[intFeatureIndex++]);
                    //objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_InwardPercentEnd4", strFeature[intFeatureIndex++]);
                    //objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_InwardPercentStart5", strFeature[intFeatureIndex++]);
                    //objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_InwardPercentEnd5", strFeature[intFeatureIndex++]);
                    //objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_InwardPercentStart6", strFeature[intFeatureIndex++]);
                    //objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_InwardPercentEnd6", strFeature[intFeatureIndex++]);
                    //objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_InwardPercentStart7", strFeature[intFeatureIndex++]);
                    //objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_InwardPercentEnd7", strFeature[intFeatureIndex++]);

                    objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_LineCount", strFeature[intFeatureIndex++]);

                    //objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_FeretWidth", strFeature[intFeatureIndex++]);
                    //objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_FeretHeight", strFeature[intFeatureIndex++]);
                    //objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_FeretCenterX", strFeature[intFeatureIndex++]);
                    //objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_FeretCenterY", strFeature[intFeatureIndex++]);
                    //objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_FeretAngle", strFeature[intFeatureIndex++]);
                    objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_FeretLengthMode", strFeature[intFeatureIndex++]);
                    if (strFeature[intFeatureIndex++] == "True")
                        objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_FeretActivated", true);
                    else
                        objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_FeretActivated", false);

                    //objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_P1X", strFeature[intFeatureIndex++]);
                    //objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_P1Y", strFeature[intFeatureIndex++]);
                    //objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_P2X", strFeature[intFeatureIndex++]);
                    //objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_P2Y", strFeature[intFeatureIndex++]);
                    //objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_P3X", strFeature[intFeatureIndex++]);
                    //objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_P3Y", strFeature[intFeatureIndex++]);
                    //objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_P4X", strFeature[intFeatureIndex++]);
                    //objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_P4Y", strFeature[intFeatureIndex++]);

                    if (strFeature[intFeatureIndex++] == "True")
                        objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_Selected", true);
                    else
                        objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_Selected", false);

                    if (strFeature[intFeatureIndex++] == "True")
                        objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_Enable", true);
                    else
                        objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_Enable", false);
                    //objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_LeftDistance", strFeature[intFeatureIndex++]);
                    //objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_RightDistance", strFeature[intFeatureIndex++]);
                    //objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_TopDistance", strFeature[intFeatureIndex++]);
                    //objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_BottomDistance", strFeature[intFeatureIndex++]);
                    //objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_XDistance", strFeature[intFeatureIndex++]);
                    //objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_YDistance", strFeature[intFeatureIndex++]);
                    //objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_Pitch", strFeature[intFeatureIndex++]);
                    //objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_Gap", strFeature[intFeatureIndex++]);

                    objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_OffSet", strFeature[intFeatureIndex++]);
                    objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_MinArea", strFeature[intFeatureIndex++]);
                    objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_MaxArea", strFeature[intFeatureIndex++]);
                    objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_MinWidth", strFeature[intFeatureIndex++]);
                    objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_MaxWidth", strFeature[intFeatureIndex++]);
                    objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_MinHeight", strFeature[intFeatureIndex++]);
                    objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_MaxHeight", strFeature[intFeatureIndex++]);
                    objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_MinPitch", strFeature[intFeatureIndex++]);
                    objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_MaxPitch", strFeature[intFeatureIndex++]);
                    objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_MinGap", strFeature[intFeatureIndex++]);
                    objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_MaxGap", strFeature[intFeatureIndex++]);
                    objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_MaxHole", strFeature[intFeatureIndex++]);   // == MaxBroken
                    objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_MaxBrokenLength", strFeature[intFeatureIndex++]);
                    objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_MaxExcess", strFeature[intFeatureIndex++]);
                    objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_MaxSmearLength", strFeature[intFeatureIndex++]);

                    objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_MaxEdgeLimitTop", strFeature[intFeatureIndex++]);
                    objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_MaxEdgeLimitRight", strFeature[intFeatureIndex++]);
                    objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_MaxEdgeLimitBottom", strFeature[intFeatureIndex++]);
                    objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_MaxEdgeLimitLeft", strFeature[intFeatureIndex++]);

                    objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_MaxStandOffTop", strFeature[intFeatureIndex++]);
                    objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_MaxStandOffBottom", strFeature[intFeatureIndex++]);
                    objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_MaxStandOffLeft", strFeature[intFeatureIndex++]);
                    objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_MaxStandOffRight", strFeature[intFeatureIndex++]);

                    objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_OffsetOffset", strFeature[intFeatureIndex++]);
                    objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_WidthOffset", strFeature[intFeatureIndex++]);
                    objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_HeightOffset", strFeature[intFeatureIndex++]);
                    objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_PitchOffset", strFeature[intFeatureIndex++]);
                    objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_GapOffset", strFeature[intFeatureIndex++]);
                    
                    objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_EdgeDistanceTopOffset", strFeature[intFeatureIndex++]);
                    objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_EdgeDistanceRightOffset", strFeature[intFeatureIndex++]);
                    objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_EdgeDistanceBottomOffset", strFeature[intFeatureIndex++]);
                    objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_EdgeDistanceLeftOffset", strFeature[intFeatureIndex++]);

                    objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_EdgeLimitTopOffset", strFeature[intFeatureIndex++]);
                    objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_EdgeLimitRightOffset", strFeature[intFeatureIndex++]);
                    objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_EdgeLimitBottomOffset", strFeature[intFeatureIndex++]);
                    objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_EdgeLimitLeftOffset", strFeature[intFeatureIndex++]);

                    objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_StandOffTopOffset", strFeature[intFeatureIndex++]);
                    objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_StandOffBottomOffset", strFeature[intFeatureIndex++]);
                    objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_StandOffLeftOffset", strFeature[intFeatureIndex++]);
                    objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_StandOffRightOffset", strFeature[intFeatureIndex++]);

                    objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_MinLine3", strFeature[intFeatureIndex++]);
                    objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_MaxLine3", strFeature[intFeatureIndex++]);
                    objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_MinLine4", strFeature[intFeatureIndex++]);
                    objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_MaxLine4", strFeature[intFeatureIndex++]);
                    objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_MinLine5", strFeature[intFeatureIndex++]);
                    objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_MaxLine5", strFeature[intFeatureIndex++]);
                    objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_MinLine6", strFeature[intFeatureIndex++]);
                    objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_MaxLine6", strFeature[intFeatureIndex++]);
                    objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_MinLine7", strFeature[intFeatureIndex++]);
                    objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_MaxLine7", strFeature[intFeatureIndex++]);
                    objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_MinLine8", strFeature[intFeatureIndex++]);
                    objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_MaxLine8", strFeature[intFeatureIndex++]);
                    objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_MinLine9", strFeature[intFeatureIndex++]);
                    objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_MaxLine9", strFeature[intFeatureIndex++]);
                    objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_MinLine10", strFeature[intFeatureIndex++]);
                    objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_MaxLine10", strFeature[intFeatureIndex++]);
                    objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_MinLine11", strFeature[intFeatureIndex++]);
                    objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_MaxLine11", strFeature[intFeatureIndex++]);
                    objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_MinLine12", strFeature[intFeatureIndex++]);
                    objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_MaxLine12", strFeature[intFeatureIndex++]);

                    objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_PadInspectionAreaFromTop", strFeature[intFeatureIndex++]);
                    objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_PadInspectionAreaFromRight", strFeature[intFeatureIndex++]);
                    objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_PadInspectionAreaFromBottom", strFeature[intFeatureIndex++]);
                    objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_PadInspectionAreaFromLeft", strFeature[intFeatureIndex++]);

                    objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_ReferTopBottom", strFeature[intFeatureIndex++]);
                    objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_CheckTop", strFeature[intFeatureIndex++]);
                    objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_CheckBottom", strFeature[intFeatureIndex++]);
                    objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_ReferLeftRight", strFeature[intFeatureIndex++]);
                    objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_CheckLeft", strFeature[intFeatureIndex++]);
                    objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_CheckRight", strFeature[intFeatureIndex++]);
                }
                else
                {
                    if (!blnSECSGEMFileExist)
                    {
                        objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_NoID", "NA");
                        objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_GroupNo", "NA");
                        //objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_Area", "NA");
                        objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_LengthMode", "NA");
                        //objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_ContourX", "NA");
                        //objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_ContourY", "NA");
                        //objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_StartX", "NA");
                        //objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_StartY", "NA");
                        //objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_EndX", "NA");
                        //objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_EndY", "NA");
                        //objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_fStartX", "NA");
                        //objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_fStartY", "NA");
                        //objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_fEndX", "NA");
                        //objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_fEndY", "NA");
                        objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_Direction", "NA");
                        objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_PadSide", "NA");
                        objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_SmearSide", "NA");
                        //objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_GravityCenterX", "NA");
                        //objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_GravityCenterY", "NA");
                        //objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_LimitCenterX", "NA");
                        //objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_LimitCenterY", "NA");
                        //objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_Width", "NA");
                        //objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_Height", "NA");

                        //objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_PercentWidthStart1", "NA");
                        //objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_PercentHeightStart1", "NA");
                        //objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_PercentWidthEnd1", "NA");
                        //objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_PercentHeightEnd1", "NA");
                        //objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_PercentWidthStart2", "NA");
                        //objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_PercentHeightStart2", "NA");
                        //objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_PercentWidthEnd2", "NA");
                        //objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_PercentHeightEnd2", "NA");
                        //objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_PercentWidthStart3", "NA");
                        //objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_PercentHeightStart3", "NA");
                        //objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_PercentWidthEnd3", "NA");
                        //objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_PercentHeightEnd3", "NA");
                        //objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_PercentWidthStart4", "NA");
                        //objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_PercentHeightStart4", "NA");
                        //objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_PercentWidthEnd4", "NA");
                        //objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_PercentHeightEnd4", "NA");
                        //objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_PercentWidthStart5", "NA");
                        //objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_PercentHeightStart5", "NA");
                        //objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_PercentWidthEnd5", "NA");
                        //objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_PercentHeightEnd5", "NA");
                        //objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_PercentWidthStart6", "NA");
                        //objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_PercentHeightStart6", "NA");
                        //objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_PercentWidthEnd6", "NA");
                        //objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_PercentHeightEnd6", "NA");
                        //objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_PercentWidthStart7", "NA");
                        //objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_PercentHeightStart7", "NA");
                        //objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_PercentWidthEnd7", "NA");
                        //objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_PercentHeightEnd7", "NA");
                        objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_LineCount", "NA");

                        //objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_FeretWidth", "NA");
                        //objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_FeretHeight", "NA");
                        //objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_FeretCenterX", "NA");
                        //objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_FeretCenterY", "NA");
                        //objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_FeretAngle", "NA");
                        //objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_FeretLengthMode", "NA");
                        objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_FeretActivated", "NA");


                        //objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_P1X", "NA");
                        //objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_P1Y", "NA");
                        //objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_P2X", "NA");
                        //objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_P2Y", "NA");
                        //objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_P3X", "NA");
                        //objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_P3Y", "NA");
                        //objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_P4X", "NA");
                        //objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_P4Y", "NA");

                        objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_Selected", "NA");
                        objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_Enable", "NA");

                        //objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_LeftDistance", "NA");
                        //objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_RightDistance", "NA");
                        //objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_TopDistance", "NA");
                        //objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_BottomDistance", "NA");
                        //objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_XDistance", "NA");
                        //objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_YDistance", "NA");
                        //objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_Pitch", "NA");
                        //objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_Gap", "NA");

                        objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_OffSet", "NA");
                        objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_MinArea", "NA");
                        objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_MaxArea", "NA");
                        objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_MinWidth", "NA");
                        objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_MaxWidth", "NA");
                        objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_MinHeight", "NA");
                        objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_MaxHeight", "NA");
                        objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_MinPitch", "NA");
                        objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_MaxPitch", "NA");
                        objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_MinGap", "NA");
                        objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_MaxGap", "NA");
                        objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_MaxHole", "NA");   // == MaxBroken
                        objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_MaxBrokenLength", "NA");
                        objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_MaxExcess", "NA");
                        objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_MaxSmearLength", "NA");

                        objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_MaxEdgeLimitTop", "NA");
                        objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_MaxEdgeLimitRight", "NA");
                        objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_MaxEdgeLimitBottom", "NA");
                        objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_MaxEdgeLimitLeft", "NA");

                        objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_MaxStandOffTop", "NA");
                        objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_MaxStandOffBottom", "NA");
                        objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_MaxStandOffLeft", "NA");
                        objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_MaxStandOffRight", "NA");

                        objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_OffsetOffset", "NA");
                        objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_WidthOffset", "NA");
                        objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_HeightOffset", "NA");
                        objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_PitchOffset", "NA");
                        objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_GapOffset", "NA");

                        objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_EdgeDistanceTopOffset", "NA");
                        objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_EdgeDistanceRightOffset", "NA");
                        objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_EdgeDistanceBottomOffset", "NA");
                        objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_EdgeDistanceLeftOffset", "NA");

                        objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_EdgeLimitTopOffset", "NA");
                        objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_EdgeLimitRightOffset", "NA");
                        objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_EdgeLimitBottomOffset", "NA");
                        objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_EdgeLimitLeftOffset", "NA");

                        objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_StandOffTopOffset", "NA");
                        objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_StandOffBottomOffset", "NA");
                        objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_StandOffLeftOffset", "NA");
                        objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_StandOffRightOffset", "NA");

                        objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_MinLine3", "NA");
                        objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_MaxLine3", "NA");
                        objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_MinLine4", "NA");
                        objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_MaxLine4", "NA");
                        objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_MinLine5", "NA");
                        objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_MaxLine5", "NA");
                        objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_MinLine6", "NA");
                        objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_MaxLine6", "NA");
                        objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_MinLine7", "NA");
                        objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_MaxLine7", "NA");
                        objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_MinLine8", "NA");
                        objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_MaxLine8", "NA");
                        objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_MinLine9", "NA");
                        objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_MaxLine9", "NA");
                        objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_MinLine10", "NA");
                        objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_MaxLine10", "NA");
                        objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_MinLine11", "NA");
                        objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_MaxLine11", "NA");
                        objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_MinLine12", "NA");
                        objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_MaxLine12", "NA");

                        objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_PadInspectionAreaFromTop", "NA");
                        objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_PadInspectionAreaFromRight", "NA");
                        objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_PadInspectionAreaFromBottom", "NA");
                        objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_PadInspectionAreaFromLeft", "NA");

                        objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_ReferTopBottom", "NA");
                        objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_CheckTop", "NA");
                        objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_CheckBottom", "NA");
                        objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_ReferLeftRight", "NA");
                        objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_CheckLeft", "NA");
                        objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_BlobsFeatures" + v + "_CheckRight", "NA");
                    }
                }
            }

            //int intIndex = 0;
            //string strPitchGapData;
            //string[] strPitchGapDataRow;
            //for (int q = 0; q < 50; q++)
            //{
            //    if (intTotalPitchGap > q)
            //    {
            //        intIndex = 0;
            //        strPitchGapData = GetMicronPitchGapData(q);
            //        strPitchGapDataRow = strPitchGapData.Split('#');

            //        objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_PitchGap" + q + "_FromPadNo", strPitchGapDataRow[intIndex++]);
            //        objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_PitchGap" + q + "_ToPadNo", strPitchGapDataRow[intIndex++]);
            //        objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_PitchGap" + q + "_MinPitch", strPitchGapDataRow[intIndex++]);
            //        objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_PitchGap" + q + "_MaxPitch", strPitchGapDataRow[intIndex++]);
            //        objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_PitchGap" + q + "_MinGap", strPitchGapDataRow[intIndex++]);
            //        objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_PitchGap" + q + "_MaxGap", strPitchGapDataRow[intIndex++]);
            //        objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_PitchGap" + q + "_Gap", strPitchGapDataRow[intIndex++]);
            //        objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_PitchGap" + q + "_Pitch", strPitchGapDataRow[intIndex++]);
            //        objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_PitchGap" + q + "_StartX", strPitchGapDataRow[intIndex++]);
            //        objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_PitchGap" + q + "_StartY", strPitchGapDataRow[intIndex++]);
            //        objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_PitchGap" + q + "_EndX", strPitchGapDataRow[intIndex++]);
            //        objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_PitchGap" + q + "_EndY", strPitchGapDataRow[intIndex++]);
            //        objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_PitchGap" + q + "_Direction", strPitchGapDataRow[intIndex++]);
            //    }
            //    else
            //    {
            //        objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_PitchGap" + q + "_FromPadNo", "NA");
            //        objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_PitchGap" + q + "_ToPadNo", "NA");
            //        objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_PitchGap" + q + "_MinPitch", "NA");
            //        objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_PitchGap" + q + "_MaxPitch", "NA");
            //        objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_PitchGap" + q + "_MinGap", "NA");
            //        objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_PitchGap" + q + "_MaxGap", "NA");
            //        objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_PitchGap" + q + "_Gap", "NA");
            //        objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_PitchGap" + q + "_Pitch", "NA");
            //        objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_PitchGap" + q + "_StartX", "NA");
            //        objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_PitchGap" + q + "_StartY", "NA");
            //        objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_PitchGap" + q + "_EndX", "NA");
            //        objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_PitchGap" + q + "_EndY", "NA");
            //        objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_PitchGap" + q + "_Direction", "NA");
            //    }
            //}

            // Save Group BlobsFeatures
            for (int i = 0; i < 15; i++)
            {
                if (m_arrGroupTemplateBlobPads.Count > i)
                {
                    BlobsFeatures m_stcBlobPad = (BlobsFeatures)m_arrGroupTemplateBlobPads[i];

                    //objFile.WriteElementValue("GroupBlobsFeatures" + i, "");
                    objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_GroupBlobsFeatures" + i + "_NoID", m_stcBlobPad.intNoID);
                    objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_GroupBlobsFeatures" + i + "_GroupNo", m_stcBlobPad.intGroupID);
                    //objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_GroupBlobsFeatures" + i + "_Area", m_stcBlobPad.fArea);
                    objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_GroupBlobsFeatures" + i + "_LengthMode", m_stcBlobPad.intLengthMode);
                    //objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_GroupBlobsFeatures" + i + "_ContourX", m_stcBlobPad.intContourX);
                    //objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_GroupBlobsFeatures" + i + "_ContourY", m_stcBlobPad.intContourY);
                    //objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_GroupBlobsFeatures" + i + "_StartX", m_stcBlobPad.intStartX);
                    //objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_GroupBlobsFeatures" + i + "_StartY", m_stcBlobPad.intStartY);
                    //objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_GroupBlobsFeatures" + i + "_EndX", m_stcBlobPad.intEndX);
                    //objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_GroupBlobsFeatures" + i + "_EndY", m_stcBlobPad.intEndY);
                    //objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_GroupBlobsFeatures" + i + "_fStartX", m_stcBlobPad.fStartX);
                    //objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_GroupBlobsFeatures" + i + "_fStartY", m_stcBlobPad.fStartY);
                    //objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_GroupBlobsFeatures" + i + "_fEndX", m_stcBlobPad.fEndX);
                    //objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_GroupBlobsFeatures" + i + "_fEndY", m_stcBlobPad.fEndY);
                    objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_GroupBlobsFeatures" + i + "_Direction", m_stcBlobPad.intDirection);
                    objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_GroupBlobsFeatures" + i + "_PadSide", m_stcBlobPad.intSide);
                    objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_GroupBlobsFeatures" + i + "_SmearSide", m_stcBlobPad.intSmearSide);
                    //objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_GroupBlobsFeatures" + i + "_GravityCenterX", m_stcBlobPad.fCenterX);
                    //objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_GroupBlobsFeatures" + i + "_GravityCenterY", m_stcBlobPad.fCenterY);
                    //objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_GroupBlobsFeatures" + i + "_LimitCenterX", m_stcBlobPad.fLimitCenterX);
                    //objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_GroupBlobsFeatures" + i + "_LimitCenterY", m_stcBlobPad.fLimitCenterY);
                    //objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_GroupBlobsFeatures" + i + "_Width", m_stcBlobPad.fWidth);
                    //objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_GroupBlobsFeatures" + i + "_Height", m_stcBlobPad.fHeight);
                    objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_GroupBlobsFeatures" + i + "_Selected", m_stcBlobPad.blnSelected);
                    objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_GroupBlobsFeatures" + i + "_Enable", m_stcBlobPad.blnEnable);
                    //objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_GroupBlobsFeatures" + i + "_LeftDistance", m_stcBlobPad.fLeftDistance);
                    //objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_GroupBlobsFeatures" + i + "_RightDistance", m_stcBlobPad.fRightDistance);
                    //objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_GroupBlobsFeatures" + i + "_TopDistance", m_stcBlobPad.fTopDistance);
                    //objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_GroupBlobsFeatures" + i + "_BottomDistance", m_stcBlobPad.fBottomDistance);
                    //objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_GroupBlobsFeatures" + i + "_XDistance", m_stcBlobPad.fXDistance);
                    //objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_GroupBlobsFeatures" + i + "_YDistance", m_stcBlobPad.fYDistance);
                    //objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_GroupBlobsFeatures" + i + "_Pitch", m_stcBlobPad.fPitch);
                    //objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_GroupBlobsFeatures" + i + "_Gap", m_stcBlobPad.fGap);

                    objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_GroupBlobsFeatures" + i + "_OffSet", m_stcBlobPad.fOffSet);
                    objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_GroupBlobsFeatures" + i + "_MinArea", m_stcBlobPad.fMinArea);
                    objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_GroupBlobsFeatures" + i + "_MaxArea", m_stcBlobPad.fMaxArea);
                    objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_GroupBlobsFeatures" + i + "_MinWidth", m_stcBlobPad.fMinWidth);
                    objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_GroupBlobsFeatures" + i + "_MaxWidth", m_stcBlobPad.fMaxWidth);
                    objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_GroupBlobsFeatures" + i + "_MinLength", m_stcBlobPad.fMinLength);
                    objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_GroupBlobsFeatures" + i + "_MaxLength", m_stcBlobPad.fMaxLength);
                    objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_GroupBlobsFeatures" + i + "_MinPitch", m_stcBlobPad.fMinPitch);
                    objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_GroupBlobsFeatures" + i + "_MaxPitch", m_stcBlobPad.fMaxPitch);
                    objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_GroupBlobsFeatures" + i + "_MinGap", m_stcBlobPad.fMinGap);
                    objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_GroupBlobsFeatures" + i + "_MaxGap", m_stcBlobPad.fMaxGap);
                    objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_GroupBlobsFeatures" + i + "_MaxHole", m_stcBlobPad.fMaxBroken);   // == MaxBroken
                    objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_GroupBlobsFeatures" + i + "_MaxBrokenLength", m_stcBlobPad.fMaxBrokenLength);
                    objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_GroupBlobsFeatures" + i + "_MaxExcess", m_stcBlobPad.fMaxExcess);
                    objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_GroupBlobsFeatures" + i + "_MaxSmearLength", m_stcBlobPad.fMaxSmearLength);

                    objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_GroupBlobsFeatures" + i + "_MaxEdgeLimitTop", m_stcBlobPad.fEdgeLimitTop);
                    objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_GroupBlobsFeatures" + i + "_MaxEdgeLimitRight", m_stcBlobPad.fEdgeLimitRight);
                    objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_GroupBlobsFeatures" + i + "_MaxEdgeLimitBottom", m_stcBlobPad.fEdgeLimitBottom);
                    objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_GroupBlobsFeatures" + i + "_MaxEdgeLimitLeft", m_stcBlobPad.fEdgeLimitLeft);

                    objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_GroupBlobsFeatures" + i + "_MaxStandOffTop", m_stcBlobPad.fMaxStandOffTop);
                    objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_GroupBlobsFeatures" + i + "_MaxStandOffBottom", m_stcBlobPad.fMaxStandOffBottom);
                    objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_GroupBlobsFeatures" + i + "_MaxStandOffLeft", m_stcBlobPad.fMaxStandOffLeft);
                    objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_GroupBlobsFeatures" + i + "_MaxStandOffRight", m_stcBlobPad.fMaxStandOffRight);

                    objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_GroupBlobsFeatures" + i + "_OffsetOffSet", m_stcBlobPad.fOffsetOffSet);
                    objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_GroupBlobsFeatures" + i + "_WidthOffset", m_stcBlobPad.fWidthOffset);
                    objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_GroupBlobsFeatures" + i + "_HeightOffset", m_stcBlobPad.fHeightOffset);
                    objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_GroupBlobsFeatures" + i + "_PitchOffset", m_stcBlobPad.fPitchOffset);
                    objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_GroupBlobsFeatures" + i + "_GapOffset", m_stcBlobPad.fGapOffset);
                    
                    objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_GroupBlobsFeatures" + i + "_EdgeDistanceTopOffset", m_stcBlobPad.fEdgeDistanceLeftOffset);
                    objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_GroupBlobsFeatures" + i + "_EdgeDistanceRightOffset", m_stcBlobPad.fEdgeDistanceRightOffset);
                    objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_GroupBlobsFeatures" + i + "_EdgeDistanceBottomOffset", m_stcBlobPad.fEdgeDistanceBottomOffset);
                    objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_GroupBlobsFeatures" + i + "_EdgeDistanceLeftOffset", m_stcBlobPad.fEdgeDistanceLeftOffset);

                    objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_GroupBlobsFeatures" + i + "_EdgeLimitTopOffset", m_stcBlobPad.fEdgeLimitTopOffset);
                    objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_GroupBlobsFeatures" + i + "_EdgeLimitRightOffset", m_stcBlobPad.fEdgeLimitRightOffset);
                    objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_GroupBlobsFeatures" + i + "_EdgeLimitBottomOffset", m_stcBlobPad.fEdgeLimitBottomOffset);
                    objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_GroupBlobsFeatures" + i + "_EdgeLimitLeftOffset", m_stcBlobPad.fEdgeLimitLeftOffset);

                    objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_GroupBlobsFeatures" + i + "_StandOffTopOffset", m_stcBlobPad.fStandOffTopOffset);
                    objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_GroupBlobsFeatures" + i + "_StandOffBottomOffset", m_stcBlobPad.fStandOffBottomOffset);
                    objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_GroupBlobsFeatures" + i + "_StandOffLeftOffset", m_stcBlobPad.fStandOffLeftOffset);
                    objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_GroupBlobsFeatures" + i + "_StandOffRightOffset", m_stcBlobPad.fStandOffRightOffset);

                    objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_GroupBlobsFeatures" + i + "_MinLine3", m_stcBlobPad.fMinLine3);
                    objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_GroupBlobsFeatures" + i + "_MaxLine3", m_stcBlobPad.fMaxLine3);
                    objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_GroupBlobsFeatures" + i + "_MinLine4", m_stcBlobPad.fMinLine4);
                    objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_GroupBlobsFeatures" + i + "_MaxLine4", m_stcBlobPad.fMaxLine4);
                    objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_GroupBlobsFeatures" + i + "_MinLine5", m_stcBlobPad.fMinLine5);
                    objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_GroupBlobsFeatures" + i + "_MaxLine5", m_stcBlobPad.fMaxLine5);
                    objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_GroupBlobsFeatures" + i + "_MinLine6", m_stcBlobPad.fMinLine6);
                    objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_GroupBlobsFeatures" + i + "_MaxLine6", m_stcBlobPad.fMaxLine6);
                    objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_GroupBlobsFeatures" + i + "_MinLine7", m_stcBlobPad.fMinLine7);
                    objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_GroupBlobsFeatures" + i + "_MaxLine7", m_stcBlobPad.fMaxLine7);
                    objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_GroupBlobsFeatures" + i + "_MinLine8", m_stcBlobPad.fMinLine8);
                    objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_GroupBlobsFeatures" + i + "_MaxLine8", m_stcBlobPad.fMaxLine8);
                    objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_GroupBlobsFeatures" + i + "_MinLine9", m_stcBlobPad.fMinLine9);
                    objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_GroupBlobsFeatures" + i + "_MaxLine9", m_stcBlobPad.fMaxLine9);
                    objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_GroupBlobsFeatures" + i + "_MinLine10", m_stcBlobPad.fMinLine10);
                    objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_GroupBlobsFeatures" + i + "_MaxLine10", m_stcBlobPad.fMaxLine10);
                    objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_GroupBlobsFeatures" + i + "_MinLine11", m_stcBlobPad.fMinLine11);
                    objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_GroupBlobsFeatures" + i + "_MaxLine11", m_stcBlobPad.fMaxLine11);
                    objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_GroupBlobsFeatures" + i + "_MinLine12", m_stcBlobPad.fMinLine12);
                    objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_GroupBlobsFeatures" + i + "_MaxLine12", m_stcBlobPad.fMaxLine12);

                    objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_GroupBlobsFeatures" + i + "_PadInspectionAreaFromTop", m_stcBlobPad.fPadInspectionAreaFromTop);
                    objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_GroupBlobsFeatures" + i + "_PadInspectionAreaFromRight", m_stcBlobPad.fPadInspectionAreaFromRight);
                    objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_GroupBlobsFeatures" + i + "_PadInspectionAreaFromBottom", m_stcBlobPad.fPadInspectionAreaFromBottom);
                    objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_GroupBlobsFeatures" + i + "_PadInspectionAreaFromLeft", m_stcBlobPad.fPadInspectionAreaFromLeft);

                    objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_GroupBlobsFeatures" + i + "_ReferTopBottom", m_stcBlobPad.intReferTopBottom);
                    objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_GroupBlobsFeatures" + i + "_CheckTop", m_stcBlobPad.blnCheckTop);
                    objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_GroupBlobsFeatures" + i + "_CheckBottom", m_stcBlobPad.blnCheckBottom);
                    objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_GroupBlobsFeatures" + i + "_ReferLeftRight", m_stcBlobPad.intReferLeftRight);
                    objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_GroupBlobsFeatures" + i + "_CheckLeft", m_stcBlobPad.blnCheckLeft);
                    objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_GroupBlobsFeatures" + i + "_CheckRight", m_stcBlobPad.blnCheckRight);

                }
                else
                {
                    if (!blnSECSGEMFileExist)
                    {
                        objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_GroupBlobsFeatures" + i + "_NoID", "NA");
                        objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_GroupBlobsFeatures" + i + "_GroupNo", "NA");
                        //objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_GroupBlobsFeatures" + i + "_Area", "NA");
                        objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_GroupBlobsFeatures" + i + "_LengthMode", "NA");
                        //objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_GroupBlobsFeatures" + i + "_ContourX", "NA");
                        //objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_GroupBlobsFeatures" + i + "_ContourY", "NA");
                        //objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_GroupBlobsFeatures" + i + "_StartX", "NA");
                        //objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_GroupBlobsFeatures" + i + "_StartY", "NA");
                        //objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_GroupBlobsFeatures" + i + "_EndX", "NA");
                        //objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_GroupBlobsFeatures" + i + "_EndY", "NA");
                        //objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_GroupBlobsFeatures" + i + "_fStartX", "NA");
                        //objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_GroupBlobsFeatures" + i + "_fStartY", "NA");
                        //objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_GroupBlobsFeatures" + i + "_fEndX", "NA");
                        //objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_GroupBlobsFeatures" + i + "_fEndY", "NA");
                        objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_GroupBlobsFeatures" + i + "_Direction", "NA");
                        objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_GroupBlobsFeatures" + i + "_PadSide", "NA");
                        objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_GroupBlobsFeatures" + i + "_SmearSide", "NA");
                        //objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_GroupBlobsFeatures" + i + "_GravityCenterX", "NA");
                        //objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_GroupBlobsFeatures" + i + "_GravityCenterY", "NA");
                        //objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_GroupBlobsFeatures" + i + "_LimitCenterX", "NA");
                        //objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_GroupBlobsFeatures" + i + "_LimitCenterY", "NA");
                        //objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_GroupBlobsFeatures" + i + "_Width", "NA");
                        //objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_GroupBlobsFeatures" + i + "_Height", "NA");
                        objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_GroupBlobsFeatures" + i + "_Selected", "NA");
                        objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_GroupBlobsFeatures" + i + "_Enable", "NA");
                        //objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_GroupBlobsFeatures" + i + "_LeftDistance", "NA");
                        //objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_GroupBlobsFeatures" + i + "_RightDistance", "NA");
                        //objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_GroupBlobsFeatures" + i + "_TopDistance", "NA");
                        //objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_GroupBlobsFeatures" + i + "_BottomDistance", "NA");
                        //objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_GroupBlobsFeatures" + i + "_XDistance", "NA");
                        //objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_GroupBlobsFeatures" + i + "_YDistance", "NA");
                        //objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_GroupBlobsFeatures" + i + "_Pitch", "NA");
                        //objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_GroupBlobsFeatures" + i + "_Gap", "NA");

                        objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_GroupBlobsFeatures" + i + "_OffSet", "NA");
                        objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_GroupBlobsFeatures" + i + "_MinArea", "NA");
                        objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_GroupBlobsFeatures" + i + "_MaxArea", "NA");
                        objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_GroupBlobsFeatures" + i + "_MinWidth", "NA");
                        objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_GroupBlobsFeatures" + i + "_MaxWidth", "NA");
                        objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_GroupBlobsFeatures" + i + "_MinHeight", "NA");
                        objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_GroupBlobsFeatures" + i + "_MaxHeight", "NA");
                        objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_GroupBlobsFeatures" + i + "_MinPitch", "NA");
                        objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_GroupBlobsFeatures" + i + "_MaxPitch", "NA");
                        objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_GroupBlobsFeatures" + i + "_MinGap", "NA");
                        objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_GroupBlobsFeatures" + i + "_MaxGap", "NA");
                        objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_GroupBlobsFeatures" + i + "_MaxHole", "NA");   // == MaxBroken
                        objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_GroupBlobsFeatures" + i + "_MaxBrokenLength", "NA");
                        objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_GroupBlobsFeatures" + i + "_MaxExcess", "NA");
                        objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_GroupBlobsFeatures" + i + "_MaxSmearLength", "NA");

                        objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_GroupBlobsFeatures" + i + "_MaxEdgeLimitTop", "NA");
                        objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_GroupBlobsFeatures" + i + "_MaxEdgeLimitRight", "NA");
                        objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_GroupBlobsFeatures" + i + "_MaxEdgeLimitBottom", "NA");
                        objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_GroupBlobsFeatures" + i + "_MaxEdgeLimitLeft", "NA");

                        objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_GroupBlobsFeatures" + i + "_MaxStandOffTop", "NA");
                        objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_GroupBlobsFeatures" + i + "_MaxStandOffBottom", "NA");
                        objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_GroupBlobsFeatures" + i + "_MaxStandOffLeft", "NA");
                        objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_GroupBlobsFeatures" + i + "_MaxStandOffRight", "NA");

                        objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_GroupBlobsFeatures" + i + "_OffsetOffset", "NA");
                        objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_GroupBlobsFeatures" + i + "_WidthOffset", "NA");
                        objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_GroupBlobsFeatures" + i + "_HeightOffset", "NA");
                        objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_GroupBlobsFeatures" + i + "_PitchOffset", "NA");
                        objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_GroupBlobsFeatures" + i + "_GapOffset", "NA");

                        objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_GroupBlobsFeatures" + i + "_EdgeDistanceTopOffset", "NA");
                        objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_GroupBlobsFeatures" + i + "_EdgeDistanceRightOffset", "NA");
                        objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_GroupBlobsFeatures" + i + "_EdgeDistanceBottomOffset", "NA");
                        objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_GroupBlobsFeatures" + i + "_EdgeDistanceLeftOffset", "NA");

                        objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_GroupBlobsFeatures" + i + "_EdgeLimitTopOffset", "NA");
                        objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_GroupBlobsFeatures" + i + "_EdgeLimitRightOffset", "NA");
                        objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_GroupBlobsFeatures" + i + "_EdgeLimitBottomOffset", "NA");
                        objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_GroupBlobsFeatures" + i + "_EdgeLimitLeftOffset", "NA");

                        objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_GroupBlobsFeatures" + i + "_StandOffTopOffset", "NA");
                        objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_GroupBlobsFeatures" + i + "_StandOffBottomOffset", "NA");
                        objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_GroupBlobsFeatures" + i + "_StandOffLeftOffset", "NA");
                        objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_GroupBlobsFeatures" + i + "_StandOffRightOffset", "NA");

                        objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_GroupBlobsFeatures" + i + "_MinLine3", "NA");
                        objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_GroupBlobsFeatures" + i + "_MaxLine3", "NA");
                        objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_GroupBlobsFeatures" + i + "_MinLine4", "NA");
                        objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_GroupBlobsFeatures" + i + "_MaxLine4", "NA");
                        objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_GroupBlobsFeatures" + i + "_MinLine5", "NA");
                        objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_GroupBlobsFeatures" + i + "_MaxLine5", "NA");
                        objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_GroupBlobsFeatures" + i + "_MinLine6", "NA");
                        objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_GroupBlobsFeatures" + i + "_MaxLine6", "NA");
                        objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_GroupBlobsFeatures" + i + "_MinLine7", "NA");
                        objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_GroupBlobsFeatures" + i + "_MaxLine7", "NA");
                        objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_GroupBlobsFeatures" + i + "_MinLine8", "NA");
                        objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_GroupBlobsFeatures" + i + "_MaxLine8", "NA");
                        objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_GroupBlobsFeatures" + i + "_MinLine9", "NA");
                        objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_GroupBlobsFeatures" + i + "_MaxLine9", "NA");
                        objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_GroupBlobsFeatures" + i + "_MinLine10", "NA");
                        objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_GroupBlobsFeatures" + i + "_MaxLine10", "NA");
                        objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_GroupBlobsFeatures" + i + "_MinLine11", "NA");
                        objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_GroupBlobsFeatures" + i + "_MaxLine11", "NA");
                        objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_GroupBlobsFeatures" + i + "_MinLine12", "NA");
                        objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_GroupBlobsFeatures" + i + "_MaxLine12", "NA");

                        objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_GroupBlobsFeatures" + i + "_PadInspectionAreaFromTop", "NA");
                        objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_GroupBlobsFeatures" + i + "_PadInspectionAreaFromRight", "NA");
                        objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_GroupBlobsFeatures" + i + "_PadInspectionAreaFromBottom", "NA");
                        objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_GroupBlobsFeatures" + i + "_PadInspectionAreaFromLeft", "NA");

                        objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_GroupBlobsFeatures" + i + "_ReferTopBottom", "NA");
                        objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_GroupBlobsFeatures" + i + "_CheckTop", "NA");
                        objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_GroupBlobsFeatures" + i + "_CheckBottom", "NA");
                        objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_GroupBlobsFeatures" + i + "_ReferLeftRight", "NA");
                        objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_GroupBlobsFeatures" + i + "_CheckLeft", "NA");
                        objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_GroupBlobsFeatures" + i + "_CheckRight", "NA");
                    }
                }
            }

            // Save Package Setting
            //objFile.WriteElementValue(strVisionName + " _PadSetting_" + strSectionName + "_PackageSetting", "");
            objFile.WriteElementValue(strVisionName + " _PackageSetting_" + strSectionName + "_ChipStartPixelFromEdge", m_fChipStartPixelFromEdge);
            objFile.WriteElementValue(strVisionName + " _PackageSetting_" + strSectionName + "_ChipStartPixelFromRight", m_fChipStartPixelFromRight);
            objFile.WriteElementValue(strVisionName + " _PackageSetting_" + strSectionName + "_ChipStartPixelFromBottom", m_fChipStartPixelFromBottom);
            objFile.WriteElementValue(strVisionName + " _PackageSetting_" + strSectionName + "_ChipStartPixelFromLeft", m_fChipStartPixelFromLeft);
            objFile.WriteElementValue(strVisionName + " _PackageSetting_" + strSectionName + "_ChipStartPixelExtendFromEdge", m_fChipStartPixelExtendFromEdge);
            objFile.WriteElementValue(strVisionName + " _PackageSetting_" + strSectionName + "_ChipStartPixelExtendFromRight", m_fChipStartPixelExtendFromRight);
            objFile.WriteElementValue(strVisionName + " _PackageSetting_" + strSectionName + "_ChipStartPixelExtendFromBottom", m_fChipStartPixelExtendFromBottom);
            objFile.WriteElementValue(strVisionName + " _PackageSetting_" + strSectionName + "_ChipStartPixelExtendFromLeft", m_fChipStartPixelExtendFromLeft);
            objFile.WriteElementValue(strVisionName + " _PackageSetting_" + strSectionName + "_ChipStartPixelFromEdge_Dark", m_fChipStartPixelFromEdge_Dark);
            objFile.WriteElementValue(strVisionName + " _PackageSetting_" + strSectionName + "_ChipStartPixelFromRight_Dark", m_fChipStartPixelFromRight_Dark);
            objFile.WriteElementValue(strVisionName + " _PackageSetting_" + strSectionName + "_ChipStartPixelFromBottom_Dark", m_fChipStartPixelFromBottom_Dark);
            objFile.WriteElementValue(strVisionName + " _PackageSetting_" + strSectionName + "_ChipStartPixelFromLeft_Dark", m_fChipStartPixelFromLeft_Dark);
            objFile.WriteElementValue(strVisionName + " _PackageSetting_" + strSectionName + "_ChipStartPixelExtendFromEdge_Dark", m_fChipStartPixelExtendFromEdge_Dark);
            objFile.WriteElementValue(strVisionName + " _PackageSetting_" + strSectionName + "_ChipStartPixelExtendFromRight_Dark", m_fChipStartPixelExtendFromRight_Dark);
            objFile.WriteElementValue(strVisionName + " _PackageSetting_" + strSectionName + "_ChipStartPixelExtendFromBottom_Dark", m_fChipStartPixelExtendFromBottom_Dark);
            objFile.WriteElementValue(strVisionName + " _PackageSetting_" + strSectionName + "_ChipStartPixelExtendFromLeft_Dark", m_fChipStartPixelExtendFromLeft_Dark);
            objFile.WriteElementValue(strVisionName + " _PackageSetting_" + strSectionName + "_MoldStartPixelFromEdge", m_fMoldStartPixelFromEdge);
            objFile.WriteElementValue(strVisionName + " _PackageSetting_" + strSectionName + "_MoldStartPixelFromRight", m_fMoldStartPixelFromRight);
            objFile.WriteElementValue(strVisionName + " _PackageSetting_" + strSectionName + "_MoldStartPixelFromBottom", m_fMoldStartPixelFromBottom);
            objFile.WriteElementValue(strVisionName + " _PackageSetting_" + strSectionName + "_MoldStartPixelFromLeft", m_fMoldStartPixelFromLeft);
            objFile.WriteElementValue(strVisionName + " _PackageSetting_" + strSectionName + "_MoldStartPixelInnerFromEdge", m_fMoldStartPixelInnerFromEdge);
            objFile.WriteElementValue(strVisionName + " _PackageSetting_" + strSectionName + "_MoldStartPixelInnerFromRight", m_fMoldStartPixelInnerFromRight);
            objFile.WriteElementValue(strVisionName + " _PackageSetting_" + strSectionName + "_MoldStartPixelInnerFromBottom", m_fMoldStartPixelInnerFromBottom);
            objFile.WriteElementValue(strVisionName + " _PackageSetting_" + strSectionName + "_MoldStartPixelInnerFromLeft", m_fMoldStartPixelInnerFromLeft);
            objFile.WriteElementValue(strVisionName + " _PackageSetting_" + strSectionName + "_PkgStartPixelFromEdge", m_fPkgStartPixelFromEdge);
            objFile.WriteElementValue(strVisionName + " _PackageSetting_" + strSectionName + "_PkgStartPixelFromRight", m_fPkgStartPixelFromRight);
            objFile.WriteElementValue(strVisionName + " _PackageSetting_" + strSectionName + "_PkgStartPixelFromBottom", m_fPkgStartPixelFromBottom);
            objFile.WriteElementValue(strVisionName + " _PackageSetting_" + strSectionName + "_PkgStartPixelFromLeft", m_fPkgStartPixelFromLeft);
            objFile.WriteElementValue(strVisionName + " _PackageSetting_" + strSectionName + "_PkgStartPixelFromEdge_Dark", m_fPkgStartPixelFromEdge_Dark);
            objFile.WriteElementValue(strVisionName + " _PackageSetting_" + strSectionName + "_PkgStartPixelFromRight_Dark", m_fPkgStartPixelFromRight_Dark);
            objFile.WriteElementValue(strVisionName + " _PackageSetting_" + strSectionName + "_PkgStartPixelFromBottom_Dark", m_fPkgStartPixelFromBottom_Dark);
            objFile.WriteElementValue(strVisionName + " _PackageSetting_" + strSectionName + "_PkgStartPixelFromLeft_Dark", m_fPkgStartPixelFromLeft_Dark);
            objFile.WriteElementValue(strVisionName + " _PackageSetting_" + strSectionName + "_ForeignMaterialStartPixelFromEdge", m_fForeignMaterialStartPixelFromEdge);
            objFile.WriteElementValue(strVisionName + " _PackageSetting_" + strSectionName + "_ForeignMaterialStartPixelFromRight", m_fForeignMaterialStartPixelFromRight);
            objFile.WriteElementValue(strVisionName + " _PackageSetting_" + strSectionName + "_ForeignMaterialStartPixelFromBottom", m_fForeignMaterialStartPixelFromBottom);
            objFile.WriteElementValue(strVisionName + " _PackageSetting_" + strSectionName + "_ForeignMaterialStartPixelFromLeft", m_fForeignMaterialStartPixelFromLeft);
            objFile.WriteElementValue(strVisionName + " _PackageSetting_" + strSectionName + "_ForeignMaterialStartPixelFromEdge_Pad", m_fForeignMaterialStartPixelFromEdge_Pad);
            objFile.WriteElementValue(strVisionName + " _PackageSetting_" + strSectionName + "_ForeignMaterialStartPixelFromRight_Pad", m_fForeignMaterialStartPixelFromRight_Pad);
            objFile.WriteElementValue(strVisionName + " _PackageSetting_" + strSectionName + "_ForeignMaterialStartPixelFromBottom_Pad", m_fForeignMaterialStartPixelFromBottom_Pad);
            objFile.WriteElementValue(strVisionName + " _PackageSetting_" + strSectionName + "_ForeignMaterialStartPixelFromLeft_Pad", m_fForeignMaterialStartPixelFromLeft_Pad);
            objFile.WriteElementValue(strVisionName + " _PackageSetting_" + strSectionName + "_PkgImage1HighPadThreshold", m_intPkgImage1HighPadThreshold);
            objFile.WriteElementValue(strVisionName + " _PackageSetting_" + strSectionName + "_PkgImage1LowPadThreshold", m_intPkgImage1LowPadThreshold);
            objFile.WriteElementValue(strVisionName + " _PackageSetting_" + strSectionName + "_PkgImage1HighSurfaceThreshold", m_intPkgImage1HighSurfaceThreshold);
            objFile.WriteElementValue(strVisionName + " _PackageSetting_" + strSectionName + "_PkgImage1LowSurfaceThreshold", m_intPkgImage1LowSurfaceThreshold);
            objFile.WriteElementValue(strVisionName + " _PackageSetting_" + strSectionName + "_PkgImage1Gain", m_fPkgImage1Gain);
            objFile.WriteElementValue(strVisionName + " _PackageSetting_" + strSectionName + "_PkgImage2HighPadThreshold", m_intPkgImage2HighThreshold);
            objFile.WriteElementValue(strVisionName + " _PackageSetting_" + strSectionName + "_PkgImage2LowPadThreshold", m_intPkgImage2LowThreshold);
            objFile.WriteElementValue(strVisionName + " _PackageSetting_" + strSectionName + "_PkgImage3HighPadThreshold", m_intPkgImage3HighThreshold);
            objFile.WriteElementValue(strVisionName + " _PackageSetting_" + strSectionName + "_PkgImage3LowPadThreshold", m_intPkgImage3LowThreshold);
            objFile.WriteElementValue(strVisionName + " _PackageSetting_" + strSectionName + "_PkgImage1MoldFlashThreshold", m_intPkgImage1MoldFlashThreshold);
            objFile.WriteElementValue(strVisionName + " _PackageSetting_" + strSectionName + "_PkgImage2VoidThreshold", m_intPkgImage2VoidThreshold);
            objFile.WriteElementValue(strVisionName + " _PackageSetting_" + strSectionName + "_PkgImage2HighCrackThreshold", m_intPkgImage2HighCrackThreshold);
            objFile.WriteElementValue(strVisionName + " _PackageSetting_" + strSectionName + "_PkgImage2LowCrackThreshold", m_intPkgImage2LowCrackThreshold);
            objFile.WriteElementValue(strVisionName + " _PackageSetting_" + strSectionName + "_PkgImage1ChippedThreshold", m_intPkgImage1ChippedThreshold);
            objFile.WriteElementValue(strVisionName + " _PackageSetting_" + strSectionName + "_ForeignMaterialBrightFieldThreshold", m_intForeignMaterialBrightFieldThreshold);
            objFile.WriteElementValue(strVisionName + " _PackageSetting_" + strSectionName + "_BrightFieldLowThreshold", m_intBrightFieldLowThreshold);
            objFile.WriteElementValue(strVisionName + " _PackageSetting_" + strSectionName + "_BrightFieldHighThreshold", m_intBrightFieldHighThreshold);
            objFile.WriteElementValue(strVisionName + " _PackageSetting_" + strSectionName + "_DarkFieldLowThreshold", m_intDarkFieldLowThreshold);
            objFile.WriteElementValue(strVisionName + " _PackageSetting_" + strSectionName + "_DarkFieldHighThreshold", m_intDarkFieldHighThreshold);

            objFile.WriteElementValue(strVisionName + " _PackageSetting_" + strSectionName + "_UnitWidth", m_fUnitWidth);
            objFile.WriteElementValue(strVisionName + " _PackageSetting_" + strSectionName + "_UnitHeight", m_fUnitHeight);
            objFile.WriteElementValue(strVisionName + " _PackageSetting_" + strSectionName + "_UnitThickness", m_fUnitThickness);
            objFile.WriteElementValue(strVisionName + " _PackageSetting_" + strSectionName + "_UnitWidthMin", m_fUnitWidthMin);
            objFile.WriteElementValue(strVisionName + " _PackageSetting_" + strSectionName + "_UnitWidthMax", m_fUnitWidthMax);
            objFile.WriteElementValue(strVisionName + " _PackageSetting_" + strSectionName + "_UnitHeightMin", m_fUnitHeightMin);
            objFile.WriteElementValue(strVisionName + " _PackageSetting_" + strSectionName + "_UnitHeightMax", m_fUnitHeightMax);
            objFile.WriteElementValue(strVisionName + " _PackageSetting_" + strSectionName + "_UnitThicknessMin", m_fUnitThicknessMin);
            objFile.WriteElementValue(strVisionName + " _PackageSetting_" + strSectionName + "_UnitThicknessMax", m_fUnitThicknessMax);

            objFile.WriteElementValue(strVisionName + " _PackageSetting_" + strSectionName + "_UnitSizeLength", m_fUnitSizeLength);
            objFile.WriteElementValue(strVisionName + " _PackageSetting_" + strSectionName + "_CrackLength", m_fCrackLength);
            objFile.WriteElementValue(strVisionName + " _PackageSetting_" + strSectionName + "_ScratchLength", m_fScratchLength);
            objFile.WriteElementValue(strVisionName + " _PackageSetting_" + strSectionName + "_ScratchArea", m_fScratchArea);
            objFile.WriteElementValue(strVisionName + " _PackageSetting_" + strSectionName + "_ChipArea", m_fChipArea);
            objFile.WriteElementValue(strVisionName + " _PackageSetting_" + strSectionName + "_ContaminationLength", m_fContaminationLength);
            objFile.WriteElementValue(strVisionName + " _PackageSetting_" + strSectionName + "_SolderMeltLength", m_fSolderMeltLength);
            objFile.WriteElementValue(strVisionName + " _PackageSetting_" + strSectionName + "_VoidLength", m_fVoidLength);
            objFile.WriteElementValue(strVisionName + " _PackageSetting_" + strSectionName + "_VoidArea", m_fVoidArea);
            objFile.WriteElementValue(strVisionName + " _PackageSetting_" + strSectionName + "_CrackLength", m_fCrackLength);
            objFile.WriteElementValue(strVisionName + " _PackageSetting_" + strSectionName + "_CrackArea", m_fCrackArea);
            objFile.WriteElementValue(strVisionName + " _PackageSetting_" + strSectionName + "_ForeignMaterialArea", m_fForeignMaterialArea);
            objFile.WriteElementValue(strVisionName + " _PackageSetting_" + strSectionName + "_MoldFlashLength_Real", m_fMoldFlashLength);
            objFile.WriteElementValue(strVisionName + " _PackageSetting_" + strSectionName + "_MoldFlashWidth", m_fMoldFlashWidth);
            objFile.WriteElementValue(strVisionName + " _PackageSetting_" + strSectionName + "_MoldFlashLength", m_fMoldFlashArea);
            objFile.WriteElementValue(strVisionName + " _PackageSetting_" + strSectionName + "_MoldFlashTotalArea", m_fMoldFlashTotalArea);
            objFile.WriteElementValue(strVisionName + " _PackageSetting_" + strSectionName + "_InCompletePlateLength", m_fInCompletePlateLength);
            objFile.WriteElementValue(strVisionName + " _PackageSetting_" + strSectionName + "_PadBrokenLength", m_fPadBrokenLength);

            objFile.WriteElementValue(strVisionName + " _PackageSetting_" + strSectionName + "_MoldFlashDefectDimensionFailCondition", m_intMoldFlashDefectDimensionFailCondition);
            objFile.WriteElementValue(strVisionName + " _PackageSetting_" + strSectionName + "_BrightDefectDimensionFailCondition", m_intBrightDefectDimensionFailCondition);
            objFile.WriteElementValue(strVisionName + " _PackageSetting_" + strSectionName + "_ForeignMaterialBrightDefectDimensionFailCondition", m_intForeignMaterialBrightDefectDimensionFailCondition);
            objFile.WriteElementValue(strVisionName + " _PackageSetting_" + strSectionName + "_DarkDefectDimensionFailCondition", m_intDarkDefectDimensionFailCondition);
            objFile.WriteElementValue(strVisionName + " _PackageSetting_" + strSectionName + "_CrackDarkDefectDimensionFailCondition", m_intCrackDarkDefectDimensionFailCondition);

            objFile.WriteElementValue(strVisionName + " _PackageSetting_" + strSectionName + "_BrightLength", m_fBrightLength);
            objFile.WriteElementValue(strVisionName + " _PackageSetting_" + strSectionName + "_BrightWidth", m_fBrightWidth);
            objFile.WriteElementValue(strVisionName + " _PackageSetting_" + strSectionName + "_BrightArea", m_fBrightArea);
            objFile.WriteElementValue(strVisionName + " _PackageSetting_" + strSectionName + "_BrightTotalArea", m_fBrightTotalArea);
            objFile.WriteElementValue(strVisionName + " _PackageSetting_" + strSectionName + "_DarkLength", m_fDarkLength);
            objFile.WriteElementValue(strVisionName + " _PackageSetting_" + strSectionName + "_DarkWidth", m_fDarkWidth);
            objFile.WriteElementValue(strVisionName + " _PackageSetting_" + strSectionName + "_DarkArea", m_fDarkArea);
            objFile.WriteElementValue(strVisionName + " _PackageSetting_" + strSectionName + "_DarkTotalArea", m_fDarkTotalArea);
            objFile.WriteElementValue(strVisionName + " _PackageSetting_" + strSectionName + "_BrightChippedOffArea", m_fBrightChippedOffArea);
            objFile.WriteElementValue(strVisionName + " _PackageSetting_" + strSectionName + "_DarkChippedOffArea", m_fDarkChippedOffArea);
            objFile.WriteElementValue(strVisionName + " _PackageSetting_" + strSectionName + "_DarkVerticalCrack", m_fDarkVerticalCrack);
            objFile.WriteElementValue(strVisionName + " _PackageSetting_" + strSectionName + "_DarkHorizontalCrack", m_fDarkHorizontalCrack);
            objFile.WriteElementValue(strVisionName + " _PackageSetting_" + strSectionName + "_BrightVerticalForeignMaterial", m_fBrightVerticalForeignMaterial);
            objFile.WriteElementValue(strVisionName + " _PackageSetting_" + strSectionName + "_BrightHorizontalForeignMaterial", m_fBrightHorizontalForeignMaterial);

            objFile.WriteElementValue(strVisionName + " _PackageSetting_" + strSectionName + "_MPErodeHalfWidth", m_intMPErodeHalfWidth);
            objFile.WriteElementValue(strVisionName + " _PackageSetting_" + strSectionName + "_MPDilateHalfWidth", m_intMPDilateHalfWidth);

            objFile.WriteElementValue(strVisionName + "_" + strSectionName + "_GoldenDataSetCount", m_arrGoldenData.Count);

            for (int i = 0; i < 3; i++)
            {
                if (m_arrGoldenData.Count > i)
                {
                    //objFile.WriteElementValue(strVisionName + "_" + strSectionName + "_GoldenDataSet" + i.ToString(), "");

                    objFile.WriteElementValue(strVisionName + "_" + strSectionName + "_GoldenDataSet" + i.ToString() + "_GoldenDataUsed", m_arrGoldenDataUsed[i]);
                    objFile.WriteElementValue(strVisionName + "_" + strSectionName + "_GoldenDataSet" + i.ToString() + "_GoldenDataCount", m_arrGoldenData[i].Count);

                    for (int j = 0; j < 5; j++)
                    {
                        if (m_arrGoldenData[i].Count > j)
                        {
                            if (m_arrGoldenData[i][j].Count > 0)
                                objFile.WriteElementValue(strVisionName + "_" + strSectionName + "_GoldenDataSet" + i.ToString() + "_Width" + j.ToString(), m_arrGoldenData[i][j][0]);
                            if (m_arrGoldenData[i][j].Count > 1)
                                objFile.WriteElementValue(strVisionName + "_" + strSectionName + "_GoldenDataSet" + i.ToString() + "_Length" + j.ToString(), m_arrGoldenData[i][j][1]);
                            if (m_arrGoldenData[i][j].Count > 2)
                                objFile.WriteElementValue(strVisionName + "_" + strSectionName + "_GoldenDataSet" + i.ToString() + "_Pitch" + j.ToString(), m_arrGoldenData[i][j][2]);
                            if (m_arrGoldenData[i][j].Count > 3)
                                objFile.WriteElementValue(strVisionName + "_" + strSectionName + "_GoldenDataSet" + i.ToString() + "_Gap" + j.ToString(), m_arrGoldenData[i][j][3]);
                        }
                        else
                        {
                            if (!blnSECSGEMFileExist)
                            {
                                //if (m_arrGoldenData[i][j].Count > 0)
                                objFile.WriteElementValue(strVisionName + "_" + strSectionName + "_GoldenDataSet" + i.ToString() + "_Width" + j.ToString(), "NA");
                                //if (m_arrGoldenData[i][j].Count > 1)
                                objFile.WriteElementValue(strVisionName + "_" + strSectionName + "_GoldenDataSet" + i.ToString() + "_Length" + j.ToString(), "NA");
                                //if (m_arrGoldenData[i][j].Count > 2)
                                objFile.WriteElementValue(strVisionName + "_" + strSectionName + "_GoldenDataSet" + i.ToString() + "_Pitch" + j.ToString(), "NA");
                                //if (m_arrGoldenData[i][j].Count > 3)
                                objFile.WriteElementValue(strVisionName + "_" + strSectionName + "_GoldenDataSet" + i.ToString() + "_Gap" + j.ToString(), "NA");
                            }
                        }
                    }
                }
                else
                {
                    if (!blnSECSGEMFileExist)
                    {
                        objFile.WriteElementValue(strVisionName + "_" + strSectionName + "_GoldenDataSet" + i.ToString() + "_GoldenDataUsed", "NA");
                        objFile.WriteElementValue(strVisionName + "_" + strSectionName + "_GoldenDataSet" + i.ToString() + "_GoldenDataCount", "NA");

                        for (int j = 0; j < 5; j++)
                        {
                            //if (m_arrGoldenData[i][j].Count > 0)
                            objFile.WriteElementValue(strVisionName + "_" + strSectionName + "_GoldenDataSet" + i.ToString() + "_Width" + j.ToString(), "NA");
                            //if (m_arrGoldenData[i][j].Count > 1)
                            objFile.WriteElementValue(strVisionName + "_" + strSectionName + "_GoldenDataSet" + i.ToString() + "_Length" + j.ToString(), "NA");
                            //if (m_arrGoldenData[i][j].Count > 2)
                            objFile.WriteElementValue(strVisionName + "_" + strSectionName + "_GoldenDataSet" + i.ToString() + "_Pitch" + j.ToString(), "NA");
                            //if (m_arrGoldenData[i][j].Count > 3)
                            objFile.WriteElementValue(strVisionName + "_" + strSectionName + "_GoldenDataSet" + i.ToString() + "_Gap" + j.ToString(), "NA");
                        }
                    }
                }
            }

            objFile.WriteEndElement();
        }
        public void SavePadGoldenData(string strPath, bool blnNewFile, string strSectionName, bool blnNewSection)
        {
            XmlParser objFile = new XmlParser(strPath, blnNewFile);

            objFile.WriteSectionElement(strSectionName, blnNewSection);

            objFile.WriteElement1Value("GoldenDataSetCount", m_arrGoldenData.Count);

            for (int i = 0; i < m_arrGoldenData.Count; i++)
            {
                objFile.WriteElement1Value("GoldenDataSet" + i.ToString(), "");

                objFile.WriteElement2Value("GoldenDataUsed", m_arrGoldenDataUsed[i]);
                objFile.WriteElement2Value("GoldenDataCount", m_arrGoldenData[i].Count);

                for (int j = 0; j < m_arrGoldenData[i].Count; j++)
                {
                    if (m_arrGoldenData[i][j].Count > 0)
                        objFile.WriteElement2Value("Width" + j.ToString(), m_arrGoldenData[i][j][0]);
                    if (m_arrGoldenData[i][j].Count > 1)
                        objFile.WriteElement2Value("Length" + j.ToString(), m_arrGoldenData[i][j][1]);
                    if (m_arrGoldenData[i][j].Count > 2)
                        objFile.WriteElement2Value("Pitch" + j.ToString(), m_arrGoldenData[i][j][2]);
                    if (m_arrGoldenData[i][j].Count > 3)
                        objFile.WriteElement2Value("Gap" + j.ToString(), m_arrGoldenData[i][j][3]);
                }
            }

            objFile.WriteEndElement();
        }

        public void SavePadTemplateImage(string strFolderPath, ImageDrawing objLearnRotatedImage, List<ROI> arrPadROIs, int intPadIndex, ImageDrawing ImgWhiteImage, ImageDrawing ImgBlackImage)
        {
            /*
            * arrPadROI[0] = Search ROI
            * arrPadROI[1] = Unit ROI (No use gauge) / Gauge ROI (Use gauge)
            * arrPadROI[2] = Package ROI (Same as package size)
            * arrPadROI[3] = Pad ROI (Same as package size + PadROISizeTolerance)
            */

            // Save Template Pad ROI Image
            arrPadROIs[3].SaveImage(strFolderPath + "UnitToleranceTemplate" + intPadIndex + ".bmp");

            // Save Template Unit Image
            arrPadROIs[2].SaveImage(strFolderPath + "UnitTemplate" + intPadIndex + ".bmp");

            //2020-09-23 ZJYEOH : Save Center Location for position reference point when no use gauge
            m_fUnitMatcherTemplateCenterX = arrPadROIs[1].ref_ROITotalCenterX;
            m_fUnitMatcherTemplateCenterY = arrPadROIs[1].ref_ROITotalCenterY;

            // Save Template Search ROI Image
            arrPadROIs[0].SaveImage(strFolderPath + "SearchROITemplate" + intPadIndex + ".bmp");

            // ---------------------- Save Image for package inspection used ----------------------------------------------------------------------------------------------------

            // Copy learn image to a temporary image memory so that the temporary image can be modified without bother the
            ImageDrawing objImage = new ImageDrawing();
            objLearnRotatedImage.CopyTo(ref objImage);
            ROI objTempROI = new ROI();
            objTempROI.LoadROISetting(
            arrPadROIs[0].ref_ROITotalX,
            arrPadROIs[0].ref_ROITotalY,
            arrPadROIs[0].ref_ROIWidth,
            arrPadROIs[0].ref_ROIHeight);
            objTempROI.AttachImage(objImage);

            //SavePadIndividualImage(strFolderPath, objLearnRotatedImage, arrPadROIs, intPadIndex);

            if (m_intSavePadTemplateImageMethod == 0)
                SavePadIndividualImage_WithCleanBackground_ContourMethod(strFolderPath, objLearnRotatedImage, arrPadROIs, intPadIndex, ImgWhiteImage);
            else
                SavePadIndividualImage_WithCleanBackground_BlobMethod(strFolderPath, objLearnRotatedImage, arrPadROIs, intPadIndex, ImgWhiteImage, ImgBlackImage);
 
            SaveUnitPattern(arrPadROIs[3], strFolderPath, intPadIndex); // Pad ROI index 2 is unit roi, index 1 is gauge roi

            objTempROI.Dispose();
            objImage.Dispose();
        }

        public void SavePadPackageTemplateImage(string strFolderPath, ImageDrawing objLearnRotatedImage, List<ROI> arrPadROIs, int intPadIndex)
        {
            ROI objUnitTemplateROI = new ROI();

            objUnitTemplateROI.AttachImage(objLearnRotatedImage);

            objUnitTemplateROI.LoadROISetting(
                arrPadROIs[2].ref_ROITotalX, arrPadROIs[2].ref_ROITotalY,
                arrPadROIs[2].ref_ROIWidth, arrPadROIs[2].ref_ROIHeight);

            // Save Template Unit Image
            arrPadROIs[2].SaveImage(strFolderPath + "UnitPackageTemplate" + intPadIndex + ".bmp");

            // ---------------------- Save Image for package inspection used ----------------------------------------------------------------------------------------------------

            // Copy learn image to a temporary image memory so that the temporary image can be modified without bother the
            ImageDrawing objImage = new ImageDrawing();
            objLearnRotatedImage.CopyTo(ref objImage);
            ROI objTempROI = new ROI();
            objTempROI.LoadROISetting(
            arrPadROIs[0].ref_ROITotalX,
            arrPadROIs[0].ref_ROITotalY,
            arrPadROIs[0].ref_ROIWidth,
            arrPadROIs[0].ref_ROIHeight);
            objTempROI.AttachImage(objImage);

            //Save Erode Image
            ImageDrawing.ErodeImage(arrPadROIs[0], ref objTempROI, 2);
            objUnitTemplateROI.AttachImage(objImage);
            objUnitTemplateROI.SaveImage(strFolderPath + "PkgImage" + intPadIndex + "_0.bmp");

            //Save Dilate Image
            ImageDrawing.DilateImage(arrPadROIs[0], ref objTempROI, 2);

            objUnitTemplateROI.SaveImage(strFolderPath + "PkgImage" + intPadIndex + "_1.bmp");

            //SaveUnitPattern(arrPadROIs[2], strFolderPath, intPadIndex); // Pad ROI index 2 is unit roi, index 1 is gauge roi

            objUnitTemplateROI.Dispose();
            objTempROI.Dispose();
            objImage.Dispose();
        }

        public void SaveUnitPattern(ROI objUnitROI, string strFolderPath, int intPadIndex)
        {

            if (objUnitROI.ref_ROIWidth == 0 || objUnitROI.ref_ROIHeight == 0)
                return;

            try
            {
#if (Debug_2_12 || Release_2_12)
                m_objMatcher.AdvancedLearning = false; // 2020-09-23 ZJYEOH : If set to true when MIN MAX angle both are same sign(++/--) then will have error
#endif
                m_objMatcher.DontCareThreshold = 1;
                m_objMatcher.LearnPattern(objUnitROI.ref_ROI);

            }
            catch
            {
                try
                {
                    m_objMatcher.MinReducedArea = 128;
#if (Debug_2_12 || Release_2_12)
                    m_objMatcher.AdvancedLearning = false; // 2020-09-23 ZJYEOH : If set to true when MIN MAX angle both are same sign(++/--) then will have error
#endif
                    m_objMatcher.DontCareThreshold = 1;
                    m_objMatcher.LearnPattern(objUnitROI.ref_ROI);

                }
                catch (Exception ex)
                {
                    SRMMessageBox.Show("Pad > SaveUnitPattern > Exception = " + ex.ToString());
                }
            }

            m_objMatcher.Save(strFolderPath + "UnitMatcher" + intPadIndex.ToString() + ".mch");
        }

        public void LoadUnitPattern(string strPath)
        {
            try
            {
                if (File.Exists(strPath))
                    m_objMatcher.Load(strPath);
            }
            catch (Exception ex)
            {
                //SRMMessageBox.Show("[Recipe is corrupted. Pad > LoadUnitPattern > Exception = " + ex.ToString());
                STTrackLog.WriteLine("Pad > LoadUnitPattern > Exception = " + ex.ToString());
            }
        }
        public void SaveTiltAnglePkgImage(string strFolderPath, ImageDrawing objLearnRotatedImage, List<ROI> arrPadROIs, int intPadIndex, int Angle, int j)
        {
            ImageDrawing objUnitImage = new ImageDrawing(true, objLearnRotatedImage.ref_intImageWidth, objLearnRotatedImage.ref_intImageHeight);

            ROI objMaxTiltROI = new ROI();
            int intStartX = 0;
            int intStartY = 0;
            int intEndX = 0;
            int intEndY = 0;
            EBW8 px = new EBW8();
            px.Value = 255; // White color pixel value

            objMaxTiltROI.AttachImage(objUnitImage);
            objMaxTiltROI.LoadROISetting(
                                0, 0,
                                objUnitImage.ref_intImageWidth,
                                (int)(objUnitImage.ref_intImageWidth * Math.Tan(Angle * Math.PI / 180)));

            EasyImage.GainOffset(objMaxTiltROI.ref_ROI, objMaxTiltROI.ref_ROI, 1f, -255f);
            string strPosition = "";
            if (j == 0)  // top Pad (LEft) 
            {
                strPosition = "Top_L";
                if (Angle > 0)
                {
                    objUnitImage.LoadImage(AppDomain.CurrentDomain.BaseDirectory + "Misc//Black.bmp");
                    intStartX = Math.Min((int)(objUnitImage.ref_intImageHeight * Math.Tan(Angle * Math.PI / 180)), 999);
                    intStartY = 0;
                    intEndX = 0;
                    intEndY = objUnitImage.ref_intImageHeight;

                    for (int x = intStartX; x >= intEndX; x--)
                    {
                        for (int y = intStartY; y < intEndY; y++)
                        {

                            int Cx = ((int)(y * Math.Tan((Angle) * Math.PI / 180)));

                            if ((Cx >= x))
                                objUnitImage.ref_objMainImage.SetPixel(px, x, y);
                        }
                    }
                }
            }
            else if (j == 1) // Top Pad (Right)
            {
                strPosition = "Top_R";
                if (Angle > 0)
                {
                    objUnitImage.LoadImage(AppDomain.CurrentDomain.BaseDirectory + "Misc//Black.bmp");
                    intStartX = objUnitImage.ref_intImageWidth;
                    intStartY = 0;
                    intEndX = objUnitImage.ref_intImageWidth - Math.Min((int)(objUnitImage.ref_intImageHeight * Math.Tan(Angle * Math.PI / 180)), 999);
                    intEndY = objUnitImage.ref_intImageHeight;

                    for (int x = intStartX - 1; x >= intEndX; x--)
                    {
                        for (int y = intStartY; y < intEndY; y++)
                        {

                            int Cx = intStartX - ((int)(y * Math.Tan((Angle) * Math.PI / 180)));

                            if ((Cx <= x))
                                objUnitImage.ref_objMainImage.SetPixel(px, x, y);
                        }
                    }
                }
            }
            else if (j == 2)// Right Pad (Top)
            {
                strPosition = "Right_T";
                if (Angle > 0)
                {
                    objUnitImage.LoadImage(AppDomain.CurrentDomain.BaseDirectory + "Misc//Black.bmp");
                    intStartX = 0;
                    intStartY = 0;
                    intEndX = objUnitImage.ref_intImageWidth;
                    intEndY = Math.Min((int)(objUnitImage.ref_intImageWidth * Math.Tan(Angle * Math.PI / 180)), 999);

                    for (int x = intStartX; x < intEndX; x++)
                    {
                        for (int y = intStartY; y < intEndY; y++)
                        {
                            int Cy = intEndY - ((int)(x * Math.Tan(Angle * Math.PI / 180)));
                            if ((Cy >= y))
                                objUnitImage.ref_objMainImage.SetPixel(px, x, y);
                        }
                    }
                }
            }
            else if (j == 3) // Right Pad (Bottom)
            {
                strPosition = "Right_B";
                if (Angle > 0)
                {
                    objUnitImage.LoadImage(AppDomain.CurrentDomain.BaseDirectory + "Misc//Black.bmp");
                    intStartX = 0;
                    intStartY = objUnitImage.ref_intImageHeight - Math.Min((int)(objUnitImage.ref_intImageWidth * Math.Tan(Angle * Math.PI / 180)), 999);
                    intEndX = objUnitImage.ref_intImageWidth;
                    intEndY = objUnitImage.ref_intImageHeight;

                    for (int x = intStartX; x < intEndX; x++)
                    {
                        for (int y = intStartY; y < intEndY; y++)
                        {
                            int Cy = intStartY + ((int)(x * Math.Tan(Angle * Math.PI / 180)));
                            if ((Cy <= y))
                                objUnitImage.ref_objMainImage.SetPixel(px, x, y);
                        }
                    }
                }
            }

            else if (j == 4)  // bottom Pad (Right) 
            {
                strPosition = "Bottom_R";
                if (Angle > 0)
                {
                    objUnitImage.LoadImage(AppDomain.CurrentDomain.BaseDirectory + "Misc//Black.bmp");
                    intStartX = objUnitImage.ref_intImageWidth - Math.Min((int)(objUnitImage.ref_intImageHeight * Math.Tan(Angle * Math.PI / 180)), 999);
                    intStartY = objUnitImage.ref_intImageHeight;
                    intEndX = objUnitImage.ref_intImageWidth;
                    intEndY = 0;

                    for (int x = intStartX; x < intEndX; x++)
                    {
                        for (int y = intStartY - 1; y >= intEndY; y--)
                        {

                            int Cx = intStartX + ((int)(y * Math.Tan((Angle) * Math.PI / 180)));

                            if ((Cx <= x))
                                objUnitImage.ref_objMainImage.SetPixel(px, x, y);
                        }
                    }
                }
            }
            else if (j == 5)  // Bottom Pad (Left) 
            {
                strPosition = "Bottom_L";
                if (Angle > 0)
                {
                    objUnitImage.LoadImage(AppDomain.CurrentDomain.BaseDirectory + "Misc//Black.bmp");
                    intStartX = Math.Min((int)(objUnitImage.ref_intImageHeight * Math.Tan(Angle * Math.PI / 180)), 999);
                    intStartY = 0;
                    intEndX = 0;
                    intEndY = objUnitImage.ref_intImageHeight;

                    for (int x = intStartX; x >= intEndX; x--)
                    {
                        for (int y = intStartY; y < intEndY; y++)
                        {

                            int Cx = intStartX - ((int)(y * Math.Tan((Angle) * Math.PI / 180)));

                            if ((Cx >= x))
                                objUnitImage.ref_objMainImage.SetPixel(px, x, y);
                        }
                    }
                }
            }
            else if (j == 6) // Left Pad (Bottom)
            {
                strPosition = "Left_B";
                if (Angle > 0)
                {
                    objUnitImage.LoadImage(AppDomain.CurrentDomain.BaseDirectory + "Misc//Black.bmp");
                    intStartX = 0;
                    intStartY = objUnitImage.ref_intImageHeight;
                    intEndX = objUnitImage.ref_intImageWidth;
                    intEndY = objUnitImage.ref_intImageHeight - Math.Min((int)(objUnitImage.ref_intImageWidth * Math.Tan(Angle * Math.PI / 180)), 999);

                    for (int x = intStartX; x < intEndX; x++)
                    {
                        for (int y = intStartY - 1; y >= intEndY; y--)
                        {
                            int Cy = intStartY - ((int)(x * Math.Tan(Angle * Math.PI / 180)));
                            if ((Cy <= y))
                                objUnitImage.ref_objMainImage.SetPixel(px, x, y);
                        }
                    }
                }
            }
            else if (j == 7) // Left Pad (Top)
            {
                strPosition = "Left_T";
                if (Angle > 0)
                {
                    objUnitImage.LoadImage(AppDomain.CurrentDomain.BaseDirectory + "Misc//Black.bmp");
                    intStartX = 0;
                    intStartY = 0;
                    intEndX = objUnitImage.ref_intImageWidth;
                    intEndY = Math.Min((int)(objUnitImage.ref_intImageWidth * Math.Tan(Angle * Math.PI / 180)), 999);

                    for (int x = intStartX; x < intEndX; x++)
                    {
                        for (int y = intStartY; y < intEndY; y++)
                        {
                            int Cy = ((int)(x * Math.Tan(Angle * Math.PI / 180)));
                            if ((Cy >= y))
                                objUnitImage.ref_objMainImage.SetPixel(px, x, y);
                        }
                    }
                }
            }

            if (Angle == 0)
            {
                // Clear all previous template image 
                if (File.Exists(strFolderPath + "Tilt_" + strPosition + ".bmp"))
                {
                    File.Delete(strFolderPath + "Tilt_" + strPosition + ".bmp");
                }

                if (File.Exists(strFolderPath + "TiltInverted_" + strPosition + ".bmp"))
                {
                    File.Delete(strFolderPath + "TiltInverted_" + strPosition + ".bmp");
                }
            }
            else
            {
                objUnitImage.SaveImage(strFolderPath + "Tilt_" + strPosition + ".bmp");
                EasyImage.Oper(EArithmeticLogicOperation.Invert, objUnitImage.ref_objMainImage, objUnitImage.ref_objMainImage);
                objUnitImage.SaveImage(strFolderPath + "TiltInverted_" + strPosition + ".bmp");
                
                //2021-02-08 ZJYEOH : Load image right after save because will use it during learning
                if (File.Exists(strFolderPath + "Tilt_" + strPosition + ".bmp") && strPosition == "Top_L")
                    m_ImgTilt_Top_L.LoadImage(strFolderPath + "Tilt_" + strPosition + ".bmp");
                if (File.Exists(strFolderPath + "Tilt_" + strPosition + ".bmp") && strPosition == "Top_R")
                    m_ImgTilt_Top_R.LoadImage(strFolderPath + "Tilt_" + strPosition + ".bmp");
                if (File.Exists(strFolderPath + "Tilt_" + strPosition + ".bmp") && strPosition == "Right_T")
                    m_ImgTilt_Right_T.LoadImage(strFolderPath + "Tilt_" + strPosition + ".bmp");
                if (File.Exists(strFolderPath + "Tilt_" + strPosition + ".bmp") && strPosition == "Right_B")
                    m_ImgTilt_Right_B.LoadImage(strFolderPath + "Tilt_" + strPosition + ".bmp");
                if (File.Exists(strFolderPath + "Tilt_" + strPosition + ".bmp") && strPosition == "Bottom_R")
                    m_ImgTilt_Bottom_R.LoadImage(strFolderPath + "Tilt_" + strPosition + ".bmp");
                if (File.Exists(strFolderPath + "Tilt_" + strPosition + ".bmp") && strPosition == "Bottom_L")
                    m_ImgTilt_Bottom_L.LoadImage(strFolderPath + "Tilt_" + strPosition + ".bmp");
                if (File.Exists(strFolderPath + "Tilt_" + strPosition + ".bmp") && strPosition == "Left_B")
                    m_ImgTilt_Left_B.LoadImage(strFolderPath + "Tilt_" + strPosition + ".bmp");
                if (File.Exists(strFolderPath + "Tilt_" + strPosition + ".bmp") && strPosition == "Left_T")
                    m_ImgTilt_Left_T.LoadImage(strFolderPath + "Tilt_" + strPosition + ".bmp");

                if (File.Exists(strFolderPath + "TiltInverted_" + strPosition + ".bmp") && strPosition == "Top_L")
                    m_ImgTiltInverted_Top_L.LoadImage(strFolderPath + "TiltInverted_" + strPosition + ".bmp");
                if (File.Exists(strFolderPath + "TiltInverted_" + strPosition + ".bmp") && strPosition == "Top_R")
                    m_ImgTiltInverted_Top_R.LoadImage(strFolderPath + "TiltInverted_" + strPosition + ".bmp");
                if (File.Exists(strFolderPath + "TiltInverted_" + strPosition + ".bmp") && strPosition == "Right_T")
                    m_ImgTiltInverted_Right_T.LoadImage(strFolderPath + "TiltInverted_" + strPosition + ".bmp");
                if (File.Exists(strFolderPath + "TiltInverted_" + strPosition + ".bmp") && strPosition == "Right_B")
                    m_ImgTiltInverted_Right_B.LoadImage(strFolderPath + "TiltInverted_" + strPosition + ".bmp");
                if (File.Exists(strFolderPath + "TiltInverted_" + strPosition + ".bmp") && strPosition == "Bottom_R")
                    m_ImgTiltInverted_Bottom_R.LoadImage(strFolderPath + "TiltInverted_" + strPosition + ".bmp");
                if (File.Exists(strFolderPath + "TiltInverted_" + strPosition + ".bmp") && strPosition == "Bottom_L")
                    m_ImgTiltInverted_Bottom_L.LoadImage(strFolderPath + "TiltInverted_" + strPosition + ".bmp");
                if (File.Exists(strFolderPath + "TiltInverted_" + strPosition + ".bmp") && strPosition == "Left_B")
                    m_ImgTiltInverted_Left_B.LoadImage(strFolderPath + "TiltInverted_" + strPosition + ".bmp");
                if (File.Exists(strFolderPath + "TiltInverted_" + strPosition + ".bmp") && strPosition == "Left_T")
                    m_ImgTiltInverted_Left_T.LoadImage(strFolderPath + "TiltInverted_" + strPosition + ".bmp");

            }
            objMaxTiltROI.Dispose();
            objUnitImage.Dispose();
        }
        private void SavePadIndividualImage(string strFolderPath, ImageDrawing objLearnRotatedImage, List<ROI> arrPadROIs, int intPadIndex)
        {

            int intBlobsCount = GetBlobsFeaturesNumber();   // Get number of pad

            if (intBlobsCount <= 0)
                return;

            // Clear all previous template pad individual image 
            string[] strFileList = Directory.GetFiles(strFolderPath, "Pad" + intPadIndex.ToString() + "_*.bmp");
            foreach (string strFile in strFileList)
            {
                if (File.Exists(strFile))
                {
                    File.Delete(strFile);
                }
            }

            ImageDrawing objUnitImage = new ImageDrawing(true);
            ROI objUnitROI = new ROI();
            int intBlobStartX = 0;
            int intBlobStartY = 0;
            int intBlobEndX = 0;
            int intBlobEndY = 0;
            EBW8 px = new EBW8();
            px.Value = 255; // White color pixel value

            List<List<int>> arrElementX = new List<List<int>>();
            List<List<int>> arrElementY = new List<List<int>>();
            for (int intBlobIndex = 0; intBlobIndex < intBlobsCount; intBlobIndex++)
            {
                arrElementX.Add(new List<int>());
                arrElementY.Add(new List<int>());

                if (intBlobIndex >= m_objTemplateContour.ref_pvContourList.Count)
                    continue;


                EBW8PathVector pv = m_objTemplateContour.ref_pvContourList[intBlobIndex];
                int intNumElements = (int)pv.NumElements;

                for (int i = 0; i < intNumElements; i++)
                {
                    arrElementX[intBlobIndex].Add(pv.GetElement(i).X);
                    arrElementY[intBlobIndex].Add(pv.GetElement(i).Y);
                }
            }

            // Scan other blobs
            for (int j = 0; j < intBlobsCount; j++)
            {
                arrPadROIs[3].CopyToImage(ref objUnitImage);
                objUnitROI.AttachImage(objUnitImage);
                objUnitROI.LoadROISetting(
                                    0, 0,
                                    arrPadROIs[0].ref_ROIWidth,
                                    arrPadROIs[0].ref_ROIHeight);

                EasyImage.GainOffset(objUnitROI.ref_ROI, objUnitROI.ref_ROI, 1f, -255f);

                BlobsFeatures m_stcBlobPad = (BlobsFeatures)m_arrTemplateBlobPads[j];
                intBlobStartX = m_stcBlobPad.intStartX;
                intBlobStartY = m_stcBlobPad.intStartY;
                intBlobEndX = m_stcBlobPad.intEndX;
                intBlobEndY = m_stcBlobPad.intEndY;

                // Scan blobs (rectangle limit size) each pixel
                for (int x = intBlobStartX; x < intBlobEndX; x++)
                {
                    for (int y = intBlobStartY; y < intBlobEndY; y++)
                    {
                        bool blnAboveX1 = false, blnBelowX2 = false, blnAboveY1 = false, blnBelowY2 = false;
                        int intNumElements = arrElementX[j].Count;
                        for (int i = 0; i < intNumElements; i++)
                        {
                            if (x == arrElementX[j][i])
                            {
                                if (y >= arrElementY[j][i])
                                    blnAboveY1 = true;

                                if (y <= arrElementY[j][i])
                                    blnBelowY2 = true;
                            }

                            if (y == arrElementY[j][i])
                            {
                                if (x >= arrElementX[j][i])
                                    blnAboveX1 = true;

                                if (x <= arrElementX[j][i])
                                    blnBelowX2 = true;
                            }
                        }

                        // Make sure the pixel is in the blob contour area
                        if (blnAboveX1 && blnBelowX2 && blnAboveY1 && blnBelowY2)
                        {
                            // change the pixel value to white
                            objUnitImage.ref_objMainImage.SetPixel(px, x, y);

                        }
                    }
                }

                objUnitImage.SaveImage(strFolderPath + "Pad" + intPadIndex + "_" + j.ToString() + ".bmp");
            }
            objUnitROI.Dispose();
            objUnitImage.Dispose();
        }

        private void SavePadIndividualImage_WithCleanBackground_ContourMethod(string strFolderPath, ImageDrawing objLearnRotatedImage, List<ROI> arrPadROIs, int intPadIndex, ImageDrawing ImgWhiteImage)
        {

            int intBlobsCount = GetBlobsFeaturesNumber();   // Get number of pad

            if (intBlobsCount <= 0)
                return;

            // Clear all previous template pad individual image 
            string[] strFileList = Directory.GetFiles(strFolderPath, "Pad" + intPadIndex.ToString() + "_*.bmp");
            foreach (string strFile in strFileList)
            {
                if (File.Exists(strFile))
                {
                    File.Delete(strFile);
                }
            }

            ImageDrawing objUnitImage = new ImageDrawing(true);
            ROI objUnitROI = new ROI();
            int intBlobStartX = 0;
            int intBlobStartY = 0;
            int intBlobEndX = 0;
            int intBlobEndY = 0;
            EBW8 px = new EBW8();
            px.Value = 255; // White color pixel value

            List<List<int>> arrElementX = new List<List<int>>();
            List<List<int>> arrElementY = new List<List<int>>();
            for (int intBlobIndex = 0; intBlobIndex < intBlobsCount; intBlobIndex++)
            {
                arrElementX.Add(new List<int>());
                arrElementY.Add(new List<int>());

                if (intBlobIndex >= m_objTemplateContour.ref_pvContourList.Count)
                    continue;


                EBW8PathVector pv = m_objTemplateContour.ref_pvContourList[intBlobIndex];
                int intNumElements = (int)pv.NumElements;

                for (int i = 0; i < intNumElements; i++)
                {
                    arrElementX[intBlobIndex].Add(pv.GetElement(i).X);
                    arrElementY[intBlobIndex].Add(pv.GetElement(i).Y);
                }
            }

            ImageDrawing ImgCleanBackGround = new ImageDrawing(ImgWhiteImage.ref_intImageWidth, ImgWhiteImage.ref_intImageHeight);
            EasyImage.Copy(ImgWhiteImage.ref_objMainImage, ImgCleanBackGround.ref_objMainImage);
            ROI objCleanBackgroundROI = new ROI();
            objCleanBackgroundROI.AttachImage(ImgCleanBackGround);
            objCleanBackgroundROI.LoadROISetting(
                                    0, 0,
                                    arrPadROIs[3].ref_ROIWidth,
                                    arrPadROIs[3].ref_ROIHeight);
            ROI objCleanBackgroundROI2 = new ROI();
            objCleanBackgroundROI2.LoadROISetting(
                                    0, 0,
                                    arrPadROIs[3].ref_ROIWidth,
                                    arrPadROIs[3].ref_ROIHeight);

            // Scan other blobs
            for (int j = 0; j < intBlobsCount; j++)
            {
                arrPadROIs[3].CopyToImage(ref objUnitImage);
                objUnitROI.AttachImage(objUnitImage);
                objUnitROI.LoadROISetting(
                                    0, 0,
                                    arrPadROIs[0].ref_ROIWidth,
                                    arrPadROIs[0].ref_ROIHeight);

                EasyImage.GainOffset(objUnitROI.ref_ROI, objUnitROI.ref_ROI, 1f, -255f);

                BlobsFeatures m_stcBlobPad = (BlobsFeatures)m_arrTemplateBlobPads[j];
                intBlobStartX = m_stcBlobPad.intStartX;
                intBlobStartY = m_stcBlobPad.intStartY;
                intBlobEndX = m_stcBlobPad.intEndX;
                intBlobEndY = m_stcBlobPad.intEndY;

                // Scan blobs (rectangle limit size) each pixel
                for (int x = intBlobStartX; x < intBlobEndX; x++)
                {
                    for (int y = intBlobStartY; y < intBlobEndY; y++)
                    {
                        bool blnAboveX1 = false, blnBelowX2 = false, blnAboveY1 = false, blnBelowY2 = false;
                        int intNumElements = arrElementX[j].Count;
                        for (int i = 0; i < intNumElements; i++)
                        {
                            if (x == arrElementX[j][i])
                            {
                                if (y >= arrElementY[j][i])
                                    blnAboveY1 = true;

                                if (y <= arrElementY[j][i])
                                    blnBelowY2 = true;
                            }

                            if (y == arrElementY[j][i])
                            {
                                if (x >= arrElementX[j][i])
                                    blnAboveX1 = true;

                                if (x <= arrElementX[j][i])
                                    blnBelowX2 = true;
                            }
                        }

                        // Make sure the pixel is in the blob contour area
                        if (blnAboveX1 && blnBelowX2 && blnAboveY1 && blnBelowY2)
                        {
                            // change the pixel value to white
                            objUnitImage.ref_objMainImage.SetPixel(px, x, y);

                        }
                    }
                }

                objUnitImage.SaveImage(strFolderPath + "Pad" + intPadIndex + "_" + j.ToString() + ".bmp");
                objCleanBackgroundROI2.AttachImage(objUnitImage);
                EasyImage.Oper(EArithmeticLogicOperation.Subtract, objCleanBackgroundROI.ref_ROI, objCleanBackgroundROI2.ref_ROI, objCleanBackgroundROI.ref_ROI);
            }
            objCleanBackgroundROI.SaveImage(strFolderPath + "Pad" + intPadIndex + ".bmp");
            objCleanBackgroundROI2.Dispose();
            ImgCleanBackGround.Dispose();
            objCleanBackgroundROI.Dispose();
            objUnitImage.Dispose();
            objUnitROI.Dispose();
        }
        private void SavePadIndividualImage_WithCleanBackground_BlobMethod(string strFolderPath, ImageDrawing objLearnRotatedImage, List<ROI> arrPadROIs, int intPadIndex, ImageDrawing ImgWhiteImage, ImageDrawing ImgBlackImage)
        {

            int intBlobsCount = GetBlobsFeaturesNumber();   // Get number of pad

            if (intBlobsCount <= 0)
                return;

            // Clear all previous template pad individual image 
            string[] strFileList = Directory.GetFiles(strFolderPath, "Pad" + intPadIndex.ToString() + "_*.bmp");
            foreach (string strFile in strFileList)
            {
                if (File.Exists(strFile))
                {
                    File.Delete(strFile);
                }
            }

            List<float> arrBlobStartX = new List<float>();
            List<float> arrBlobStartY = new List<float>();
            List<float> arrBlobEndX = new List<float>();
            List<float> arrBlobEndY = new List<float>();
            List<int> arrLengthMode = new List<int>();
            List<int> arrObjectNo = new List<int>();
            // Scan other blobs
            for (int j = 0; j < intBlobsCount; j++)
            {
                BlobsFeatures m_stcBlobPad = (BlobsFeatures)m_arrTemplateBlobPads[j];
                arrBlobStartX.Add(m_stcBlobPad.fStartX);
                arrBlobStartY.Add(m_stcBlobPad.fStartY);
                arrBlobEndX.Add(m_stcBlobPad.fEndX);
                arrBlobEndY.Add(m_stcBlobPad.fEndY);
                arrLengthMode.Add(m_stcBlobPad.intLengthMode);
                arrObjectNo.Add(m_stcBlobPad.intObjNo);
            }
            m_objEBlobs.SaveLearnIndividualBlobsImage(arrPadROIs[3], arrBlobStartX, arrBlobStartY, arrBlobEndX, arrBlobEndY, strFolderPath + "Pad" + intPadIndex, arrLengthMode, arrObjectNo, ImgWhiteImage, ImgBlackImage);
        }
        public bool FindUnitUsingPRS(ROI objSearchROI, int intAngleTolerance, bool blnFastMode)
        {
            /*
             * Accuracy is not good when FastMode is true
             */

            if (!m_objMatcher.PatternLearnt)
            {
                m_strErrorMessage += "No Pattern Learnt.";
                return false;
            }

            m_objMatcher.MinAngle = -intAngleTolerance;
            m_objMatcher.MaxAngle = intAngleTolerance;

            m_objMatcher.MaxPositions = 1;
            if (blnFastMode)
                m_objMatcher.FinalReduction = 2;
            else
                m_objMatcher.FinalReduction = 1;
            m_objMatcher.Interpolate = true;

            m_objMatcher.Match(objSearchROI.ref_ROI);

            if (m_objMatcher.NumPositions > 0)     // if macthing result hit the min score, its position will be 1 or more
            {
                if (m_objMatcher.GetPosition(0).Score < 0.5)
                {
                    m_strErrorMessage += "Unit Pattern Matching Fail.";
                    return false;
                }

                m_pUnitCenterPoint = new PointF(objSearchROI.ref_ROITotalX + m_objMatcher.GetPosition(0).CenterX,
                                                objSearchROI.ref_ROITotalY + m_objMatcher.GetPosition(0).CenterY);

                m_fUnitAngle = m_objMatcher.GetPosition(0).Angle;
                return true;
            }
            else
            {
                m_strErrorMessage += "Unit Pattern Matching Fail."; 
                return false;
            }
        }
        public bool FindUnitUsingPRS_SideROI(ROI objSearchROI, int intLearnPadROICenterX, int intLearnPadROICenterY, int intAngleTolerance, bool blnFastMode)
        {
            /*
             * Accuracy is not good when FastMode is true
             */

            if (!m_objMatcher.PatternLearnt)
            {
                m_strErrorMessage += "No Pattern Learnt.";
                return false;
            }

            m_objMatcher.MinAngle = -intAngleTolerance;
            m_objMatcher.MaxAngle = intAngleTolerance;

            m_objMatcher.MaxPositions = 1;
            if (blnFastMode)
                m_objMatcher.FinalReduction = 2;
            else
                m_objMatcher.FinalReduction = 1;
            m_objMatcher.Interpolate = true;

            m_objMatcher.Match(objSearchROI.ref_ROI);

            if (m_objMatcher.NumPositions > 0)     // if macthing result hit the min score, its position will be 1 or more
            {
                if (m_objMatcher.GetPosition(0).Score < 0.5)
                {
                    //if (m_intPadROIDirection == 4)
                    //{
                    //    STTrackLog.WriteLine("F =" + intLearnPadROICenterX.ToString() + ", " + intLearnPadROICenterY.ToString() + ", " + m_fUnitAngle.ToString());
                    //}

                    // 2021 07 23 - CCENG: If score fail, then direct use Pad ROI Center Position.
                    //            - Pad ROI will fail sometime due to user learn side surface with empty pad.
                    m_pUnitCenterPoint = new PointF(intLearnPadROICenterX, intLearnPadROICenterY);
                    m_fUnitAngle = 0;
                    return true;
                    //m_strErrorMessage += "Unit Pattern Matching Fail.";
                    //return false;
                }

                //if (m_intPadROIDirection == 4)
                //{
                //    STTrackLog.WriteLine("P =" + intLearnPadROICenterX.ToString() + ", " + intLearnPadROICenterY.ToString() + ", " + m_fUnitAngle.ToString());
                //}

                m_pUnitCenterPoint = new PointF(objSearchROI.ref_ROITotalX + m_objMatcher.GetPosition(0).CenterX,
                                                objSearchROI.ref_ROITotalY + m_objMatcher.GetPosition(0).CenterY);

                m_fUnitAngle = m_objMatcher.GetPosition(0).Angle;
                return true;
            }
            else
            {
                m_strErrorMessage += "Unit Pattern Matching Fail.";
                return false;
            }
        }

        private bool IsPixelInBlobContourArea(int intBlobIndex, int intPixelX, int intPixelY)
        {
            if (intBlobIndex >= m_objTemplateContour.ref_pvContourList.Count)
                return false;


            EBW8PathVector pv = m_objTemplateContour.ref_pvContourList[intBlobIndex];
            int intNumElements = (int)pv.NumElements;

            bool blnAboveX1 = false, blnBelowX2 = false, blnAboveY1 = false, blnBelowY2 = false;
            for (int i = 0; i < intNumElements; i++)
            {
                if (intPixelX == pv.GetElement(i).X)
                {
                    if (intPixelY >= pv.GetElement(i).Y)
                        blnAboveY1 = true;

                    if (intPixelY <= pv.GetElement(i).Y)
                        blnBelowY2 = true;
                }

                if (intPixelY == pv.GetElement(i).Y)
                {
                    if (intPixelX >= pv.GetElement(i).X)
                        blnAboveX1 = true;

                    if (intPixelX <= pv.GetElement(i).X)
                        blnBelowX2 = true;
                }
            }

            return (blnAboveX1 && blnBelowX2 && blnAboveY1 && blnBelowY2);
        }

        public void SaveAdvancePad(string strPath, string strSectionName)
        {
            SavePad(strPath, false, strSectionName, true);

            //XmlParser objFile = new XmlParser(strPath, false);

            //objFile.WriteSectionElement(strSectionName, true);

            //objFile.WriteElement1Value("PadSetting", "", "", true);
            //objFile.WriteElement2Value("WhiteOnBlack", m_blnWhiteOnBlack);
            //objFile.WriteElement2Value("DefaultPixelTolerance", m_fDefaultPixelTolerance);
            //objFile.WriteElement2Value("GaugeSizeImageIndex", m_intGaugeSizeImageIndex);

            //objFile.WriteEndElement();
        }
        private void ClearColorDefect()
        {
            m_arrDefectColorThresName.Clear();
            m_arrDefectColorSystem.Clear();
            m_arrDefectCloseIteration.Clear();
            m_arrDefectInvertBlackWhite.Clear();
            m_arrDefectColor.Clear();
            m_arrDefectColorTolerance.Clear();
            m_arrDefectColorMinArea.Clear();
            m_arrDefectType.Clear();
            m_arrDefectImageNo.Clear();
            m_arrDefectDontCareMode.Clear();
            m_arrDefectColorInspection_Top.Clear();
            m_arrDefectColorInspection_Right.Clear();
            m_arrDefectColorInspection_Bottom.Clear();
            m_arrDefectColorInspection_Left.Clear();

        }
        public void LoadPad(string strPath, string strSectionName)
        {
            XmlParser objFile = new XmlParser(strPath);

            objFile.GetFirstSection(strSectionName);

            // Load Pad General Setting
            objFile.GetSecondSection("PadSetting");
            m_fUnitMatcherTemplateCenterX = objFile.GetValueAsFloat("UnitMatcherTemplateCenterX", 0, 2);
            m_fUnitMatcherTemplateCenterY = objFile.GetValueAsFloat("UnitMatcherTemplateCenterY", 0, 2);
            m_intOrientDirections = objFile.GetValueAsInt("OrientDirections", 4, 2);
            m_fAngleTolerance = objFile.GetValueAsFloat("AngleTolerance", 2, 2);
            m_fXTolerance = objFile.GetValueAsFloat("XTolerance", 2, 2);
            m_fYTolerance = objFile.GetValueAsFloat("YTolerance", 2, 2);
            m_intThresholdValue = objFile.GetValueAsInt("ThresholdValue", 125, 2);// 2021 04 02 - CCENG: Default use 125 instead of using -4. 
            m_intCopperThresholdValue = objFile.GetValueAsInt("CopperThresholdValue", -4, 2);
            //m_intImageMerge2ThresholdValue = objFile.GetValueAsInt("ImageMerge2ThresholdValue", -4, 2);
            m_intImageMerge2ThresholdHighValue = objFile.GetValueAsInt("ImageMerge2ThresholdHighValue", 255, 2);
            m_intImageMerge2ThresholdLowValue = objFile.GetValueAsInt("ImageMerge2ThresholdLowValue", 0, 2);
            m_intInterPadThresholdValue = objFile.GetValueAsInt("InterPadThresholdValue", -4, 2);
            m_intSurfaceThresholdValue = objFile.GetValueAsInt("SurfaceThresholdValue", m_intThresholdValue, 2);// 2021 04 02 - CCENG: Default same as pad threshold instead of using -4.
            // 2021 04 02 - CCENG: no longer use autothreshold -4 here bcos make user confuse.
            if (m_intSurfaceThresholdValue < 0)
            {
                m_intSurfaceThresholdValue = m_intThresholdValue;
            }
            m_intSurfaceLowThresholdValue = objFile.GetValueAsInt("SurfaceLowThresholdValue", 0, 2);
            m_intFailOptionMask = objFile.GetValueAsInt("FailMask", 0x1FFF, 2); //change default value from 0xFFF to 0x1FFF because Check Foreign Material Total Area use the masking 0x1000
            m_intFailPkgOptionMask = objFile.GetValueAsInt("FailPkgMask", 0xFFF, 2);
            m_blnInspectPackage = objFile.GetValueAsBoolean("WantInspectPackage", false, 2);
            m_blnWhiteOnBlack = objFile.GetValueAsBoolean("WhiteOnBlack", true, 2);
            m_fEmptyMinScore = objFile.GetValueAsFloat("EmptyMinScore", 50, 2);
            m_bUseEmptyUnitThreshold = objFile.GetValueAsBoolean("UseEmtpyUnitThreshold", false, 2);
            m_blnWantGaugeMeasurePkgSize = objFile.GetValueAsBoolean("WantGaugeMeasurePkgSize", false, 2);
            m_blnMeasureCenterPkgSizeUsingSidePkg = objFile.GetValueAsBoolean("MeasureCenterPkgSizeUsingSidePkg", false, 2);
            m_blnUseDetailDefectCriteria = objFile.GetValueAsBoolean("UseDetailDefectCriteria", false, 2);
            m_intEmptyThreshold = objFile.GetValueAsInt("EmptyThreshold", 125, 2);
            m_intEmptyAreaColorTransition = objFile.GetValueAsInt("EmptyAreaColorTransition", 0, 2);
            m_fPadPRSScore = objFile.GetValueAsFloat("PadPRSScore", 50, 2);
            m_fUnitAngleLimit = objFile.GetValueAsFloat("UnitAngleLimit", 5, 2);
            m_fImageGain = objFile.GetValueAsFloat("ImageGain", 1f, 2);
            m_intGaugeSizeImageIndex = objFile.GetValueAsInt("GaugeSizeImageIndex", 0, 2);
            m_intCheckPadDimensionImageIndex = 0; // objFile.GetValueAsInt("CheckPadDimensionImageIndex", 0, 2); // 2020 01 06 - CCENG: Pad Dimension Image index should always 0
            m_intPadROISizeTolerance = objFile.GetValueAsInt("PadROISizeTolerance", 10, 2);
            m_intPadROISizeToleranceADV = objFile.GetValueAsInt("PadROISizeToleranceADV", 10, 2);
            m_intBrokenPadImageViewNo = objFile.GetValueAsInt("BrokenPadImageViewNo", 0, 2);
            m_intSensitivityOnPadMethod = objFile.GetValueAsInt("SensitivityOnPadMethod", 0, 2);
            m_intSensitivityOnPadValue = objFile.GetValueAsInt("SensitivityOnPadValue", 0, 2);
            m_intInspectPadMode = objFile.GetValueAsInt("InspectPadMode", 0, 2);
            m_blnWantTightSetting = objFile.GetValueAsBoolean("WantTightSetting", false, 2);
            m_blnWantConsiderPadImage2 = objFile.GetValueAsBoolean("WantConsiderPadImage2", false, 2);
            m_blnWantPRUnitLocationBeforeGauge = objFile.GetValueAsBoolean("WantPRUnitLocationBeforeGauge", false, 2);
            m_blnWantUseGaugeMeasureDimension = objFile.GetValueAsBoolean("WantUseGaugeMeasureDimension", false, 2);
            m_blnWantUseClosestSizeDefineTolerance = objFile.GetValueAsBoolean("WantUseClosestSizeDefineTolerance", false, 2);
            m_blnWantAutoGauge = objFile.GetValueAsBoolean("WantAutoGauge", false, 2);
            m_blnWantRotateSidePadImage = objFile.GetValueAsBoolean("WantRotateSidePadImage", true, 2); // Set default true bcos this feature is ON before set it as optional in Advance Setting.
            m_blnWantLinkDifferentGroupPitchGap = objFile.GetValueAsBoolean("WantLinkDifferentGroupPitchGap", false, 2);
            m_blnWantShowUseGaugeCheckBox  = objFile.GetValueAsBoolean("WantShowUseGaugeCheckBox", false, 2);
            m_blnWantSeparateBrokenPadThresholdSetting = objFile.GetValueAsBoolean("WantSeparateBrokenPadThresholdSetting", false, 2);
            m_blnWantUseGroupToleranceSetting = objFile.GetValueAsBoolean("WantUseGroupToleranceSetting", false, 2);
            m_blnWantViewCheckForeignMaterialOptionWhenPackageON = objFile.GetValueAsBoolean("WantViewCheckForeignMaterialOptionWhenPackageON", false, 2);
            m_blnWantUseBorderLimitAsOffset = objFile.GetValueAsBoolean("WantUseBorderLimitAsOffset", false, 2);
            m_blnWantIndividualSideThickness = objFile.GetValueAsBoolean("WantIndividualSideThickness", false, 2);

            // Pixel
            m_fFilterMinArea = objFile.GetValueAsFloat("MinArea", 20, 2);
            m_fBlobsMinArea = objFile.GetValueAsFloat("InspectionMinArea", 20, 2);
            m_fImageMerge2BlobsMinArea = objFile.GetValueAsFloat("InspectionImageMerge2MinArea", 20, 2);
            m_fSurfaceMinArea = objFile.GetValueAsFloat("SurfaceMinArea", 20, 2);
            m_fImage2SurfaceMinArea = objFile.GetValueAsFloat("Image2SurfaceMinArea", 20, 2);
            m_fMoldFlashMinArea = objFile.GetValueAsFloat("MoldFlashMinArea", 20, 2);
            m_fVoidMinArea = objFile.GetValueAsFloat("VoidMinArea", 20, 2);
            m_fCrackMinArea = objFile.GetValueAsFloat("CrackMinArea", 20, 2);
            m_intForeignMaterialBrightFieldMinArea = objFile.GetValueAsInt("ForeignMaterialBrightFieldMinArea", 20, 2);
            m_intBrightFieldMinArea = objFile.GetValueAsInt("BrightFieldMinArea", 20, 2);
            m_intDarkFieldMinArea = objFile.GetValueAsInt("DarkFieldMinArea", 20, 2);

            m_intPadWidthLengthMode = objFile.GetValueAsInt("PadWidthLengthMode", 0, 2);
            m_intPadLabelRefCorner = objFile.GetValueAsInt("PadLabelRefCorner", 0, 2);
            m_intPadLabelDirection = objFile.GetValueAsInt("PadLabelDirection", 0, 2);
            m_fPadRangeStartX = objFile.GetValueAsFloat("PadStartX", 0, 2);
            m_fPadRangeStartY = objFile.GetValueAsFloat("PadStartY", 0, 2);
            m_fPadRangeEndX = objFile.GetValueAsFloat("PadEndX", 0, 2);
            m_fPadRangeEndY = objFile.GetValueAsFloat("PadEndY", 0, 2);
            m_fDefaultPixelTolerance = objFile.GetValueAsFloat("DefaultPixelTolerance", 3, 2);
            m_intEmptyAreaLimit = objFile.GetValueAsInt("EmptyAreaLimit", 1000, 2);
            //m_intPadSizeHalfWidthTolerance = objFile.GetValueAsInt("PadSizeHalfWidthTolerance", 3, 2);    // 2019 08 27 - CCENG : No longer use. Replaced by m_intMPErodeHalfWidth and m_intMPDilateHalfWidth
            m_intTightSettingThresholdTolerance = objFile.GetValueAsInt("TightSettingThresholdTolerance", 25, 2);
            // mm            
            m_fPosToleranceX = objFile.GetValueAsFloat("PosToleranceX", 0, 2);
            m_fPosToleranceY = objFile.GetValueAsFloat("PosToleranceY", 0, 2);
            m_fMinSpanX = objFile.GetValueAsFloat("MinSpanX", 0, 2);
            m_fMaxSpanX = objFile.GetValueAsFloat("MaxSpanX", 0, 2);
            m_fMinSpanY = objFile.GetValueAsFloat("MinSpanY", 0, 2);
            m_fMaxSpanY = objFile.GetValueAsFloat("MaxSpanY", 0, 2);
            m_fEdgeDistanceMin_Top = objFile.GetValueAsFloat("EdgeDistanceMin_Top", 0, 2);
            m_fEdgeDistanceMax_Top = objFile.GetValueAsFloat("EdgeDistanceMax_Top", 0, 2);
            m_fEdgeDistanceMin_Right = objFile.GetValueAsFloat("EdgeDistanceMin_Right", 0, 2);
            m_fEdgeDistanceMax_Right = objFile.GetValueAsFloat("EdgeDistanceMax_Right", 0, 2);
            m_fEdgeDistanceMin_Bottom = objFile.GetValueAsFloat("EdgeDistanceMin_Bottom", 0, 2);
            m_fEdgeDistanceMax_Bottom = objFile.GetValueAsFloat("EdgeDistanceMax_Bottom", 0, 2);
            m_fEdgeDistanceMin_Left = objFile.GetValueAsFloat("EdgeDistanceMin_Left", 0, 2);
            m_fEdgeDistanceMax_Left = objFile.GetValueAsFloat("EdgeDistanceMax_Left", 0, 2);
            m_fExtraPadSetArea = objFile.GetValueAsFloat("ExtraPadMinArea", 0.004f, 2);
            m_fTotalExtraPadSetArea = objFile.GetValueAsFloat("TotalExtraPadMinArea", 0.004f, 2);
            m_fExcessPadSetArea = objFile.GetValueAsFloat("ExcessPadMinArea", 0.004f, 2);
            m_fExtraPadSetLength = objFile.GetValueAsFloat("ExtraPadSetLength", 0.001f, 2);
            m_fExcessPadSetLength = objFile.GetValueAsFloat("ExcessPadSetLength", 0.001f, 2);
            m_fSmearLength = objFile.GetValueAsFloat("SmearLength", 0.05f, 2);  // must mm
            m_fTightSettingTolerance = objFile.GetValueAsFloat("TightSettingTolerance", 0.01f, 2);  // must mm

            // 2018 01 07 - JBTAN: Changed the default value to true because m_intFailOptionMask default value is check all
            m_blnWantCheckExtraPadLength = objFile.GetValueAsBoolean("WantCheckExtraPadLength", true, 2);
            m_blnWantCheckExtraPadArea = objFile.GetValueAsBoolean("WantCheckExtraPadArea", true, 2);
            m_blnWantCheckBrokenPadLength = objFile.GetValueAsBoolean("WantCheckBrokenPadLength", true, 2);
            m_blnWantCheckBrokenPadArea = objFile.GetValueAsBoolean("WantCheckBrokenPadArea", true, 2);
            m_blnWantCheckSmearPadLength = objFile.GetValueAsBoolean("WantCheckSmearPadLength", true, 2);
            m_blnWantCheckPadEdgeLimit = objFile.GetValueAsBoolean("WantCheckPadEdgeLimit", true, 2);
            m_blnWantCheckPadEdgeDistance = objFile.GetValueAsBoolean("WantCheckPadEdgeDistance", true, 2);
            m_blnWantCheckPadSpanX = objFile.GetValueAsBoolean("WantCheckPadSpanX", true, 2);
            m_blnWantCheckPadSpanY = objFile.GetValueAsBoolean("WantCheckPadSpanY", true, 2);
            m_blnWantCheckPadStandOff = objFile.GetValueAsBoolean("WantCheckPadStandOff", true, 2);
            m_blnWantCheckExcessPadLength = objFile.GetValueAsBoolean("WantCheckExcessPadLength", true, 2);
            m_blnWantCheckExcessPadArea = objFile.GetValueAsBoolean("WantCheckExcessPadArea", true, 2);

            m_intPadROIStartPixelFromTop = objFile.GetValueAsInt("PadROIStartPixelFromTop", 10, 2);
            m_intPadROIStartPixelFromRight = objFile.GetValueAsInt("PadROIStartPixelFromRight", 10, 2);
            m_intPadROIStartPixelFromBottom = objFile.GetValueAsInt("PadROIStartPixelFromBottom", 10, 2);
            m_intPadROIStartPixelFromLeft = objFile.GetValueAsInt("PadROIStartPixelFromLeft", 10, 2);

            // Load Pad Blobs Features
            int intBlobsCount = objFile.GetValueAsInt("BlobsFeaturesCount", 0, 2);
            int intGroupBlobsCount = objFile.GetValueAsInt("GroupBlobsFeaturesCount", 0, 2);
            int intPitchGapCount = objFile.GetValueAsInt("PitchGapCount", 0, 2);

            objFile.GetSecondSection("ColorPadSetting");
            m_intColorDefectLinkMethod = objFile.GetValueAsInt("ColorDefectLinkMethod", 0, 2);
            m_intColorDefectLinkTolerance = objFile.GetValueAsInt("ColorDefectLinkTolerance", 10, 2);
            if (m_intPadROIDirection == 0)
                m_intColorPadGroupIndex = objFile.GetValueAsInt("ColorPadGroupIndex", 0x01, 2);
            else if (m_intPadROIDirection == 1)
                m_intColorPadGroupIndex = objFile.GetValueAsInt("ColorPadGroupIndex", 0x02, 2);
            else if (m_intPadROIDirection == 2)
                m_intColorPadGroupIndex = objFile.GetValueAsInt("ColorPadGroupIndex", 0x04, 2);
            else if (m_intPadROIDirection == 3)
                m_intColorPadGroupIndex = objFile.GetValueAsInt("ColorPadGroupIndex", 0x08, 2);
            else if (m_intPadROIDirection == 4)
                m_intColorPadGroupIndex = objFile.GetValueAsInt("ColorPadGroupIndex", 0x10, 2);
            m_intFailColorOptionMask = objFile.GetValueAsInt("FailColorMask", 0, 2);
            int intColorDefectCount = objFile.GetValueAsInt("ColorDefectCount", 0, 2);
            ClearColorDefect();
            for (int v = 0; v < intColorDefectCount; v++)
            {
                objFile.GetSecondSection("ColorDefect" + v);
                m_arrDefectColorThresName.Add(objFile.GetValueAsString("DefectColorThresName", "", 2));
                m_arrDefectColorSystem.Add(objFile.GetValueAsInt("DefectColorSystem", 0, 2));
                m_arrDefectCloseIteration.Add(objFile.GetValueAsInt("DefectCloseIteration", 0, 2));
                m_arrDefectInvertBlackWhite.Add(objFile.GetValueAsBoolean("DefectInvertBlackWhite", false, 2));
                m_arrDefectColor.Add(new int[3]);
                m_arrDefectColor[v][0] = objFile.GetValueAsInt("DefectColor0", 0, 2);
                m_arrDefectColor[v][1] = objFile.GetValueAsInt("DefectColor1", 0, 2);
                m_arrDefectColor[v][2] = objFile.GetValueAsInt("DefectColor2", 0, 2);
                m_arrDefectColorTolerance.Add(new int[3]);
                m_arrDefectColorTolerance[v][0] = objFile.GetValueAsInt("DefectColorTolerance0", 0, 2);
                m_arrDefectColorTolerance[v][1] = objFile.GetValueAsInt("DefectColorTolerance1", 0, 2);
                m_arrDefectColorTolerance[v][2] = objFile.GetValueAsInt("DefectColorTolerance2", 0, 2);
                m_arrDefectColorMinArea.Add(objFile.GetValueAsInt("DefectColorMinArea", 0, 2));
                m_arrDefectType.Add(objFile.GetValueAsInt("DefectType", 0, 2));
                m_arrDefectImageNo.Add(objFile.GetValueAsInt("DefectImageNo", 0, 2));
                m_arrDefectDontCareMode.Add(objFile.GetValueAsInt("DefectDontCareMode", 0, 2));
                m_arrDefectColorInspection_Top.Add(objFile.GetValueAsInt("DefectColorInspection_Top", 0, 2));
                m_arrDefectColorInspection_Right.Add(objFile.GetValueAsInt("DefectColorInspection_Right", 0, 2));
                m_arrDefectColorInspection_Bottom.Add(objFile.GetValueAsInt("DefectColorInspection_Bottom", 0, 2));
                m_arrDefectColorInspection_Left.Add(objFile.GetValueAsInt("DefectColorInspection_Left", 0, 2));
                m_arrDefectColorInspectionFailCondition.Add(objFile.GetValueAsInt("DefectColorInspectionFailCondition", 0, 2));
                m_arrDefectColorInspectionWidth.Add(objFile.GetValueAsFloat("DefectColorInspectionWidth", 0, 2));
                m_arrDefectColorInspectionLength.Add(objFile.GetValueAsFloat("DefectColorInspectionLength", 0, 2));
                m_arrDefectColorInspectionMinArea.Add(objFile.GetValueAsFloat("DefectColorInspectionMinArea", 0, 2));
                m_arrDefectColorInspectionMaxArea.Add(objFile.GetValueAsFloat("DefectColorInspectionMaxArea", 0, 2));
                m_arrDefectColorInspectionTotalArea.Add(objFile.GetValueAsFloat("DefectColorInspectionTotalArea", 0, 2));

            }

            ClearTemplateBlobsFeatures();
            for (int intBlobIndex = 0; intBlobIndex < intBlobsCount; intBlobIndex++)
            {
                objFile.GetSecondSection("BlobsFeatures" + intBlobIndex);

                SetTemplateBlobsFeatures(
                    objFile.GetValueAsInt("NoID", 0, 2),
                    objFile.GetValueAsInt("GroupNo", 0, 2),
                    objFile.GetValueAsFloat("Area", 0, 2),
                    objFile.GetValueAsInt("LengthMode", 0, 2),
                    objFile.GetValueAsInt("ContourX", 0, 2),
                    objFile.GetValueAsInt("ContourY", 0, 2),
                    objFile.GetValueAsInt("StartX", 0, 2),
                    objFile.GetValueAsInt("StartY", 0, 2),
                    objFile.GetValueAsInt("EndX", 0, 2),
                    objFile.GetValueAsInt("EndY", 0, 2),
                    objFile.GetValueAsFloat("fStartX", 0, 2),
                    objFile.GetValueAsFloat("fStartY", 0, 2),
                    objFile.GetValueAsFloat("fEndX", 0, 2),
                    objFile.GetValueAsFloat("fEndY", 0, 2),
                    objFile.GetValueAsInt("Direction", 0, 2),
                    objFile.GetValueAsInt("PadSide", 0, 2),
                     objFile.GetValueAsInt("SmearSide", 0, 2),
                    objFile.GetValueAsFloat("GravityCenterX", 0, 2),
                    objFile.GetValueAsFloat("GravityCenterY", 0, 2),
                    objFile.GetValueAsFloat("LimitCenterX", 0, 2),
                    objFile.GetValueAsFloat("LimitCenterY", 0, 2),
                    objFile.GetValueAsFloat("Width", 0, 2),
                    objFile.GetValueAsFloat("Height", 0, 2),
                     objFile.GetValueAsFloat("PercentWidthStart1", 0, 2),
                    objFile.GetValueAsFloat("PercentHeightStart1", 0, 2),
                    objFile.GetValueAsFloat("PercentWidthEnd1", 0, 2),
                    objFile.GetValueAsFloat("PercentHeightEnd1", 0, 2),
                    objFile.GetValueAsFloat("PercentWidthStart2", 0, 2),
                    objFile.GetValueAsFloat("PercentHeightStart2", 0, 2),
                    objFile.GetValueAsFloat("PercentWidthEnd2", 0, 2),
                    objFile.GetValueAsFloat("PercentHeightEnd2", 0, 2),
                    objFile.GetValueAsFloat("PercentWidthStart3", 0, 2),
                    objFile.GetValueAsFloat("PercentHeightStart3", 0, 2),
                    objFile.GetValueAsFloat("PercentWidthEnd3", 0, 2),
                    objFile.GetValueAsFloat("PercentHeightEnd3", 0, 2),
                    objFile.GetValueAsFloat("PercentWidthStart4", 0, 2),
                    objFile.GetValueAsFloat("PercentHeightStart4", 0, 2),
                    objFile.GetValueAsFloat("PercentWidthEnd4", 0, 2),
                    objFile.GetValueAsFloat("PercentHeightEnd4", 0, 2),
                    objFile.GetValueAsFloat("PercentWidthStart5", 0, 2),
                    objFile.GetValueAsFloat("PercentHeightStart5", 0, 2),
                    objFile.GetValueAsFloat("PercentWidthEnd5", 0, 2),
                    objFile.GetValueAsFloat("PercentHeightEnd5", 0, 2),
                    objFile.GetValueAsFloat("PercentWidthStart6", 0, 2),
                    objFile.GetValueAsFloat("PercentHeightStart6", 0, 2),
                    objFile.GetValueAsFloat("PercentWidthEnd6", 0, 2),
                    objFile.GetValueAsFloat("PercentHeightEnd6", 0, 2),
                    objFile.GetValueAsFloat("PercentWidthStart7", 0, 2),
                    objFile.GetValueAsFloat("PercentHeightStart7", 0, 2),
                    objFile.GetValueAsFloat("PercentWidthEnd7", 0, 2),
                    objFile.GetValueAsFloat("PercentHeightEnd7", 0, 2),
                    objFile.GetValueAsFloat("PercentWidthStart8", 0, 2),
                    objFile.GetValueAsFloat("PercentHeightStart8", 0, 2),
                    objFile.GetValueAsFloat("PercentWidthEnd8", 0, 2),
                    objFile.GetValueAsFloat("PercentHeightEnd8", 0, 2),
                    objFile.GetValueAsFloat("PercentWidthStart9", 0, 2),
                    objFile.GetValueAsFloat("PercentHeightStart9", 0, 2),
                    objFile.GetValueAsFloat("PercentWidthEnd9", 0, 2),
                    objFile.GetValueAsFloat("PercentHeightEnd9", 0, 2),
                    objFile.GetValueAsFloat("PercentWidthStart10", 0, 2),
                    objFile.GetValueAsFloat("PercentHeightStart10", 0, 2),
                    objFile.GetValueAsFloat("PercentWidthEnd10", 0, 2),
                    objFile.GetValueAsFloat("PercentHeightEnd10", 0, 2),
                    objFile.GetValueAsFloat("PercentWidthStart11", 0, 2),
                    objFile.GetValueAsFloat("PercentHeightStart11", 0, 2),
                    objFile.GetValueAsFloat("PercentWidthEnd11", 0, 2),
                    objFile.GetValueAsFloat("PercentHeightEnd11", 0, 2),
                    objFile.GetValueAsFloat("PercentWidthStart12", 0, 2),
                    objFile.GetValueAsFloat("PercentHeightStart12", 0, 2),
                    objFile.GetValueAsFloat("PercentWidthEnd12", 0, 2),
                    objFile.GetValueAsFloat("PercentHeightEnd12", 0, 2),

                    objFile.GetValueAsFloat("InwardPercentStart1", 0, 2),
                    objFile.GetValueAsFloat("InwardPercentEnd1", 0, 2),
                    objFile.GetValueAsFloat("InwardPercentStart2", 0, 2),
                    objFile.GetValueAsFloat("InwardPercentEnd2", 0, 2),
                    objFile.GetValueAsFloat("InwardPercentStart3", 0, 2),
                    objFile.GetValueAsFloat("InwardPercentEnd3", 0, 2),
                    objFile.GetValueAsFloat("InwardPercentStart4", 0, 2),
                    objFile.GetValueAsFloat("InwardPercentEnd4", 0, 2),
                    objFile.GetValueAsFloat("InwardPercentStart5", 0, 2),
                    objFile.GetValueAsFloat("InwardPercentEnd5", 0, 2),
                    objFile.GetValueAsFloat("InwardPercentStart6", 0, 2),
                    objFile.GetValueAsFloat("InwardPercentEnd6", 0, 2),
                    objFile.GetValueAsFloat("InwardPercentStart7", 0, 2),
                    objFile.GetValueAsFloat("InwardPercentEnd7", 0, 2),
                    objFile.GetValueAsFloat("InwardPercentStart8", 0, 2),
                    objFile.GetValueAsFloat("InwardPercentEnd8", 0, 2),
                    objFile.GetValueAsFloat("InwardPercentStart9", 0, 2),
                    objFile.GetValueAsFloat("InwardPercentEnd9", 0, 2),
                    objFile.GetValueAsFloat("InwardPercentStart10", 0, 2),
                    objFile.GetValueAsFloat("InwardPercentEnd10", 0, 2),
                    objFile.GetValueAsFloat("InwardPercentStart11", 0, 2),
                    objFile.GetValueAsFloat("InwardPercentEnd11", 0, 2),
                    objFile.GetValueAsFloat("InwardPercentStart12", 0, 2),
                    objFile.GetValueAsFloat("InwardPercentEnd12", 0, 2),

                   objFile.GetValueAsInt("MeasureMethod1", 0, 2),
                   objFile.GetValueAsInt("MeasureMethod2", 0, 2),
                   0,//objFile.GetValueAsInt("MeasureMethod3", 0, 2),
                   0,//objFile.GetValueAsInt("MeasureMethod4", 0, 2),
                   0,//objFile.GetValueAsInt("MeasureMethod5", 0, 2),
                   0,//objFile.GetValueAsInt("MeasureMethod6", 0, 2),
                   0,//objFile.GetValueAsInt("MeasureMethod7", 0, 2),
                   0,//objFile.GetValueAsInt("MeasureMethod8", 0, 2),
                   0,//objFile.GetValueAsInt("MeasureMethod9", 0, 2),
                   0,//objFile.GetValueAsInt("MeasureMethod10", 0, 2),
                   0,//objFile.GetValueAsInt("MeasureMethod11", 0, 2),
                   0,//objFile.GetValueAsInt("MeasureMethod12", 0, 2),

                   objFile.GetValueAsFloat("Angle", 0, 2),

                    objFile.GetValueAsInt("LineCount", 2, 2),

                    objFile.GetValueAsFloat("FeretWidth", 0, 2),
                    objFile.GetValueAsFloat("FeretHeight", 0, 2),
                    objFile.GetValueAsFloat("FeretCenterX", 0, 2),
                    objFile.GetValueAsFloat("FeretCenterY", 0, 2),
                    objFile.GetValueAsFloat("FeretAngle", 0, 2),
                    objFile.GetValueAsInt("FeretLengthMode", 1, 2),
                    false,//2021-06-19 ZJYEOH : not using feret anymore objFile.GetValueAsBoolean("FeretActivated", false, 2),
                    objFile.GetValueAsInt("P1X", 0, 2),
                    objFile.GetValueAsInt("P1Y", 0, 2),
                    objFile.GetValueAsInt("P2X", 0, 2),
                    objFile.GetValueAsInt("P2Y", 0, 2),
                    objFile.GetValueAsInt("P3X", 0, 2),
                    objFile.GetValueAsInt("P3Y", 0, 2),
                    objFile.GetValueAsInt("P4X", 0, 2),
                    objFile.GetValueAsInt("P4Y", 0, 2),

                    objFile.GetValueAsBoolean("Selected", false, 2),
                    objFile.GetValueAsBoolean("Enable", true, 2),
                    objFile.GetValueAsFloat("LeftDistance", 0, 2),
                    objFile.GetValueAsFloat("RightDistance", 0, 2),
                    objFile.GetValueAsFloat("TopDistance", 0, 2),
                    objFile.GetValueAsFloat("BottomDistance", 0, 2),
                    objFile.GetValueAsFloat("XDistance", 0, 2),
                    objFile.GetValueAsFloat("YDistance", 0, 2), 
                    objFile.GetValueAsFloat("TemplateROICenterX", 0, 2),
                    objFile.GetValueAsFloat("TemplateROICenterY", 0, 2),
                    objFile.GetValueAsFloat("TemplateROITopLeftCornerX", 0, 2),
                    objFile.GetValueAsFloat("TemplateROITopLeftCornerY", 0, 2),
                     objFile.GetValueAsFloat("XDistance_Pattern", 0, 2),
                    objFile.GetValueAsFloat("YDistance_Pattern", 0, 2),
                    objFile.GetValueAsFloat("TemplateROICenterX_Pattern", 0, 2),
                    objFile.GetValueAsFloat("TemplateROICenterY_Pattern", 0, 2),
                    objFile.GetValueAsFloat("TemplateROITopLeftCornerX_Pattern", 0, 2),
                    objFile.GetValueAsFloat("TemplateROITopLeftCornerY_Pattern", 0, 2),
                    objFile.GetValueAsFloat("Pitch", 0, 2),
                    objFile.GetValueAsFloat("Gap", 0, 2),

                    objFile.GetValueAsFloat("OffSet", 0, 2),
                    objFile.GetValueAsFloat("MinArea", 0, 2),
                    objFile.GetValueAsFloat("MaxArea", 0, 2),
                    objFile.GetValueAsFloat("MinWidth", 0, 2),
                    objFile.GetValueAsFloat("MaxWidth", 0, 2),
                    objFile.GetValueAsFloat("MinHeight", 0, 2),
                    objFile.GetValueAsFloat("MaxHeight", 0, 2),
                    objFile.GetValueAsFloat("MinPitch", 0, 2),
                    objFile.GetValueAsFloat("MaxPitch", 0, 2),
                    objFile.GetValueAsFloat("MinGap", 0, 2),
                    objFile.GetValueAsFloat("MaxGap", 0, 2),
                    objFile.GetValueAsFloat("MaxHole", 0, 2),
                    objFile.GetValueAsFloat("MaxBrokenLength", 0, 2),
                    objFile.GetValueAsFloat("MaxExcess", 0, 2),
                  objFile.GetValueAsFloat("MaxSmearLength", 0, 2),

                  objFile.GetValueAsFloat("MaxEdgeLimitTop", 0, 2),
                  objFile.GetValueAsFloat("MaxEdgeLimitRight", 0, 2),
                  objFile.GetValueAsFloat("MaxEdgeLimitBottom", 0, 2),
                  objFile.GetValueAsFloat("MaxEdgeLimitLeft", 0, 2),

                  objFile.GetValueAsFloat("MaxStandOffTop", 0, 2),
                  objFile.GetValueAsFloat("MaxStandOffBottom", 0, 2),
                  objFile.GetValueAsFloat("MaxStandOffLeft", 0, 2),
                  objFile.GetValueAsFloat("MaxStandOffRight", 0, 2),

                objFile.GetValueAsFloat("OffsetOffset", 0, 2),
                objFile.GetValueAsFloat("WidthOffset", 0, 2),
                objFile.GetValueAsFloat("HeightOffset", 0, 2),
                objFile.GetValueAsFloat("PitchOffset", 0, 2),
                objFile.GetValueAsFloat("GapOffset", 0, 2),
                
                objFile.GetValueAsFloat("EdgeDistanceTopOffset", 0, 2),
                objFile.GetValueAsFloat("EdgeDistanceRightOffset", 0, 2),
                objFile.GetValueAsFloat("EdgeDistanceBottomOffset", 0, 2),
                objFile.GetValueAsFloat("EdgeDistanceLeftOffset", 0, 2),

                objFile.GetValueAsFloat("EdgeLimitTopOffset", 0, 2),
                objFile.GetValueAsFloat("EdgeLimitRightOffset", 0, 2),
                objFile.GetValueAsFloat("EdgeLimitBottomOffset", 0, 2),
                objFile.GetValueAsFloat("EdgeLimitLeftOffset", 0, 2),

                objFile.GetValueAsFloat("StandOffTopOffset", 0, 2),
                objFile.GetValueAsFloat("StandOffBottomOffset", 0, 2),
                objFile.GetValueAsFloat("StandOffLeftOffset", 0, 2),
                objFile.GetValueAsFloat("StandOffRightOffset", 0, 2),

                objFile.GetValueAsFloat("MinLine3", 0, 2),
                objFile.GetValueAsFloat("MaxLine3", 0, 2),
                objFile.GetValueAsFloat("MinLine4", 0, 2),
                objFile.GetValueAsFloat("MaxLine4", 0, 2),
                objFile.GetValueAsFloat("MinLine5", 0, 2),
                objFile.GetValueAsFloat("MaxLine5", 0, 2),
                objFile.GetValueAsFloat("MinLine6", 0, 2),
                objFile.GetValueAsFloat("MaxLine6", 0, 2),
                objFile.GetValueAsFloat("MinLine7", 0, 2),
                objFile.GetValueAsFloat("MaxLine7", 0, 2),
                objFile.GetValueAsFloat("MinLine8", 0, 2),
                objFile.GetValueAsFloat("MaxLine8", 0, 2),
                objFile.GetValueAsFloat("MinLine9", 0, 2),
                objFile.GetValueAsFloat("MaxLine9", 0, 2),
                objFile.GetValueAsFloat("MinLine10", 0, 2),
                objFile.GetValueAsFloat("MaxLine10", 0, 2),
                objFile.GetValueAsFloat("MinLine11", 0, 2),
                objFile.GetValueAsFloat("MaxLine11", 0, 2),
                objFile.GetValueAsFloat("MinLine12", 0, 2),
                objFile.GetValueAsFloat("MaxLine12", 0, 2),

                objFile.GetValueAsFloat("PadInspectionAreaFromTop", 0, 2),
                objFile.GetValueAsFloat("PadInspectionAreaFromRight", 0, 2),
                objFile.GetValueAsFloat("PadInspectionAreaFromBottom", 0, 2),
                objFile.GetValueAsFloat("PadInspectionAreaFromLeft", 0, 2),

                objFile.GetValueAsInt("ReferTopBottom", 0, 2),
                objFile.GetValueAsBoolean("CheckTop", false, 2),
                objFile.GetValueAsBoolean("CheckBottom", false, 2),
                objFile.GetValueAsInt("ReferLeftRight", 0, 2),
                objFile.GetValueAsBoolean("CheckLeft", false, 2),
                objFile.GetValueAsBoolean("CheckRight", false, 2)
                );
            }

            // Load Group Pad Blobs Features
            m_arrGroupTemplateBlobPads.Clear();
            for (int intBlobIndex = 0; intBlobIndex < intGroupBlobsCount; intBlobIndex++)
            {
                objFile.GetSecondSection("GroupBlobsFeatures" + intBlobIndex);
                BlobsFeatures m_stcBlobPad = new BlobsFeatures();
                m_stcBlobPad.intNoID = objFile.GetValueAsInt("NoID", 0, 2);
                m_stcBlobPad.intGroupID = objFile.GetValueAsInt("GroupNo", 0, 2);
                m_stcBlobPad.fArea = objFile.GetValueAsFloat("Area", 0, 2);
                m_stcBlobPad.intLengthMode = objFile.GetValueAsInt("LengthMode", 0, 2);
                m_stcBlobPad.intContourX = objFile.GetValueAsInt("ContourX", 0, 2);
                m_stcBlobPad.intContourY = objFile.GetValueAsInt("ContourY", 0, 2);
                m_stcBlobPad.intStartX = objFile.GetValueAsInt("StartX", 0, 2);
                m_stcBlobPad.intStartY = objFile.GetValueAsInt("StartY", 0, 2);
                m_stcBlobPad.intEndX = objFile.GetValueAsInt("EndX", 0, 2);
                m_stcBlobPad.intEndY = objFile.GetValueAsInt("EndY", 0, 2);
                m_stcBlobPad.fStartX = objFile.GetValueAsFloat("fStartX", 0, 2);
                m_stcBlobPad.fStartY = objFile.GetValueAsFloat("fStartY", 0, 2);
                m_stcBlobPad.fEndX = objFile.GetValueAsFloat("fEndX", 0, 2);
                m_stcBlobPad.fEndY = objFile.GetValueAsFloat("fEndY", 0, 2);
                m_stcBlobPad.intDirection = objFile.GetValueAsInt("Direction", 0, 2);
                m_stcBlobPad.intSide = objFile.GetValueAsInt("PadSide", 0, 2);
                m_stcBlobPad.intSmearSide = objFile.GetValueAsInt("SmearSide", 0, 2);
                m_stcBlobPad.fCenterX = objFile.GetValueAsFloat("GravityCenterX", 0, 2);
                m_stcBlobPad.fCenterY = objFile.GetValueAsFloat("GravityCenterY", 0, 2);
                m_stcBlobPad.fLimitCenterX = objFile.GetValueAsFloat("LimitCenterX", 0, 2);
                m_stcBlobPad.fLimitCenterY = objFile.GetValueAsFloat("LimitCenterY", 0, 2);
                m_stcBlobPad.fWidth = objFile.GetValueAsFloat("Width", 0, 2);
                m_stcBlobPad.fHeight = objFile.GetValueAsFloat("Height", 0, 2);
                m_stcBlobPad.blnSelected = objFile.GetValueAsBoolean("Selected", false, 2);
                m_stcBlobPad.blnEnable = objFile.GetValueAsBoolean("Enable", true, 2);
                m_stcBlobPad.fLeftDistance = objFile.GetValueAsFloat("LeftDistance", 0, 2);
                m_stcBlobPad.fRightDistance = objFile.GetValueAsFloat("RightDistance", 0, 2);
                m_stcBlobPad.fTopDistance = objFile.GetValueAsFloat("TopDistance", 0, 2);
                m_stcBlobPad.fBottomDistance = objFile.GetValueAsFloat("BottomDistance", 0, 2);
                m_stcBlobPad.fXDistance = objFile.GetValueAsFloat("XDistance", 0, 2);
                m_stcBlobPad.fYDistance = objFile.GetValueAsFloat("YDistance", 0, 2);
                m_stcBlobPad.fTemplateROICenterX = objFile.GetValueAsFloat("TemplateROICenterX", 0, 2);
                m_stcBlobPad.fTemplateROICenterY = objFile.GetValueAsFloat("TemplateROICenterY", 0, 2);
                m_stcBlobPad.fTemplateROITopLeftCornerX = objFile.GetValueAsFloat("TemplateROITopLeftCornerX", 0, 2);
                m_stcBlobPad.fTemplateROITopLeftCornerY = objFile.GetValueAsFloat("TemplateROITopLeftCornerY", 0, 2);
                m_stcBlobPad.fXDistance_Pattern = objFile.GetValueAsFloat("XDistance_Pattern", 0, 2);
                m_stcBlobPad.fYDistance_Pattern = objFile.GetValueAsFloat("YDistance_Pattern", 0, 2);
                m_stcBlobPad.fTemplateROICenterX_Pattern = objFile.GetValueAsFloat("TemplateROICenterX_Pattern", 0, 2);
                m_stcBlobPad.fTemplateROICenterY_Pattern = objFile.GetValueAsFloat("TemplateROICenterY_Pattern", 0, 2);
                m_stcBlobPad.fTemplateROITopLeftCornerX_Pattern = objFile.GetValueAsFloat("TemplateROITopLeftCornerX_Pattern", 0, 2);
                m_stcBlobPad.fTemplateROITopLeftCornerY_Pattern = objFile.GetValueAsFloat("TemplateROITopLeftCornerY_Pattern", 0, 2);
                m_stcBlobPad.fPitch = objFile.GetValueAsFloat("Pitch", 0, 2);
                m_stcBlobPad.fGap = objFile.GetValueAsFloat("Gap", 0, 2);

                m_stcBlobPad.fOffSet = objFile.GetValueAsFloat("OffSet", 0, 2);
                m_stcBlobPad.fMinArea = objFile.GetValueAsFloat("MinArea", 0, 2);
                m_stcBlobPad.fMaxArea = objFile.GetValueAsFloat("MaxArea", 0, 2);
                m_stcBlobPad.fMinWidth = objFile.GetValueAsFloat("MinWidth", 0, 2);
                m_stcBlobPad.fMaxWidth = objFile.GetValueAsFloat("MaxWidth", 0, 2);
                m_stcBlobPad.fMinLength = objFile.GetValueAsFloat("MinHeight", 0, 2);
                m_stcBlobPad.fMaxLength = objFile.GetValueAsFloat("MaxHeight", 0, 2);
                m_stcBlobPad.fMinPitch = objFile.GetValueAsFloat("MinPitch", 0, 2);
                m_stcBlobPad.fMaxPitch = objFile.GetValueAsFloat("MaxPitch", 0, 2);
                m_stcBlobPad.fMinGap = objFile.GetValueAsFloat("MinGap", 0, 2);
                m_stcBlobPad.fMaxGap = objFile.GetValueAsFloat("MaxGap", 0, 2);
                m_stcBlobPad.fMaxBroken = objFile.GetValueAsFloat("MaxHole", 0, 2);
                m_stcBlobPad.fMaxBrokenLength = objFile.GetValueAsFloat("MaxBrokenLength", 0, 2);
                m_stcBlobPad.fMaxExcess = objFile.GetValueAsFloat("MaxExcess", 0, 2);
                m_stcBlobPad.fMaxSmearLength = objFile.GetValueAsFloat("MaxSmearLength", 0, 2);

                m_stcBlobPad.fEdgeLimitTop = objFile.GetValueAsFloat("MaxEdgeLimitTop", 0, 2);
                m_stcBlobPad.fEdgeLimitRight = objFile.GetValueAsFloat("MaxEdgeLimitRight", 0, 2);
                m_stcBlobPad.fEdgeLimitBottom = objFile.GetValueAsFloat("MaxEdgeLimitBottom", 0, 2);
                m_stcBlobPad.fEdgeLimitLeft = objFile.GetValueAsFloat("MaxEdgeLimitLeft", 0, 2);

                m_stcBlobPad.fMaxStandOffTop = objFile.GetValueAsFloat("MaxStandOffTop", 0, 2);
                m_stcBlobPad.fMaxStandOffBottom = objFile.GetValueAsFloat("MaxStandOffBottom", 0, 2);
                m_stcBlobPad.fMaxStandOffLeft = objFile.GetValueAsFloat("MaxStandOffLeft", 0, 2);
                m_stcBlobPad.fMaxStandOffRight = objFile.GetValueAsFloat("MaxStandOffRight", 0, 2);
                
                m_stcBlobPad.fOffsetOffSet = objFile.GetValueAsFloat("OffsetOffSet", 0, 2);
                m_stcBlobPad.fWidthOffset = objFile.GetValueAsFloat("WidthOffset", 0, 2);
                m_stcBlobPad.fHeightOffset = objFile.GetValueAsFloat("HeightOffset", 0, 2);
                m_stcBlobPad.fPitchOffset = objFile.GetValueAsFloat("PitchOffset", 0, 2);
                m_stcBlobPad.fGapOffset = objFile.GetValueAsFloat("GapOffset", 0, 2);

                m_stcBlobPad.fEdgeDistanceTopOffset = objFile.GetValueAsFloat("EdgeDistanceTopOffset", 0, 2);
                m_stcBlobPad.fEdgeDistanceRightOffset = objFile.GetValueAsFloat("EdgeDistanceRightOffset", 0, 2);
                m_stcBlobPad.fEdgeDistanceBottomOffset = objFile.GetValueAsFloat("EdgeDistanceBottomOffset", 0, 2);
                m_stcBlobPad.fEdgeDistanceLeftOffset = objFile.GetValueAsFloat("EdgeDistanceLeftOffset", 0, 2);

                m_stcBlobPad.fEdgeLimitTopOffset = objFile.GetValueAsFloat("EdgeLimitTopOffset", 0, 2);
                m_stcBlobPad.fEdgeLimitRightOffset = objFile.GetValueAsFloat("EdgeLimitRightOffset", 0, 2);
                m_stcBlobPad.fEdgeLimitBottomOffset = objFile.GetValueAsFloat("EdgeLimitBottomOffset", 0, 2);
                m_stcBlobPad.fEdgeLimitLeftOffset = objFile.GetValueAsFloat("EdgeLimitLeftOffset", 0, 2);

                m_stcBlobPad.fStandOffTopOffset = objFile.GetValueAsFloat("StandOffTopOffset", 0, 2);
                m_stcBlobPad.fStandOffBottomOffset = objFile.GetValueAsFloat("StandOffBottomOffset", 0, 2);
                m_stcBlobPad.fStandOffLeftOffset = objFile.GetValueAsFloat("StandOffLeftOffset", 0, 2);
                m_stcBlobPad.fStandOffRightOffset = objFile.GetValueAsFloat("StandOffRightOffset", 0, 2);
                
                m_stcBlobPad.fMinLine3 = objFile.GetValueAsFloat("MinLine3", 0, 2);
                m_stcBlobPad.fMaxLine3 = objFile.GetValueAsFloat("MaxLine3", 0, 2);
                m_stcBlobPad.fMinLine4 = objFile.GetValueAsFloat("MinLine4", 0, 2);
                m_stcBlobPad.fMaxLine4 = objFile.GetValueAsFloat("MaxLine4", 0, 2);
                m_stcBlobPad.fMinLine5 = objFile.GetValueAsFloat("MinLine5", 0, 2);
                m_stcBlobPad.fMaxLine5 = objFile.GetValueAsFloat("MaxLine5", 0, 2);
                m_stcBlobPad.fMinLine6 = objFile.GetValueAsFloat("MinLine6", 0, 2);
                m_stcBlobPad.fMaxLine6 = objFile.GetValueAsFloat("MaxLine6", 0, 2);
                m_stcBlobPad.fMinLine7 = objFile.GetValueAsFloat("MinLine7", 0, 2);
                m_stcBlobPad.fMaxLine7 = objFile.GetValueAsFloat("MaxLine7", 0, 2);
                m_stcBlobPad.fMinLine8 = objFile.GetValueAsFloat("MinLine8", 0, 2);
                m_stcBlobPad.fMaxLine8 = objFile.GetValueAsFloat("MaxLine8", 0, 2);
                m_stcBlobPad.fMinLine9 = objFile.GetValueAsFloat("MinLine9", 0, 2);
                m_stcBlobPad.fMaxLine9 = objFile.GetValueAsFloat("MaxLine9", 0, 2);
                m_stcBlobPad.fMinLine10 = objFile.GetValueAsFloat("MinLine10", 0, 2);
                m_stcBlobPad.fMaxLine10 = objFile.GetValueAsFloat("MaxLine10", 0, 2);
                m_stcBlobPad.fMinLine11 = objFile.GetValueAsFloat("MinLine11", 0, 2);
                m_stcBlobPad.fMaxLine11 = objFile.GetValueAsFloat("MaxLine11", 0, 2);
                m_stcBlobPad.fMinLine12 = objFile.GetValueAsFloat("MinLine12", 0, 2);
                m_stcBlobPad.fMaxLine12 = objFile.GetValueAsFloat("MaxLine12", 0, 2);

                m_stcBlobPad.fPadInspectionAreaFromTop = objFile.GetValueAsFloat("PadInspectionAreaFromTop", 0, 2);
                m_stcBlobPad.fPadInspectionAreaFromRight = objFile.GetValueAsFloat("PadInspectionAreaFromRight", 0, 2);
                m_stcBlobPad.fPadInspectionAreaFromBottom = objFile.GetValueAsFloat("PadInspectionAreaFromBottom", 0, 2);
                m_stcBlobPad.fPadInspectionAreaFromLeft = objFile.GetValueAsFloat("PadInspectionAreaFromLeft", 0, 2);

                m_stcBlobPad.intReferTopBottom = objFile.GetValueAsInt("ReferTopBottom", 0, 2);
                m_stcBlobPad.blnCheckTop = objFile.GetValueAsBoolean("CheckTop", false, 2);
                m_stcBlobPad.blnCheckBottom = objFile.GetValueAsBoolean("CheckBottom", false, 2);
                m_stcBlobPad.intReferLeftRight = objFile.GetValueAsInt("ReferLeftRight", 0, 2);
                m_stcBlobPad.blnCheckLeft = objFile.GetValueAsBoolean("CheckLeft", false, 2);
                m_stcBlobPad.blnCheckRight = objFile.GetValueAsBoolean("CheckRight", false, 2);
              
                m_arrGroupTemplateBlobPads.Add(m_stcBlobPad);
            }

            // Load Pitch Gap
            ClearTemplatePitchGap();
            for (int intPitchGapIndex = 0; intPitchGapIndex < intPitchGapCount; intPitchGapIndex++)
            {
                objFile.GetSecondSection("PitchGap" + intPitchGapIndex);

                float gg = objFile.GetValueAsFloat("Gap", 0, 2);
                float pp = objFile.GetValueAsFloat("Pitch", 0, 2);
                SetPitchGapData(
                    objFile.GetValueAsInt("FromPadNo", 0, 2),
                    objFile.GetValueAsInt("ToPadNo", 0, 2),
                    objFile.GetValueAsFloat("MinPitch", 0, 2),
                    objFile.GetValueAsFloat("MaxPitch", 0, 2),
                    objFile.GetValueAsFloat("MinGap", 0, 2),
                    objFile.GetValueAsFloat("MaxGap", 0, 2),
                    objFile.GetValueAsFloat("Pitch", 0, 2),
                    objFile.GetValueAsFloat("Gap", 0, 2),
                    objFile.GetValueAsInt("StartX", 0, 2),
                    objFile.GetValueAsInt("StartY", 0, 2),
                    objFile.GetValueAsInt("EndX", 0, 2),
                    objFile.GetValueAsInt("EndY", 0, 2),
                    objFile.GetValueAsInt("Direction", 0, 2)
                    );
            }

            // Load Package
            objFile.GetSecondSection("PackageSetting");
            m_fChipStartPixelFromEdge = objFile.GetValueAsFloat("ChipStartPixelFromEdge", 2, 2);
            m_fChipStartPixelFromRight = objFile.GetValueAsFloat("ChipStartPixelFromRight", 2, 2);
            m_fChipStartPixelFromBottom = objFile.GetValueAsFloat("ChipStartPixelFromBottom", 2, 2);
            m_fChipStartPixelFromLeft = objFile.GetValueAsFloat("ChipStartPixelFromLeft", 2, 2);
            m_fChipStartPixelExtendFromEdge = objFile.GetValueAsFloat("ChipStartPixelExtendFromEdge", 2, 2);
            m_fChipStartPixelExtendFromRight = objFile.GetValueAsFloat("ChipStartPixelExtendFromRight", 2, 2);
            m_fChipStartPixelExtendFromBottom = objFile.GetValueAsFloat("ChipStartPixelExtendFromBottom", 2, 2);
            m_fChipStartPixelExtendFromLeft = objFile.GetValueAsFloat("ChipStartPixelExtendFromLeft", 2, 2);
            m_fChipStartPixelFromEdge_Dark = objFile.GetValueAsFloat("ChipStartPixelFromEdge_Dark", 2, 2);
            m_fChipStartPixelFromRight_Dark = objFile.GetValueAsFloat("ChipStartPixelFromRight_Dark", 2, 2);
            m_fChipStartPixelFromBottom_Dark = objFile.GetValueAsFloat("ChipStartPixelFromBottom_Dark", 2, 2);
            m_fChipStartPixelFromLeft_Dark = objFile.GetValueAsFloat("ChipStartPixelFromLeft_Dark", 2, 2);
            m_fChipStartPixelExtendFromEdge_Dark = objFile.GetValueAsFloat("ChipStartPixelExtendFromEdge_Dark", 2, 2);
            m_fChipStartPixelExtendFromRight_Dark = objFile.GetValueAsFloat("ChipStartPixelExtendFromRight_Dark", 2, 2);
            m_fChipStartPixelExtendFromBottom_Dark = objFile.GetValueAsFloat("ChipStartPixelExtendFromBottom_Dark", 2, 2);
            m_fChipStartPixelExtendFromLeft_Dark = objFile.GetValueAsFloat("ChipStartPixelExtendFromLeft_Dark", 2, 2);
            m_fMoldStartPixelFromEdge = objFile.GetValueAsFloat("MoldStartPixelFromEdge", 2, 2);
            m_fMoldStartPixelFromRight = objFile.GetValueAsFloat("MoldStartPixelFromRight", 2, 2);
            m_fMoldStartPixelFromBottom = objFile.GetValueAsFloat("MoldStartPixelFromBottom", 2, 2);
            m_fMoldStartPixelFromLeft = objFile.GetValueAsFloat("MoldStartPixelFromLeft", 2, 2);
            m_fMoldStartPixelInnerFromEdge = objFile.GetValueAsFloat("MoldStartPixelInnerFromEdge", 2, 2);
            m_fMoldStartPixelInnerFromRight = objFile.GetValueAsFloat("MoldStartPixelInnerFromRight", 2, 2);
            m_fMoldStartPixelInnerFromBottom = objFile.GetValueAsFloat("MoldStartPixelInnerFromBottom", 2, 2);
            m_fMoldStartPixelInnerFromLeft = objFile.GetValueAsFloat("MoldStartPixelInnerFromLeft", 2, 2);
            m_fPkgStartPixelFromEdge = objFile.GetValueAsFloat("PkgStartPixelFromEdge", 0, 2);
            m_fPkgStartPixelFromRight = objFile.GetValueAsFloat("PkgStartPixelFromRight", 0, 2);
            m_fPkgStartPixelFromBottom = objFile.GetValueAsFloat("PkgStartPixelFromBottom", 0, 2);
            m_fPkgStartPixelFromLeft = objFile.GetValueAsFloat("PkgStartPixelFromLeft", 0, 2);
            m_fPkgStartPixelFromEdge_Dark = objFile.GetValueAsFloat("PkgStartPixelFromEdge_Dark", 0, 2);
            m_fPkgStartPixelFromRight_Dark = objFile.GetValueAsFloat("PkgStartPixelFromRight_Dark", 0, 2);
            m_fPkgStartPixelFromBottom_Dark = objFile.GetValueAsFloat("PkgStartPixelFromBottom_Dark", 0, 2);
            m_fPkgStartPixelFromLeft_Dark = objFile.GetValueAsFloat("PkgStartPixelFromLeft_Dark", 0, 2);
            m_fForeignMaterialStartPixelFromEdge = objFile.GetValueAsFloat("ForeignMaterialStartPixelFromEdge", 0, 2);
            m_fForeignMaterialStartPixelFromRight = objFile.GetValueAsFloat("ForeignMaterialStartPixelFromRight", 0, 2);
            m_fForeignMaterialStartPixelFromBottom = objFile.GetValueAsFloat("ForeignMaterialStartPixelFromBottom", 0, 2);
            m_fForeignMaterialStartPixelFromLeft = objFile.GetValueAsFloat("ForeignMaterialStartPixelFromLeft", 0, 2);
            m_fForeignMaterialStartPixelFromEdge_Pad = objFile.GetValueAsFloat("ForeignMaterialStartPixelFromEdge_Pad", 0, 2);
            m_fForeignMaterialStartPixelFromRight_Pad = objFile.GetValueAsFloat("ForeignMaterialStartPixelFromRight_Pad", 0, 2);
            m_fForeignMaterialStartPixelFromBottom_Pad = objFile.GetValueAsFloat("ForeignMaterialStartPixelFromBottom_Pad", 0, 2);
            m_fForeignMaterialStartPixelFromLeft_Pad = objFile.GetValueAsFloat("ForeignMaterialStartPixelFromLeft_Pad", 0, 2);
            m_intPkgImage1HighPadThreshold = objFile.GetValueAsInt("PkgImage1HighPadThreshold", 255, 2);
            m_intPkgImage1LowPadThreshold = objFile.GetValueAsInt("PkgImage1LowPadThreshold", 0, 2);
            m_intPkgImage1HighSurfaceThreshold = objFile.GetValueAsInt("PkgImage1HighSurfaceThreshold", 255, 2);
            m_intPkgImage1LowSurfaceThreshold = objFile.GetValueAsInt("PkgImage1LowSurfaceThreshold", 0, 2);
            m_fPkgImage1Gain = objFile.GetValueAsFloat("PkgImage1Gain", 1f, 2);
            m_intPkgImage2HighThreshold = objFile.GetValueAsInt("PkgImage2HighPadThreshold", 255, 2);
            m_intPkgImage2LowThreshold = objFile.GetValueAsInt("PkgImage2LowPadThreshold", 0, 2);
            m_intPkgImage3HighThreshold = objFile.GetValueAsInt("PkgImage3HighPadThreshold", 255, 2);
            m_intPkgImage3LowThreshold = objFile.GetValueAsInt("PkgImage3LowPadThreshold", 0, 2);
            m_intPkgImage1MoldFlashThreshold = objFile.GetValueAsInt("PkgImage1MoldFlashThreshold", 125, 2);
            m_intPkgImage2VoidThreshold = objFile.GetValueAsInt("PkgImage2VoidThreshold", 125, 2);
            m_intPkgImage2HighCrackThreshold = objFile.GetValueAsInt("PkgImage2HighCrackThreshold", 255, 2);
            m_intPkgImage2LowCrackThreshold = objFile.GetValueAsInt("PkgImage2LowCrackThreshold", 0, 2);
            m_intPkgImage1ChippedThreshold = objFile.GetValueAsInt("PkgImage1ChippedThreshold", 125, 2);
            m_intForeignMaterialBrightFieldThreshold = objFile.GetValueAsInt("ForeignMaterialBrightFieldThreshold", 125, 2);
            m_intBrightFieldLowThreshold = objFile.GetValueAsInt("BrightFieldLowThreshold", 50, 2);
            m_intBrightFieldHighThreshold = objFile.GetValueAsInt("BrightFieldHighThreshold", 255, 2);
            m_intDarkFieldLowThreshold = objFile.GetValueAsInt("DarkFieldLowThreshold", 50, 2);
            m_fDarkFieldImageGain = objFile.GetValueAsFloat("DarkFieldImageGain", 1f, 2);
            m_fPadImageGain = objFile.GetValueAsFloat("PadImageGain", 1f, 2);
            m_intDarkFieldHighThreshold = objFile.GetValueAsInt("DarkFieldHighThreshold", 255, 2);

            //PackageSize Offset
            m_fPackageWidthOffsetMM = objFile.GetValueAsFloat("PackageWidthOffsetMM", 0, 2);
            m_fPackageHeightOffsetMM = objFile.GetValueAsFloat("PackageHeightOffsetMM", 0, 2);
            m_fPackageThicknessOffsetMM = objFile.GetValueAsFloat("PackageThicknessOffsetMM", 0, 2);

            m_fUnitWidth = objFile.GetValueAsFloat("UnitWidth", 0, 2);
            m_fUnitHeight = objFile.GetValueAsFloat("UnitHeight", 0, 2);
            m_fUnitThickness = objFile.GetValueAsFloat("UnitThickness", 0, 2);
            m_fUnitWidthMin = objFile.GetValueAsFloat("UnitWidthMin", 0, 2);
            m_fUnitWidthMax = objFile.GetValueAsFloat("UnitWidthMax", 0, 2);
            m_fUnitHeightMin = objFile.GetValueAsFloat("UnitHeightMin", 0, 2);
            m_fUnitHeightMax = objFile.GetValueAsFloat("UnitHeightMax", 0, 2);
            m_fUnitThicknessMin = objFile.GetValueAsFloat("UnitThicknessMin", 0, 2);
            m_fUnitThicknessMax = objFile.GetValueAsFloat("UnitThicknessMax", 0, 2);

            m_fUnitSizeLength = objFile.GetValueAsFloat("UnitSizeLength", 0, 2);
            m_fCrackLength = objFile.GetValueAsFloat("CrackLength", 0, 2);
            m_fScratchLength = objFile.GetValueAsFloat("ScratchLength", 0, 2);
            m_fScratchArea = objFile.GetValueAsFloat("ScratchArea", 0, 2);
            m_fChipArea = objFile.GetValueAsFloat("ChipArea", 0, 2);
            m_fContaminationLength = objFile.GetValueAsFloat("ContaminationLength", 0, 2);
            m_fSolderMeltLength = objFile.GetValueAsFloat("SolderMeltLength", 0, 2);
            m_fVoidLength = objFile.GetValueAsFloat("VoidLength", 0, 2);
            m_fVoidArea = objFile.GetValueAsFloat("VoidArea", 0, 2);
            m_fCrackLength = objFile.GetValueAsFloat("CrackLength", 0, 2);
            m_fCrackArea = objFile.GetValueAsFloat("CrackArea", 0, 2);
            m_fForeignMaterialArea = objFile.GetValueAsFloat("ForeignMaterialArea", 0, 2);
            m_fMoldFlashLength = objFile.GetValueAsFloat("MoldFlashLength_Real", 0, 2);
            m_fMoldFlashWidth = objFile.GetValueAsFloat("MoldFlashWidth", 0, 2);
            m_fMoldFlashArea = objFile.GetValueAsFloat("MoldFlashLength", 0, 2);
            m_fMoldFlashTotalArea = objFile.GetValueAsFloat("MoldFlashTotalArea", 0, 2);
            m_fInCompletePlateLength = objFile.GetValueAsFloat("InCompletePlateLength", 0, 2);
            m_fPadBrokenLength = objFile.GetValueAsFloat("PadBrokenLength", 0, 2);

            m_intMoldFlashDefectDimensionFailCondition = objFile.GetValueAsInt("MoldFlashDefectDimensionFailCondition", 0, 2);
            m_intBrightDefectDimensionFailCondition = objFile.GetValueAsInt("BrightDefectDimensionFailCondition", 0, 2);
            m_intForeignMaterialBrightDefectDimensionFailCondition = objFile.GetValueAsInt("ForeignMaterialBrightDefectDimensionFailCondition", 0, 2);
            m_intDarkDefectDimensionFailCondition = objFile.GetValueAsInt("DarkDefectDimensionFailCondition", 0, 2);
            m_intCrackDarkDefectDimensionFailCondition = objFile.GetValueAsInt("CrackDarkDefectDimensionFailCondition", 0, 2);
            
            m_fBrightLength = objFile.GetValueAsFloat("BrightLength", 0, 2);
            m_fBrightWidth = objFile.GetValueAsFloat("BrightWidth", 0, 2);
            m_fBrightArea = objFile.GetValueAsFloat("BrightArea", 0, 2);
            m_fBrightTotalArea = objFile.GetValueAsFloat("BrightTotalArea", 0, 2);
            m_fDarkLength = objFile.GetValueAsFloat("DarkLength", 0, 2);
            m_fDarkWidth = objFile.GetValueAsFloat("DarkWidth", 0, 2);
            m_fDarkArea = objFile.GetValueAsFloat("DarkArea", 0, 2);
            m_fDarkTotalArea = objFile.GetValueAsFloat("DarkTotalArea", 0, 2);
            m_fBrightChippedOffArea = objFile.GetValueAsFloat("BrightChippedOffArea", 0, 2);
            m_fDarkChippedOffArea = objFile.GetValueAsFloat("DarkChippedOffArea", 0, 2);
            m_fDarkVerticalCrack = objFile.GetValueAsFloat("DarkVerticalCrack", 0, 2);
            m_fDarkHorizontalCrack = objFile.GetValueAsFloat("DarkHorizontalCrack", 0, 2);
            m_fBrightVerticalForeignMaterial = objFile.GetValueAsFloat("BrightVerticalForeignMaterial", 0, 2);
            m_fBrightHorizontalForeignMaterial = objFile.GetValueAsFloat("BrightHorizontalForeignMaterial", 0, 2);

            m_intMPErodeHalfWidth = objFile.GetValueAsInt("MPErodeHalfWidth", 3, 2);
            m_intMPDilateHalfWidth = objFile.GetValueAsInt("MPDilateHalfWidth", 3, 2);

            //2022-02-21 ZJYEOH : limit to 100
            if (m_intMPErodeHalfWidth > 100)
                m_intMPErodeHalfWidth = 100;
            if (m_intMPDilateHalfWidth > 100)
                m_intMPDilateHalfWidth = 100;

            if (m_objPosCrosshair != null)
                m_objPosCrosshair.LoadCrosshair(strPath, "PositionCrosshair");

        }

        public void LoadPadToleranceOnly(string strPath, string strSectionName)
        {
            XmlParser objFile = new XmlParser(strPath);

            objFile.GetFirstSection(strSectionName);

            // Load Pad General Setting
            objFile.GetSecondSection("PadSetting");
            m_fAngleTolerance = objFile.GetValueAsFloat("AngleTolerance", 2, 2);
            m_fXTolerance = objFile.GetValueAsFloat("XTolerance", 2, 2);
            m_fYTolerance = objFile.GetValueAsFloat("YTolerance", 2, 2);

            // mm            
            m_fPosToleranceX = objFile.GetValueAsFloat("PosToleranceX", 0, 2);
            m_fPosToleranceY = objFile.GetValueAsFloat("PosToleranceY", 0, 2);
            m_fMinSpanX = objFile.GetValueAsFloat("MinSpanX", 0, 2);
            m_fMaxSpanX = objFile.GetValueAsFloat("MaxSpanX", 0, 2);
            m_fMinSpanY = objFile.GetValueAsFloat("MinSpanY", 0, 2);
            m_fMaxSpanY = objFile.GetValueAsFloat("MaxSpanY", 0, 2);
            m_fEdgeDistanceMin_Top = objFile.GetValueAsFloat("EdgeDistanceMin_Top", 0, 2);
            m_fEdgeDistanceMax_Top = objFile.GetValueAsFloat("EdgeDistanceMax_Top", 0, 2);
            m_fEdgeDistanceMin_Right = objFile.GetValueAsFloat("EdgeDistanceMin_Right", 0, 2);
            m_fEdgeDistanceMax_Right = objFile.GetValueAsFloat("EdgeDistanceMax_Right", 0, 2);
            m_fEdgeDistanceMin_Bottom = objFile.GetValueAsFloat("EdgeDistanceMin_Bottom", 0, 2);
            m_fEdgeDistanceMax_Bottom = objFile.GetValueAsFloat("EdgeDistanceMax_Bottom", 0, 2);
            m_fEdgeDistanceMin_Left = objFile.GetValueAsFloat("EdgeDistanceMin_Left", 0, 2);
            m_fEdgeDistanceMax_Left = objFile.GetValueAsFloat("EdgeDistanceMax_Left", 0, 2);
            m_fExtraPadSetArea = objFile.GetValueAsFloat("ExtraPadMinArea", 0.004f, 2);
            m_fTotalExtraPadSetArea = objFile.GetValueAsFloat("TotalExtraPadMinArea", 0.004f, 2);
            m_fExcessPadSetArea = objFile.GetValueAsFloat("ExcessPadMinArea", 0.004f, 2);
            m_fExtraPadSetLength = objFile.GetValueAsFloat("ExtraPadSetLength", 0.001f, 2);
            m_fExcessPadSetLength = objFile.GetValueAsFloat("ExcessPadSetLength", 0.001f, 2);
            m_fSmearLength = objFile.GetValueAsFloat("SmearLength", 0.05f, 2);  // must mm
            m_fTightSettingTolerance = objFile.GetValueAsFloat("TightSettingTolerance", 0.01f, 2);  // must mm


            // Load Pad Blobs Features
            int intBlobsCount = objFile.GetValueAsInt("BlobsFeaturesCount", 0, 2);
            int intGroupBlobsCount = objFile.GetValueAsInt("GroupBlobsFeaturesCount", 0, 2);
            int intPitchGapCount = objFile.GetValueAsInt("PitchGapCount", 0, 2);

            objFile.GetSecondSection("ColorPadSetting");
            m_intColorDefectLinkMethod = objFile.GetValueAsInt("ColorDefectLinkMethod", 0, 2);
            m_intColorDefectLinkTolerance = objFile.GetValueAsInt("ColorDefectLinkTolerance", 10, 2);
            if (m_intPadROIDirection == 0)
                m_intColorPadGroupIndex = objFile.GetValueAsInt("ColorPadGroupIndex", 0x01, 2);
            else if (m_intPadROIDirection == 1)
                m_intColorPadGroupIndex = objFile.GetValueAsInt("ColorPadGroupIndex", 0x02, 2);
            else if (m_intPadROIDirection == 2)
                m_intColorPadGroupIndex = objFile.GetValueAsInt("ColorPadGroupIndex", 0x04, 2);
            else if (m_intPadROIDirection == 3)
                m_intColorPadGroupIndex = objFile.GetValueAsInt("ColorPadGroupIndex", 0x08, 2);
            else if (m_intPadROIDirection == 4)
                m_intColorPadGroupIndex = objFile.GetValueAsInt("ColorPadGroupIndex", 0x10, 2);
            m_intFailColorOptionMask = objFile.GetValueAsInt("FailColorMask", 0, 2);
            int intColorDefectCount = objFile.GetValueAsInt("ColorDefectCount", 0, 2);
            ClearColorDefect();
            for (int v = 0; v < intColorDefectCount; v++)
            {
                objFile.GetSecondSection("ColorDefect" + v);
                m_arrDefectColorThresName.Add(objFile.GetValueAsString("DefectColorThresName", "", 2));
                m_arrDefectColorSystem.Add(objFile.GetValueAsInt("DefectColorSystem", 0, 2));
                m_arrDefectCloseIteration.Add(objFile.GetValueAsInt("DefectCloseIteration", 0, 2));
                m_arrDefectInvertBlackWhite.Add(objFile.GetValueAsBoolean("DefectInvertBlackWhite", false, 2));
                m_arrDefectColor.Add(new int[3]);
                m_arrDefectColor[v][0] = objFile.GetValueAsInt("DefectColor0", 0, 2);
                m_arrDefectColor[v][1] = objFile.GetValueAsInt("DefectColor1", 0, 2);
                m_arrDefectColor[v][2] = objFile.GetValueAsInt("DefectColor2", 0, 2);
                m_arrDefectColorTolerance.Add(new int[3]);
                m_arrDefectColorTolerance[v][0] = objFile.GetValueAsInt("DefectColorTolerance0", 0, 2);
                m_arrDefectColorTolerance[v][1] = objFile.GetValueAsInt("DefectColorTolerance1", 0, 2);
                m_arrDefectColorTolerance[v][2] = objFile.GetValueAsInt("DefectColorTolerance2", 0, 2);
                m_arrDefectColorMinArea.Add(objFile.GetValueAsInt("DefectColorMinArea", 0, 2));
                m_arrDefectType.Add(objFile.GetValueAsInt("DefectType", 0, 2));
                m_arrDefectImageNo.Add(objFile.GetValueAsInt("DefectImageNo", 0, 2));
                m_arrDefectDontCareMode.Add(objFile.GetValueAsInt("DefectDontCareMode", 0, 2));
                m_arrDefectColorInspection_Top.Add(objFile.GetValueAsInt("DefectColorInspection_Top", 0, 2));
                m_arrDefectColorInspection_Right.Add(objFile.GetValueAsInt("DefectColorInspection_Right", 0, 2));
                m_arrDefectColorInspection_Bottom.Add(objFile.GetValueAsInt("DefectColorInspection_Bottom", 0, 2));
                m_arrDefectColorInspection_Left.Add(objFile.GetValueAsInt("DefectColorInspection_Left", 0, 2));
                m_arrDefectColorInspectionFailCondition.Add(objFile.GetValueAsInt("DefectColorInspectionFailCondition", 0, 2));
                m_arrDefectColorInspectionWidth.Add(objFile.GetValueAsFloat("DefectColorInspectionWidth", 0, 2));
                m_arrDefectColorInspectionLength.Add(objFile.GetValueAsFloat("DefectColorInspectionLength", 0, 2));
                m_arrDefectColorInspectionMinArea.Add(objFile.GetValueAsFloat("DefectColorInspectionMinArea", 0, 2));
                m_arrDefectColorInspectionMaxArea.Add(objFile.GetValueAsFloat("DefectColorInspectionMaxArea", 0, 2));
                m_arrDefectColorInspectionTotalArea.Add(objFile.GetValueAsFloat("DefectColorInspectionTotalArea", 0, 2));

            }

            //ClearTemplateBlobsFeatures(); 
            for (int intBlobIndex = 0; intBlobIndex < intBlobsCount; intBlobIndex++)
            {
                objFile.GetSecondSection("BlobsFeatures" + intBlobIndex);

                SetTemplateBlobsFeatures_ToleranceOnly(
                    intBlobIndex,
                    objFile.GetValueAsFloat("OffSet", 0, 2),
                    objFile.GetValueAsFloat("MinArea", 0, 2),
                    objFile.GetValueAsFloat("MaxArea", 0, 2),
                    objFile.GetValueAsFloat("MinWidth", 0, 2),
                    objFile.GetValueAsFloat("MaxWidth", 0, 2),
                    objFile.GetValueAsFloat("MinHeight", 0, 2),
                    objFile.GetValueAsFloat("MaxHeight", 0, 2),
                    objFile.GetValueAsFloat("MinPitch", 0, 2),
                    objFile.GetValueAsFloat("MaxPitch", 0, 2),
                    objFile.GetValueAsFloat("MinGap", 0, 2),
                    objFile.GetValueAsFloat("MaxGap", 0, 2),
                    objFile.GetValueAsFloat("MaxHole", 0, 2),
                    objFile.GetValueAsFloat("MaxBrokenLength", 0, 2),
                    objFile.GetValueAsFloat("MaxExcess", 0, 2),
                    objFile.GetValueAsFloat("MaxSmearLength", 0, 2),

                    objFile.GetValueAsFloat("MaxEdgeLimitTop", 0, 2),
                    objFile.GetValueAsFloat("MaxEdgeLimitRight", 0, 2),
                    objFile.GetValueAsFloat("MaxEdgeLimitBottom", 0, 2),
                    objFile.GetValueAsFloat("MaxEdgeLimitLeft", 0, 2),

                    objFile.GetValueAsFloat("MaxStandOffTop", 0, 2),
                    objFile.GetValueAsFloat("MaxStandOffBottom", 0, 2),
                    objFile.GetValueAsFloat("MaxStandOffLeft", 0, 2),
                    objFile.GetValueAsFloat("MaxStandOffRight", 0, 2),

                    objFile.GetValueAsFloat("OffsetOffset", 0, 2),
                    objFile.GetValueAsFloat("WidthOffset", 0, 2),
                    objFile.GetValueAsFloat("HeightOffset", 0, 2),
                    objFile.GetValueAsFloat("PitchOffset", 0, 2),
                    objFile.GetValueAsFloat("GapOffset", 0, 2),

                    objFile.GetValueAsFloat("EdgeDistanceTopOffset", 0, 2),
                    objFile.GetValueAsFloat("EdgeDistanceRightOffset", 0, 2),
                    objFile.GetValueAsFloat("EdgeDistanceBottomOffset", 0, 2),
                    objFile.GetValueAsFloat("EdgeDistanceLeftOffset", 0, 2),

                    objFile.GetValueAsFloat("EdgeLimitTopOffset", 0, 2),
                    objFile.GetValueAsFloat("EdgeLimitRightOffset", 0, 2),
                    objFile.GetValueAsFloat("EdgeLimitBottomOffset", 0, 2),
                    objFile.GetValueAsFloat("EdgeLimitLeftOffset", 0, 2),

                    objFile.GetValueAsFloat("StandOffTopOffset", 0, 2),
                    objFile.GetValueAsFloat("StandOffBottomOffset", 0, 2),
                    objFile.GetValueAsFloat("StandOffLeftOffset", 0, 2),
                    objFile.GetValueAsFloat("StandOffRightOffset", 0, 2),

                    objFile.GetValueAsFloat("MinLine3", 0, 2),
                    objFile.GetValueAsFloat("MaxLine3", 0, 2),
                    objFile.GetValueAsFloat("MinLine4", 0, 2),
                    objFile.GetValueAsFloat("MaxLine4", 0, 2),
                    objFile.GetValueAsFloat("MinLine5", 0, 2),
                    objFile.GetValueAsFloat("MaxLine5", 0, 2),
                    objFile.GetValueAsFloat("MinLine6", 0, 2),
                    objFile.GetValueAsFloat("MaxLine6", 0, 2),
                    objFile.GetValueAsFloat("MinLine7", 0, 2),
                    objFile.GetValueAsFloat("MaxLine7", 0, 2),
                    objFile.GetValueAsFloat("MinLine8", 0, 2),
                    objFile.GetValueAsFloat("MaxLine8", 0, 2),
                    objFile.GetValueAsFloat("MinLine9", 0, 2),
                    objFile.GetValueAsFloat("MaxLine9", 0, 2),
                    objFile.GetValueAsFloat("MinLine10", 0, 2),
                    objFile.GetValueAsFloat("MaxLine10", 0, 2),
                    objFile.GetValueAsFloat("MinLine11", 0, 2),
                    objFile.GetValueAsFloat("MaxLine11", 0, 2),
                    objFile.GetValueAsFloat("MinLine12", 0, 2),
                    objFile.GetValueAsFloat("MaxLine12", 0, 2),

                    objFile.GetValueAsFloat("PadInspectionAreaFromTop", 0, 2),
                    objFile.GetValueAsFloat("PadInspectionAreaFromRight", 0, 2),
                    objFile.GetValueAsFloat("PadInspectionAreaFromBottom", 0, 2),
                    objFile.GetValueAsFloat("PadInspectionAreaFromLeft", 0, 2)
                  );
            }

            // Load Group Pad Blobs Features
            //m_arrGroupTemplateBlobPads.Clear();
            for (int intBlobIndex = 0; intBlobIndex < intGroupBlobsCount; intBlobIndex++)
            {
                objFile.GetSecondSection("GroupBlobsFeatures" + intBlobIndex);
                if (intBlobIndex < m_arrGroupTemplateBlobPads.Count)
                {
                    BlobsFeatures m_stcBlobPad = (BlobsFeatures)m_arrGroupTemplateBlobPads[intBlobIndex];
                    m_stcBlobPad.fOffSet = objFile.GetValueAsFloat("OffSet", 0, 2);
                    m_stcBlobPad.fMinArea = objFile.GetValueAsFloat("MinArea", 0, 2);
                    m_stcBlobPad.fMaxArea = objFile.GetValueAsFloat("MaxArea", 0, 2);
                    m_stcBlobPad.fMinWidth = objFile.GetValueAsFloat("MinWidth", 0, 2);
                    m_stcBlobPad.fMaxWidth = objFile.GetValueAsFloat("MaxWidth", 0, 2);
                    m_stcBlobPad.fMinLength = objFile.GetValueAsFloat("MinHeight", 0, 2);
                    m_stcBlobPad.fMaxLength = objFile.GetValueAsFloat("MaxHeight", 0, 2);
                    m_stcBlobPad.fMinPitch = objFile.GetValueAsFloat("MinPitch", 0, 2);
                    m_stcBlobPad.fMaxPitch = objFile.GetValueAsFloat("MaxPitch", 0, 2);
                    m_stcBlobPad.fMinGap = objFile.GetValueAsFloat("MinGap", 0, 2);
                    m_stcBlobPad.fMaxGap = objFile.GetValueAsFloat("MaxGap", 0, 2);
                    m_stcBlobPad.fMaxBroken = objFile.GetValueAsFloat("MaxHole", 0, 2);
                    m_stcBlobPad.fMaxBrokenLength = objFile.GetValueAsFloat("MaxBrokenLength", 0, 2);
                    m_stcBlobPad.fMaxExcess = objFile.GetValueAsFloat("MaxExcess", 0, 2);
                    m_stcBlobPad.fMaxSmearLength = objFile.GetValueAsFloat("MaxSmearLength", 0, 2);

                    m_stcBlobPad.fEdgeLimitTop = objFile.GetValueAsFloat("MaxEdgeLimitTop", 0, 2);
                    m_stcBlobPad.fEdgeLimitRight = objFile.GetValueAsFloat("MaxEdgeLimitRight", 0, 2);
                    m_stcBlobPad.fEdgeLimitBottom = objFile.GetValueAsFloat("MaxEdgeLimitBottom", 0, 2);
                    m_stcBlobPad.fEdgeLimitLeft = objFile.GetValueAsFloat("MaxEdgeLimitLeft", 0, 2);

                    m_stcBlobPad.fMaxStandOffTop = objFile.GetValueAsFloat("MaxStandOffTop", 0, 2);
                    m_stcBlobPad.fMaxStandOffBottom = objFile.GetValueAsFloat("MaxStandOffBottom", 0, 2);
                    m_stcBlobPad.fMaxStandOffLeft = objFile.GetValueAsFloat("MaxStandOffLeft", 0, 2);
                    m_stcBlobPad.fMaxStandOffRight = objFile.GetValueAsFloat("MaxStandOffRight", 0, 2);
                    
                    m_stcBlobPad.fOffsetOffSet = objFile.GetValueAsFloat("OffsetOffSet", 0, 2);
                    m_stcBlobPad.fWidthOffset = objFile.GetValueAsFloat("WidthOffset", 0, 2);
                    m_stcBlobPad.fHeightOffset = objFile.GetValueAsFloat("HeightOffset", 0, 2);
                    m_stcBlobPad.fPitchOffset = objFile.GetValueAsFloat("PitchOffset", 0, 2);
                    m_stcBlobPad.fGapOffset = objFile.GetValueAsFloat("GapOffset", 0, 2);
                    
                    m_stcBlobPad.fEdgeDistanceTopOffset = objFile.GetValueAsFloat("EdgeDistanceTopOffset", 0, 2);
                    m_stcBlobPad.fEdgeDistanceRightOffset = objFile.GetValueAsFloat("EdgeDistanceRightOffset", 0, 2);
                    m_stcBlobPad.fEdgeDistanceBottomOffset = objFile.GetValueAsFloat("EdgeDistanceBottomOffset", 0, 2);
                    m_stcBlobPad.fEdgeDistanceLeftOffset = objFile.GetValueAsFloat("EdgeDistanceLeftOffset", 0, 2);

                    m_stcBlobPad.fEdgeLimitTopOffset = objFile.GetValueAsFloat("EdgeLimitTopOffset", 0, 2);
                    m_stcBlobPad.fEdgeLimitRightOffset = objFile.GetValueAsFloat("EdgeLimitRightOffset", 0, 2);
                    m_stcBlobPad.fEdgeLimitBottomOffset = objFile.GetValueAsFloat("EdgeLimitBottomOffset", 0, 2);
                    m_stcBlobPad.fEdgeLimitLeftOffset = objFile.GetValueAsFloat("EdgeLimitLeftOffset", 0, 2);

                    m_stcBlobPad.fStandOffTopOffset = objFile.GetValueAsFloat("StandOffTopOffset", 0, 2);
                    m_stcBlobPad.fStandOffBottomOffset = objFile.GetValueAsFloat("StandOffBottomOffset", 0, 2);
                    m_stcBlobPad.fStandOffLeftOffset = objFile.GetValueAsFloat("StandOffLeftOffset", 0, 2);
                    m_stcBlobPad.fStandOffRightOffset = objFile.GetValueAsFloat("StandOffRightOffset", 0, 2);

                    m_stcBlobPad.fMinLine3 = objFile.GetValueAsFloat("MinLine3", 0, 2);
                    m_stcBlobPad.fMaxLine3 = objFile.GetValueAsFloat("MaxLine3", 0, 2);
                    m_stcBlobPad.fMinLine4 = objFile.GetValueAsFloat("MinLine4", 0, 2);
                    m_stcBlobPad.fMaxLine4 = objFile.GetValueAsFloat("MaxLine4", 0, 2);
                    m_stcBlobPad.fMinLine5 = objFile.GetValueAsFloat("MinLine5", 0, 2);
                    m_stcBlobPad.fMaxLine5 = objFile.GetValueAsFloat("MaxLine5", 0, 2);
                    m_stcBlobPad.fMinLine6 = objFile.GetValueAsFloat("MinLine6", 0, 2);
                    m_stcBlobPad.fMaxLine6 = objFile.GetValueAsFloat("MaxLine6", 0, 2);
                    m_stcBlobPad.fMinLine7 = objFile.GetValueAsFloat("MinLine7", 0, 2);
                    m_stcBlobPad.fMaxLine7 = objFile.GetValueAsFloat("MaxLine7", 0, 2);
                    m_stcBlobPad.fMinLine8 = objFile.GetValueAsFloat("MinLine8", 0, 2);
                    m_stcBlobPad.fMaxLine8 = objFile.GetValueAsFloat("MaxLine8", 0, 2);
                    m_stcBlobPad.fMinLine9 = objFile.GetValueAsFloat("MinLine9", 0, 2);
                    m_stcBlobPad.fMaxLine9 = objFile.GetValueAsFloat("MaxLine9", 0, 2);
                    m_stcBlobPad.fMinLine10 = objFile.GetValueAsFloat("MinLine10", 0, 2);
                    m_stcBlobPad.fMaxLine10 = objFile.GetValueAsFloat("MaxLine10", 0, 2);
                    m_stcBlobPad.fMinLine11 = objFile.GetValueAsFloat("MinLine11", 0, 2);
                    m_stcBlobPad.fMaxLine11 = objFile.GetValueAsFloat("MaxLine11", 0, 2);
                    m_stcBlobPad.fMinLine12 = objFile.GetValueAsFloat("MinLine12", 0, 2);
                    m_stcBlobPad.fMaxLine12 = objFile.GetValueAsFloat("MaxLine12", 0, 2);

                    m_stcBlobPad.fPadInspectionAreaFromTop = objFile.GetValueAsFloat("PadInspectionAreaFromTop", 0, 2);
                    m_stcBlobPad.fPadInspectionAreaFromRight = objFile.GetValueAsFloat("PadInspectionAreaFromRight", 0, 2);
                    m_stcBlobPad.fPadInspectionAreaFromBottom = objFile.GetValueAsFloat("PadInspectionAreaFromBottom", 0, 2);
                    m_stcBlobPad.fPadInspectionAreaFromLeft = objFile.GetValueAsFloat("PadInspectionAreaFromLeft", 0, 2);

                    m_stcBlobPad.intReferTopBottom = objFile.GetValueAsInt("ReferTopBottom", 0, 2);
                    m_stcBlobPad.blnCheckTop = objFile.GetValueAsBoolean("CheckTop", false, 2);
                    m_stcBlobPad.blnCheckBottom = objFile.GetValueAsBoolean("CheckBottom", false, 2);
                    m_stcBlobPad.intReferLeftRight = objFile.GetValueAsInt("ReferLeftRight", 0, 2);
                    m_stcBlobPad.blnCheckLeft = objFile.GetValueAsBoolean("CheckLeft", false, 2);
                    m_stcBlobPad.blnCheckRight = objFile.GetValueAsBoolean("CheckRight", false, 2);

                    m_arrGroupTemplateBlobPads.RemoveAt(intBlobIndex);
                    m_arrGroupTemplateBlobPads.Insert(intBlobIndex, m_stcBlobPad);
                }
                else
                {
                    BlobsFeatures m_stcBlobPad = new BlobsFeatures();
                    m_stcBlobPad.fOffSet = objFile.GetValueAsFloat("OffSet", 0, 2);
                    m_stcBlobPad.fMinArea = objFile.GetValueAsFloat("MinArea", 0, 2);
                    m_stcBlobPad.fMaxArea = objFile.GetValueAsFloat("MaxArea", 0, 2);
                    m_stcBlobPad.fMinWidth = objFile.GetValueAsFloat("MinWidth", 0, 2);
                    m_stcBlobPad.fMaxWidth = objFile.GetValueAsFloat("MaxWidth", 0, 2);
                    m_stcBlobPad.fMinLength = objFile.GetValueAsFloat("MinHeight", 0, 2);
                    m_stcBlobPad.fMaxLength = objFile.GetValueAsFloat("MaxHeight", 0, 2);
                    m_stcBlobPad.fMinPitch = objFile.GetValueAsFloat("MinPitch", 0, 2);
                    m_stcBlobPad.fMaxPitch = objFile.GetValueAsFloat("MaxPitch", 0, 2);
                    m_stcBlobPad.fMinGap = objFile.GetValueAsFloat("MinGap", 0, 2);
                    m_stcBlobPad.fMaxGap = objFile.GetValueAsFloat("MaxGap", 0, 2);
                    m_stcBlobPad.fMaxBroken = objFile.GetValueAsFloat("MaxHole", 0, 2);
                    m_stcBlobPad.fMaxBrokenLength = objFile.GetValueAsFloat("MaxBrokenLength", 0, 2);
                    m_stcBlobPad.fMaxExcess = objFile.GetValueAsFloat("MaxExcess", 0, 2);
                    m_stcBlobPad.fMaxSmearLength = objFile.GetValueAsFloat("MaxSmearLength", 0, 2);

                    m_stcBlobPad.fEdgeLimitTop = objFile.GetValueAsFloat("MaxEdgeLimitTop", 0, 2);
                    m_stcBlobPad.fEdgeLimitRight = objFile.GetValueAsFloat("MaxEdgeLimitRight", 0, 2);
                    m_stcBlobPad.fEdgeLimitBottom = objFile.GetValueAsFloat("MaxEdgeLimitBottom", 0, 2);
                    m_stcBlobPad.fEdgeLimitLeft = objFile.GetValueAsFloat("MaxEdgeLimitLeft", 0, 2);

                    m_stcBlobPad.fMaxStandOffTop = objFile.GetValueAsFloat("MaxStandOffTop", 0, 2);
                    m_stcBlobPad.fMaxStandOffBottom = objFile.GetValueAsFloat("MaxStandOffBottom", 0, 2);
                    m_stcBlobPad.fMaxStandOffLeft = objFile.GetValueAsFloat("MaxStandOffLeft", 0, 2);
                    m_stcBlobPad.fMaxStandOffRight = objFile.GetValueAsFloat("MaxStandOffRight", 0, 2);
                    
                    m_stcBlobPad.fOffsetOffSet = objFile.GetValueAsFloat("OffsetOffSet", 0, 2);
                    m_stcBlobPad.fWidthOffset = objFile.GetValueAsFloat("WidthOffset", 0, 2);
                    m_stcBlobPad.fHeightOffset = objFile.GetValueAsFloat("HeightOffset", 0, 2);
                    m_stcBlobPad.fPitchOffset = objFile.GetValueAsFloat("PitchOffset", 0, 2);
                    m_stcBlobPad.fGapOffset = objFile.GetValueAsFloat("GapOffset", 0, 2);

                    m_stcBlobPad.fEdgeDistanceTopOffset = objFile.GetValueAsFloat("EdgeDistanceTopOffset", 0, 2);
                    m_stcBlobPad.fEdgeDistanceRightOffset = objFile.GetValueAsFloat("EdgeDistanceRightOffset", 0, 2);
                    m_stcBlobPad.fEdgeDistanceBottomOffset = objFile.GetValueAsFloat("EdgeDistanceBottomOffset", 0, 2);
                    m_stcBlobPad.fEdgeDistanceLeftOffset = objFile.GetValueAsFloat("EdgeDistanceLeftOffset", 0, 2);

                    m_stcBlobPad.fEdgeLimitTopOffset = objFile.GetValueAsFloat("EdgeLimitTopOffset", 0, 2);
                    m_stcBlobPad.fEdgeLimitRightOffset = objFile.GetValueAsFloat("EdgeLimitRightOffset", 0, 2);
                    m_stcBlobPad.fEdgeLimitBottomOffset = objFile.GetValueAsFloat("EdgeLimitBottomOffset", 0, 2);
                    m_stcBlobPad.fEdgeLimitLeftOffset = objFile.GetValueAsFloat("EdgeLimitLeftOffset", 0, 2);

                    m_stcBlobPad.fStandOffTopOffset = objFile.GetValueAsFloat("StandOffTopOffset", 0, 2);
                    m_stcBlobPad.fStandOffBottomOffset = objFile.GetValueAsFloat("StandOffBottomOffset", 0, 2);
                    m_stcBlobPad.fStandOffLeftOffset = objFile.GetValueAsFloat("StandOffLeftOffset", 0, 2);
                    m_stcBlobPad.fStandOffRightOffset = objFile.GetValueAsFloat("StandOffRightOffset", 0, 2);

                    m_stcBlobPad.fMinLine3 = objFile.GetValueAsFloat("MinLine3", 0, 2);
                    m_stcBlobPad.fMaxLine3 = objFile.GetValueAsFloat("MaxLine3", 0, 2);
                    m_stcBlobPad.fMinLine4 = objFile.GetValueAsFloat("MinLine4", 0, 2);
                    m_stcBlobPad.fMaxLine4 = objFile.GetValueAsFloat("MaxLine4", 0, 2);
                    m_stcBlobPad.fMinLine5 = objFile.GetValueAsFloat("MinLine5", 0, 2);
                    m_stcBlobPad.fMaxLine5 = objFile.GetValueAsFloat("MaxLine5", 0, 2);
                    m_stcBlobPad.fMinLine6 = objFile.GetValueAsFloat("MinLine6", 0, 2);
                    m_stcBlobPad.fMaxLine6 = objFile.GetValueAsFloat("MaxLine6", 0, 2);
                    m_stcBlobPad.fMinLine7 = objFile.GetValueAsFloat("MinLine7", 0, 2);
                    m_stcBlobPad.fMaxLine7 = objFile.GetValueAsFloat("MaxLine7", 0, 2);
                    m_stcBlobPad.fMinLine8 = objFile.GetValueAsFloat("MinLine8", 0, 2);
                    m_stcBlobPad.fMaxLine8 = objFile.GetValueAsFloat("MaxLine8", 0, 2);
                    m_stcBlobPad.fMinLine9 = objFile.GetValueAsFloat("MinLine9", 0, 2);
                    m_stcBlobPad.fMaxLine9 = objFile.GetValueAsFloat("MaxLine9", 0, 2);
                    m_stcBlobPad.fMinLine10 = objFile.GetValueAsFloat("MinLine10", 0, 2);
                    m_stcBlobPad.fMaxLine10 = objFile.GetValueAsFloat("MaxLine10", 0, 2);
                    m_stcBlobPad.fMinLine11 = objFile.GetValueAsFloat("MinLine11", 0, 2);
                    m_stcBlobPad.fMaxLine11 = objFile.GetValueAsFloat("MaxLine11", 0, 2);
                    m_stcBlobPad.fMinLine12 = objFile.GetValueAsFloat("MinLine12", 0, 2);
                    m_stcBlobPad.fMaxLine12 = objFile.GetValueAsFloat("MaxLine12", 0, 2);

                    m_stcBlobPad.fPadInspectionAreaFromTop = objFile.GetValueAsFloat("PadInspectionAreaFromTop", 0, 2);
                    m_stcBlobPad.fPadInspectionAreaFromRight = objFile.GetValueAsFloat("PadInspectionAreaFromRight", 0, 2);
                    m_stcBlobPad.fPadInspectionAreaFromBottom = objFile.GetValueAsFloat("PadInspectionAreaFromBottom", 0, 2);
                    m_stcBlobPad.fPadInspectionAreaFromLeft = objFile.GetValueAsFloat("PadInspectionAreaFromLeft", 0, 2);

                    m_stcBlobPad.intReferTopBottom = objFile.GetValueAsInt("ReferTopBottom", 0, 2);
                    m_stcBlobPad.blnCheckTop = objFile.GetValueAsBoolean("CheckTop", false, 2);
                    m_stcBlobPad.blnCheckBottom = objFile.GetValueAsBoolean("CheckBottom", false, 2);
                    m_stcBlobPad.intReferLeftRight = objFile.GetValueAsInt("ReferLeftRight", 0, 2);
                    m_stcBlobPad.blnCheckLeft = objFile.GetValueAsBoolean("CheckLeft", false, 2);
                    m_stcBlobPad.blnCheckRight = objFile.GetValueAsBoolean("CheckRight", false, 2);

                    m_arrGroupTemplateBlobPads.Add(m_stcBlobPad);
                }
            }

            // Load Pitch Gap
            //ClearTemplatePitchGap();
            for (int intPitchGapIndex = 0; intPitchGapIndex < intPitchGapCount; intPitchGapIndex++)
            {
                objFile.GetSecondSection("PitchGap" + intPitchGapIndex);
                SetPitchGapToleranceOnly(
                    intPitchGapIndex,
                    objFile.GetValueAsFloat("MinPitch", 0, 2),
                    objFile.GetValueAsFloat("MaxPitch", 0, 2),
                    objFile.GetValueAsFloat("MinGap", 0, 2),
                    objFile.GetValueAsFloat("MaxGap", 0, 2)
                    );
            }

            // Load Package
            objFile.GetSecondSection("PackageSetting");

            //PackageSize Offset
            m_fPackageWidthOffsetMM = objFile.GetValueAsFloat("PackageWidthOffsetMM", 0, 2);
            m_fPackageHeightOffsetMM = objFile.GetValueAsFloat("PackageHeightOffsetMM", 0, 2);
            m_fPackageThicknessOffsetMM = objFile.GetValueAsFloat("PackageThicknessOffsetMM", 0, 2);

            m_fUnitWidth = objFile.GetValueAsFloat("UnitWidth", 0, 2);
            m_fUnitHeight = objFile.GetValueAsFloat("UnitHeight", 0, 2);
            m_fUnitThickness = objFile.GetValueAsFloat("UnitThickness", 0, 2);
            m_fUnitWidthMin = objFile.GetValueAsFloat("UnitWidthMin", 0, 2);
            m_fUnitWidthMax = objFile.GetValueAsFloat("UnitWidthMax", 0, 2);
            m_fUnitHeightMin = objFile.GetValueAsFloat("UnitHeightMin", 0, 2);
            m_fUnitHeightMax = objFile.GetValueAsFloat("UnitHeightMax", 0, 2);
            m_fUnitThicknessMin = objFile.GetValueAsFloat("UnitThicknessMin", 0, 2);
            m_fUnitThicknessMax = objFile.GetValueAsFloat("UnitThicknessMax", 0, 2);

            m_fUnitSizeLength = objFile.GetValueAsFloat("UnitSizeLength", 0, 2);
            m_fCrackLength = objFile.GetValueAsFloat("CrackLength", 0, 2);
            m_fScratchLength = objFile.GetValueAsFloat("ScratchLength", 0, 2);
            m_fScratchArea = objFile.GetValueAsFloat("ScratchArea", 0, 2);
            m_fChipArea = objFile.GetValueAsFloat("ChipArea", 0, 2);
            m_fContaminationLength = objFile.GetValueAsFloat("ContaminationLength", 0, 2);
            m_fSolderMeltLength = objFile.GetValueAsFloat("SolderMeltLength", 0, 2);
            m_fVoidLength = objFile.GetValueAsFloat("VoidLength", 0, 2);
            m_fVoidArea = objFile.GetValueAsFloat("VoidArea", 0, 2);
            m_fCrackLength = objFile.GetValueAsFloat("CrackLength", 0, 2);
            m_fCrackArea = objFile.GetValueAsFloat("CrackArea", 0, 2);
            m_fForeignMaterialArea = objFile.GetValueAsFloat("ForeignMaterialArea", 0, 2);
            m_fMoldFlashLength = objFile.GetValueAsFloat("MoldFlashLength_Real", 0, 2);
            m_fMoldFlashWidth = objFile.GetValueAsFloat("MoldFlashWidth", 0, 2);
            m_fMoldFlashArea = objFile.GetValueAsFloat("MoldFlashLength", 0, 2);
            m_fMoldFlashTotalArea = objFile.GetValueAsFloat("MoldFlashTotalArea", 0, 2);
            m_fInCompletePlateLength = objFile.GetValueAsFloat("InCompletePlateLength", 0, 2);
            m_fPadBrokenLength = objFile.GetValueAsFloat("PadBrokenLength", 0, 2);

            m_intMoldFlashDefectDimensionFailCondition = objFile.GetValueAsInt("MoldFlashDefectDimensionFailCondition", 0, 2);
            m_intBrightDefectDimensionFailCondition = objFile.GetValueAsInt("BrightDefectDimensionFailCondition", 0, 2);
            m_intForeignMaterialBrightDefectDimensionFailCondition = objFile.GetValueAsInt("ForeignMaterialBrightDefectDimensionFailCondition", 0, 2);
            m_intDarkDefectDimensionFailCondition = objFile.GetValueAsInt("DarkDefectDimensionFailCondition", 0, 2);
            m_intCrackDarkDefectDimensionFailCondition = objFile.GetValueAsInt("CrackDarkDefectDimensionFailCondition", 0, 2);

            m_fBrightLength = objFile.GetValueAsFloat("BrightLength", 0, 2);
            m_fBrightWidth = objFile.GetValueAsFloat("BrightWidth", 0, 2);
            m_fBrightArea = objFile.GetValueAsFloat("BrightArea", 0, 2);
            m_fBrightTotalArea = objFile.GetValueAsFloat("BrightTotalArea", 0, 2);
            m_fDarkLength = objFile.GetValueAsFloat("DarkLength", 0, 2);
            m_fDarkWidth = objFile.GetValueAsFloat("DarkWidth", 0, 2);
            m_fDarkArea = objFile.GetValueAsFloat("DarkArea", 0, 2);
            m_fDarkTotalArea = objFile.GetValueAsFloat("DarkTotalArea", 0, 2);
            m_fBrightChippedOffArea = objFile.GetValueAsFloat("BrightChippedOffArea", 0, 2);
            m_fDarkChippedOffArea = objFile.GetValueAsFloat("DarkChippedOffArea", 0, 2);
            m_fDarkVerticalCrack = objFile.GetValueAsFloat("DarkVerticalCrack", 0, 2);
            m_fDarkHorizontalCrack = objFile.GetValueAsFloat("DarkHorizontalCrack", 0, 2);
            m_fBrightVerticalForeignMaterial = objFile.GetValueAsFloat("BrightVerticalForeignMaterial", 0, 2);
            m_fBrightHorizontalForeignMaterial = objFile.GetValueAsFloat("BrightHorizontalForeignMaterial", 0, 2);
        }
        public void LoadColorPadOnly(string strPath, string strSectionName)
        {
            XmlParser objFile = new XmlParser(strPath);

            objFile.GetFirstSection(strSectionName);

            objFile.GetSecondSection("ColorPadSetting");
            m_intColorDefectLinkMethod = objFile.GetValueAsInt("ColorDefectLinkMethod", 0, 2);
            m_intColorDefectLinkTolerance = objFile.GetValueAsInt("ColorDefectLinkTolerance", 10, 2);
            if (m_intPadROIDirection == 0)
                m_intColorPadGroupIndex = objFile.GetValueAsInt("ColorPadGroupIndex", 0x01, 2);
            else if (m_intPadROIDirection == 1)
                m_intColorPadGroupIndex = objFile.GetValueAsInt("ColorPadGroupIndex", 0x02, 2);
            else if (m_intPadROIDirection == 2)
                m_intColorPadGroupIndex = objFile.GetValueAsInt("ColorPadGroupIndex", 0x04, 2);
            else if (m_intPadROIDirection == 3)
                m_intColorPadGroupIndex = objFile.GetValueAsInt("ColorPadGroupIndex", 0x08, 2);
            else if (m_intPadROIDirection == 4)
                m_intColorPadGroupIndex = objFile.GetValueAsInt("ColorPadGroupIndex", 0x10, 2);
            m_intFailColorOptionMask = objFile.GetValueAsInt("FailColorMask", 0, 2);
            int intColorDefectCount = objFile.GetValueAsInt("ColorDefectCount", 0, 2);
            ClearColorDefect();
            for (int v = 0; v < intColorDefectCount; v++)
            {
                objFile.GetSecondSection("ColorDefect" + v);
                m_arrDefectColorThresName.Add(objFile.GetValueAsString("DefectColorThresName", "", 2));
                m_arrDefectColorSystem.Add(objFile.GetValueAsInt("DefectColorSystem", 0, 2));
                m_arrDefectCloseIteration.Add(objFile.GetValueAsInt("DefectCloseIteration", 0, 2));
                m_arrDefectInvertBlackWhite.Add(objFile.GetValueAsBoolean("DefectInvertBlackWhite", false, 2));
                m_arrDefectColor.Add(new int[3]);
                m_arrDefectColor[v][0] = objFile.GetValueAsInt("DefectColor0", 0, 2);
                m_arrDefectColor[v][1] = objFile.GetValueAsInt("DefectColor1", 0, 2);
                m_arrDefectColor[v][2] = objFile.GetValueAsInt("DefectColor2", 0, 2);
                m_arrDefectColorTolerance.Add(new int[3]);
                m_arrDefectColorTolerance[v][0] = objFile.GetValueAsInt("DefectColorTolerance0", 0, 2);
                m_arrDefectColorTolerance[v][1] = objFile.GetValueAsInt("DefectColorTolerance1", 0, 2);
                m_arrDefectColorTolerance[v][2] = objFile.GetValueAsInt("DefectColorTolerance2", 0, 2);
                m_arrDefectColorMinArea.Add(objFile.GetValueAsInt("DefectColorMinArea", 0, 2));
                m_arrDefectType.Add(objFile.GetValueAsInt("DefectType", 0, 2));
                m_arrDefectImageNo.Add(objFile.GetValueAsInt("DefectImageNo", 0, 2));
                m_arrDefectDontCareMode.Add(objFile.GetValueAsInt("DefectDontCareMode", 0, 2));
                m_arrDefectColorInspection_Top.Add(objFile.GetValueAsInt("DefectColorInspection_Top", 0, 2));
                m_arrDefectColorInspection_Right.Add(objFile.GetValueAsInt("DefectColorInspection_Right", 0, 2));
                m_arrDefectColorInspection_Bottom.Add(objFile.GetValueAsInt("DefectColorInspection_Bottom", 0, 2));
                m_arrDefectColorInspection_Left.Add(objFile.GetValueAsInt("DefectColorInspection_Left", 0, 2));
                m_arrDefectColorInspectionFailCondition.Add(objFile.GetValueAsInt("DefectColorInspectionFailCondition", 0, 2));
                m_arrDefectColorInspectionWidth.Add(objFile.GetValueAsFloat("DefectColorInspectionWidth", 0, 2));
                m_arrDefectColorInspectionLength.Add(objFile.GetValueAsFloat("DefectColorInspectionLength", 0, 2));
                m_arrDefectColorInspectionMinArea.Add(objFile.GetValueAsFloat("DefectColorInspectionMinArea", 0, 2));
                m_arrDefectColorInspectionMaxArea.Add(objFile.GetValueAsFloat("DefectColorInspectionMaxArea", 0, 2));
                m_arrDefectColorInspectionTotalArea.Add(objFile.GetValueAsFloat("DefectColorInspectionTotalArea", 0, 2));
            }

        }
        public void LoadPadGoldenData(string strPath, string strSectionName)
        {
            XmlParser objFile = new XmlParser(strPath);
            objFile.GetFirstSection(strSectionName);

            int intGoldenDataSetCount = objFile.GetValueAsInt("GoldenDataSetCount", 0, 1);

            m_arrGoldenData.Clear();
            m_arrGoldenDataUsed.Clear();
            for (int i = 0; i < intGoldenDataSetCount; i++)
            {
                m_arrGoldenData.Add(new List<List<float>>());
                m_arrGoldenDataUsed.Add(new bool());

                objFile.GetSecondSection("GoldenDataSet" + i.ToString());

                m_arrGoldenDataUsed[i] = objFile.GetValueAsBoolean("GoldenDataUsed", false, 2);
                int intGoldenDataCount = objFile.GetValueAsInt("GoldenDataCount", 0, 2);

                for (int j = 0; j < intGoldenDataCount; j++)
                {
                    m_arrGoldenData[i].Add(new List<float>());

                    m_arrGoldenData[i][j].Add(objFile.GetValueAsFloat("Width" + j.ToString(), 0, 2));
                    m_arrGoldenData[i][j].Add(objFile.GetValueAsFloat("Length" + j.ToString(), 0, 2));
                    m_arrGoldenData[i][j].Add(objFile.GetValueAsFloat("Pitch" + j.ToString(), 0, 2));
                    m_arrGoldenData[i][j].Add(objFile.GetValueAsFloat("Gap" + j.ToString(), 0, 2));
                }
            }
        }

        public void LoadPadTemplateImage(string strFolderPath, int intPadIndex)
        {
            ROI objROI = new ROI();

            if (File.Exists(strFolderPath + "SearchROITemplate" + intPadIndex + ".bmp"))
            {
                objROI.LoadImage(strFolderPath + "SearchROITemplate" + intPadIndex + ".bmp", false);
                DefineTemplatePadContour(objROI);

            }

            if (File.Exists(strFolderPath + "Pad" + intPadIndex.ToString() + ".bmp"))
                m_ImgUnitTemplateImage_CleanBackground.Load(strFolderPath + "Pad" + intPadIndex.ToString() + ".bmp");

            // Load from LoadPadPackageTemplateImage function
            //if (File.Exists(strFolderPath + "UnitTemplate" + intPadIndex + ".bmp"))
            //    AddTemplateImage(strFolderPath + "UnitTemplate" + intPadIndex + ".bmp");

            //// Load Package Erode and Dilate image
            //if (File.Exists(strFolderPath + "PackageImage" + intPadIndex + "_0.bmp"))
            //    m_ErodeROI.LoadImage(strFolderPath + "PackageImage" + intPadIndex + "_0.bmp", false);
            //if (File.Exists(strFolderPath + "PackageImage" + intPadIndex + "_1.bmp"))
            //    m_DilateROI.LoadImage(strFolderPath + "PackageImage" + intPadIndex + "_1.bmp", false);
            if (File.Exists(strFolderPath + "UnitToleranceTemplate" + intPadIndex + ".bmp"))
                AddTemplateImage(strFolderPath + "UnitToleranceTemplate" + intPadIndex + ".bmp");

            //// Load Package Erode and Dilate image
            //if (File.Exists(strFolderPath + "PackageImage" + intPadIndex + "_0.bmp"))
            //    m_ErodeROI.LoadImage(strFolderPath + "PackageImage" + intPadIndex + "_0.bmp", false);
            //if (File.Exists(strFolderPath + "PackageImage" + intPadIndex + "_1.bmp"))
            //    m_DilateROI.LoadImage(strFolderPath + "PackageImage" + intPadIndex + "_1.bmp", false);

            m_arrImgPadImage.Clear();
            int intBlobsCount = GetBlobsFeaturesNumber();
            for (int i = 0; i < intBlobsCount; i++)
            {
                // 2022 03 25 - CCENG: Add array here, not check inside If. 
                //                     Sometime pad recipe corrupted. Image is missing. This will cause i bigger than m_arrImgPadImage count and index out of range error will happen.
                m_arrImgPadImage.Add(new EImageBW8());
                if (File.Exists(strFolderPath + "Pad" + intPadIndex.ToString() + "_" + i.ToString() + ".bmp"))
                {
                    //for (int j = m_arrImgPadImage.Count; j <= i; j++)
                    //    m_arrImgPadImage.Add(new EImageBW8());
                    m_arrImgPadImage[i].Load(strFolderPath + "Pad" + intPadIndex.ToString() + "_" + i.ToString() + ".bmp");
                }
            }

            LoadUnitPattern(strFolderPath + "UnitMatcher" + intPadIndex.ToString() + ".mch");

            if (File.Exists(strFolderPath + "DontCareImage" + intPadIndex.ToString() + "_0.bmp"))
                m_objPadDontCareImage.LoadImage(strFolderPath + "DontCareImage" + intPadIndex.ToString() + "_0.bmp");

            for (int i = 0; i < m_arrDefectColorThresName.Count; i++)
            {
                if (File.Exists(strFolderPath + "ColorDontCareImage" + intPadIndex.ToString() + "_" + i.ToString() + ".bmp"))
                    m_arrPadColorDontCareImage[i].LoadImage(strFolderPath + "ColorDontCareImage" + intPadIndex.ToString() + "_" + i.ToString() + ".bmp");
            }

            objROI.Dispose();
        }


        public void LoadPadPackageTemplateImage(string strFolderPath, int intPadIndex)
        {
            //ROI objROI = new ROI();

            //if (File.Exists(strFolderPath + "SearchROITemplate" + intPadIndex + ".bmp"))
            //{
            //    objROI.LoadImage(strFolderPath + "SearchROITemplate" + intPadIndex + ".bmp", false);
            //    DefineTemplatePadContour(objROI);

            //}

            if (File.Exists(strFolderPath + "UnitPackageTemplate" + intPadIndex + ".bmp"))
                AddPackageTemplateImage(strFolderPath + "UnitPackageTemplate" + intPadIndex + ".bmp");

            // Load Package Erode and Dilate image
            if (File.Exists(strFolderPath + "PkgImage" + intPadIndex + "_0.bmp"))
                m_ErodeROI.LoadImage(strFolderPath + "PkgImage" + intPadIndex + "_0.bmp", false);
            if (File.Exists(strFolderPath + "PkgImage" + intPadIndex + "_1.bmp"))
                m_DilateROI.LoadImage(strFolderPath + "PkgImage" + intPadIndex + "_1.bmp", false);

            if (File.Exists(strFolderPath + "Tilt_Top_L.bmp"))
                m_ImgTilt_Top_L.LoadImage(strFolderPath + "Tilt_Top_L.bmp");
            if (File.Exists(strFolderPath + "Tilt_Top_R.bmp"))
                m_ImgTilt_Top_R.LoadImage(strFolderPath + "Tilt_Top_R.bmp");
            if (File.Exists(strFolderPath + "Tilt_Right_T.bmp"))
                m_ImgTilt_Right_T.LoadImage(strFolderPath + "Tilt_Right_T.bmp");
            if (File.Exists(strFolderPath + "Tilt_Right_B.bmp"))
                m_ImgTilt_Right_B.LoadImage(strFolderPath + "Tilt_Right_B.bmp");
            if (File.Exists(strFolderPath + "Tilt_Bottom_R.bmp"))
                m_ImgTilt_Bottom_R.LoadImage(strFolderPath + "Tilt_Bottom_R.bmp");
            if (File.Exists(strFolderPath + "Tilt_Bottom_L.bmp"))
                m_ImgTilt_Bottom_L.LoadImage(strFolderPath + "Tilt_Bottom_L.bmp");
            if (File.Exists(strFolderPath + "Tilt_Left_B.bmp"))
                m_ImgTilt_Left_B.LoadImage(strFolderPath + "Tilt_Left_B.bmp");
            if (File.Exists(strFolderPath + "Tilt_Left_T.bmp"))
                m_ImgTilt_Left_T.LoadImage(strFolderPath + "Tilt_Left_T.bmp");

            if (File.Exists(strFolderPath + "TiltInverted_Top_L.bmp"))
                m_ImgTiltInverted_Top_L.LoadImage(strFolderPath + "TiltInverted_Top_L.bmp");
            if (File.Exists(strFolderPath + "TiltInverted_Top_R.bmp"))
                m_ImgTiltInverted_Top_R.LoadImage(strFolderPath + "TiltInverted_Top_R.bmp");
            if (File.Exists(strFolderPath + "TiltInverted_Right_T.bmp"))
                m_ImgTiltInverted_Right_T.LoadImage(strFolderPath + "TiltInverted_Right_T.bmp");
            if (File.Exists(strFolderPath + "TiltInverted_Right_B.bmp"))
                m_ImgTiltInverted_Right_B.LoadImage(strFolderPath + "TiltInverted_Right_B.bmp");
            if (File.Exists(strFolderPath + "TiltInverted_Bottom_R.bmp"))
                m_ImgTiltInverted_Bottom_R.LoadImage(strFolderPath + "TiltInverted_Bottom_R.bmp");
            if (File.Exists(strFolderPath + "TiltInverted_Bottom_L.bmp"))
                m_ImgTiltInverted_Bottom_L.LoadImage(strFolderPath + "TiltInverted_Bottom_L.bmp");
            if (File.Exists(strFolderPath + "TiltInverted_Left_B.bmp"))
                m_ImgTiltInverted_Left_B.LoadImage(strFolderPath + "TiltInverted_Left_B.bmp");
            if (File.Exists(strFolderPath + "TiltInverted_Left_T.bmp"))
                m_ImgTiltInverted_Left_T.LoadImage(strFolderPath + "TiltInverted_Left_T.bmp");

            if (File.Exists(strFolderPath + "DontCareImage" + intPadIndex.ToString() + "_0.bmp"))
                m_objPackageDontCareImageWhite.LoadImage(strFolderPath + "DontCareImage" + intPadIndex.ToString() + "_0.bmp");
            if (File.Exists(strFolderPath + "DontCareImage" + intPadIndex.ToString() + "_1.bmp"))
                m_objPackageDontCareImageBlack.LoadImage(strFolderPath + "DontCareImage" + intPadIndex.ToString() + "_1.bmp");

            //m_arrImgPadImage.Clear();
            //int intBlobsCount = GetBlobsFeaturesNumber();
            //for (int i = 0; i < intBlobsCount; i++)
            //{
            //    if (File.Exists(strFolderPath + "Pad" + intPadIndex.ToString() + "_" + i.ToString() + ".bmp"))
            //    {
            //        m_arrImgPadImage.Add(new EImageBW8());
            //        m_arrImgPadImage[i].Load(strFolderPath + "Pad" + intPadIndex.ToString() + "_" + i.ToString() + ".bmp");
            //    }
            //}

            //LoadUnitPattern(strFolderPath + "UnitMatcher" + intPadIndex.ToString() + ".mch");

            //objROI.Dispose();
        }

        // ------------------ Package Function ---------------------------------------------------------------------

        private bool IsImage1UnitChippedOff2(ROI objImage1UnitROI, int intImageIndex)
        {
            /*
             * Algoritm:
             * 
             *
             * 
             * 
             * 
             * 
             */

            //if (m_fChipStartPixelFromEdge == 0) // No checking for chippedoff if tolerance setting is 0
            //    return true;

            bool blnResult = true;
            bool blnDebugImage = false;

            // Get Chipped off setting length in pixel
            int intCeilChipLengthX = (int)Math.Ceiling(m_fChipStartPixelFromEdge * m_fMMToPixelXValue);
            int intCeilChipLengthY = (int)Math.Ceiling(m_fChipStartPixelFromEdge * m_fMMToPixelYValue);

            ROI objChippedOffROI = new ROI();
            objChippedOffROI.AttachImage(m_objInsSurfacePkgImage1); // m_objInsSurfacePkgImage1 is sample image after double threshold
            //objChippedOffROI.LoadROISetting(objImage1UnitROI.ref_ROITotalX,
            //                                            objImage1UnitROI.ref_ROITotalY,
            //                                            objImage1UnitROI.ref_ROIWidth,
            //                                            objImage1UnitROI.ref_ROIHeight);
            objChippedOffROI.LoadROISetting(0, 0, objImage1UnitROI.ref_ROIWidth, objImage1UnitROI.ref_ROIHeight);
            objChippedOffROI.CopyToImage(ref m_objInsChipOffPkgImage1); // Copy sample image to another image memory so that image can be modified without affect the original image.
            objChippedOffROI.AttachImage(m_objInsChipOffPkgImage1);
            objChippedOffROI.LoadROISetting(0, 0, m_objInsChipOffPkgImage1.ref_intImageWidth, m_objInsChipOffPkgImage1.ref_intImageHeight);

            if (blnDebugImage)
            {
                m_objInsSurfacePkgImage1.SaveImage("D:\\TS\\m_objInsSurfacePkgImage1.bmp");
                objChippedOffROI.SaveImage("D:\\TS\\Bf_Sb_objChippedOffROI.bmp");// debug 
            }

            FillChipLineLimitToCorner(m_objInsChipOffPkgImage1, intCeilChipLengthX, intCeilChipLengthY, 0);

            //m_objImage1ChipOffEBlobs.BuildObjects_Filter_GetElement(objChippedOffROI, false, true, 0, 125,
            //    Math.Min(intCeilChipLengthX, intCeilChipLengthY), 999999, false, 0x0F);

            // 2019 03 04 - JBTAN: Use self-defined minimum build blob area by user
            switch (intImageIndex)
            {
                case 0: // Image 1 (Grab 1 & Grab 2 Merged)
                    {
                        m_objImage1ChipOffEBlobs.BuildObjects_Filter_GetElement(objChippedOffROI, false, true, 0, 125,
                            (int)Math.Floor(m_fSurfaceMinArea), 999999, false, 0x0F);
                    }
                    break;
                case 2: // Image 2 (Grab 3)
                    {
                        m_objImage1ChipOffEBlobs.BuildObjects_Filter_GetElement(objChippedOffROI, false, true, 0, 125,
                            (int)Math.Floor(m_fImage2SurfaceMinArea), 999999, false, 0x0F);
                    }
                    break;
            }

            if (blnDebugImage)
            {
                objImage1UnitROI.SaveImage("D:\\TS\\objImage1UnitROI2.bmp");// debug
                objChippedOffROI.SaveImage("D:\\TS\\objChippedOffROI2.bmp");// debug 
            }

            if (m_objImage1ChipOffEBlobs.ref_intNumSelectedObject > 0)
            {
                float fDefectLengthPixelX = m_fChipStartPixelFromEdge * m_fMMToPixelXValue;
                float fDefectLengthPixelY = m_fChipStartPixelFromEdge * m_fMMToPixelYValue;
                int intObjectArea = 0;
                float fObjectHeight = 0, fObjectWidth = 0, fObjectCenterX = 0, fObjectCenterY = 0;
                float fStartX, fStartY, fEndX, fEndY;
                float fOuterStartX = 1;
                float fOuterStartY = 1;
                float fOuterEndX = objChippedOffROI.ref_ROIWidth;
                float fOuterEndY = objChippedOffROI.ref_ROIHeight;
                float fInterStartX = fDefectLengthPixelX;
                float fInterStartY = fDefectLengthPixelY;
                float fInterEndX = (float)objChippedOffROI.ref_ROIWidth - fDefectLengthPixelX - 1;
                float fInterEndY = (float)objChippedOffROI.ref_ROIHeight - fDefectLengthPixelY - 1;
                // float fTolerance = 2f;
                float fTolerance = Math.Min(fDefectLengthPixelX, fDefectLengthPixelY) / 2;
                int intFailCount = 0;

                for (int i = 0; i < m_objImage1ChipOffEBlobs.ref_intNumSelectedObject; i++)
                {
                    fObjectCenterX = m_objImage1ChipOffEBlobs.ref_arrLimitCenterX[i];
                    fObjectCenterY = m_objImage1ChipOffEBlobs.ref_arrLimitCenterY[i];
                    fObjectWidth = m_objImage1ChipOffEBlobs.ref_arrWidth[i];
                    fObjectHeight = m_objImage1ChipOffEBlobs.ref_arrHeight[i];
                    intObjectArea = m_objImage1ChipOffEBlobs.ref_arrArea[i];

                    fStartX = (float)Math.Floor(fObjectCenterX - (fObjectWidth / 2));
                    fStartY = (float)Math.Floor(fObjectCenterY - (fObjectHeight / 2));
                    fEndX = (float)Math.Ceiling(fObjectCenterX + (fObjectWidth / 2));
                    fEndY = (float)Math.Ceiling(fObjectCenterY + (fObjectHeight / 2));

                    bool blnDefect = false;
                    float fAddX = 0;
                    float fAddY = 0;
                    bool blnFailWidth = false;

                    if (fStartX < fInterStartX) // Possible Left Chipped
                    {
                        if (fStartY < fInterStartY) // Possible Top Chipped
                        {
                            if (fStartX < fStartY)  // Confirm Left Chipped
                            {
                                if (fObjectWidth >= fDefectLengthPixelX)  // Is Chipped over setting min value
                                {
                                    blnDefect = true;
                                    blnFailWidth = true;
                                }
                                else if ((fObjectCenterX - fObjectWidth / 2) > 0)
                                {
                                    //if (fObjectWidth == intCeilChipLengthX - fTolerance)    // Is Chipped same length with chip setting + tolerance
                                    if (fObjectWidth >= intCeilChipLengthX - fTolerance)    // Is Chipped over chip setting - tolerance
                                    {
                                        //if ((fTolerance - (fObjectCenterX + fObjectWidth / 2)) <= fTolerance) // Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                                        if ((fTolerance - (fObjectCenterX + fObjectWidth / 2)) <= 1) // Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                                        {
                                            blnDefect = true;
                                            blnFailWidth = true;
                                            fAddX = fObjectCenterX - fObjectWidth / 2;
                                        }
                                    }
                                }
                            }
                            else // Confirm Top Chipped
                            {
                                if (fObjectHeight >= fDefectLengthPixelY) // Is Chipped over setting min value
                                {
                                    blnDefect = true;
                                }
                                else if ((fObjectCenterY - fObjectHeight / 2) > 0)
                                {
                                    //if (fObjectHeight == intCeilChipLengthY - fTolerance) // Is Chipped same length with chip setting + tolerance
                                    if (fObjectHeight >= intCeilChipLengthY - fTolerance)    // Is Chipped over chip setting - tolerance
                                    {
                                        //if ((fInterStartY - (fObjectCenterY + fObjectHeight / 2)) <= fTolerance)// Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                                        if ((fInterStartY - (fObjectCenterY + fObjectHeight / 2)) <= 1)// Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                                        {
                                            blnDefect = true;
                                            fAddY = fObjectCenterY - fObjectHeight / 2;
                                        }
                                    }
                                }

                            }
                        }
                        else if (fEndY > fInterEndY)    // Possible Bottom Chipped
                        {
                            if (fStartX < (objChippedOffROI.ref_ROIHeight - fEndY)) // Confirm Left Chipped
                            {
                                if (fObjectWidth >= fDefectLengthPixelX)  // Is Chipped over setting min value
                                {
                                    blnDefect = true;
                                    blnFailWidth = true;
                                }
                                else if ((fObjectCenterX - fObjectWidth / 2) > 0)
                                {
                                    //if (fObjectWidth == intCeilChipLengthX - fTolerance)    // Is Chipped same length with chip setting + tolerance
                                    if (fObjectWidth >= intCeilChipLengthX - fTolerance)    // Is Chipped over chip setting - tolerance
                                    {
                                        //if ((fInterStartX - (fObjectCenterX + fObjectWidth / 2)) <= fTolerance) // Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                                        if ((fInterStartX - (fObjectCenterX + fObjectWidth / 2)) <= 1) // Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                                        {
                                            blnDefect = true;
                                            blnFailWidth = true;
                                            fAddX = fObjectCenterX - fObjectWidth / 2;
                                        }
                                    }
                                }
                            }
                            else // Confirm BOttom Chipped
                            {
                                if (fObjectHeight >= fDefectLengthPixelY) // Is Chipped over setting min value
                                {
                                    blnDefect = true;
                                }
                                else if ((objChippedOffROI.ref_ROIHeight - (fObjectCenterY + fObjectHeight / 2)) > 0)
                                {
                                    //if (fObjectHeight == intCeilChipLengthY - fTolerance) // Is Chipped same length with chip setting + tolerance
                                    if (fObjectHeight >= intCeilChipLengthY - fTolerance)    // Is Chipped over chip setting - tolerance
                                    {
                                        //if (((fObjectCenterY - fObjectHeight / 2) - fInterEndY) <= fTolerance)// Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                                        if (((fObjectCenterY - fObjectHeight / 2) - fInterEndY) <= 1)// Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                                        {
                                            blnDefect = true;
                                            fAddY = objChippedOffROI.ref_ROIHeight - (fObjectCenterY + fObjectHeight / 2);
                                        }
                                    }
                                }
                            }
                        }
                        else // Confirm Right Chipped
                        {
                            if (fObjectWidth >= fDefectLengthPixelX)  // Is Chipped over setting min value
                            {
                                blnDefect = true;
                                blnFailWidth = true;
                            }
                            else if ((fObjectCenterX - fObjectWidth / 2) > 0)
                            {
                                //if (fObjectWidth == intCeilChipLengthX - fTolerance)    // Is Chipped same length with chip setting + tolerance
                                if (fObjectWidth >= intCeilChipLengthX - fTolerance)    // Is Chipped over chip setting - tolerance
                                {
                                    //if ((fInterStartX - (fObjectCenterX + fObjectWidth / 2)) <= fTolerance) // Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                                    if ((fInterStartX - (fObjectCenterX + fObjectWidth / 2)) <= 1) // Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                                    {
                                        blnDefect = true;
                                        blnFailWidth = true;
                                        fAddX = fObjectCenterX - fObjectWidth / 2;
                                    }
                                }
                            }

                        }
                    }

                    if (!blnDefect && fEndX > fInterEndX) // Possible Right Chipped
                    {
                        if (fStartY < fInterStartY) // Possible Top Chipped
                        {
                            if (fStartY < (objChippedOffROI.ref_ROIWidth - fEndX))  // Confirm Top Chipped
                            {
                                if (fObjectHeight >= fDefectLengthPixelY)  // Is Chipped over setting min value
                                {
                                    blnDefect = true;
                                }
                                else if ((fObjectCenterY - fObjectHeight / 2) > 0)
                                {
                                    //if (fObjectHeight == intCeilChipLengthY - fTolerance) // Is Chipped same length with chip setting + tolerance
                                    if (fObjectHeight >= intCeilChipLengthY - fTolerance)    // Is Chipped over chip setting - tolerance
                                    {
                                        //if ((fInterStartY - (fObjectCenterY + fObjectHeight / 2)) <= fTolerance)// Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                                        if ((fInterStartY - (fObjectCenterY + fObjectHeight / 2)) <= 1)// Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                                        {
                                            blnDefect = true;
                                            fAddY = fObjectCenterY - fObjectHeight / 2;
                                        }
                                    }
                                }
                            }
                            else // Confirm Right Chipped
                            {
                                if (fObjectWidth >= fDefectLengthPixelX) // Is Chipped over setting min value
                                {
                                    blnDefect = true;
                                    blnFailWidth = true;
                                }
                                else if ((objChippedOffROI.ref_ROIWidth - (fObjectCenterX + fObjectWidth / 2)) > 0)
                                {
                                    //if (fObjectWidth == intCeilChipLengthX - fTolerance)    // Is Chipped same length with chip setting + tolerance
                                    if (fObjectWidth >= intCeilChipLengthX - fTolerance)    // Is Chipped over chip setting - tolerance
                                    {
                                        //if (((fObjectCenterX - fObjectWidth / 2) - fInterEndX) <= fTolerance) // Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                                        if (((fObjectCenterX - fObjectWidth / 2) - fInterEndX) <= 1) // Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                                        {
                                            blnDefect = true;
                                            blnFailWidth = true;
                                            fAddX = objChippedOffROI.ref_ROIWidth - (fObjectCenterX + fObjectWidth / 2);
                                        }
                                    }
                                }
                            }
                        }
                        else if (fEndY > fInterEndY)    // Possible Bottom Chipped
                        {
                            if ((objChippedOffROI.ref_ROIWidth - fEndX) < (objChippedOffROI.ref_ROIHeight - fEndY)) // Confirm Right Chipped
                            {
                                if (fObjectWidth >= fDefectLengthPixelX)  // Is Chipped over setting min value
                                {
                                    blnDefect = true;
                                    blnFailWidth = true;
                                }
                                else if ((objChippedOffROI.ref_ROIWidth - (fObjectCenterX + fObjectWidth / 2)) > 0)
                                {
                                    //if (fObjectWidth == intCeilChipLengthX - fTolerance)    // Is Chipped same length with chip setting + tolerance
                                    if (fObjectWidth >= intCeilChipLengthX - fTolerance)    // Is Chipped over chip setting - tolerance
                                    {
                                        //if (((fObjectCenterX - fObjectWidth / 2) - fInterEndX) <= fTolerance) // Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                                        if (((fObjectCenterX - fObjectWidth / 2) - fInterEndX) <= 1) // Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                                        {
                                            blnDefect = true;
                                            blnFailWidth = true;
                                            fAddX = objChippedOffROI.ref_ROIWidth - (fObjectCenterX + fObjectWidth / 2);
                                        }
                                    }
                                }
                            }
                            else // Confirm BOttom Chipped
                            {
                                if (fObjectHeight >= fDefectLengthPixelY) // Is Chipped over setting min value
                                {
                                    blnDefect = true;
                                }
                                else if ((objChippedOffROI.ref_ROIHeight - (fObjectCenterY + fObjectHeight / 2)) > 0)
                                {
                                    //if (fObjectHeight == intCeilChipLengthY - fTolerance) // Is Chipped same length with chip setting + tolerance
                                    if (fObjectHeight >= intCeilChipLengthY - fTolerance)    // Is Chipped over chip setting - tolerance
                                    {
                                        //if (((fObjectCenterY - fObjectHeight / 2) - fInterEndY) <= fTolerance)// Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                                        if (((fObjectCenterY - fObjectHeight / 2) - fInterEndY) <= 1)// Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                                        {
                                            blnDefect = true;
                                            fAddY = objChippedOffROI.ref_ROIHeight - (fObjectCenterY + fObjectHeight / 2);
                                        }
                                    }
                                }
                            }
                        }
                        else // Confirm Right Chipped
                        {
                            if (fObjectWidth >= fDefectLengthPixelX)  // Is Chipped over setting min value
                            {
                                blnDefect = true;
                                blnFailWidth = true;
                            }
                            else if ((objChippedOffROI.ref_ROIWidth - (fObjectCenterX + fObjectWidth / 2)) > 0)
                            {
                                if (fObjectWidth >= intCeilChipLengthX - fTolerance)    // Is Chipped same length with chip setting + tolerance
                                {
                                    //if (((fObjectCenterX - fObjectWidth / 2) - fInterEndX) <= fTolerance) // Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                                    if (((fObjectCenterX - fObjectWidth / 2) - fInterEndX) <= 1) // Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                                    {
                                        blnDefect = true;
                                        blnFailWidth = true;
                                        fAddX = objChippedOffROI.ref_ROIWidth - (fObjectCenterX + fObjectWidth / 2);
                                    }
                                }
                            }
                        }
                    }

                    if (!blnDefect && fStartY < fInterStartY) // Possible Top chipped
                    {
                        if (fStartX < fInterStartX) // Possible Left Chipped
                        {
                            if (fStartX < fStartY)  // Confirm Left Chipped
                            {
                                if (fObjectWidth >= fDefectLengthPixelX)  // Is Chipped over setting min value
                                {
                                    blnDefect = true;
                                    blnFailWidth = true;
                                }
                                else if ((fObjectCenterX - fObjectWidth / 2) > 0)
                                {
                                    //if (fObjectWidth == intCeilChipLengthX - fTolerance)    // Is Chipped same length with chip setting + tolerance
                                    if (fObjectWidth >= intCeilChipLengthX - fTolerance)    // Is Chipped over chip setting - tolerance
                                    {
                                        //if ((fInterStartX - (fObjectCenterX + fObjectWidth / 2)) <= fTolerance) // Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                                        if ((fInterStartX - (fObjectCenterX + fObjectWidth / 2)) <= 1) // Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                                        {
                                            blnDefect = true;
                                            blnFailWidth = true;
                                            fAddX = fObjectCenterX - fObjectWidth / 2;
                                        }
                                    }
                                }

                            }
                            else // Confirm Top Chipped
                            {
                                if (fObjectHeight >= fDefectLengthPixelY) // Is Chipped over setting min value
                                {
                                    blnDefect = true;
                                }
                                else if ((fObjectCenterY - fObjectHeight / 2) > 0)
                                {
                                    //if (fObjectHeight == intCeilChipLengthY - fTolerance) // Is Chipped same length with chip setting + tolerance
                                    if (fObjectHeight >= intCeilChipLengthY - fTolerance)    // Is Chipped over chip setting - tolerance
                                    {
                                        //if ((fInterStartY - (fObjectCenterY + fObjectHeight / 2)) <= fTolerance)// Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                                        if ((fInterStartY - (fObjectCenterY + fObjectHeight / 2)) <= 1)// Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                                        {
                                            blnDefect = true;
                                            fAddY = fObjectCenterY - fObjectHeight / 2;
                                        }
                                    }
                                }
                            }
                        }
                        else if (fEndX > fInterEndX)    // Possible Right Chipped
                        {
                            if (fStartY < (objChippedOffROI.ref_ROIWidth - fEndX)) // Confirm Top Chipped
                            {
                                if (fObjectHeight >= fDefectLengthPixelY)  // Is Chipped over setting min value
                                {
                                    blnDefect = true;
                                }
                                else if ((fObjectCenterY - fObjectHeight / 2) > 0)
                                {
                                    //if (fObjectHeight == intCeilChipLengthY - fTolerance) // Is Chipped same length with chip setting + tolerance
                                    if (fObjectHeight >= intCeilChipLengthY - fTolerance)    // Is Chipped over chip setting - tolerance
                                    {
                                        //if ((fInterStartY - (fObjectCenterY + fObjectHeight / 2)) <= fTolerance)// Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                                        if ((fInterStartY - (fObjectCenterY + fObjectHeight / 2)) <= 1)// Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                                        {
                                            blnDefect = true;
                                            fAddY = fObjectCenterY - fObjectHeight / 2;
                                        }
                                    }
                                }
                            }
                            else // Confirm Right Chipped
                            {
                                if (fObjectWidth >= fDefectLengthPixelX) // Is Chipped over setting min value
                                {
                                    blnDefect = true;
                                    blnFailWidth = true;
                                }
                                else if ((objChippedOffROI.ref_ROIWidth - (fObjectCenterX + fObjectWidth / 2)) > 0)
                                {
                                    //if (fObjectWidth == intCeilChipLengthX - fTolerance)    // Is Chipped same length with chip setting + tolerance
                                    if (fObjectWidth >= intCeilChipLengthX - fTolerance)    // Is Chipped over chip setting - tolerance
                                    {
                                        //if (((fObjectCenterX - fObjectWidth / 2) - fInterEndX) <= fTolerance) // Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                                        if (((fObjectCenterX - fObjectWidth / 2) - fInterEndX) <= 1) // Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                                        {
                                            blnDefect = true;
                                            blnFailWidth = true;
                                            fAddX = objChippedOffROI.ref_ROIWidth - (fObjectCenterX + fObjectWidth / 2);
                                        }
                                    }
                                }
                            }
                        }
                        else // Confirm Top Chipped
                        {
                            if (fObjectHeight >= fDefectLengthPixelY)  // Is Chipped over setting min value
                            {
                                blnDefect = true;
                            }
                            else if ((fObjectCenterY - fObjectHeight / 2) > 0)
                            {
                                //if (fObjectHeight == intCeilChipLengthY - fTolerance) // Is Chipped same length with chip setting + tolerance
                                if (fObjectHeight >= intCeilChipLengthY - fTolerance)    // Is Chipped over chip setting - tolerance
                                {
                                    //if ((fInterStartY - (fObjectCenterY + fObjectHeight / 2)) <= fTolerance)// Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                                    if ((fInterStartY - (fObjectCenterY + fObjectHeight / 2)) <= 1)// Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                                    {
                                        blnDefect = true;
                                        fAddY = fObjectCenterY - fObjectHeight / 2;
                                    }
                                }
                            }
                        }
                    }

                    if (!blnDefect && fEndY > fInterEndY) // Possible Bottom Chipped
                    {
                        if (fStartX < fInterStartX) // Possible Left Chipped
                        {
                            if (fStartX < (objChippedOffROI.ref_ROIHeight - fEndY))  // Confirm Left Chipped
                            {
                                if (fObjectWidth >= fDefectLengthPixelX)  // Is Chipped over setting min value
                                {
                                    blnDefect = true;
                                    blnFailWidth = true;
                                }
                                else if ((fObjectCenterX - fObjectWidth / 2) > 0)
                                {
                                    //if (fObjectWidth == intCeilChipLengthX - fTolerance)    // Is Chipped same length with chip setting + tolerance
                                    if (fObjectWidth >= intCeilChipLengthX - fTolerance)    // Is Chipped over chip setting - tolerance
                                    {
                                        //if ((fInterStartX - (fObjectCenterX + fObjectWidth / 2)) <= fTolerance) // Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                                        if ((fInterStartX - (fObjectCenterX + fObjectWidth / 2)) <= 1) // Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                                        {
                                            blnDefect = true;
                                            blnFailWidth = true;
                                            fAddX = fObjectCenterX - fObjectWidth / 2;
                                        }
                                    }
                                }

                            }
                            else // Confirm Bottom Chipped
                            {
                                if (fObjectHeight >= fDefectLengthPixelY) // Is Chipped over setting min value
                                {
                                    blnDefect = true;
                                }
                                else if ((objChippedOffROI.ref_ROIHeight - (fObjectCenterY + fObjectHeight / 2)) > 0)
                                {
                                    //if (fObjectHeight == intCeilChipLengthY - fTolerance) // Is Chipped same length with chip setting + tolerance
                                    if (fObjectHeight >= intCeilChipLengthY - fTolerance)    // Is Chipped over chip setting - tolerance
                                    {
                                        //if (((fObjectCenterY - fObjectHeight / 2) - fInterEndY) <= fTolerance)// Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                                        if (((fObjectCenterY - fObjectHeight / 2) - fInterEndY) <= 1)// Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                                        {
                                            blnDefect = true;
                                            fAddY = objChippedOffROI.ref_ROIHeight - (fObjectCenterY + fObjectHeight / 2);
                                        }
                                    }
                                }
                            }
                        }
                        else if (fEndX > fInterEndX)    // Possible Right Chipped
                        {
                            if ((objChippedOffROI.ref_ROIWidth - fEndX) < (objChippedOffROI.ref_ROIHeight - fEndY)) // Confirm Right Chipped
                            {
                                if (fObjectWidth >= fDefectLengthPixelX)  // Is Chipped over setting min value
                                {
                                    blnDefect = true;
                                    blnFailWidth = true;
                                }
                                else if ((objChippedOffROI.ref_ROIWidth - (fObjectCenterX + fObjectWidth / 2)) > 0)
                                {
                                    //if (fObjectWidth == intCeilChipLengthX - fTolerance)    // Is Chipped same length with chip setting + tolerance
                                    if (fObjectWidth >= intCeilChipLengthX - fTolerance)    // Is Chipped over chip setting - tolerance
                                    {
                                        //if (((fObjectCenterX - fObjectWidth / 2) - fInterEndX) <= fTolerance) // Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                                        if (((fObjectCenterX - fObjectWidth / 2) - fInterEndX) <= 1) // Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                                        {
                                            blnDefect = true;
                                            blnFailWidth = true;
                                            fAddX = objChippedOffROI.ref_ROIWidth - (fObjectCenterX + fObjectWidth / 2);
                                        }
                                    }
                                }
                            }
                            else // Confirm BOttom Chipped
                            {
                                if (fObjectHeight >= fDefectLengthPixelY) // Is Chipped over setting min value
                                {
                                    blnDefect = true;
                                }
                                else if ((objChippedOffROI.ref_ROIHeight - (fObjectCenterY + fObjectHeight / 2)) > 0)
                                {
                                    //if (fObjectHeight == intCeilChipLengthY - fTolerance) // Is Chipped same length with chip setting + tolerance
                                    if (fObjectHeight >= intCeilChipLengthY - fTolerance)    // Is Chipped over chip setting - tolerance
                                    {
                                        //if (((fObjectCenterY - fObjectHeight / 2) - fInterEndY) <= fTolerance)// Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                                        if (((fObjectCenterY - fObjectHeight / 2) - fInterEndY) <= 1)// Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                                        {
                                            blnDefect = true;
                                            fAddY = objChippedOffROI.ref_ROIHeight - (fObjectCenterY + fObjectHeight / 2);
                                        }
                                    }
                                }
                            }
                        }
                        else // Confirm Bottom Chipped
                        {
                            if (fObjectHeight >= fDefectLengthPixelY)  // Is Chipped over setting min value
                            {
                                blnDefect = true;
                            }
                            else if ((objChippedOffROI.ref_ROIHeight - (fObjectCenterY + fObjectHeight / 2)) > 0)
                            {
                                //if (fObjectHeight == intCeilChipLengthY - fTolerance) // Is Chipped same length with chip setting + tolerance
                                if (fObjectHeight >= intCeilChipLengthY - fTolerance)    // Is Chipped over chip setting - tolerance
                                {
                                    //if (((fObjectCenterY - fObjectHeight / 2) - fInterEndY) <= fTolerance)// Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                                    if (((fObjectCenterY - fObjectHeight / 2) - fInterEndY) <= 1)// Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                                    {
                                        blnDefect = true;
                                        fAddY = objChippedOffROI.ref_ROIHeight - (fObjectCenterY + fObjectHeight / 2);
                                    }
                                }
                            }
                        }
                    }

                    if (blnDefect)
                    {
                        intFailCount++;
                        float fWidthMM = (fObjectWidth + fAddX) / m_fMMToPixelXValue;
                        float fHeightMM = (fObjectHeight + fAddY) / m_fMMToPixelYValue; // 11-04-2019 ZJYEOH : Changed m_fMMToPixelXValue to m_fMMToPixelYValue
                        float fAreaInMM = intObjectArea / m_fMMToPixelXValue / m_fMMToPixelYValue;

                        m_intFailPkgResultMask |= 0x04; // Fail image 1 chipped off

                        Defect objDefect = new Defect();

                        if (intImageIndex != 0)
                            objDefect.ref_strName = "Image 2 Chipped Off " + intFailCount.ToString();
                        else
                            objDefect.ref_strName = "Image 1 Chipped Off " + intFailCount.ToString();

                        objDefect.ref_intFailMask |= 0x04;
                        objDefect.ref_fCenterX = objImage1UnitROI.ref_ROITotalX + objChippedOffROI.ref_ROITotalX + fObjectCenterX;
                        objDefect.ref_fCenterY = objImage1UnitROI.ref_ROITotalY + objChippedOffROI.ref_ROITotalY + fObjectCenterY;
                        objDefect.ref_fStartX = objImage1UnitROI.ref_ROITotalX + fStartX;
                        objDefect.ref_fStartY = objImage1UnitROI.ref_ROITotalY + fStartY;
                        objDefect.ref_fEndX = objImage1UnitROI.ref_ROITotalX + fEndX;
                        objDefect.ref_fEndY = objImage1UnitROI.ref_ROITotalY + fEndY;
                        objDefect.ref_fWidth = fObjectWidth + fAddX;
                        objDefect.ref_fHeight = fObjectHeight + fAddY;
                        objDefect.ref_fArea = intObjectArea;
                        objDefect.ref_fWidthInMM = fWidthMM;
                        objDefect.ref_fHeightInMM = fHeightMM;
                        objDefect.ref_fAreaInMM2 = fAreaInMM;
                        objDefect.ref_intImageNo = 1;
                        if (blnFailWidth)
                        {
                            objDefect.ref_fFailValue = fWidthMM;
                            objDefect.ref_intFailCriteria |= 0x01;
                        }
                        else
                        {
                            objDefect.ref_fFailValue = fHeightMM;
                            objDefect.ref_intFailCriteria |= 0x02;
                        }
                        m_arrPkgDefectList.Add(objDefect);

                        if (blnResult)
                            blnResult = false;
                    }
                }
            }

            objChippedOffROI.Dispose();

            return blnResult;
        }

        private bool IsImage2UnitChippedOff2(ROI objImage1UnitROI)
        {
            /*
             * Algorithm
             * 
             * 
             * 
             */

            bool blnResult = true;
            bool blnDebugImage = false;

            // Get Chipped off Image
            int intCeilChipLengthX = (int)Math.Ceiling(m_fChipStartPixelFromEdge * m_fMMToPixelXValue);
            int intCeilChipLengthY = (int)Math.Ceiling(m_fChipStartPixelFromEdge * m_fMMToPixelYValue);

            ROI objChippedOffROI = new ROI();
            objChippedOffROI.AttachImage(m_objInsPkgImage2);
            //objChippedOffROI.LoadROISetting(objImage1UnitROI.ref_ROITotalX,
            //                                            objImage1UnitROI.ref_ROITotalY,
            //                                            objImage1UnitROI.ref_ROIWidth,
            //                                            objImage1UnitROI.ref_ROIHeight);
            objChippedOffROI.LoadROISetting(0, 0, objImage1UnitROI.ref_ROIWidth, objImage1UnitROI.ref_ROIHeight);
            objChippedOffROI.CopyToImage(ref m_objInsChipOffPkgImage2);
            objChippedOffROI.AttachImage(m_objInsChipOffPkgImage2);
            objChippedOffROI.LoadROISetting(0, 0, m_objInsChipOffPkgImage2.ref_intImageWidth, m_objInsChipOffPkgImage2.ref_intImageHeight);


            FillChipLineLimitToCorner(m_objInsChipOffPkgImage2, intCeilChipLengthX, intCeilChipLengthY, 0);

            m_objImage2ChipOffEBlobs.BuildObjects_Filter_GetElement(objChippedOffROI, false, true, 0, 125,
                Math.Min(intCeilChipLengthX, intCeilChipLengthY), 999999, false, 0x0F);


            if (blnDebugImage)
            {
                objImage1UnitROI.SaveImage("D:\\TS\\objImage1UnitROI.bmp");// debug
                objChippedOffROI.SaveImage("D:\\TS\\objChippedOffROI.bmp");// debug
            }

            if (m_objImage2ChipOffEBlobs.ref_intNumSelectedObject > 0)
            {
                float fDefectLengthPixelX = m_fChipStartPixelFromEdge * m_fMMToPixelXValue;
                float fDefectLengthPixelY = m_fChipStartPixelFromEdge * m_fMMToPixelYValue;
                int intObjectArea = 0;
                float fObjectHeight = 0, fObjectWidth = 0, fObjectCenterX = 0, fObjectCenterY = 0;
                float fStartX, fStartY, fEndX, fEndY;
                float fOuterStartX = 1;
                float fOuterStartY = 1;
                float fOuterEndX = objChippedOffROI.ref_ROIWidth;
                float fOuterEndY = objChippedOffROI.ref_ROIHeight;
                float fInterStartX = fDefectLengthPixelX;
                float fInterStartY = fDefectLengthPixelY;
                float fInterEndX = (float)objChippedOffROI.ref_ROIWidth - fDefectLengthPixelX - 1;
                float fInterEndY = (float)objChippedOffROI.ref_ROIHeight - fDefectLengthPixelY - 1;
                int intFailCount = 0;

                for (int i = 0; i < m_objImage2ChipOffEBlobs.ref_intNumSelectedObject; i++)
                {
                    fObjectCenterX = m_objImage2ChipOffEBlobs.ref_arrLimitCenterX[i];
                    fObjectCenterY = m_objImage2ChipOffEBlobs.ref_arrLimitCenterY[i];
                    fObjectWidth = m_objImage2ChipOffEBlobs.ref_arrWidth[i];
                    fObjectHeight = m_objImage2ChipOffEBlobs.ref_arrHeight[i];
                    intObjectArea = m_objImage2ChipOffEBlobs.ref_arrArea[i];

                    fStartX = (float)Math.Floor(fObjectCenterX - (fObjectWidth / 2));
                    fStartY = (float)Math.Floor(fObjectCenterY - (fObjectHeight / 2));
                    fEndX = (float)Math.Ceiling(fObjectCenterX + (fObjectWidth / 2));
                    fEndY = (float)Math.Ceiling(fObjectCenterY + (fObjectHeight / 2));

                    float fTolerance = 1f;
                    bool blnDefect = false;
                    float fAddX = 0;
                    float fAddY = 0;
                    bool blnFailWidth = false;

                    if (fStartX < fInterStartX) // Possible Left Chipped
                    {
                        if (fStartY < fInterStartY) // Possible Top Chipped
                        {
                            if (fStartX < fStartY)  // Confirm Left Chipped
                            {
                                if (fObjectWidth >= fDefectLengthPixelX)  // Is Chipped over setting min value
                                {
                                    blnDefect = true;
                                    blnFailWidth = true;
                                }
                                else if ((fObjectCenterX - fObjectWidth / 2) > 0)
                                {
                                    //if (fObjectWidth == intCeilChipLengthX - fTolerance)    // Is Chipped same length with chip setting + tolerance
                                    if (fObjectWidth >= intCeilChipLengthX - fTolerance)    // Is Chipped over chip setting - tolerance
                                    {
                                        //if ((fTolerance - (fObjectCenterX + fObjectWidth / 2)) <= fTolerance) // Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                                        if ((fTolerance - (fObjectCenterX + fObjectWidth / 2)) <= 1) // Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                                        {
                                            blnDefect = true;
                                            blnFailWidth = true;
                                            fAddX = fObjectCenterX - fObjectWidth / 2;
                                        }
                                    }
                                }
                            }
                            else // Confirm Top Chipped
                            {
                                if (fObjectHeight >= fDefectLengthPixelY) // Is Chipped over setting min value
                                {
                                    blnDefect = true;
                                }
                                else if ((fObjectCenterY - fObjectHeight / 2) > 0)
                                {
                                    //if (fObjectHeight == intCeilChipLengthY - fTolerance) // Is Chipped same length with chip setting + tolerance
                                    if (fObjectHeight >= intCeilChipLengthY - fTolerance)    // Is Chipped over chip setting - tolerance
                                    {
                                        //if ((fInterStartY - (fObjectCenterY + fObjectHeight / 2)) <= fTolerance)// Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                                        if ((fInterStartY - (fObjectCenterY + fObjectHeight / 2)) <= 1)// Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                                        {
                                            blnDefect = true;
                                            fAddY = fObjectCenterY - fObjectHeight / 2;
                                        }
                                    }
                                }

                            }
                        }
                        else if (fEndY > fInterEndY)    // Possible Bottom Chipped
                        {
                            if (fStartX < (objChippedOffROI.ref_ROIHeight - fEndY)) // Confirm Left Chipped
                            {
                                if (fObjectWidth >= fDefectLengthPixelX)  // Is Chipped over setting min value
                                {
                                    blnDefect = true;
                                    blnFailWidth = true;
                                }
                                else if ((fObjectCenterX - fObjectWidth / 2) > 0)
                                {
                                    //if (fObjectWidth == intCeilChipLengthX - fTolerance)    // Is Chipped same length with chip setting + tolerance
                                    if (fObjectWidth >= intCeilChipLengthX - fTolerance)    // Is Chipped over chip setting - tolerance
                                    {
                                        //if ((fInterStartX - (fObjectCenterX + fObjectWidth / 2)) <= fTolerance) // Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                                        if ((fInterStartX - (fObjectCenterX + fObjectWidth / 2)) <= 1) // Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                                        {
                                            blnDefect = true;
                                            blnFailWidth = true;
                                            fAddX = fObjectCenterX - fObjectWidth / 2;
                                        }
                                    }
                                }
                            }
                            else // Confirm BOttom Chipped
                            {
                                if (fObjectHeight >= fDefectLengthPixelY) // Is Chipped over setting min value
                                {
                                    blnDefect = true;
                                }
                                else if ((objChippedOffROI.ref_ROIHeight - (fObjectCenterY + fObjectHeight / 2)) > 0)
                                {
                                    //if (fObjectHeight == intCeilChipLengthY - fTolerance) // Is Chipped same length with chip setting + tolerance
                                    if (fObjectHeight >= intCeilChipLengthY - fTolerance)    // Is Chipped over chip setting - tolerance
                                    {
                                        //if (((fObjectCenterY - fObjectHeight / 2) - fInterEndY) <= fTolerance)// Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                                        if (((fObjectCenterY - fObjectHeight / 2) - fInterEndY) <= 1)// Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                                        {
                                            blnDefect = true;
                                            fAddY = objChippedOffROI.ref_ROIHeight - (fObjectCenterY + fObjectHeight / 2);
                                        }
                                    }
                                }
                            }
                        }
                        else // Confirm Right Chipped
                        {
                            if (fObjectWidth >= fDefectLengthPixelX)  // Is Chipped over setting min value
                            {
                                blnDefect = true;
                                blnFailWidth = true;
                            }
                            else if ((fObjectCenterX - fObjectWidth / 2) > 0)
                            {
                                //if (fObjectWidth == intCeilChipLengthX - fTolerance)    // Is Chipped same length with chip setting + tolerance
                                if (fObjectWidth >= intCeilChipLengthX - fTolerance)    // Is Chipped over chip setting - tolerance
                                {
                                    //if ((fInterStartX - (fObjectCenterX + fObjectWidth / 2)) <= fTolerance) // Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                                    if ((fInterStartX - (fObjectCenterX + fObjectWidth / 2)) <= 1) // Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                                    {
                                        blnDefect = true;
                                        blnFailWidth = true;
                                        fAddX = fObjectCenterX - fObjectWidth / 2;
                                    }
                                }
                            }

                        }
                    }

                    if (!blnDefect && fEndX > fInterEndX) // Possible Right Chipped
                    {
                        if (fStartY < fInterStartY) // Possible Top Chipped
                        {
                            if (fStartY < (objChippedOffROI.ref_ROIWidth - fEndX))  // Confirm Top Chipped
                            {
                                if (fObjectHeight >= fDefectLengthPixelY)  // Is Chipped over setting min value
                                {
                                    blnDefect = true;
                                }
                                else if ((fObjectCenterY - fObjectHeight / 2) > 0)
                                {
                                    //if (fObjectHeight == intCeilChipLengthY - fTolerance) // Is Chipped same length with chip setting + tolerance
                                    if (fObjectHeight >= intCeilChipLengthY - fTolerance)    // Is Chipped over chip setting - tolerance
                                    {
                                        //if ((fInterStartY - (fObjectCenterY + fObjectHeight / 2)) <= fTolerance)// Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                                        if ((fInterStartY - (fObjectCenterY + fObjectHeight / 2)) <= 1)// Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                                        {
                                            blnDefect = true;
                                            fAddY = fObjectCenterY - fObjectHeight / 2;
                                        }
                                    }
                                }
                            }
                            else // Confirm Right Chipped
                            {
                                if (fObjectWidth >= fDefectLengthPixelX) // Is Chipped over setting min value
                                {
                                    blnDefect = true;
                                    blnFailWidth = true;
                                }
                                else if ((objChippedOffROI.ref_ROIWidth - (fObjectCenterX + fObjectWidth / 2)) > 0)
                                {
                                    //if (fObjectWidth == intCeilChipLengthX - fTolerance)    // Is Chipped same length with chip setting + tolerance
                                    if (fObjectWidth >= intCeilChipLengthX - fTolerance)    // Is Chipped over chip setting - tolerance
                                    {
                                        //if (((fObjectCenterX - fObjectWidth / 2) - fInterEndX) <= fTolerance) // Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                                        if (((fObjectCenterX - fObjectWidth / 2) - fInterEndX) <= 1) // Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                                        {
                                            blnDefect = true;
                                            blnFailWidth = true;
                                            fAddX = objChippedOffROI.ref_ROIWidth - (fObjectCenterX + fObjectWidth / 2);
                                        }
                                    }
                                }
                            }
                        }
                        else if (fEndY > fInterEndY)    // Possible Bottom Chipped
                        {
                            if ((objChippedOffROI.ref_ROIWidth - fEndX) < (objChippedOffROI.ref_ROIHeight - fEndY)) // Confirm Right Chipped
                            {
                                if (fObjectWidth >= fDefectLengthPixelX)  // Is Chipped over setting min value
                                {
                                    blnDefect = true;
                                    blnFailWidth = true;
                                }
                                else if ((objChippedOffROI.ref_ROIWidth - (fObjectCenterX + fObjectWidth / 2)) > 0)
                                {
                                    //if (fObjectWidth == intCeilChipLengthX - fTolerance)    // Is Chipped same length with chip setting + tolerance
                                    if (fObjectWidth >= intCeilChipLengthX - fTolerance)    // Is Chipped over chip setting - tolerance
                                    {
                                        //if (((fObjectCenterX - fObjectWidth / 2) - fInterEndX) <= fTolerance) // Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                                        if (((fObjectCenterX - fObjectWidth / 2) - fInterEndX) <= 1) // Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                                        {
                                            blnDefect = true;
                                            blnFailWidth = true;
                                            fAddX = objChippedOffROI.ref_ROIWidth - (fObjectCenterX + fObjectWidth / 2);
                                        }
                                    }
                                }
                            }
                            else // Confirm BOttom Chipped
                            {
                                if (fObjectHeight >= fDefectLengthPixelY) // Is Chipped over setting min value
                                {
                                    blnDefect = true;
                                }
                                else if ((objChippedOffROI.ref_ROIHeight - (fObjectCenterY + fObjectHeight / 2)) > 0)
                                {
                                    //if (fObjectHeight == intCeilChipLengthY - fTolerance) // Is Chipped same length with chip setting + tolerance
                                    if (fObjectHeight >= intCeilChipLengthY - fTolerance)    // Is Chipped over chip setting - tolerance
                                    {
                                        //if (((fObjectCenterY - fObjectHeight / 2) - fInterEndY) <= fTolerance)// Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                                        if (((fObjectCenterY - fObjectHeight / 2) - fInterEndY) <= 1)// Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                                        {
                                            blnDefect = true;
                                            fAddY = objChippedOffROI.ref_ROIHeight - (fObjectCenterY + fObjectHeight / 2);
                                        }
                                    }
                                }
                            }
                        }
                        else // Confirm Right Chipped
                        {
                            if (fObjectWidth >= fDefectLengthPixelX)  // Is Chipped over setting min value
                            {
                                blnDefect = true;
                                blnFailWidth = true;
                            }
                            else if ((objChippedOffROI.ref_ROIWidth - (fObjectCenterX + fObjectWidth / 2)) > 0)
                            {
                                //if (fObjectWidth == intCeilChipLengthX - fTolerance)    // Is Chipped same length with chip setting + tolerance
                                if (fObjectWidth >= intCeilChipLengthX - fTolerance)    // Is Chipped over chip setting - tolerance
                                {
                                    //if (((fObjectCenterX - fObjectWidth / 2) - fInterEndX) <= fTolerance) // Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                                    if (((fObjectCenterX - fObjectWidth / 2) - fInterEndX) <= 1) // Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                                    {
                                        blnDefect = true;
                                        blnFailWidth = true;
                                        fAddX = objChippedOffROI.ref_ROIWidth - (fObjectCenterX + fObjectWidth / 2);
                                    }
                                }
                            }
                        }
                    }

                    if (!blnDefect && fStartY < fInterStartY) // Possible Top chipped
                    {
                        if (fStartX < fInterStartX) // Possible Left Chipped
                        {
                            if (fStartX < fStartY)  // Confirm Left Chipped
                            {
                                if (fObjectWidth >= fDefectLengthPixelX)  // Is Chipped over setting min value
                                {
                                    blnDefect = true;
                                    blnFailWidth = true;
                                }
                                else if ((fObjectCenterX - fObjectWidth / 2) > 0)
                                {
                                    //if (fObjectWidth == intCeilChipLengthX - fTolerance)    // Is Chipped same length with chip setting + tolerance
                                    if (fObjectWidth >= intCeilChipLengthX - fTolerance)    // Is Chipped over chip setting - tolerance
                                    {
                                        //if ((fInterStartX - (fObjectCenterX + fObjectWidth / 2)) <= fTolerance) // Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                                        if ((fInterStartX - (fObjectCenterX + fObjectWidth / 2)) <= 1) // Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                                        {
                                            blnDefect = true;
                                            blnFailWidth = true;
                                            fAddX = fObjectCenterX - fObjectWidth / 2;
                                        }
                                    }
                                }

                            }
                            else // Confirm Top Chipped
                            {
                                if (fObjectHeight >= fDefectLengthPixelY) // Is Chipped over setting min value
                                {
                                    blnDefect = true;
                                }
                                else if ((fObjectCenterY - fObjectHeight / 2) > 0)
                                {
                                    //if (fObjectHeight == intCeilChipLengthY - fTolerance) // Is Chipped same length with chip setting + tolerance
                                    if (fObjectHeight >= intCeilChipLengthY - fTolerance)    // Is Chipped over chip setting - tolerance
                                    {
                                        //if ((fInterStartY - (fObjectCenterY + fObjectHeight / 2)) <= fTolerance)// Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                                        if ((fInterStartY - (fObjectCenterY + fObjectHeight / 2)) <= 1)// Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                                        {
                                            blnDefect = true;
                                            fAddY = fObjectCenterY - fObjectHeight / 2;
                                        }
                                    }
                                }
                            }
                        }
                        else if (fEndX > fInterEndX)    // Possible Right Chipped
                        {
                            if (fStartY < (objChippedOffROI.ref_ROIWidth - fEndX)) // Confirm Top Chipped
                            {
                                if (fObjectHeight >= fDefectLengthPixelY)  // Is Chipped over setting min value
                                {
                                    blnDefect = true;
                                }
                                else if ((fObjectCenterY - fObjectHeight / 2) > 0)
                                {
                                    //if (fObjectHeight == intCeilChipLengthY - fTolerance) // Is Chipped same length with chip setting + tolerance
                                    if (fObjectHeight >= intCeilChipLengthY - fTolerance)    // Is Chipped over chip setting - tolerance
                                    {
                                        //if ((fInterStartY - (fObjectCenterY + fObjectHeight / 2)) <= fTolerance)// Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                                        if ((fInterStartY - (fObjectCenterY + fObjectHeight / 2)) <= 1)// Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                                        {
                                            blnDefect = true;
                                            fAddY = fObjectCenterY - fObjectHeight / 2;
                                        }
                                    }
                                }
                            }
                            else // Confirm Right Chipped
                            {
                                if (fObjectWidth >= fDefectLengthPixelX) // Is Chipped over setting min value
                                {
                                    blnDefect = true;
                                    blnFailWidth = true;
                                }
                                else if ((objChippedOffROI.ref_ROIWidth - (fObjectCenterX + fObjectWidth / 2)) > 0)
                                {
                                    //if (fObjectWidth == intCeilChipLengthX - fTolerance)    // Is Chipped same length with chip setting + tolerance
                                    if (fObjectWidth >= intCeilChipLengthX - fTolerance)    // Is Chipped over chip setting - tolerance
                                    {
                                        //if (((fObjectCenterX - fObjectWidth / 2) - fInterEndX) <= fTolerance) // Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                                        if (((fObjectCenterX - fObjectWidth / 2) - fInterEndX) <= 1) // Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                                        {
                                            blnDefect = true;
                                            blnFailWidth = true;
                                            fAddX = objChippedOffROI.ref_ROIWidth - (fObjectCenterX + fObjectWidth / 2);
                                        }
                                    }
                                }
                            }
                        }
                        else // Confirm Top Chipped
                        {
                            if (fObjectHeight >= fDefectLengthPixelY)  // Is Chipped over setting min value
                            {
                                blnDefect = true;
                            }
                            else if ((fObjectCenterY - fObjectHeight / 2) > 0)
                            {
                                //if (fObjectHeight == intCeilChipLengthY - fTolerance) // Is Chipped same length with chip setting + tolerance
                                if (fObjectHeight >= intCeilChipLengthY - fTolerance)    // Is Chipped over chip setting - tolerance
                                {
                                    //if ((fInterStartY - (fObjectCenterY + fObjectHeight / 2)) <= fTolerance)// Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                                    if ((fInterStartY - (fObjectCenterY + fObjectHeight / 2)) <= 1)// Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                                    {
                                        blnDefect = true;
                                        fAddY = fObjectCenterY - fObjectHeight / 2;
                                    }
                                }
                            }
                        }
                    }

                    if (!blnDefect && fEndY > fInterEndY) // Possible Bottom Chipped
                    {
                        if (fStartX < fInterStartX) // Possible Left Chipped
                        {
                            if (fStartX < (objChippedOffROI.ref_ROIHeight - fEndY))  // Confirm Left Chipped
                            {
                                if (fObjectWidth >= fDefectLengthPixelX)  // Is Chipped over setting min value
                                {
                                    blnDefect = true;
                                    blnFailWidth = true;
                                }
                                else if ((fObjectCenterX - fObjectWidth / 2) > 0)
                                {
                                    //if (fObjectWidth == intCeilChipLengthX - fTolerance)    // Is Chipped same length with chip setting + tolerance
                                    if (fObjectWidth >= intCeilChipLengthX - fTolerance)    // Is Chipped over chip setting - tolerance
                                    {
                                        //if ((fInterStartX - (fObjectCenterX + fObjectWidth / 2)) <= fTolerance) // Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                                        if ((fInterStartX - (fObjectCenterX + fObjectWidth / 2)) <= 1) // Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                                        {
                                            blnDefect = true;
                                            blnFailWidth = true;
                                            fAddX = fObjectCenterX - fObjectWidth / 2;
                                        }
                                    }
                                }

                            }
                            else // Confirm Bottom Chipped
                            {
                                if (fObjectHeight >= fDefectLengthPixelY) // Is Chipped over setting min value
                                {
                                    blnDefect = true;
                                }
                                else if ((objChippedOffROI.ref_ROIHeight - (fObjectCenterY + fObjectHeight / 2)) > 0)
                                {
                                    //if (fObjectHeight == intCeilChipLengthY - fTolerance) // Is Chipped same length with chip setting + tolerance
                                    if (fObjectHeight >= intCeilChipLengthY - fTolerance)    // Is Chipped over chip setting - tolerance
                                    {
                                        //if (((fObjectCenterY - fObjectHeight / 2) - fInterEndY) <= fTolerance)// Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                                        if (((fObjectCenterY - fObjectHeight / 2) - fInterEndY) <= 1)// Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                                        {
                                            blnDefect = true;
                                            fAddY = objChippedOffROI.ref_ROIHeight - (fObjectCenterY + fObjectHeight / 2);
                                        }
                                    }
                                }
                            }
                        }
                        else if (fEndX > fInterEndX)    // Possible Right Chipped
                        {
                            if ((objChippedOffROI.ref_ROIWidth - fEndX) < (objChippedOffROI.ref_ROIHeight - fEndY)) // Confirm Right Chipped
                            {
                                if (fObjectWidth >= fDefectLengthPixelX)  // Is Chipped over setting min value
                                {
                                    blnDefect = true;
                                    blnFailWidth = true;
                                }
                                else if ((objChippedOffROI.ref_ROIWidth - (fObjectCenterX + fObjectWidth / 2)) > 0)
                                {
                                    //if (fObjectWidth == intCeilChipLengthX - fTolerance)    // Is Chipped same length with chip setting + tolerance
                                    if (fObjectWidth >= intCeilChipLengthX - fTolerance)    // Is Chipped over chip setting - tolerance
                                    {
                                        //if (((fObjectCenterX - fObjectWidth / 2) - fInterEndX) <= fTolerance) // Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                                        if (((fObjectCenterX - fObjectWidth / 2) - fInterEndX) <= 1) // Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                                        {
                                            blnDefect = true;
                                            blnFailWidth = true;
                                            fAddX = objChippedOffROI.ref_ROIWidth - (fObjectCenterX + fObjectWidth / 2);
                                        }
                                    }
                                }
                            }
                            else // Confirm BOttom Chipped
                            {
                                if (fObjectHeight >= fDefectLengthPixelY) // Is Chipped over setting min value
                                {
                                    blnDefect = true;
                                }
                                else if ((objChippedOffROI.ref_ROIHeight - (fObjectCenterY + fObjectHeight / 2)) > 0)
                                {
                                    //if (fObjectHeight == intCeilChipLengthY - fTolerance) // Is Chipped same length with chip setting + tolerance
                                    if (fObjectHeight >= intCeilChipLengthY - fTolerance)    // Is Chipped over chip setting - tolerance
                                    {
                                        //if (((fObjectCenterY - fObjectHeight / 2) - fInterEndY) <= fTolerance)// Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                                        if (((fObjectCenterY - fObjectHeight / 2) - fInterEndY) <= 1)// Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                                        {
                                            blnDefect = true;
                                            fAddY = objChippedOffROI.ref_ROIHeight - (fObjectCenterY + fObjectHeight / 2);
                                        }
                                    }
                                }
                            }
                        }
                        else // Confirm Bottom Chipped
                        {
                            if (fObjectHeight >= fDefectLengthPixelY)  // Is Chipped over setting min value
                            {
                                blnDefect = true;
                            }
                            else if ((objChippedOffROI.ref_ROIHeight - (fObjectCenterY + fObjectHeight / 2)) > 0)
                            {
                                //if (fObjectHeight == intCeilChipLengthY - fTolerance) // Is Chipped same length with chip setting + tolerance
                                if (fObjectHeight >= intCeilChipLengthY - fTolerance)    // Is Chipped over chip setting - tolerance
                                {
                                    //if (((fObjectCenterY - fObjectHeight / 2) - fInterEndY) <= fTolerance)// Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                                    if (((fObjectCenterY - fObjectHeight / 2) - fInterEndY) <= 1)// Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                                    {
                                        blnDefect = true;
                                        fAddY = objChippedOffROI.ref_ROIHeight - (fObjectCenterY + fObjectHeight / 2);
                                    }
                                }
                            }
                        }
                    }

                    if (blnDefect)
                    {
                        intFailCount++;
                        float fWidthMM = (fObjectWidth + fAddX) / m_fMMToPixelXValue;
                        float fHeightMM = (fObjectHeight + fAddY) / m_fMMToPixelYValue; // 11-04-2019 ZJYEOH : Changed m_fMMToPixelXValue to m_fMMToPixelYValue
                        float fAreaInMM = intObjectArea / m_fMMToPixelXValue / m_fMMToPixelYValue;

                        m_intFailPkgResultMask |= 0x04; // Fail image 1 chipped off

                        Defect objDefect = new Defect();
                        objDefect.ref_strName = "Image 2 Chipped Off " + intFailCount.ToString();
                        objDefect.ref_intFailMask |= 0x04;
                        objDefect.ref_fCenterX = objImage1UnitROI.ref_ROITotalX + objChippedOffROI.ref_ROITotalX + fObjectCenterX;
                        objDefect.ref_fCenterY = objImage1UnitROI.ref_ROITotalY + objChippedOffROI.ref_ROITotalY + fObjectCenterY;
                        objDefect.ref_fStartX = objImage1UnitROI.ref_ROITotalX + fStartX;
                        objDefect.ref_fStartY = objImage1UnitROI.ref_ROITotalY + fStartY;
                        objDefect.ref_fEndX = objImage1UnitROI.ref_ROITotalX + fEndX;
                        objDefect.ref_fEndY = objImage1UnitROI.ref_ROITotalY + fEndY;
                        objDefect.ref_fWidth = fObjectWidth + fAddX;
                        objDefect.ref_fHeight = fObjectHeight + fAddY;
                        objDefect.ref_fArea = intObjectArea;
                        objDefect.ref_fWidthInMM = fWidthMM;
                        objDefect.ref_fHeightInMM = fHeightMM;
                        objDefect.ref_fAreaInMM2 = fAreaInMM;
                        objDefect.ref_intFailCriteria |= 0x07;
                        objDefect.ref_intImageNo = 2;
                        if (blnFailWidth)
                        {
                            objDefect.ref_fFailValue = fWidthMM;
                            objDefect.ref_intFailCriteria |= 0x01;
                        }
                        else
                        {
                            objDefect.ref_fFailValue = fHeightMM;
                            objDefect.ref_intFailCriteria |= 0x02;
                        }
                        m_arrPkgDefectList.Add(objDefect);

                        if (blnResult)
                            blnResult = false;
                    }
                }
            }

            objChippedOffROI.Dispose();

            return blnResult;
        }

        private void FillChipLineLimitToCorner(ImageDrawing objImage, int intChippedOffToleranceX, int intChippedOffToleranceY, int intChipLineLimitPixelValue)
        {
            if (objImage.ref_intImageHeight == 0 || objImage.ref_intImageWidth == 0)
                return;

            int intStartX1 = 0;
            int intStartY1 = 0;
            int intEndX1 = objImage.ref_intImageWidth - 1;
            int intEndY1 = objImage.ref_intImageHeight - 1;

            int intStartX2 = intChippedOffToleranceX;
            int intStartY2 = intChippedOffToleranceY;
            int intEndX2 = objImage.ref_intImageWidth - intChippedOffToleranceX - 1;
            int intEndY2 = objImage.ref_intImageHeight - intChippedOffToleranceY - 1;

            Line objLine1 = new Line();
            Line objLine2 = new Line();
            Line objLine3 = new Line();
            Line objLine4 = new Line();
            objLine1.CalculateStraightLine(new PointF(intStartX1, intStartY1), new PointF(intStartX2, intStartY2));
            objLine2.CalculateStraightLine(new PointF(intEndX1, intStartY1), new PointF(intEndX2, intStartY2));
            objLine3.CalculateStraightLine(new PointF(intStartX1, intEndY1), new PointF(intStartX2, intEndY2));
            objLine4.CalculateStraightLine(new PointF(intEndX1, intEndY1), new PointF(intEndX2, intEndY2));
            int x, y;
            EBW8 darkPixel = new EBW8((byte)intChipLineLimitPixelValue);

            // -------- separate corner with dark line -------------------------------------------
            for (x = intStartX1; x <= intStartX2; x++)
            {
                y = (int)Math.Round(objLine1.GetPointY(x), 0, MidpointRounding.AwayFromZero);

                if (!(y >= 0 && y < objImage.ref_objMainImage.Height &&
                     x >= 0 && x < objImage.ref_objMainImage.Width))
                {
                    continue;
                }

                if (y < objImage.ref_objMainImage.Height)
                    objImage.ref_objMainImage.SetPixel(darkPixel, x, y);
            }
            for (x = intEndX2; x <= intEndX1; x++)
            {
                y = (int)Math.Round(objLine2.GetPointY(x), 0, MidpointRounding.AwayFromZero);

                if (!(y >= 0 && y < objImage.ref_objMainImage.Height &&
                     x >= 0 && x < objImage.ref_objMainImage.Width))
                {
                    continue;
                }

                if (y < objImage.ref_objMainImage.Height)
                    objImage.ref_objMainImage.SetPixel(darkPixel, x, y);
            }
            for (x = intStartX1; x <= intStartX2; x++)
            {
                y = (int)Math.Round(objLine3.GetPointY(x), 0, MidpointRounding.AwayFromZero);

                if (!(y >= 0 && y < objImage.ref_objMainImage.Height &&
                     x >= 0 && x < objImage.ref_objMainImage.Width))
                {
                    continue;
                }

                if (y < objImage.ref_objMainImage.Height)
                    objImage.ref_objMainImage.SetPixel(darkPixel, x, y);
            }
            for (x = intEndX2; x <= intEndX1; x++)
            {
                y = (int)Math.Round(objLine4.GetPointY(x), 0, MidpointRounding.AwayFromZero);

                if (!(y >= 0 && y < objImage.ref_objMainImage.Height &&
                     x >= 0 && x < objImage.ref_objMainImage.Width))
                {
                    continue;
                }

                if (y < objImage.ref_objMainImage.Height)
                    objImage.ref_objMainImage.SetPixel(darkPixel, x, y);
            }

            // ------------------- Set limit with dark pixel --------------------------------------------------
            for (x = intStartX2; x < intEndX2; x++)
            {
                objImage.ref_objMainImage.SetPixel(darkPixel, x, intStartY2);
            }
            int intEnd = intEndY2;
            for (x = intStartX2; x < intEndX2; x++)
            {
                objImage.ref_objMainImage.SetPixel(darkPixel, x, intEnd);
            }
            for (y = intStartY2; y < intEndY2; y++)
            {
                objImage.ref_objMainImage.SetPixel(darkPixel, intStartX2, y);
            }
            intEnd = intEndX2;
            for (y = intStartY2; y < intEndY2; y++)
            {
                objImage.ref_objMainImage.SetPixel(darkPixel, intEnd, y);
            }
        }
        private bool IsImage1UnitChippedOff(ROI objImage1UnitROI)
        {
            bool blnResult = true;
            bool blnDebugImage = false;

            // Get Chipped off Image
            int intStartPixelFromEdgeX = (int)Math.Round(m_fChipStartPixelFromEdge * m_fMMToPixelXValue, 0, MidpointRounding.AwayFromZero);
            int intStartPixelFromEdgeY = (int)Math.Round(m_fChipStartPixelFromEdge * m_fMMToPixelYValue, 0, MidpointRounding.AwayFromZero);


            m_objInsSurfacePkgImage1.CopyTo(ref m_objInsChipOffPkgImage1);
            int intPkgSizeTolerance = 3;
            ROI objChippedOffROI = new ROI();
            objChippedOffROI.AttachImage(m_objInsChipOffPkgImage1);
            objChippedOffROI.LoadROISetting(objImage1UnitROI.ref_ROITotalX + intPkgSizeTolerance,
                                            objImage1UnitROI.ref_ROITotalY + intPkgSizeTolerance,
                                            objImage1UnitROI.ref_ROIWidth - intPkgSizeTolerance * 2,
                                            objImage1UnitROI.ref_ROIHeight - intPkgSizeTolerance * 2);
            FillDarkColorToCorner(m_objInsChipOffPkgImage1, intStartPixelFromEdgeX, intStartPixelFromEdgeY, objChippedOffROI);

            m_objImage1ChipOffEBlobs.BuildObjects_Filter_GetElement(objChippedOffROI, false, true, 0, 125,
                Math.Min(intStartPixelFromEdgeX, intStartPixelFromEdgeY), 999999, false, 0x0F);

            if (blnDebugImage)
            {
                objImage1UnitROI.SaveImage("D:\\TS\\objImage1UnitROI.bmp");// debug
                objChippedOffROI.SaveImage("D:\\TS\\objChippedOffROI.bmp");// debug
            }

            if (m_objImage1ChipOffEBlobs.ref_intNumSelectedObject > 0)
            {
                float fCenterX = 0, fCenterY = 0, fWidth = 0, fHeight = 0;
                float fStartX, fStartY, fEndX, fEndY;
                int intArea = 0;
                float fInterStartX = intStartPixelFromEdgeX;
                float fInterStartY = intStartPixelFromEdgeY;
                float fInterEndX = objChippedOffROI.ref_ROIWidth - intStartPixelFromEdgeX;
                float fInterEndY = objChippedOffROI.ref_ROIHeight - intStartPixelFromEdgeY;
                float fOuterStartX = Math.Min(2, fInterStartX - 1);
                float fOuterStartY = Math.Min(2, fInterStartY - 1);
                float fOuterEndX = objChippedOffROI.ref_ROIWidth - fOuterStartX;
                float fOuterEndY = objChippedOffROI.ref_ROIHeight - fOuterStartY;
                int intFailCount = 0;

                for (int i = 0; i < m_objImage1ChipOffEBlobs.ref_intNumSelectedObject; i++)
                {
                    fCenterX = m_objImage1ChipOffEBlobs.ref_arrLimitCenterX[i];
                    fCenterY = m_objImage1ChipOffEBlobs.ref_arrLimitCenterY[i];
                    fWidth = m_objImage1ChipOffEBlobs.ref_arrWidth[i];
                    fHeight = m_objImage1ChipOffEBlobs.ref_arrHeight[i];
                    intArea = m_objImage1ChipOffEBlobs.ref_arrArea[i];

                    fStartX = (float)Math.Floor(fCenterX - (fWidth / 2));
                    fStartY = (float)Math.Floor(fCenterY - (fHeight / 2));
                    fEndX = (float)Math.Ceiling(fCenterX + (fWidth / 2));
                    fEndY = (float)Math.Ceiling(fCenterY + (fHeight / 2));

                    if ((fStartY <= fOuterStartY && fEndY >= fInterStartY) || // check top position
                       (fStartY <= fInterEndY && fEndY >= fOuterEndY) || // check bottom position
                       (fStartX <= fOuterStartX && fEndX >= fInterStartX) || // check left position
                       (fStartX <= fInterEndX && fEndX >= fOuterEndX)) // check right position
                    {
                        intFailCount++;
                        m_intFailPkgResultMask |= 0x04; // Fail image 1 chipped off

                        float fWidthMM = fWidth / m_fMMToPixelXValue;
                        float fHeightMM = fHeight / m_fMMToPixelYValue; // 11-04-2019 ZJYEOH : Changed m_fMMToPixelXValue to m_fMMToPixelYValue
                        float fAreaInMM = intArea / m_fMMToPixelXValue / m_fMMToPixelYValue;

                        m_intFailPkgResultMask |= 0x04; // Fail image 1 chipped off

                        Defect objDefect = new Defect();
                        objDefect.ref_strName = "Image 1 Chipped Off " + intFailCount.ToString();
                        objDefect.ref_intFailMask |= 0x04;
                        objDefect.ref_fCenterX = objChippedOffROI.ref_ROITotalX + fCenterX;
                        objDefect.ref_fCenterY = objChippedOffROI.ref_ROITotalY + fCenterY;
                        objDefect.ref_fStartX = objChippedOffROI.ref_ROITotalX + fStartX;
                        objDefect.ref_fStartY = objChippedOffROI.ref_ROITotalY + fStartY;
                        objDefect.ref_fEndX = objChippedOffROI.ref_ROITotalX + fEndX;
                        objDefect.ref_fEndY = objChippedOffROI.ref_ROITotalY + fEndY;
                        objDefect.ref_fWidth = fWidth;
                        objDefect.ref_fHeight = fHeight;
                        objDefect.ref_fArea = intArea;
                        objDefect.ref_fWidthInMM = fWidthMM;
                        objDefect.ref_fHeightInMM = fHeightMM;
                        objDefect.ref_fAreaInMM2 = fAreaInMM;
                        objDefect.ref_intFailCriteria |= 0x01;
                        objDefect.ref_intImageNo = 1;

                        m_arrPkgDefectList.Add(objDefect);

                        if (blnResult)
                            blnResult = false;
                    }
                }
            }

            objChippedOffROI.Dispose();

            return blnResult;
        }
        private bool IsImage1UnitScratch(ROI objSampleROI, int intROIStartX, int intROIStartY, int intImageIndex)
        {
            bool blnResult = true;
            bool blnDebugImage = false;

            if (blnDebugImage)
                objSampleROI.SaveImage("D:\\TS\\objSampleROI.bmp"); // debug

            // Calculate start point from actual measurement package size. Fyi, objSampleROI size is not same as package size, but is PadROI Size
            float fPkgOffsetX = (objSampleROI.ref_ROIWidth - Math.Max(GetResultUpWidth_RectGauge4L(0), GetResultDownWidth_RectGauge4L(0))) / 2;
            float fPkgOffsetY = (objSampleROI.ref_ROIHeight - Math.Max(GetResultLeftHeight_RectGauge4L(0), GetResultRightHeight_RectGauge4L(0))) / 2;

            int intPkgSizeTolerance = 0;
            int intStartPixelFromEdgeX = (int)Math.Round(fPkgOffsetX + m_fPkgStartPixelFromLeft, 0, MidpointRounding.AwayFromZero) + intPkgSizeTolerance;
            int intStartPixelFromEdgeY = (int)Math.Round(fPkgOffsetY + m_fPkgStartPixelFromEdge, 0, MidpointRounding.AwayFromZero) + intPkgSizeTolerance;
            int intStartPixelFromEdgeX2 = (int)Math.Round(fPkgOffsetX + m_fPkgStartPixelFromRight, 0, MidpointRounding.AwayFromZero) + intPkgSizeTolerance;
            int intStartPixelFromEdgeY2 = (int)Math.Round(fPkgOffsetY + m_fPkgStartPixelFromBottom, 0, MidpointRounding.AwayFromZero) + intPkgSizeTolerance;

            ROI objCheckAreaSampleROI = new ROI();
            objCheckAreaSampleROI.AttachImage(objSampleROI);
            objCheckAreaSampleROI.LoadROISetting(intStartPixelFromEdgeX, intStartPixelFromEdgeY,
                objSampleROI.ref_ROIWidth - intStartPixelFromEdgeX - intStartPixelFromEdgeX2,
                objSampleROI.ref_ROIHeight - intStartPixelFromEdgeY - intStartPixelFromEdgeY2);

            //// Build blobs object for subtract image
            //m_objImage1SurfaceEBlobs.BuildObjects_Filter_GetElement(objCheckAreaSampleROI, false, true, 0, 125,
            //            (int)m_fBlobsMinArea, 999999, false, 0x0F);

            // 2019 03 04 - JBTAN: Use self-defined minimum build blob area by user
            switch (intImageIndex)
            {
                case 1: // Image 1 (Grab 1 & Grab 2 Merged)
                    {
                        m_objImage1SurfaceEBlobs.BuildObjects_Filter_GetElement(objCheckAreaSampleROI, false, true, 0, 125,
                                    (int)Math.Floor(m_fSurfaceMinArea), 999999, false, 0x0F);
                    }
                    break;
                case 2: // Image 2 (Grab 3)
                    {
                        m_objImage1SurfaceEBlobs.BuildObjects_Filter_GetElement(objCheckAreaSampleROI, false, true, 0, 125,
                                    (int)Math.Floor(m_fImage2SurfaceMinArea), 999999, false, 0x0F);
                    }
                    break;
            }

            if (blnDebugImage)
                objCheckAreaSampleROI.SaveImage("D:\\TS\\objCheckAreaSampleROI.bmp");   // debug

            bool blnOverallResult = true;
            if (m_objImage1SurfaceEBlobs.ref_intNumSelectedObject > 0)
            {
                float fCenterX = 0, fCenterY = 0, fWidth = 0, fHeight = 0;
                float fStartX, fStartY, fEndX, fEndY;
                int intArea = 0;
                float fWidthMM, fHeightMM, fAreaInMM;
                int intFailCount = 0;
                for (int i = 0; i < m_objImage1SurfaceEBlobs.ref_intNumSelectedObject; i++)
                {
                    fCenterX = m_objImage1SurfaceEBlobs.ref_arrLimitCenterX[i];
                    fCenterY = m_objImage1SurfaceEBlobs.ref_arrLimitCenterY[i];
                    fWidth = m_objImage1SurfaceEBlobs.ref_arrWidth[i];
                    fHeight = m_objImage1SurfaceEBlobs.ref_arrHeight[i];
                    intArea = m_objImage1SurfaceEBlobs.ref_arrArea[i];
                    fCenterX += intStartPixelFromEdgeX;
                    fCenterY += intStartPixelFromEdgeY;
                    fStartX = (float)Math.Floor(fCenterX - (fWidth / 2));
                    fStartY = (float)Math.Floor(fCenterY - (fHeight / 2));
                    fEndX = (float)Math.Ceiling(fCenterX + (fWidth / 2));
                    fEndY = (float)Math.Ceiling(fCenterY + (fHeight / 2));

                    // convert width and height to mm
                    fWidthMM = fWidth / m_fMMToPixelXValue;
                    fHeightMM = fHeight / m_fMMToPixelYValue; // 11-04-2019 ZJYEOH : Changed m_fMMToPixelXValue to m_fMMToPixelYValue
                    fAreaInMM = intArea / m_fMMToPixelXValue / m_fMMToPixelYValue;

                    //if ((fWidthMM > m_fScratchLength) || (fHeightMM > m_fScratchLength) || (fAreaInMM > m_fScratchArea))
                    {
                        intFailCount++;
                        m_intFailPkgResultMask |= 0x08; // Fail image 1 surface scratch
                        Defect objDefect = new Defect();
                        objDefect.ref_strName = "Scratch";
                        objDefect.ref_intFailMask |= 0x08;
                        objDefect.ref_fCenterX = intROIStartX + fCenterX;// +objCheckAreaSampleROI.ref_ROITotalX
                        objDefect.ref_fCenterY = intROIStartY + fCenterY;//+ objCheckAreaSampleROI.ref_ROITotalY 
                        objDefect.ref_fStartX = intROIStartX + fStartX;
                        objDefect.ref_fStartY = intROIStartY + fStartY;
                        objDefect.ref_fEndX = intROIStartX + fEndX;
                        objDefect.ref_fEndY = intROIStartY + fEndY;
                        objDefect.ref_fWidth = fWidth;
                        objDefect.ref_fHeight = fHeight;
                        objDefect.ref_fArea = intArea;
                        objDefect.ref_fWidthInMM = fWidthMM;
                        objDefect.ref_fHeightInMM = fHeightMM;
                        objDefect.ref_fAreaInMM2 = fAreaInMM;
                        objDefect.ref_intImageNo = 1;

                        if ((m_intFailPkgOptionMask & 0x1000) > 0)
                        {
                            if (fWidthMM > m_fScratchLength)
                            {
                                blnOverallResult = false;
                                objDefect.ref_fWidthFailValue = fWidthMM;
                                objDefect.ref_intFailCriteria |= 0x01;
                            }
                            if (fHeightMM > m_fScratchLength)
                            {
                                blnOverallResult = false;
                                objDefect.ref_fHeightFailValue = fHeightMM;
                                objDefect.ref_intFailCriteria |= 0x02;
                            }
                        }

                        if ((m_intFailPkgOptionMask & 0x08) > 0)
                        {
                            if (fAreaInMM > m_fScratchArea)
                            {
                                blnOverallResult = false;
                                objDefect.ref_fAreaFailValue = fAreaInMM;
                                objDefect.ref_intFailCriteria |= 0x04;
                            }
                        }

                        // Collect Scratch min and max area for display error message
                        if ((fWidthMM > m_fScratchLength) || (fHeightMM > m_fScratchLength))
                        {
                            if (fWidthMM > fHeightMM)
                            {
                                if (fWidthMM > m_fScratchLength)
                                    objDefect.ref_fFailValue = fWidthMM;
                                else
                                    objDefect.ref_fFailValue = fHeightMM;

                            }
                            else
                            {
                                if (fHeightMM > m_fScratchLength)
                                    objDefect.ref_fFailValue = fHeightMM;
                                else
                                    objDefect.ref_fFailValue = fWidthMM;
                            }
                        }
                        else
                        {
                            objDefect.ref_fFailValue = fAreaInMM;
                        }

                        m_arrPkgDefectList.Add(objDefect);
                    }
                }
            }

            objCheckAreaSampleROI.Dispose();
            return blnOverallResult;
        }
        private bool IsImage1UnitScratch_TiltAngle(ROI objSampleROI, int intROIStartX, int intROIStartY, int intImageIndex, int intPadIndex)
        {
            bool blnResult = true;
            bool blnDebugImage = false;

            if (blnDebugImage)
                objSampleROI.SaveImage("D:\\TS\\objSampleROI.bmp"); // debug

            // Calculate start point from actual measurement package size. Fyi, objSampleROI size is not same as package size, but is PadROI Size
            float fPkgOffsetX = (objSampleROI.ref_ROIWidth - Math.Max(GetResultUpWidth_RectGauge4L(0), GetResultDownWidth_RectGauge4L(0))) / 2;
            float fPkgOffsetY = (objSampleROI.ref_ROIHeight - Math.Max(GetResultLeftHeight_RectGauge4L(0), GetResultRightHeight_RectGauge4L(0))) / 2;

            int intPkgSizeTolerance = 0;
            int intStartPixelFromEdgeX = (int)Math.Round(fPkgOffsetX + m_fPkgStartPixelFromLeft, 0, MidpointRounding.AwayFromZero) + intPkgSizeTolerance;
            int intStartPixelFromEdgeY = (int)Math.Round(fPkgOffsetY + m_fPkgStartPixelFromEdge, 0, MidpointRounding.AwayFromZero) + intPkgSizeTolerance;
            int intStartPixelFromEdgeX2 = (int)Math.Round(fPkgOffsetX + m_fPkgStartPixelFromRight, 0, MidpointRounding.AwayFromZero) + intPkgSizeTolerance;
            int intStartPixelFromEdgeY2 = (int)Math.Round(fPkgOffsetY + m_fPkgStartPixelFromBottom, 0, MidpointRounding.AwayFromZero) + intPkgSizeTolerance;

            ROI objCheckAreaSampleROI = new ROI();
            objCheckAreaSampleROI.AttachImage(objSampleROI);
            objCheckAreaSampleROI.LoadROISetting(intStartPixelFromEdgeX, intStartPixelFromEdgeY,
                objSampleROI.ref_ROIWidth - intStartPixelFromEdgeX - intStartPixelFromEdgeX2,
                objSampleROI.ref_ROIHeight - intStartPixelFromEdgeY - intStartPixelFromEdgeY2);

            //2019-09-23 ZJYEOH : Subtract tilt dont care area 
            if (intPadIndex == 1) // Top
            {
                ROI DontCareTop = new ROI();

                DontCareTop.LoadROISetting(0, 0, objCheckAreaSampleROI.ref_ROIWidth, objCheckAreaSampleROI.ref_ROIHeight);
                DontCareTop.AttachImage(m_ImgTilt_Top_L);
                EasyImage.Oper(EArithmeticLogicOperation.Subtract, objCheckAreaSampleROI.ref_ROI, DontCareTop.ref_ROI, objCheckAreaSampleROI.ref_ROI);
                DontCareTop.LoadROISetting(m_ImgTilt_Top_R.ref_intImageWidth - objCheckAreaSampleROI.ref_ROIWidth, 0, objCheckAreaSampleROI.ref_ROIWidth, objCheckAreaSampleROI.ref_ROIHeight);
                DontCareTop.AttachImage(m_ImgTilt_Top_R);
                EasyImage.Oper(EArithmeticLogicOperation.Subtract, objCheckAreaSampleROI.ref_ROI, DontCareTop.ref_ROI, objCheckAreaSampleROI.ref_ROI);
                if (blnDebugImage)
                    objCheckAreaSampleROI.SaveImage("D:\\IsImage1UnitScratch_objCheckAreaSampleROITop.bmp");
                DontCareTop.Dispose();
            }
            if (intPadIndex == 2) // Right
            {
                ROI DontCareRight = new ROI();
                DontCareRight.LoadROISetting(m_ImgTilt_Top_R.ref_intImageWidth - objCheckAreaSampleROI.ref_ROIWidth, 0, objCheckAreaSampleROI.ref_ROIWidth, objCheckAreaSampleROI.ref_ROIHeight);
                DontCareRight.AttachImage(m_ImgTilt_Right_T);
                EasyImage.Oper(EArithmeticLogicOperation.Subtract, objCheckAreaSampleROI.ref_ROI, DontCareRight.ref_ROI, objCheckAreaSampleROI.ref_ROI);
                DontCareRight.LoadROISetting(m_ImgTilt_Top_R.ref_intImageWidth - objCheckAreaSampleROI.ref_ROIWidth, m_ImgTilt_Top_R.ref_intImageHeight - objCheckAreaSampleROI.ref_ROIHeight, objCheckAreaSampleROI.ref_ROIWidth, objCheckAreaSampleROI.ref_ROIHeight);
                DontCareRight.AttachImage(m_ImgTilt_Right_B);
                EasyImage.Oper(EArithmeticLogicOperation.Subtract, objCheckAreaSampleROI.ref_ROI, DontCareRight.ref_ROI, objCheckAreaSampleROI.ref_ROI);
                if (blnDebugImage)
                    objCheckAreaSampleROI.SaveImage("D:\\IsImage1UnitScratch_objCheckAreaSampleROIRight.bmp");
                DontCareRight.Dispose();
            }
            if (intPadIndex == 3) // Bottom
            {
                ROI DontCareBottom = new ROI();

                DontCareBottom.LoadROISetting(0, m_ImgTilt_Top_R.ref_intImageHeight - objCheckAreaSampleROI.ref_ROIHeight, objCheckAreaSampleROI.ref_ROIWidth, objCheckAreaSampleROI.ref_ROIHeight);
                DontCareBottom.AttachImage(m_ImgTilt_Bottom_L);
                EasyImage.Oper(EArithmeticLogicOperation.Subtract, objCheckAreaSampleROI.ref_ROI, DontCareBottom.ref_ROI, objCheckAreaSampleROI.ref_ROI);
                DontCareBottom.LoadROISetting(m_ImgTilt_Top_R.ref_intImageWidth - objCheckAreaSampleROI.ref_ROIWidth, m_ImgTilt_Top_R.ref_intImageHeight - objCheckAreaSampleROI.ref_ROIHeight, objCheckAreaSampleROI.ref_ROIWidth, objCheckAreaSampleROI.ref_ROIHeight);
                DontCareBottom.AttachImage(m_ImgTilt_Bottom_R);
                EasyImage.Oper(EArithmeticLogicOperation.Subtract, objCheckAreaSampleROI.ref_ROI, DontCareBottom.ref_ROI, objCheckAreaSampleROI.ref_ROI);
                if (blnDebugImage)
                    objCheckAreaSampleROI.SaveImage("D:\\IsImage1UnitScratch_objCheckAreaSampleROIBottom.bmp");
                DontCareBottom.Dispose();
            }
            if (intPadIndex == 4) // Left
            {
                ROI DontCareLeft = new ROI();

                DontCareLeft.LoadROISetting(0, 0, objCheckAreaSampleROI.ref_ROIWidth, objCheckAreaSampleROI.ref_ROIHeight);
                DontCareLeft.AttachImage(m_ImgTilt_Left_T);
                EasyImage.Oper(EArithmeticLogicOperation.Subtract, objCheckAreaSampleROI.ref_ROI, DontCareLeft.ref_ROI, objCheckAreaSampleROI.ref_ROI);
                DontCareLeft.LoadROISetting(0, m_ImgTilt_Top_R.ref_intImageHeight - objCheckAreaSampleROI.ref_ROIHeight, objCheckAreaSampleROI.ref_ROIWidth, objCheckAreaSampleROI.ref_ROIHeight);
                DontCareLeft.AttachImage(m_ImgTilt_Left_B);
                EasyImage.Oper(EArithmeticLogicOperation.Subtract, objCheckAreaSampleROI.ref_ROI, DontCareLeft.ref_ROI, objCheckAreaSampleROI.ref_ROI);
                if (blnDebugImage)
                    objCheckAreaSampleROI.SaveImage("D:\\IsImage1UnitScratch_objCheckAreaSampleROILeft.bmp");
                DontCareLeft.Dispose();
            }
            //// Build blobs object for subtract image
            //m_objImage1SurfaceEBlobs.BuildObjects_Filter_GetElement(objCheckAreaSampleROI, false, true, 0, 125,
            //            (int)m_fBlobsMinArea, 999999, false, 0x0F);

            // 2019 03 04 - JBTAN: Use self-defined minimum build blob area by user
            switch (intImageIndex)
            {
                case 1: // Image 1 (Grab 1 & Grab 2 Merged)
                    {
                        m_objImage1SurfaceEBlobs.BuildObjects_Filter_GetElement(objCheckAreaSampleROI, false, true, 0, 125,
                                    (int)Math.Floor(m_fSurfaceMinArea), 999999, false, 0x0F);
                    }
                    break;
                case 2: // Image 2 (Grab 3)
                    {
                        m_objImage1SurfaceEBlobs.BuildObjects_Filter_GetElement(objCheckAreaSampleROI, false, true, 0, 125,
                                    (int)Math.Floor(m_fImage2SurfaceMinArea), 999999, false, 0x0F);
                    }
                    break;
            }

            if (blnDebugImage)
                objCheckAreaSampleROI.SaveImage("D:\\TS\\objCheckAreaSampleROI.bmp");   // debug

            bool blnOverallResult = true;
            if (m_objImage1SurfaceEBlobs.ref_intNumSelectedObject > 0)
            {
                float fCenterX = 0, fCenterY = 0, fWidth = 0, fHeight = 0;
                float fStartX, fStartY, fEndX, fEndY;
                int intArea = 0;
                float fWidthMM, fHeightMM, fAreaInMM;
                int intFailCount = 0;
                for (int i = 0; i < m_objImage1SurfaceEBlobs.ref_intNumSelectedObject; i++)
                {
                    fCenterX = m_objImage1SurfaceEBlobs.ref_arrLimitCenterX[i];
                    fCenterY = m_objImage1SurfaceEBlobs.ref_arrLimitCenterY[i];
                    fWidth = m_objImage1SurfaceEBlobs.ref_arrWidth[i];
                    fHeight = m_objImage1SurfaceEBlobs.ref_arrHeight[i];
                    intArea = m_objImage1SurfaceEBlobs.ref_arrArea[i];
                    fCenterX += intStartPixelFromEdgeX;
                    fCenterY += intStartPixelFromEdgeY;
                    fStartX = (float)Math.Floor(fCenterX - (fWidth / 2));
                    fStartY = (float)Math.Floor(fCenterY - (fHeight / 2));
                    fEndX = (float)Math.Ceiling(fCenterX + (fWidth / 2));
                    fEndY = (float)Math.Ceiling(fCenterY + (fHeight / 2));

                    // convert width and height to mm
                    fWidthMM = fWidth / m_fMMToPixelXValue;
                    fHeightMM = fHeight / m_fMMToPixelYValue; // 11-04-2019 ZJYEOH : Changed m_fMMToPixelXValue to m_fMMToPixelYValue
                    fAreaInMM = intArea / m_fMMToPixelXValue / m_fMMToPixelYValue;

                    //if ((fWidthMM > m_fScratchLength) || (fHeightMM > m_fScratchLength) || (fAreaInMM > m_fScratchArea))
                    {
                        intFailCount++;
                        m_intFailPkgResultMask |= 0x08; // Fail image 1 surface scratch
                        Defect objDefect = new Defect();
                        objDefect.ref_strName = "Scratch";
                        objDefect.ref_intFailMask |= 0x08;
                        objDefect.ref_fCenterX = intROIStartX + fCenterX;// +objCheckAreaSampleROI.ref_ROITotalX
                        objDefect.ref_fCenterY = intROIStartY + fCenterY;//+ objCheckAreaSampleROI.ref_ROITotalY 
                        objDefect.ref_fStartX = intROIStartX + fStartX;
                        objDefect.ref_fStartY = intROIStartY + fStartY;
                        objDefect.ref_fEndX = intROIStartX + fEndX;
                        objDefect.ref_fEndY = intROIStartY + fEndY;
                        objDefect.ref_fWidth = fWidth;
                        objDefect.ref_fHeight = fHeight;
                        objDefect.ref_fArea = intArea;
                        objDefect.ref_fWidthInMM = fWidthMM;
                        objDefect.ref_fHeightInMM = fHeightMM;
                        objDefect.ref_fAreaInMM2 = fAreaInMM;
                        objDefect.ref_intImageNo = 1;

                        if ((m_intFailPkgOptionMask & 0x1000) > 0)
                        {
                            if (fWidthMM > m_fScratchLength)
                            {
                                blnOverallResult = false;
                                objDefect.ref_fWidthFailValue = fWidthMM;
                                objDefect.ref_intFailCriteria |= 0x01;
                            }
                            if (fHeightMM > m_fScratchLength)
                            {
                                blnOverallResult = false;
                                objDefect.ref_fHeightFailValue = fHeightMM;
                                objDefect.ref_intFailCriteria |= 0x02;
                            }
                        }

                        if ((m_intFailPkgOptionMask & 0x08) > 0)
                        {
                            if (fAreaInMM > m_fScratchArea)
                            {
                                blnOverallResult = false;
                                objDefect.ref_fAreaFailValue = fAreaInMM;
                                objDefect.ref_intFailCriteria |= 0x04;
                            }
                        }

                        // Collect Scratch min and max area for display error message
                        if ((fWidthMM > m_fScratchLength) || (fHeightMM > m_fScratchLength))
                        {
                            if (fWidthMM > fHeightMM)
                            {
                                if (fWidthMM > m_fScratchLength)
                                    objDefect.ref_fFailValue = fWidthMM;
                                else
                                    objDefect.ref_fFailValue = fHeightMM;

                            }
                            else
                            {
                                if (fHeightMM > m_fScratchLength)
                                    objDefect.ref_fFailValue = fHeightMM;
                                else
                                    objDefect.ref_fFailValue = fWidthMM;
                            }
                        }
                        else
                        {
                            objDefect.ref_fFailValue = fAreaInMM;
                        }

                        m_arrPkgDefectList.Add(objDefect);
                    }
                }
            }

            objCheckAreaSampleROI.Dispose();
            return blnOverallResult;
        }

        private bool IsImage1UnitScratch_Gradient(ROI objSampleROI, int intROIStartX, int intROIStartY, int intImageIndex)
        {
            bool blnResult = true;
            bool blnDebugImage = false;

            if (blnDebugImage)
                objSampleROI.SaveImage("D:\\TS\\objSampleROI.bmp"); // debug

            // Calculate start point from actual measurement package size. Fyi, objSampleROI size is not same as package size, but is PadROI Size
            float fPkgOffsetX = (objSampleROI.ref_ROIWidth - Math.Max(GetResultUpWidth_RectGauge4L(0), GetResultDownWidth_RectGauge4L(0))) / 2;
            float fPkgOffsetY = (objSampleROI.ref_ROIHeight - Math.Max(GetResultLeftHeight_RectGauge4L(0), GetResultRightHeight_RectGauge4L(0))) / 2;

            int intPkgSizeTolerance = 0;
            int intStartPixelFromEdgeX = (int)Math.Round(fPkgOffsetX + m_fPkgStartPixelFromLeft, 0, MidpointRounding.AwayFromZero) + intPkgSizeTolerance;
            int intStartPixelFromEdgeY = (int)Math.Round(fPkgOffsetY + m_fPkgStartPixelFromEdge, 0, MidpointRounding.AwayFromZero) + intPkgSizeTolerance;
            int intStartPixelFromEdgeX2 = (int)Math.Round(fPkgOffsetX + m_fPkgStartPixelFromRight, 0, MidpointRounding.AwayFromZero) + intPkgSizeTolerance;
            int intStartPixelFromEdgeY2 = (int)Math.Round(fPkgOffsetY + m_fPkgStartPixelFromBottom, 0, MidpointRounding.AwayFromZero) + intPkgSizeTolerance;

            ROI objCheckAreaSampleROI = new ROI();
            objCheckAreaSampleROI.AttachImage(objSampleROI);
            objCheckAreaSampleROI.LoadROISetting(intStartPixelFromEdgeX, intStartPixelFromEdgeY,
                objSampleROI.ref_ROIWidth - intStartPixelFromEdgeX - intStartPixelFromEdgeX2,
                objSampleROI.ref_ROIHeight - intStartPixelFromEdgeY - intStartPixelFromEdgeY2);
            //objCheckAreaSampleROI.SaveImage("D:\\objCheckAreaSampleROI.bmp");
            //EasyImage.MorphoGradientBox(objCheckAreaSampleROI.ref_ROI, objCheckAreaSampleROI.ref_ROI , 1);
            //objCheckAreaSampleROI.SaveImage("D:\\GradientROI.bmp");
            switch (intImageIndex)
            {
                case 1: // Image 1 (Grab 1 & Grab 2 Merged)
                    {
                        m_objImage1SurfaceEBlobs.BuildObjects_Filter_GetElement(objCheckAreaSampleROI, false, true, 0, 45,
                                    (int)Math.Floor(m_fSurfaceMinArea), 999999, false, 0x0F);
                    }
                    break;
                case 2: // Image 2 (Grab 3)
                    {
                        m_objImage1SurfaceEBlobs.BuildObjects_Filter_GetElement(objCheckAreaSampleROI, false, true, 0, 45,
                                    (int)Math.Floor(m_fImage2SurfaceMinArea), 999999, false, 0x0F);
                    }
                    break;
            }

            if (blnDebugImage)
                objCheckAreaSampleROI.SaveImage("D:\\TS\\objCheckAreaSampleROI.bmp");   // debug

            if (m_objImage1SurfaceEBlobs.ref_intNumSelectedObject > 0)
            {

                float fCenterX = 0, fCenterY = 0, fWidth = 0, fHeight = 0;
                float fStartX, fStartY, fEndX, fEndY;
                int intArea = 0;
                float fWidthMM, fHeightMM, fAreaInMM;
                int intFailCount = 0;
                for (int i = 0; i < m_objImage1SurfaceEBlobs.ref_intNumSelectedObject; i++)
                {
                    float fHoleCenterX = 0, fHoleCenterY = 0, fHoleArea = 0;
                    m_objImage1SurfaceEBlobs.GetBlobsHole(i, ref fHoleCenterX, ref fHoleCenterY, ref fHoleArea);
                    fCenterX = m_objImage1SurfaceEBlobs.ref_arrLimitCenterX[i];
                    fCenterY = m_objImage1SurfaceEBlobs.ref_arrLimitCenterY[i];
                    fWidth = m_objImage1SurfaceEBlobs.ref_arrWidth[i];
                    fHeight = m_objImage1SurfaceEBlobs.ref_arrHeight[i];
                    intArea = m_objImage1SurfaceEBlobs.ref_arrArea[i];
                    fCenterX += intStartPixelFromEdgeX;
                    fCenterY += intStartPixelFromEdgeY;
                    fStartX = (float)Math.Floor(fCenterX - (fWidth / 2));
                    fStartY = (float)Math.Floor(fCenterY - (fHeight / 2));
                    fEndX = (float)Math.Ceiling(fCenterX + (fWidth / 2));
                    fEndY = (float)Math.Ceiling(fCenterY + (fHeight / 2));

                    // convert width and height to mm
                    fWidthMM = fWidth / m_fMMToPixelXValue;
                    fHeightMM = fHeight / m_fMMToPixelYValue; // 11-04-2019 ZJYEOH : Changed m_fMMToPixelXValue to m_fMMToPixelYValue
                    fAreaInMM = (intArea + fHoleArea) / m_fMMToPixelXValue / m_fMMToPixelYValue;

                    if ((fWidthMM > m_fScratchLength) || (fHeightMM > m_fScratchLength) || (fAreaInMM > m_fScratchArea))
                    {
                        intFailCount++;
                        m_intFailPkgResultMask |= 0x08; // Fail image 1 surface scratch

                        Defect objDefect = new Defect();


                        objDefect.ref_strName = "Scratch";

                        objDefect.ref_intFailMask |= 0x08;
                        objDefect.ref_fCenterX = intROIStartX + fCenterX;// +objCheckAreaSampleROI.ref_ROITotalX
                        objDefect.ref_fCenterY = intROIStartY + fCenterY;//+ objCheckAreaSampleROI.ref_ROITotalY 
                        objDefect.ref_fStartX = intROIStartX + fStartX;
                        objDefect.ref_fStartY = intROIStartY + fStartY;
                        objDefect.ref_fEndX = intROIStartX + fEndX;
                        objDefect.ref_fEndY = intROIStartY + fEndY;
                        objDefect.ref_fWidth = fWidth;
                        objDefect.ref_fHeight = fHeight;
                        objDefect.ref_fArea = intArea;
                        objDefect.ref_fWidthInMM = fWidthMM;
                        objDefect.ref_fHeightInMM = fHeightMM;
                        objDefect.ref_fAreaInMM2 = fAreaInMM;

                        if ((m_intFailPkgOptionMask & 0x1000) > 0)
                        {
                            if (fWidthMM > m_fScratchLength)
                            {

                                objDefect.ref_fWidthFailValue = fWidthMM;
                                objDefect.ref_intFailCriteria |= 0x01;
                            }
                            if (fHeightMM > m_fScratchLength)
                            {

                                objDefect.ref_fHeightFailValue = fHeightMM;
                                objDefect.ref_intFailCriteria |= 0x02;
                            }
                        }

                        if ((m_intFailPkgOptionMask & 0x08) > 0)
                        {
                            if (fAreaInMM > m_fScratchArea)
                            {

                                objDefect.ref_fAreaFailValue = fAreaInMM;
                                objDefect.ref_intFailCriteria |= 0x04;
                            }
                        }
                        objDefect.ref_intImageNo = 1;

                        // Collect Scratch min and max area for display error message

                        if ((fWidthMM > m_fScratchLength) || (fHeightMM > m_fScratchLength))
                        {
                            if (fWidthMM > fHeightMM)
                            {
                                if (fWidthMM > m_fScratchLength)
                                    objDefect.ref_fFailValue = fWidthMM;
                                else
                                    objDefect.ref_fFailValue = fHeightMM;

                            }
                            else
                            {
                                if (fHeightMM > m_fScratchLength)
                                    objDefect.ref_fFailValue = fHeightMM;
                                else
                                    objDefect.ref_fFailValue = fWidthMM;
                            }
                        }
                        else
                        {
                            objDefect.ref_fFailValue = fAreaInMM;
                        }

                        m_arrPkgDefectList.Add(objDefect);

                        if (blnResult)
                            blnResult = false;
                    }
                }
            }

            objCheckAreaSampleROI.Dispose();
            return blnResult;
        }
        private bool IsImage2UnitChippedOff(ROI objImage2UnitROI)
        {
            bool blnResult = true;
            bool blnDebugImage = false;

            // Get Chipped off Image
            int intPkgSizeTolerance = 3;
            int intStartPixelFromEdgeX = (int)Math.Round(m_fChipStartPixelFromEdge * m_fMMToPixelXValue, 0, MidpointRounding.AwayFromZero) + intPkgSizeTolerance;
            int intStartPixelFromEdgeY = (int)Math.Round(m_fChipStartPixelFromEdge * m_fMMToPixelYValue, 0, MidpointRounding.AwayFromZero) + intPkgSizeTolerance;

            m_objInsPkgImage2.CopyTo(ref m_objInsChipOffPkgImage2);
            ROI objChippedOffROI = new ROI();
            objChippedOffROI.AttachImage(m_objInsChipOffPkgImage2);
            objChippedOffROI.LoadROISetting(objImage2UnitROI.ref_ROITotalX + intStartPixelFromEdgeX,
                                            objImage2UnitROI.ref_ROITotalY + intStartPixelFromEdgeY,
                                            objImage2UnitROI.ref_ROIWidth - intStartPixelFromEdgeX * 2,
                                            objImage2UnitROI.ref_ROIHeight - intStartPixelFromEdgeX * 2);
            FillDarkColorToCorner(m_objInsChipOffPkgImage2, intStartPixelFromEdgeX, intStartPixelFromEdgeY, objChippedOffROI);

            if (blnDebugImage)
            {
                m_objInsChipOffPkgImage2.SaveImage("D:\\TS\\m_objInsChipOffPkgImage2.bmp"); // debug
                objChippedOffROI.SaveImage("D:\\TS\\objChippedOffROI.bmp"); // debug
            }

            // Build blobs object for subtract image
            m_objImage2ChipOffEBlobs.BuildObjects_Filter_GetElement(objChippedOffROI, false, true, 0, 125,
                Math.Min(intStartPixelFromEdgeX, intStartPixelFromEdgeY), 999999, false, 0x0F);


            if (m_objImage2ChipOffEBlobs.ref_intNumSelectedObject > 0)
            {
                float fCenterX = 0, fCenterY = 0, fWidth = 0, fHeight = 0;
                float fStartX, fStartY, fEndX, fEndY;
                int intArea = 0;
                float fWidthMM, fHeightMM, fAreaInMM;
                float fOuterStartX = 2;
                float fOuterStartY = 2;
                float fOuterEndX = objChippedOffROI.ref_ROIWidth - 2;
                float fOuterEndY = objChippedOffROI.ref_ROIHeight - 2;
                float fInterStartX = intStartPixelFromEdgeX;
                float fInterStartY = intStartPixelFromEdgeY;
                float fInterEndX = objChippedOffROI.ref_ROIWidth - intStartPixelFromEdgeX;
                float fInterEndY = objChippedOffROI.ref_ROIHeight - intStartPixelFromEdgeY;
                int intFailCount = 0;

                for (int i = 0; i < m_objImage2ChipOffEBlobs.ref_intNumSelectedObject; i++)
                {
                    fCenterX = m_objImage2ChipOffEBlobs.ref_arrLimitCenterX[i];
                    fCenterY = m_objImage2ChipOffEBlobs.ref_arrLimitCenterY[i];
                    fWidth = m_objImage2ChipOffEBlobs.ref_arrWidth[i];
                    fHeight = m_objImage2ChipOffEBlobs.ref_arrHeight[i];
                    intArea = m_objImage2ChipOffEBlobs.ref_arrArea[i];

                    fStartX = (float)Math.Floor(fCenterX - (fWidth / 2));
                    fStartY = (float)Math.Floor(fCenterY - (fHeight / 2));
                    fEndX = (float)Math.Ceiling(fCenterX + (fWidth / 2));
                    fEndY = (float)Math.Ceiling(fCenterY + (fHeight / 2));

                    fWidthMM = fWidth / m_fMMToPixelXValue;
                    fHeightMM = fHeight / m_fMMToPixelYValue; // 11-04-2019 ZJYEOH : Changed m_fMMToPixelXValue to m_fMMToPixelYValue
                    fAreaInMM = intArea / m_fMMToPixelXValue / m_fMMToPixelYValue;

                    if ((fStartY <= fOuterStartY && fEndY >= fInterStartY) || // check top position
                       (fStartY <= fInterEndY && fEndY >= fOuterEndY) || // check bottom position
                       (fStartX <= fOuterStartX && fEndX >= fInterStartX) || // check left position
                       (fStartX <= fInterEndX && fEndX >= fOuterEndX)) // check right position
                    {
                        intFailCount++;
                        m_intFailPkgResultMask |= 0x04; // Fail image 1 chipped off

                        Defect objDefect = new Defect();
                        objDefect.ref_strName = "Image 2 Chipped Off " + intFailCount.ToString();
                        objDefect.ref_intFailMask |= 0x04;
                        objDefect.ref_fCenterX = objChippedOffROI.ref_ROITotalX + fCenterX;
                        objDefect.ref_fCenterY = objChippedOffROI.ref_ROITotalY + fCenterY;
                        objDefect.ref_fStartX = objChippedOffROI.ref_ROITotalX + fStartX;
                        objDefect.ref_fStartY = objChippedOffROI.ref_ROITotalY + fStartY;
                        objDefect.ref_fEndX = objChippedOffROI.ref_ROITotalX + fEndX;
                        objDefect.ref_fEndY = objChippedOffROI.ref_ROITotalY + fEndY;
                        objDefect.ref_fWidth = fWidth;
                        objDefect.ref_fHeight = fHeight;
                        objDefect.ref_fArea = intArea;
                        objDefect.ref_fWidthInMM = fWidthMM;
                        objDefect.ref_fHeightInMM = fHeightMM;
                        objDefect.ref_fAreaInMM2 = fAreaInMM;

                        objDefect.ref_intImageNo = 2;
                        m_arrPkgDefectList.Add(objDefect);

                        if (blnResult)
                            blnResult = false;
                    }
                }
            }

            objChippedOffROI.Dispose();

            return blnResult;
        }

        private bool IsImage2UnitScratch(ROI objSampleROI, int intROIStartX, int intROIStartY)
        {
            bool blnResult = true;
            bool blnDebugImage = false;

            int intPkgSizeTolerance = 3;
            int intStartPixelFromEdgeX = (int)Math.Round(m_fPkgStartPixelFromEdge * m_fMMToPixelXValue, 0, MidpointRounding.AwayFromZero) + intPkgSizeTolerance;
            int intStartPixelFromEdgeY = (int)Math.Round(m_fPkgStartPixelFromEdge * m_fMMToPixelYValue, 0, MidpointRounding.AwayFromZero) + intPkgSizeTolerance;

            ROI objCheckAreaSampleROI = new ROI();
            objCheckAreaSampleROI.AttachImage(objSampleROI);
            objCheckAreaSampleROI.LoadROISetting(intStartPixelFromEdgeX, intStartPixelFromEdgeY,
                objSampleROI.ref_ROIWidth - intStartPixelFromEdgeX * 2,
                objSampleROI.ref_ROIHeight - intStartPixelFromEdgeY * 2);

            // Build blobs object for subtract image
            m_objImage2SurfaceEBlobs.BuildObjects_Filter_GetElement(objCheckAreaSampleROI, false, true, 0, 125,
                (int)m_fBlobsMinArea, 999999, false, 0x0F);

            if (blnDebugImage)
                objCheckAreaSampleROI.SaveImage("D:\\TS\\objCheckAreaSampleROI.bmp");   // debug

            if (m_objImage2SurfaceEBlobs.ref_intNumSelectedObject > 0)
            {
                float fCenterX = 0, fCenterY = 0, fWidth = 0, fHeight = 0;
                float fStartX, fStartY, fEndX, fEndY;
                int intArea = 0;
                float fWidthMM, fHeightMM, fAreaInMM;
                int intFailCount = 0;

                for (int i = 0; i < m_objImage2SurfaceEBlobs.ref_intNumSelectedObject; i++)
                {
                    fCenterX = m_objImage2SurfaceEBlobs.ref_arrLimitCenterX[i];
                    fCenterY = m_objImage2SurfaceEBlobs.ref_arrLimitCenterY[i];
                    fWidth = m_objImage2SurfaceEBlobs.ref_arrWidth[i];
                    fHeight = m_objImage2SurfaceEBlobs.ref_arrHeight[i];
                    intArea = m_objImage2SurfaceEBlobs.ref_arrArea[i];

                    fStartX = (float)Math.Floor(fCenterX - (fWidth / 2));
                    fStartY = (float)Math.Floor(fCenterY - (fHeight / 2));
                    fEndX = (float)Math.Ceiling(fCenterX + (fWidth / 2));
                    fEndY = (float)Math.Ceiling(fCenterY + (fHeight / 2));

                    // convert width and height to mm
                    fWidthMM = fWidth / m_fMMToPixelXValue;
                    fHeightMM = fHeight / m_fMMToPixelYValue; // 11-04-2019 ZJYEOH : Changed m_fMMToPixelXValue to m_fMMToPixelYValue
                    fAreaInMM = intArea / m_fMMToPixelXValue / m_fMMToPixelYValue;

                    if ((fWidthMM > m_fScratchLength) || (fHeightMM > m_fScratchLength) || (fAreaInMM > m_fScratchArea))
                    {
                        intFailCount++;
                        m_intFailPkgResultMask |= 0x08; // Fail image 1 surface scratch

                        Defect objDefect = new Defect();
                        objDefect.ref_strName = "Image 2 Package Scratch " + intFailCount.ToString();
                        objDefect.ref_intFailMask |= 0x08;
                        objDefect.ref_fCenterX = intROIStartX + objCheckAreaSampleROI.ref_ROITotalX + fCenterX;
                        objDefect.ref_fCenterY = intROIStartY + objCheckAreaSampleROI.ref_ROITotalY + fCenterY;
                        objDefect.ref_fStartX = intROIStartX + objCheckAreaSampleROI.ref_ROITotalX + fStartX;
                        objDefect.ref_fStartY = intROIStartY + objCheckAreaSampleROI.ref_ROITotalY + fStartY;
                        objDefect.ref_fEndX = intROIStartX + objCheckAreaSampleROI.ref_ROITotalX + fEndX;
                        objDefect.ref_fEndY = intROIStartY + objCheckAreaSampleROI.ref_ROITotalY + fEndY;
                        objDefect.ref_fWidth = fWidth;
                        objDefect.ref_fHeight = fHeight;
                        objDefect.ref_fArea = intArea;
                        objDefect.ref_fWidthInMM = fWidthMM;
                        objDefect.ref_fHeightInMM = fHeightMM;
                        objDefect.ref_fAreaInMM2 = fAreaInMM;
                        if (fWidthMM > m_fScratchLength)
                            objDefect.ref_intFailCriteria |= 0x01;

                        if (fHeightMM > m_fScratchLength)
                            objDefect.ref_intFailCriteria |= 0x02;

                        if (fAreaInMM > m_fScratchArea)
                            objDefect.ref_intFailCriteria |= 0x04;

                        objDefect.ref_intImageNo = 2;

                        // Collect Scratch min and max area for display error message

                        if ((fWidthMM > m_fScratchLength) || (fHeightMM > m_fScratchLength))
                        {
                            if (fWidthMM > fHeightMM)
                            {
                                if (fWidthMM > m_fScratchLength)
                                    objDefect.ref_fFailValue = fWidthMM;
                                else
                                    objDefect.ref_fFailValue = fHeightMM;

                            }
                            else
                            {
                                if (fHeightMM > m_fScratchLength)
                                    objDefect.ref_fFailValue = fHeightMM;
                                else
                                    objDefect.ref_fFailValue = fWidthMM;
                            }
                        }
                        else
                        {
                            objDefect.ref_fFailValue = fAreaInMM;
                        }

                        m_arrPkgDefectList.Add(objDefect);

                        if (blnResult)
                            blnResult = false;
                    }

                }
            }

            objCheckAreaSampleROI.Dispose();
            return blnResult;
        }

        // ------------------ Blobs Find Unit Location --------------------------------------------------------

        public bool FindSecondImageUnitLocation_UsingBlobs(ROI obj2ndImageROI,
            int intSearchAndUnitROIOffSetX, int intSearchAndUnitROIOffSetY, ref PointF pSecondImageUnitCenterPoint)
        {
            /*
             * This function is only working if first image unit location found and Pad Test is done.
             * Using rotated images for both first and second image.
             * Based on sample pad location first image
             * Build second image pad as blobs
             * Match the second image blobs and first image blobs
             * and then determine the second image unit center
             * Place the package size onto second image unit center.
             *
             */

            if (BuildOnlyPadObjects(obj2ndImageROI))
            {
                float fLimitCenterX = 0, fLimitCenterY = 0;
                float fWidth = 0, fHeight = 0;
                int intArea = 0;

                float fStartX, fStartY, fEndX, fEndY;
                List<float> arrOffSetX = new List<float>();
                List<float> arrOffSetY = new List<float>();
                bool[] arrMatched = new bool[m_arrSampleBlobPads.Length];

                for (int i = 0; i < m_objEBlobs.ref_intNumSelectedObject; i++)
                {
                    // Stop find location after loop second image blobs count higher than first image blobs count.
                    // The less of the second image blobs are just the noise.
                    if (i >= m_arrSampleBlobPads.Length)
                        break;

                    // Get second image pad data
                    intArea = m_objEBlobs.ref_arrArea[i];
                    fLimitCenterX = m_objEBlobs.ref_arrLimitCenterX[i];
                    fLimitCenterY = m_objEBlobs.ref_arrLimitCenterY[i];
                    fWidth = m_objEBlobs.ref_arrWidth[i];
                    fHeight = m_objEBlobs.ref_arrHeight[i];

                    // Scan first image pads
                    for (int k = 0; k < m_arrSampleBlobPads.Length; k++)
                    {
                        //Skip if join pad
                        if ((m_arrSampleBlobPads[k].intFailMask & 0x02) > 0)
                            continue;

                        //Skip if missing pad
                        if ((m_arrSampleBlobPads[k].intFailMask & 0x04) > 0)
                            continue;

                        //Skip if alrady matched.
                        if (arrMatched[k])
                            continue;

                        // Get first image pads start and end point
                        fStartX = m_arrSampleBlobPads[k].fCenterX -
                                  (m_arrSampleBlobPads[k].fWidth / 2) + intSearchAndUnitROIOffSetX;
                        fStartY = m_arrSampleBlobPads[k].fCenterY -
                                  (m_arrSampleBlobPads[k].fHeight / 2) + intSearchAndUnitROIOffSetY;
                        fEndX = m_arrSampleBlobPads[k].fCenterX +
                                (m_arrSampleBlobPads[k].fWidth / 2) + intSearchAndUnitROIOffSetX;
                        fEndY = m_arrSampleBlobPads[k].fCenterY +
                                (m_arrSampleBlobPads[k].fHeight / 2) + intSearchAndUnitROIOffSetY;

                        // Check is second image pad center point in first image pad area
                        if ((fLimitCenterX >= fStartX) &&
                            (fLimitCenterX <= fEndX) &&
                            (fLimitCenterY >= fStartY) &&
                            (fLimitCenterY <= fEndY))
                        {
                            // get the offset between second pad and first pad.
                            arrOffSetX.Add(fLimitCenterX - (m_arrSampleBlobPads[k].fCenterX + intSearchAndUnitROIOffSetX));
                            arrOffSetY.Add(fLimitCenterY - (m_arrSampleBlobPads[k].fCenterY + intSearchAndUnitROIOffSetY));

                            arrMatched[k] = true;
                            break;
                        }


                    }
                }

                // Do sorting
                List<float> arrSortedOffSetX = new List<float>();
                List<float> arrSortedOffSetY = new List<float>();
                Math2.SortData(arrOffSetX.ToArray(), Math2.Sorting.Increase, ref arrSortedOffSetX);
                Math2.SortData(arrOffSetY.ToArray(), Math2.Sorting.Increase, ref arrSortedOffSetY);
                float fModeValueX = Math2.GetModeValue(arrSortedOffSetX.ToArray(), 1f);
                float fModeValueY = Math2.GetModeValue(arrSortedOffSetY.ToArray(), 1f);

                pSecondImageUnitCenterPoint = new PointF(
                    GetResultCenterPoint_RectGauge4L().X + fModeValueX,
                    GetResultCenterPoint_RectGauge4L().Y + fModeValueY);

            }
            else
                return false;

            return true;
        }

        // ------------------ RectGauge4L Function ------------------------------------------------------------

        public void DrawGaugeResult_Rotated(Graphics g, float fDrawingScaleX, float fDrawingScaleY)
        {
            //lock (m_objLockBlobs)
            //{
            //    if (m_blnInspectLock)
            //        return;

            //    m_objRectGauge4L.DrawGaugeResult_ResultLine_Rotated(g, fDrawingScaleX, fDrawingScaleY, m_intPadROIDirection);

            //}

            lock (m_objLockBlobs)
            {
                if (m_blnInspectLock)
                    return;

                bool blnLineResultAllOK = true;
                for (int i = 0; i < m_objRectGauge4L.ref_arrLineResultOK.Length; i++)
                {
                    if (!m_objRectGauge4L.ref_arrLineResultOK[i])
                    {
                        blnLineResultAllOK = false;
                    }
                }

                if (blnLineResultAllOK) // 2019 10 09 - CCENG: if all gauge measurement pass, then only will draw 0 deg rectangle.
                    m_objRectGauge4L.DrawGaugeResult_ResultLine_Rotated(g, fDrawingScaleX, fDrawingScaleY, m_intPadROIDirection, m_blnWantRotateSidePadImage);
                else
                    DrawGauge(g, fDrawingScaleX, fDrawingScaleY);

            }
        }

        public void DrawGaugeResult_EdgeNotFound(Graphics g, float fDrawingScaleX, float fDrawingScaleY)
        {
            lock (m_objLockBlobs)
            {
                if (m_blnInspectLock)
                    return;

                m_objRectGauge4L.DrawGaugeResult_EdgeNotFound(g, fDrawingScaleX, fDrawingScaleY);

            }
        }

        public void DrawGauge(Graphics g, float fDrawingScaleX, float fDrawingScaleY)
        {
            lock (m_objLockBlobs)
            {
                if (m_blnInspectLock)
                    return;

                if (m_blnDrawSamplingPoint)
                    m_objRectGauge4L.DrawGaugeResult_SamplingPoint(g);
                if (m_blnDrawDraggingBox)
                    m_objRectGauge4L.DrawGaugeSetting_Inside(g, fDrawingScaleX, fDrawingScaleY);
                else
                    m_objRectGauge4L.DrawGaugeResult_ResultLine(g, fDrawingScaleX, fDrawingScaleY);

            }
        }

        public void DrawGauge_ForLearning(Graphics g, float fDrawingScaleX, float fDrawingScaleY)
        {
            lock (m_objLockBlobs)
            {
                if (m_blnInspectLock)
                    return;

                if (m_blnDrawSamplingPoint)
                    m_objRectGauge4L.DrawGaugeResult_SamplingPoint_ForLearning(g, m_intSelectedGaugeEdgeMask, m_intPadROIDirection);
                //////if (m_blnDrawDraggingBox)
                //////{
                //////    //m_objRectGauge4L.DrawGaugeSetting_Inside(g, fDrawingScaleX, fDrawingScaleY);
                //////}
                //////else
                //////    m_objRectGauge4L.DrawGaugeResult_ResultLine(g, fDrawingScaleX, fDrawingScaleY);
                m_objRectGauge4L.DrawGaugeResult_ResultLine(g, fDrawingScaleX, fDrawingScaleY, m_intPadROIDirection);

                //if (m_blnDrawTransitionTypeArrow)
                //    m_objRectGauge4L.DrawGaugeSetting_TransitionTypeArrow(g, fDrawingScaleX, fDrawingScaleY, m_intSelectedGaugeEdgeMask);
            }
        }

        /// <summary>
        /// measure the die edge using rectangle gauge
        /// </summary>
        /// <param name="g">target pictire box to draw</param>
        /// <param name="objROI">source image for measuring</param>
        public bool MeasureEdge_UsingRectGauge4L(ImageDrawing objImage, ImageDrawing objWhiteImage)
        {
            //if (m_objRectGauge4L.Measure_Pad5SPackage(objImage, false))
            if (m_objRectGauge4L.Measure_Pad5SPackage_WithDontCareArea(objImage, false, objWhiteImage))
                    return true;
            else
            {
                m_strErrorMessage = m_objRectGauge4L.ref_strErrorMessage;
                return false;
            }
        }

        public bool MeasureEdge_UsingRectGauge4L(List<ImageDrawing> arrImage, ImageDrawing objWhiteImage, bool blnReferTemplateSize)
        {
            if (m_intPadROIDirection == 3)
            {

            }
            //if (m_objRectGauge4L.Measure_Pad5SPackage(objImage, false))
            //if (m_objRectGauge4L.Measure_Pad5SPackage_WithDontCareArea(arrImage, false, objWhiteImage))
            if (m_objRectGauge4L.Measure_Pad5SPackage_WithDontCareArea_ImprovedAngleVersion(arrImage, false, objWhiteImage, m_intPadROIDirection, blnReferTemplateSize, m_fUnitWidth, m_fUnitHeight))
                return true;
            else
            {
                m_strErrorMessage = m_objRectGauge4L.ref_strErrorMessage;
                return false;
            }
        }

        public bool MeasureEdge_UsingSidePkgCornerPoint(float fCornerX_TL, float fCornerY_TL,
                                                     float fCornerX_TR, float fCornerY_TR,
                                                     float fCornerX_BR, float fCornerY_BR,
                                                     float fCornerX_BL, float fCornerY_BL)
        {
            if (m_objRectGauge4L.Measure_UseSidePkgCornerPoint(fCornerX_TL, fCornerY_TL,
                                                     fCornerX_TR, fCornerY_TR,
                                                     fCornerX_BR, fCornerY_BR,
                                                     fCornerX_BL, fCornerY_BL))
                return true;
            else
            {
                m_strErrorMessage = m_objRectGauge4L.ref_strErrorMessage;
                return false;
            }

            return true;
        }

        public bool MeasureEdge_ResetGaugePlaceUsingPRPositionBeforeMeasure(List<ImageDrawing> arrImage, ImageDrawing objWhiteImage)
        {
            if (m_pUnitCenterPoint.X > 0 && m_pUnitCenterPoint.Y > 0 && m_blnWantPRUnitLocationBeforeGauge)
            {
                m_objRectGauge4L.SetGaugePlace(m_pUnitCenterPoint.X, m_pUnitCenterPoint.Y);
                m_objRectGauge4L.SetGaugeAngle(m_fUnitAngle);
            }

            // Make sure RectGauge4L is using User Setting
            m_objRectGauge4L.ResetGaugeSettingToUserVariables();

            //if (m_objRectGauge4L.Measure_Pad5SPackage(objImage, false))
            //if (m_objRectGauge4L.Measure_Pad5SPackage_WithDontCareArea(arrImage, false, objWhiteImage))
            if (m_objRectGauge4L.Measure_Pad5SPackage_WithDontCareArea_ImprovedAngleVersion(arrImage, false, objWhiteImage, m_intPadROIDirection, true, m_fUnitWidth, m_fUnitHeight))
            {
                //if (m_objRectGauge4L.ref_arrLineResultOK[0] && m_objRectGauge4L.ref_arrLineResultOK[1] && m_objRectGauge4L.ref_arrLineResultOK[2] && m_objRectGauge4L.ref_arrLineResultOK[3])
                return true;
                //else
                // {
                //    return false;
                //}
            }
            else
            {
                m_strErrorMessage = m_objRectGauge4L.ref_strErrorMessage;
                return false;
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="intValueType">0=Pixel, 1=mm, 2=mil, 3=um</param>
        /// <returns></returns>
        public float GetResultUpWidth_RectGauge4L(int intValueType)
        {
            switch (intValueType)
            {
                case 0: // Pixel
                    return m_objRectGauge4L.ref_fRectUpWidth;
                case 1: // mm
                case 2: // mil
                case 3: // micron
                    return m_objRectGauge4L.ref_fRectUpWidth * m_fMMPerPixelX * m_fMMToUnitValue;
                default:
                    return 0;
            }
        }
        /// <summary>
        /// 
        /// </summary>
        /// <param name="intValueType">0=Pixel, 1=mm, 2=mil, 3=um</param>
        /// <returns></returns>
        public float GetResultDownWidth_RectGauge4L(int intValueType)
        {
            switch (intValueType)
            {
                case 0: // Pixel
                    return m_objRectGauge4L.ref_fRectDownWidth;
                case 1: // mm
                case 2: // mil
                case 3: // micron
                    return m_objRectGauge4L.ref_fRectDownWidth * m_fMMPerPixelX * m_fMMToUnitValue;
                default:
                    return 0;
            }
        }
        /// <summary>
        /// 
        /// </summary>
        /// <param name="intValueType">0=Pixel, 1=mm, 2=mil, 3=um</param>
        /// <returns></returns>
        public float GetResultMaxWidth_RectGauge4L(int intValueType)
        {
            if (m_objRectGauge4L.ref_fRectDownWidth > m_objRectGauge4L.ref_fRectUpWidth)
                return GetResultDownWidth_RectGauge4L(intValueType);
            else
                return GetResultUpWidth_RectGauge4L(intValueType);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="intValueType">0=Pixel, 1=mm, 2=mil, 3=um</param>
        /// <returns></returns>
        public float GetResultLeftHeight_RectGauge4L(int intValueType)
        {
            switch (intValueType)
            {
                case 0: // Pixel
                    return m_objRectGauge4L.ref_fRectLeftHeight;
                case 1: // mm
                case 2: // mil
                case 3: // micron
                    return m_objRectGauge4L.ref_fRectLeftHeight * m_fMMPerPixelY * m_fMMToUnitValue;
                default:
                    return 0;
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="intValueType">0=Pixel, 1=mm, 2=mil, 3=um</param>
        /// <returns></returns>
        public float GetResultRightHeight_RectGauge4L(int intValueType)
        {
            switch (intValueType)
            {
                case 0: // Pixel
                    return m_objRectGauge4L.ref_fRectRightHeight;
                case 1: // mm
                case 2: // mil
                case 3: // micron
                    return m_objRectGauge4L.ref_fRectRightHeight * m_fMMPerPixelY * m_fMMToUnitValue;
                default:
                    return 0;
            }
        }
        /// <summary>
        /// 
        /// </summary>
        /// <param name="intValueType">0=Pixel, 1=mm, 2=mil, 3=um</param>
        /// <returns></returns>
        public float GetResultMaxHeight_RectGauge4L(int intValueType)
        {
            if (m_objRectGauge4L.ref_fRectLeftHeight > m_objRectGauge4L.ref_fRectRightHeight)
                return GetResultLeftHeight_RectGauge4L(intValueType);
            else
                return GetResultRightHeight_RectGauge4L(intValueType);
        }
        /// <summary>
        /// 
        /// </summary>
        /// <returns></returns>
        public float GetResultAngle_RectGauge4L()
        {
            return m_objRectGauge4L.ref_fRectAngle;
        }

        public float GetResultAngle_UnitMatcher()
        {
            return m_fUnitAngle;
        }
        /// <summary>
        /// 
        /// </summary>
        /// <returns></returns>
        public PointF GetResultCenterPoint_RectGauge4L()
        {
            return m_objRectGauge4L.ref_pRectCenterPoint;
        }
        public PointF GetResultTopLeftCornerPoint_RectGauge4L()
        {
            switch (m_intPadROIDirection)
            {
                case 0:
                case 1:
                    return m_objRectGauge4L.ref_arrRectCornerPoints[0];
                    break;
                case 2:
                    return m_objRectGauge4L.ref_arrRectCornerPoints[1];
                    break;
                case 3:
                    return m_objRectGauge4L.ref_arrRectCornerPoints[3];
                    break;
                case 4:
                    return m_objRectGauge4L.ref_arrRectCornerPoints[2];
                    break;
            }
            return new PointF(0, 0);
        }
        public PointF GetResultCenterPoint_UnitMatcher()
        {
            return m_pUnitCenterPoint;
        }
        public PointF GetResultTopLeftCornerPoint_UnitMatcher()
        {
            switch (m_intPadROIDirection)
            {
                case 0:
                case 1:
                    return new PointF(m_pUnitCenterPoint.X - (m_objMatcher.PatternWidth / 2), m_pUnitCenterPoint.Y - (m_objMatcher.PatternHeight / 2));
                    break;
                case 2:
                    return new PointF(m_pUnitCenterPoint.X + (m_objMatcher.PatternWidth / 2), m_pUnitCenterPoint.Y - (m_objMatcher.PatternHeight / 2));
                    break;
                case 3:
                    return new PointF(m_pUnitCenterPoint.X + (m_objMatcher.PatternWidth / 2), m_pUnitCenterPoint.Y + (m_objMatcher.PatternHeight / 2));
                    break;
                case 4:
                    return new PointF(m_pUnitCenterPoint.X - (m_objMatcher.PatternWidth / 2), m_pUnitCenterPoint.Y + (m_objMatcher.PatternHeight / 2));
                    break;
            }
            return new PointF(0, 0);
        }
        public SizeF GetPatternSize_UnitMatcher()
        {
            return new SizeF(m_objMatcher.PatternWidth, m_objMatcher.PatternHeight);
        }
        public bool GetRectGauge4LPassFail(int intPadIndex)
        {
            switch (intPadIndex)
            {
                case 0: // Center Pad
                    if (m_objRectGauge4L.ref_arrLineResultOK[0] && m_objRectGauge4L.ref_arrLineResultOK[1] && m_objRectGauge4L.ref_arrLineResultOK[2] && m_objRectGauge4L.ref_arrLineResultOK[3])
                        return true;
                    break;
                case 1: // Top Pad (bottom gauge can be ignored)
                    if (m_objRectGauge4L.ref_arrLineResultOK[0] && m_objRectGauge4L.ref_arrLineResultOK[1] && m_objRectGauge4L.ref_arrLineResultOK[3])
                        return true;
                    break;
                case 2: // Right Pad (Left gauge can be ignored)
                    if (m_objRectGauge4L.ref_arrLineResultOK[0] && m_objRectGauge4L.ref_arrLineResultOK[1] && m_objRectGauge4L.ref_arrLineResultOK[2])
                        return true;
                    break;
                case 3: // Botom Pad (Top gauge can be ignored)
                    if (m_objRectGauge4L.ref_arrLineResultOK[1] && m_objRectGauge4L.ref_arrLineResultOK[2] && m_objRectGauge4L.ref_arrLineResultOK[3])
                        return true;
                    break;
                case 4: // Left Pad (Right gauge can be ignored)
                    if (m_objRectGauge4L.ref_arrLineResultOK[0] && m_objRectGauge4L.ref_arrLineResultOK[2] && m_objRectGauge4L.ref_arrLineResultOK[3])
                        return true;
                    break;
            }
            return false;
        }

        public float AddGrayColorOuterGaugePoint(ROI objROI, PadIndex padDirection)
        {
            return m_objRectGauge4L.AddGrayColorToGaugePoint(objROI, (int)padDirection - 1, m_intThresholdValue);
        }

        //public void SetRectGauge4LPlacement1(PointF pCenter, float fAngle, float fWidth, float fHeight)
        //{
        //    m_objRectGauge4L.SetGaugePlace(pCenter.X, pCenter.Y, fWidth, fHeight);
        //}

        public void SetRectGauge4LPlacement(ROI objROI)
        {
            m_objRectGauge4L.SetGaugePlace(objROI);
        }

        public void SetPointGaugePlacement_UsingInspectedPadPointGaugePosition(int intPadIndex, int intDirectionIndex)
        {
            /*
             * intDirectionIndex
             *          0
             *      3        1
             *          2
             */

            if (intPadIndex < 0)
                return;

            if (intPadIndex >= m_arrPadPointGaugeStartX.Count)
                return;

            if (intDirectionIndex >= m_arrPadPointGaugeStartX[intPadIndex].Count)
                return;



            m_objSettingPointGauge.SetGaugePlacement(m_arrPadPointGaugeStartX[intPadIndex][intDirectionIndex],
                m_arrPadPointGaugeStartY[intPadIndex][intDirectionIndex],
                m_arrPadPointGaugeTolerance[intPadIndex][intDirectionIndex],
                m_arrPadPointGaugeAngle[intPadIndex][intDirectionIndex]
                );
        }

        // ------------------ Golden Data ---------------------------------------------------------------------

        public int CalculateThresholdUsingGoldenData()
        {
            float fAccuracy = 0.0125f;
            int intPassCount = 0;
            int intFailCount = 0;
            for (int i = 0; i < m_arrGoldenData.Count; i++)
            {
                if (!m_arrGoldenDataUsed[i])
                    continue;

                // Get the accuracy data
                for (int j = 0; j < m_arrGoldenData[i].Count; j++)
                {
                    if (((BlobsFeatures)m_arrTemplateBlobPads[j]).intLengthMode == 1)
                    {
                        if (m_arrSampleBlobPads[j].fWidthMM == -999)
                            return -1;
                        else if (Math.Abs(m_arrSampleBlobPads[j].fWidthMM - m_arrGoldenData[i][j][0]) < fAccuracy)
                            intPassCount++;
                        else
                            intFailCount++;

                        if (m_arrSampleBlobPads[j].fHeightMM == -999)
                            return -1;
                        else if (Math.Abs(m_arrSampleBlobPads[j].fHeightMM - m_arrGoldenData[i][j][1]) < fAccuracy)
                            intPassCount++;
                        else
                            intFailCount++;

                    }
                    else
                    {
                        if (m_arrSampleBlobPads[j].fHeightMM == -999)
                            return -1;
                        else if (Math.Abs(m_arrSampleBlobPads[j].fHeightMM - m_arrGoldenData[i][j][0]) < fAccuracy)
                            intPassCount++;
                        else
                            intFailCount++;

                        if (m_arrSampleBlobPads[j].fWidthMM == -999)
                            return -1;
                        else if (Math.Abs(m_arrSampleBlobPads[j].fWidthMM - m_arrGoldenData[i][j][1]) < fAccuracy)
                            intPassCount++;
                        else
                            intFailCount++;
                    }

                    if (m_arrPitchGap.Count > j)
                    {
                        float fPitch = 0, fGap = 0;
                        if (GetPitchGapResult(j, ref fPitch, ref fGap))
                        {
                            if (Math.Abs(fPitch - m_arrGoldenData[i][j][2]) < fAccuracy)
                                intPassCount++;
                            else
                                intFailCount++;

                            if (Math.Abs(fGap - m_arrGoldenData[i][j][3]) < fAccuracy)
                                intPassCount++;
                            else
                                intFailCount++;
                        }
                        else
                        {
                            intFailCount += 2;
                        }

                        //if (Math.Abs(m_arrPitchGap[j].fPitchMM - m_arrGoldenData[i][j][2]) < fAccuracy)
                        //    intPassCount++;
                        //else
                        //    intFailCount++;

                        //if (Math.Abs(m_arrPitchGap[j].fGapMM - m_arrGoldenData[i][j][3]) < fAccuracy)
                        //    intPassCount++;
                        //else
                        //    intFailCount++;
                    }
                }
            }

            return intFailCount;
        }

        public void CalculateThresholdUsingGoldenData(ref List<int> arrOptimumThreshold)
        {
            arrOptimumThreshold = new List<int>();

            List<List<int>> arrPassCountList = new List<List<int>>();
            float fAccuracy = 0.0125f;
            int intPassCount = 0;
            for (int t = 0; t < 255; t++)   // Scan all threshold value
            {
                intPassCount = 0;
                for (int i = 0; i < m_arrGoldenData.Count; i++)
                {
                    if (!m_arrGoldenDataUsed[i])
                        continue;

                    // Get the accuracy data
                    for (int j = 0; j < m_arrGoldenData[i].Count; j++)
                    {
                        if (((BlobsFeatures)m_arrTemplateBlobPads[i]).intLengthMode == 1)
                        {
                            if (Math.Abs(m_arrSampleBlobPads[j].fWidthMM - m_arrGoldenData[i][j][0]) < fAccuracy)
                                intPassCount++;

                            if (Math.Abs(m_arrSampleBlobPads[j].fHeightMM - m_arrGoldenData[i][j][1]) < fAccuracy)
                                intPassCount++;
                        }
                        else
                        {
                            if (Math.Abs(m_arrSampleBlobPads[j].fHeightMM - m_arrGoldenData[i][j][0]) < fAccuracy)
                                intPassCount++;

                            if (Math.Abs(m_arrSampleBlobPads[j].fWidthMM - m_arrGoldenData[i][j][1]) < fAccuracy)
                                intPassCount++;
                        }

                        if (Math.Abs(m_arrPitchGap[j].fPitchMM - m_arrGoldenData[i][j][2]) < fAccuracy)
                            intPassCount++;

                        if (Math.Abs(m_arrPitchGap[j].fGapMM - m_arrGoldenData[i][j][3]) < fAccuracy)
                            intPassCount++;
                    }
                }

                arrPassCountList.Add(new List<int>());
                arrPassCountList[arrPassCountList.Count - 1].Add(intPassCount);  // Add Pad Count
                arrPassCountList[arrPassCountList.Count - 1].Add(t);             // Add threshold;
            }

            List<List<int>> arrSortedList = new List<List<int>>();
            Math2.SortData(arrPassCountList, 0, Math2.Sorting.Decrease, ref arrSortedList);

            arrOptimumThreshold.Add(arrSortedList[0][1]);
            for (int i = 1; i < arrSortedList.Count; i++)
            {
                if (arrSortedList[i][0] < arrSortedList[i - 1][0])
                    break;

                arrOptimumThreshold.Add(arrPassCountList[i][1]);
            }
        }

        public void CalculateResolutionOffSetUsingGoldenData(ref float fOffSetX, ref float fOffSetY)
        {
            List<List<float>> arrAccuracyWidth = new List<List<float>>();
            List<List<float>> arrAccuracyLength = new List<List<float>>();
            int intDataIndex;
            for (int i = 0; i < m_arrGoldenData.Count; i++)
            {
                if (!m_arrGoldenDataUsed[i])
                    continue;

                arrAccuracyWidth.Add(new List<float>());
                arrAccuracyLength.Add(new List<float>());
                intDataIndex = arrAccuracyWidth.Count - 1;

                // Get the accuracy data
                for (int j = 0; j < m_arrGoldenData[i].Count; j++)
                {
                    if (((BlobsFeatures)m_arrTemplateBlobPads[j]).intLengthMode == 1)
                    {
                        arrAccuracyWidth[intDataIndex].Add(m_arrSampleBlobPads[j].fWidthMM - m_arrGoldenData[i][j][0]);
                        arrAccuracyLength[intDataIndex].Add(m_arrSampleBlobPads[j].fHeightMM - m_arrGoldenData[i][j][1]);
                    }
                    else
                    {
                        arrAccuracyWidth[intDataIndex].Add(m_arrSampleBlobPads[j].fHeightMM - m_arrGoldenData[i][j][0]);
                        arrAccuracyLength[intDataIndex].Add(m_arrSampleBlobPads[j].fWidthMM - m_arrGoldenData[i][j][1]);
                    }
                }


                // Sort the list
                List<float> arrSortDataWidth = new List<float>();
                List<float> arrSortDataLength = new List<float>();
                Math2.SortData(arrAccuracyWidth[intDataIndex].ToArray(), Math2.Sorting.Increase, ref arrSortDataWidth);
                Math2.SortData(arrAccuracyLength[intDataIndex].ToArray(), Math2.Sorting.Increase, ref arrSortDataLength);

                // Find the mode value with tolerance 12.5 (Pad vision specification)
                float fModeWidth = Math2.GetModeRangeCenterValue(arrSortDataWidth.ToArray(), 0.0125f);
                float fModeLength = Math2.GetModeRangeCenterValue(arrSortDataLength.ToArray(), 0.0125f);

                float fResultCompensateX = -fModeWidth;
                float fResultCompensateY = -fModeLength;

                if (m_arrSampleBlobPads.Length > 0)
                {
                    float fObjectPixelX = m_arrSampleBlobPads[0].fWidthMM / m_fMMPerPixelX;
                    float fObjectPixelY = m_arrSampleBlobPads[0].fHeightMM / m_fMMPerPixelY;

                    float fNewObjectMMX = m_arrSampleBlobPads[0].fWidthMM + fResultCompensateX;
                    float fNewObjectMMY = m_arrSampleBlobPads[0].fHeightMM + fResultCompensateY;

                    float fNewResolutionX = fNewObjectMMX / fObjectPixelX;
                    float fNewResolutionY = fNewObjectMMY / fObjectPixelY;

                    fOffSetX = (1 / fNewResolutionX - 1 / m_fMMPerPixelX);
                    fOffSetY = (1 / fNewResolutionY - 1 / m_fMMPerPixelY);
                }
                else
                    return;

            }
        }


        // ------------------ Positioning ---------------------------------------------------------------------

        public float GetPositioningResultOffSetX()
        {
            return (GetResultCenterPoint_RectGauge4L().X - m_objPosCrosshair.ref_intCrosshairX) / m_fMMToPixelXValue;
        }

        public float GetPositioningResultOffSetY()
        {
            return (GetResultCenterPoint_RectGauge4L().Y - m_objPosCrosshair.ref_intCrosshairY) / m_fMMToPixelYValue;
        }

        /// <summary>
        /// Get Positioning Result OffSet X
        /// </summary>
        /// <param name="intValueType">0=Pixel, 1=mm, 2=mil, 3=um</param>
        /// <returns></returns>
        public float GetPositioningResultOffSetX(int intValueType)
        {
            switch (intValueType)
            {
                case 0: // Pixel
                    return (GetResultCenterPoint_RectGauge4L().X - m_objPosCrosshair.ref_intCrosshairX);  // this result is in pixel
                case 1: // mm
                case 2: // mil
                case 3: // micron
                    return (GetResultCenterPoint_RectGauge4L().X - m_objPosCrosshair.ref_intCrosshairX) / m_fMMToPixelXValue * m_fMMToUnitValue;
                default:
                    return 0;
            }
        }

        /// <summary>
        /// Get Positioning Result OffSet Y
        /// </summary>
        /// <param name="intValueType">0=Pixel, 1=mm, 2=mil, 3=um</param>
        /// <returns></returns>
        public float GetPositioningResultOffSetY(int intValueType)
        {
            switch (intValueType)
            {
                case 0: // Pixel
                    return (GetResultCenterPoint_RectGauge4L().Y - m_objPosCrosshair.ref_intCrosshairY);  // this result is in pixel
                case 1: // mm
                case 2: // mil
                case 3: // micron
                    return (GetResultCenterPoint_RectGauge4L().Y - m_objPosCrosshair.ref_intCrosshairY) / m_fMMToPixelYValue * m_fMMToUnitValue;
                default:
                    return 0;
            }
        }

        private void UpdateBlobSizeAndCenterPointWithGauge_WithIndividualLine(ROI objROI,
                                                         float fStartX, float fStartY,
                                                         ref float fWidth, ref float fHeight,
                                                         ref float fNewCenterX, ref float fNewCenterY,
                                                         int intThresholdValue,
           float WidthPercentStart, float WidthPercentEnd, float HeightPercentStart, float HeightPercentEnd,
           float InwardPercentStart, float InwardPercentEnd,
           int lineCount, int line, int lenghtMode, float FeretAngle, ref float fLineLength,
           int p1X, int p1Y, int p2X, int p2Y, int p3X, int p3Y, int p4X, int p4Y, ref List<PointF> fpStart, ref List<PointF> fpEnd, int intMeasureMode,
           ref List<PointF> fpStart_Ori, ref List<PointF> fpEnd_Ori)
        {
            System.Drawing.Point p1 = new System.Drawing.Point(p1X, p1Y);
            System.Drawing.Point p2 = new System.Drawing.Point(p2X, p2Y);
            System.Drawing.Point p3 = new System.Drawing.Point(p3X, p3Y);
            System.Drawing.Point p4 = new System.Drawing.Point(p4X, p4Y);

            float StartX = 0;
            float StartY = 0;
            float EndX = 0;
            float EndY = 0;

            if (line == 0 && lenghtMode == 1)
            {
                StartX = objROI.ref_ROI.TotalOrgX + fStartX + (fWidth / 2) + (fWidth * (WidthPercentStart / 100));
                StartY = fStartY + objROI.ref_ROI.TotalOrgY + (fHeight * (HeightPercentStart / 100));
                EndX = fStartX + objROI.ref_ROI.TotalOrgX + (fWidth / 2) + (fWidth * (WidthPercentEnd / 100));
                EndY = fStartY + objROI.ref_ROI.TotalOrgY + fHeight + (fHeight * (HeightPercentEnd / 100));
            }
            else if (line == 1 && lenghtMode == 1)
            {
                StartX = objROI.ref_ROI.TotalOrgX + fStartX + (fWidth * (WidthPercentStart / 100));
                StartY = fStartY + objROI.ref_ROI.TotalOrgY + (fHeight / 2) + (fHeight * (HeightPercentStart / 100));
                EndX = fStartX + objROI.ref_ROI.TotalOrgX + (fWidth) + (fWidth * (WidthPercentEnd / 100));
                EndY = fStartY + objROI.ref_ROI.TotalOrgY + (fHeight / 2) + (fHeight * (HeightPercentEnd / 100));
            }

            if (line == 0 && lenghtMode == 2)
            {
                StartX = objROI.ref_ROI.TotalOrgX + fStartX + (fWidth * (WidthPercentStart / 100));
                StartY = fStartY + objROI.ref_ROI.TotalOrgY + (fHeight / 2) + (fHeight * (HeightPercentStart / 100));
                EndX = fStartX + objROI.ref_ROI.TotalOrgX + (fWidth) + (fWidth * (WidthPercentEnd / 100));
                EndY = fStartY + objROI.ref_ROI.TotalOrgY + (fHeight / 2) + (fHeight * (HeightPercentEnd / 100));
            }
            else if (line == 1 && lenghtMode == 2)
            {
                StartX = objROI.ref_ROI.TotalOrgX + fStartX + (fWidth / 2) + (fWidth * (WidthPercentStart / 100));
                StartY = fStartY + objROI.ref_ROI.TotalOrgY + (fHeight * (HeightPercentStart / 100));
                EndX = fStartX + objROI.ref_ROI.TotalOrgX + (fWidth / 2) + (fWidth * (WidthPercentEnd / 100));
                EndY = fStartY + objROI.ref_ROI.TotalOrgY + fHeight + (fHeight * (HeightPercentEnd / 100));

            }

            if (line > 1)
            {
                StartX = objROI.ref_ROI.TotalOrgX + fStartX + (fWidth / 2) + ((fWidth / 2) / (line)) + (fWidth * (WidthPercentStart / 100));
                StartY = fStartY + objROI.ref_ROI.TotalOrgY + (fHeight * (HeightPercentStart / 100));
                EndX = fStartX + objROI.ref_ROI.TotalOrgX + (fWidth / 2) + ((fWidth / 2) / (line)) + (fWidth * (WidthPercentEnd / 100));
                EndY = fStartY + objROI.ref_ROI.TotalOrgY + fHeight + (fHeight * (HeightPercentEnd / 100));
            }


            float CenterX = (StartX + EndX) / 2;
            float CenterY = (StartY + EndY) / 2;

            float DiffY = Math.Abs(EndY - StartY);
            float DiffX = Math.Abs(EndX - StartX);
            float AdditionDiffY = EndY - StartY;
            float AdditionDiffX = EndX - StartX;
            float Length = (float)Math.Sqrt(Math.Pow(DiffY, 2) + Math.Pow(DiffX, 2));
            PointF pStart = new PointF(StartX, StartY);
            PointF pEnd = new PointF(EndX, EndY);

            float Angle = 0, AngleStart = 0, AngleEnd = 0;
            //if (line == 0 && lenghtMode == 1)
            //{
            //    if (DiffX == 0)
            //        Angle = 90;
            //    else
            //    {
            //        Angle = (float)(Math.Atan(DiffX / DiffY) * 180 / Math.PI);
            //    }

            //    if ((EndX - StartX) < 0)
            //    {
            //        if (Angle == 90)
            //        {
            //            AngleStart = -Angle;
            //            AngleEnd = Angle;
            //        }
            //        else
            //        {
            //            AngleStart = 90 - Angle;
            //            AngleStart = -AngleStart;
            //            AngleEnd = 90 + Angle;
            //        }
            //    }
            //    else
            //    {
            //        if (Angle == 90)
            //        {
            //            AngleStart = -Angle;
            //            AngleEnd = Angle;
            //        }
            //        else
            //        {
            //            AngleStart = 90 + Angle;
            //            AngleStart = -AngleStart;
            //            AngleEnd = 90 - Angle;
            //        }

            //    }

            //}
            //else if (line == 1 && lenghtMode == 1)
            //{
            //    if (DiffY == 0)
            //        Angle = 180;
            //    else
            //    {
            //        Angle = (float)(Math.Atan(DiffX / DiffY) * 180 / Math.PI);
            //    }

            //    if ((EndY - StartY) < 0)
            //    {
            //        if (Angle == 180)
            //        {
            //            AngleStart = Angle;
            //            AngleEnd = 0;
            //        }
            //        else
            //        {
            //            AngleEnd = 90 - Angle;
            //            AngleEnd = -AngleEnd;
            //            AngleStart = 90 + Angle;
            //        }
            //    }
            //    else
            //    {
            //        if (Angle == 180)
            //        {
            //            AngleStart = Angle;
            //            AngleEnd = 0;
            //        }
            //        else
            //        {
            //            AngleStart = 90 + Angle;
            //            AngleStart = -AngleStart;
            //            AngleEnd = 90 - Angle;
            //        }

            //    }
            //}


            //if (line == 0 && lenghtMode == 2)
            //{
            //    if (DiffY == 0)
            //        Angle = 180;
            //    else
            //    {
            //        Angle = (float)(Math.Atan(DiffX / DiffY) * 180 / Math.PI);
            //    }

            //    if ((EndY - StartY) < 0)
            //    {
            //        if (Angle == 180)
            //        {
            //            AngleStart = Angle;
            //            AngleEnd = 0;
            //        }
            //        else
            //        {
            //            AngleEnd = 90 - Angle;
            //            AngleEnd = -AngleEnd;
            //            AngleStart = 90 + Angle;
            //        }
            //    }
            //    else
            //    {
            //        if (Angle == 180)
            //        {
            //            AngleStart = Angle;
            //            AngleEnd = 0;
            //        }
            //        else
            //        {
            //            AngleStart = 90 + Angle;
            //            AngleStart = -AngleStart;
            //            AngleEnd = 90 - Angle;
            //        }

            //    }

            //}
            //else if (line == 1 && lenghtMode == 2)
            //{
            //    if (DiffX == 0)
            //        Angle = 90;
            //    else
            //    {
            //        Angle = (float)(Math.Atan(DiffX / DiffY) * 180 / Math.PI);
            //    }

            //    if ((EndX - StartX) < 0)
            //    {
            //        if (Angle == 90)
            //        {
            //            AngleStart = -Angle;
            //            AngleEnd = Angle;
            //        }
            //        else
            //        {
            //            AngleStart = 90 - Angle;
            //            AngleStart = -AngleStart;
            //            AngleEnd = 90 + Angle;
            //        }
            //    }
            //    else
            //    {
            //        if (Angle == 90)
            //        {
            //            AngleStart = -Angle;
            //            AngleEnd = Angle;
            //        }
            //        else
            //        {
            //            AngleStart = 90 + Angle;
            //            AngleStart = -AngleStart;
            //            AngleEnd = 90 - Angle;
            //        }

            //    }


            //}

            //if (line > 1)
            {
                GetFeretAngle(pStart, pEnd, ref AngleStart, ref AngleEnd);
                //if (FeretAngle != 90 && FeretAngle != -90 && FeretAngle != 180 && FeretAngle != 0)
                //{
                //    AngleStart = 90 - FeretAngle;
                //    AngleStart = -AngleStart;
                //    AngleEnd = 90 + FeretAngle;
                //}
                //else
                //{
                //    if (DiffX == 0)
                //        Angle = 90;
                //    else
                //    {
                //        AdditionDiffY = AdditionDiffY;
                //        AdditionDiffX = AdditionDiffX;
                //        Angle = (float)(Math.Atan(DiffY / DiffX) * 180 / Math.PI);
                //        float test = (float)(Math.Atan(DiffX / DiffY) * 180 / Math.PI);
                //    }

                //    if (AdditionDiffY >= 0 && AdditionDiffX < 0)
                //    {
                //        if (FeretAngle < 0)
                //        {
                //            if (Angle == 90)
                //            {
                //                AngleStart = -Angle;
                //                AngleEnd = Angle;
                //            }
                //            else
                //            {
                //                AngleStart = 180 - Angle;
                //                AngleStart = -AngleStart;
                //                AngleEnd = Angle;
                //            }
                //        }
                //        else
                //        {
                //            if (Angle == 90)
                //            {
                //                AngleStart = -Angle;
                //                AngleEnd = Angle;
                //            }
                //            else
                //            {
                //                AngleStart = -Angle;
                //                // AngleStart = -AngleStart;
                //                AngleEnd = 180 - Angle;
                //            }

                //        }
                //    }
                //    else if (AdditionDiffY < 0 && AdditionDiffX < 0)
                //    {
                //        if (FeretAngle < 0)
                //        {
                //            if (Angle == 90)
                //            {
                //                //fFeretAngle == -90
                //                AngleStart = Angle;
                //                AngleEnd = -Angle;
                //            }
                //            else
                //            {
                //                AngleStart = 180 - Angle;
                //                //AngleStart = -AngleStart;
                //                AngleEnd = -Angle;
                //            }
                //        }
                //        else
                //        {
                //            if (Angle == 90)
                //            {
                //                AngleStart = -Angle;
                //                AngleEnd = Angle;
                //            }
                //            else
                //            {
                //                AngleStart = Angle;//180 -
                //                //AngleStart = -AngleStart;
                //                AngleEnd = Angle - 180;//Angle
                //            }

                //        }
                //    }
                //    else if (AdditionDiffY >= 0 && AdditionDiffX >= 0)
                //    {
                //        if (FeretAngle < 0)
                //        {
                //            if (Angle == 90)
                //            {
                //                //fFeretAngle == -90
                //                AngleStart = Angle;
                //                AngleEnd = -Angle;
                //            }
                //            else
                //            {
                //                AngleStart = 180 - Angle;
                //                //AngleStart = -AngleStart;
                //                AngleEnd = -Angle;
                //            }
                //        }
                //        else
                //        {
                //            if (Angle == 90)
                //            {
                //                AngleStart = -Angle;
                //                AngleEnd = Angle;
                //            }
                //            else
                //            {
                //                AngleStart = 180 - Angle;//
                //                AngleStart = -AngleStart;
                //                AngleEnd = Angle;//
                //            }

                //        }
                //    }
                //    else if (AdditionDiffY < 0 && AdditionDiffX >= 0)
                //    {
                //        if (FeretAngle < 0)
                //        {
                //            if (Angle == 90)
                //            {
                //                AngleStart = -Angle;
                //                AngleEnd = Angle;
                //            }
                //            else
                //            {
                //                AngleStart = 180 - Angle;
                //                AngleStart = -AngleStart;
                //                AngleEnd = Angle;
                //            }
                //        }
                //        else
                //        {
                //            if (Angle == 90)
                //            {
                //                AngleStart = Angle;
                //                AngleEnd = -Angle;
                //            }
                //            else
                //            {
                //                AngleStart = 180 - Angle;
                //                // AngleStart = -AngleStart;
                //                AngleEnd = -Angle;
                //            }

                //        }
                //    }
                //}
            }

            float fX_Start = Math.Abs(StartX - EndX) * (InwardPercentStart / 100);
            float fX_End = Math.Abs(StartX - EndX) * (InwardPercentEnd / 100);
            float fY_Start = Math.Abs(StartY - EndY) * (InwardPercentStart / 100);
            float fY_End = Math.Abs(StartY - EndY) * (InwardPercentEnd / 100);

            float fStartX_Final = StartX + fX_Start;
            float fStartY_Final = StartY + fY_Start;
            float fEndX_Final = EndX - fX_End;
            float fEndY_Final = EndY - fY_End;
            if (StartX > EndX)
            {
                fStartX_Final = StartX - fX_Start;
                fEndX_Final = EndX + fX_End;
            }
            if (StartY > EndY)
            {
                fStartY_Final = StartY - fY_Start;
                fEndY_Final = EndY + fY_End;
            }

            StartX = fStartX_Final;
            StartY = fStartY_Final;
            EndX = fEndX_Final;
            EndY = fEndY_Final;

            fpStart_Ori[line] = new PointF(StartX - objROI.ref_ROI.TotalOrgX, StartY - objROI.ref_ROI.TotalOrgY);
            fpEnd_Ori[line] = new PointF(EndX - objROI.ref_ROI.TotalOrgX, EndY - objROI.ref_ROI.TotalOrgY);

            List<PointF> arrGaugeMeasurePoints = new List<PointF>();

            // 2019-09-26 ZJYEOH : User now can select which TransChoice to use
            //m_objPointGauge.ref_GaugeThreshold = m_objPointGauge.AutoTuneThreshold(objROI);
            //if (m_objPointGauge.ref_GaugeTransChoice != 0)
            //    m_objPointGauge.ref_GaugeTransChoice = 0;   // Use Largest Amplitude

            //if (m_objPointGauge.ref_GaugeTransType != 1)
            //    m_objPointGauge.ref_GaugeTransType = 1;   // Use Largest Amplitude

            // Get Start Point
            m_objPointGauge.SetGaugePlacement(StartX, StartY, Math.Min(Length / 4, 10), AngleStart);
            m_objPointGauge.Measure(objROI);
            arrGaugeMeasurePoints.Add(m_objPointGauge.GetMeasurePoint(AngleStart, EndX, EndY, line <= 1));

            if ((arrGaugeMeasurePoints[arrGaugeMeasurePoints.Count - 1].X == 0 && arrGaugeMeasurePoints[arrGaugeMeasurePoints.Count - 1].Y == 0) ||
                (m_objPointGauge.ref_intMeasuredPointCount == 0))
            //if (m_objPointGauge.ref_intMeasuredPointCount == 0) // 27-06-2019 ZJYEOH: Measure again with longer length if cannot found any point
            {
                m_objPointGauge.SetGaugePlacement(StartX, StartY, Math.Max(Length / 4, 10), AngleStart);
                m_objPointGauge.Measure(objROI);
                arrGaugeMeasurePoints[arrGaugeMeasurePoints.Count - 1] = m_objPointGauge.GetMeasurePoint(AngleStart, EndX, EndY, line <= 1);

                if ((arrGaugeMeasurePoints[arrGaugeMeasurePoints.Count - 1].X == 0 && arrGaugeMeasurePoints[arrGaugeMeasurePoints.Count - 1].Y == 0) ||
                    (m_objPointGauge.ref_intMeasuredPointCount == 0))
                //if (m_objPointGauge.ref_intMeasuredPointCount == 0) // 27-06-2019 ZJYEOH: Measure again with longer length if cannot found any point
                {
                    m_objPointGauge.SetGaugePlacement(StartX, StartY, Length / 2, AngleStart);
                    m_objPointGauge.Measure(objROI);
                    arrGaugeMeasurePoints[arrGaugeMeasurePoints.Count - 1] = m_objPointGauge.GetMeasurePoint(AngleStart, EndX, EndY, line <= 1);

                    if ((arrGaugeMeasurePoints[arrGaugeMeasurePoints.Count - 1].X == 0 && arrGaugeMeasurePoints[arrGaugeMeasurePoints.Count - 1].Y == 0) ||
                        (m_objPointGauge.ref_intMeasuredPointCount == 0))
                    //if (m_objPointGauge.ref_intMeasuredPointCount == 0)  // 18-10-2019 ZJYEOH: Set back point gauge tolerance to default if still cannot found point, so that drawing for line profile will not draw wrong dimension
                    {
                        m_objPointGauge.SetGaugePlacement(StartX, StartY, Math.Min(Length / 4, 10), AngleStart);
                    }
                }
            }

            if (m_blnWantCollectPadEdgeGaugePoints)
            {
                if (line == 0 && lenghtMode == 1)
                {
                    /*
                     *          0=start0
                     * 3=start1           1=end1
                     *          2=End0
                     */

                    m_arrPadPointGaugeStartX.Add(new List<float>());
                    m_arrPadPointGaugeStartX[m_arrPadPointGaugeStartX.Count - 1].Add(m_objPointGauge.ref_GaugeCenterX);
                    m_arrPadPointGaugeStartX[m_arrPadPointGaugeStartX.Count - 1].Add(-1);
                    m_arrPadPointGaugeStartX[m_arrPadPointGaugeStartX.Count - 1].Add(-1);
                    m_arrPadPointGaugeStartX[m_arrPadPointGaugeStartX.Count - 1].Add(-1);

                    m_arrPadPointGaugeStartY.Add(new List<float>());
                    m_arrPadPointGaugeStartY[m_arrPadPointGaugeStartY.Count - 1].Add(m_objPointGauge.ref_GaugeCenterY);
                    m_arrPadPointGaugeStartY[m_arrPadPointGaugeStartY.Count - 1].Add(-1);
                    m_arrPadPointGaugeStartY[m_arrPadPointGaugeStartY.Count - 1].Add(-1);
                    m_arrPadPointGaugeStartY[m_arrPadPointGaugeStartY.Count - 1].Add(-1);

                    m_arrPadPointGaugeTolerance.Add(new List<float>());
                    m_arrPadPointGaugeTolerance[m_arrPadPointGaugeTolerance.Count - 1].Add(m_objPointGauge.ref_GaugeTolerance);
                    m_arrPadPointGaugeTolerance[m_arrPadPointGaugeTolerance.Count - 1].Add(-1);
                    m_arrPadPointGaugeTolerance[m_arrPadPointGaugeTolerance.Count - 1].Add(-1);
                    m_arrPadPointGaugeTolerance[m_arrPadPointGaugeTolerance.Count - 1].Add(-1);

                    m_arrPadPointGaugeAngle.Add(new List<float>());
                    m_arrPadPointGaugeAngle[m_arrPadPointGaugeAngle.Count - 1].Add(m_objPointGauge.ref_GaugeAngle);
                    m_arrPadPointGaugeAngle[m_arrPadPointGaugeAngle.Count - 1].Add(-1);
                    m_arrPadPointGaugeAngle[m_arrPadPointGaugeAngle.Count - 1].Add(-1);
                    m_arrPadPointGaugeAngle[m_arrPadPointGaugeAngle.Count - 1].Add(-1);
                }
                else if (line == 0 && lenghtMode == 2)
                {
                    /*
                     *          0=start1
                     * 3=start0           1=end0
                     *          2=End1
                     */

                    m_arrPadPointGaugeStartX.Add(new List<float>());
                    m_arrPadPointGaugeStartX[m_arrPadPointGaugeStartX.Count - 1].Add(-1);
                    m_arrPadPointGaugeStartX[m_arrPadPointGaugeStartX.Count - 1].Add(-1);
                    m_arrPadPointGaugeStartX[m_arrPadPointGaugeStartX.Count - 1].Add(-1);
                    m_arrPadPointGaugeStartX[m_arrPadPointGaugeStartX.Count - 1].Add(m_objPointGauge.ref_GaugeCenterX);

                    m_arrPadPointGaugeStartY.Add(new List<float>());
                    m_arrPadPointGaugeStartY[m_arrPadPointGaugeStartY.Count - 1].Add(-1);
                    m_arrPadPointGaugeStartY[m_arrPadPointGaugeStartY.Count - 1].Add(-1);
                    m_arrPadPointGaugeStartY[m_arrPadPointGaugeStartY.Count - 1].Add(-1);
                    m_arrPadPointGaugeStartY[m_arrPadPointGaugeStartY.Count - 1].Add(m_objPointGauge.ref_GaugeCenterY);

                    m_arrPadPointGaugeTolerance.Add(new List<float>());
                    m_arrPadPointGaugeTolerance[m_arrPadPointGaugeTolerance.Count - 1].Add(-1);
                    m_arrPadPointGaugeTolerance[m_arrPadPointGaugeTolerance.Count - 1].Add(-1);
                    m_arrPadPointGaugeTolerance[m_arrPadPointGaugeTolerance.Count - 1].Add(-1);
                    m_arrPadPointGaugeTolerance[m_arrPadPointGaugeTolerance.Count - 1].Add(m_objPointGauge.ref_GaugeTolerance);

                    m_arrPadPointGaugeAngle.Add(new List<float>());
                    m_arrPadPointGaugeAngle[m_arrPadPointGaugeAngle.Count - 1].Add(-1);
                    m_arrPadPointGaugeAngle[m_arrPadPointGaugeAngle.Count - 1].Add(-1);
                    m_arrPadPointGaugeAngle[m_arrPadPointGaugeAngle.Count - 1].Add(-1);
                    m_arrPadPointGaugeAngle[m_arrPadPointGaugeAngle.Count - 1].Add(m_objPointGauge.ref_GaugeAngle);
                }
                else if (line == 1 && lenghtMode == 1)
                {
                    /*
                     *          0=start0
                     * 3=start1           1=end1
                     *          2=End0
                     */

                    m_arrPadPointGaugeStartX[m_arrPadPointGaugeStartX.Count - 1][3] = m_objPointGauge.ref_GaugeCenterX;
                    m_arrPadPointGaugeStartY[m_arrPadPointGaugeStartX.Count - 1][3] = m_objPointGauge.ref_GaugeCenterY;
                    m_arrPadPointGaugeTolerance[m_arrPadPointGaugeStartX.Count - 1][3] = m_objPointGauge.ref_GaugeTolerance;
                    m_arrPadPointGaugeAngle[m_arrPadPointGaugeStartX.Count - 1][3] = m_objPointGauge.ref_GaugeAngle;
                }
                else if (line == 1 && lenghtMode == 2)
                {
                    /*
                     *          0=start1
                     * 3=start0           1=end0
                     *          2=End1
                     */

                    m_arrPadPointGaugeStartX[m_arrPadPointGaugeStartX.Count - 1][0] = m_objPointGauge.ref_GaugeCenterX;
                    m_arrPadPointGaugeStartY[m_arrPadPointGaugeStartX.Count - 1][0] = m_objPointGauge.ref_GaugeCenterY;
                    m_arrPadPointGaugeTolerance[m_arrPadPointGaugeStartX.Count - 1][0] = m_objPointGauge.ref_GaugeTolerance;
                    m_arrPadPointGaugeAngle[m_arrPadPointGaugeStartX.Count - 1][0] = m_objPointGauge.ref_GaugeAngle;
                }
            }

            // Get End Point
            m_objPointGauge.SetGaugePlacement(EndX, EndY, Math.Min(Length / 4, 10), AngleEnd);
            m_objPointGauge.Measure(objROI);
            arrGaugeMeasurePoints.Add(m_objPointGauge.GetMeasurePoint(AngleEnd, StartX, StartY, line <= 1));

            if ((arrGaugeMeasurePoints[arrGaugeMeasurePoints.Count - 1].X == 0 && arrGaugeMeasurePoints[arrGaugeMeasurePoints.Count - 1].Y == 0) ||
                (m_objPointGauge.ref_intMeasuredPointCount == 0))
            //if (m_objPointGauge.ref_intMeasuredPointCount == 0)  // 27-06-2019 ZJYEOH: Measure again with longer length if cannot found any point
            {
                m_objPointGauge.SetGaugePlacement(EndX, EndY, Math.Max(Length / 4, 10), AngleEnd);
                m_objPointGauge.Measure(objROI);
                arrGaugeMeasurePoints[arrGaugeMeasurePoints.Count - 1] = m_objPointGauge.GetMeasurePoint(AngleEnd, StartX, StartY, line <= 1);

                if ((arrGaugeMeasurePoints[arrGaugeMeasurePoints.Count - 1].X == 0 && arrGaugeMeasurePoints[arrGaugeMeasurePoints.Count - 1].Y == 0) ||
                    (m_objPointGauge.ref_intMeasuredPointCount == 0))  // 27-06-2019 ZJYEOH: Measure again with longer length if cannot found any point
                {
                    m_objPointGauge.SetGaugePlacement(EndX, EndY, Length / 2, AngleEnd);
                    m_objPointGauge.Measure(objROI);
                    arrGaugeMeasurePoints[arrGaugeMeasurePoints.Count - 1] = m_objPointGauge.GetMeasurePoint(AngleEnd, StartX, StartY, line <= 1);

                    if ((arrGaugeMeasurePoints[arrGaugeMeasurePoints.Count - 1].X == 0 && arrGaugeMeasurePoints[arrGaugeMeasurePoints.Count - 1].Y == 0) ||
                        (m_objPointGauge.ref_intMeasuredPointCount == 0))
                    //if (m_objPointGauge.ref_intMeasuredPointCount == 0)  // 18-10-2019 ZJYEOH: Set back point gauge tolerance to default if still cannot found point, so that drawing for line profile will not draw wrong dimension
                    {
                        m_objPointGauge.SetGaugePlacement(EndX, EndY, Math.Min(Length / 4, 10), AngleEnd);
                    }
                }
            }

            if (m_blnWantCollectPadEdgeGaugePoints)
            {
                if (line == 0 && lenghtMode == 1)
                {
                    /*
                     *          0=start0
                     * 3=start1           1=end1
                     *          (2=End0)
                     */
                    m_arrPadPointGaugeStartX[m_arrPadPointGaugeStartX.Count - 1][2] = m_objPointGauge.ref_GaugeCenterX;
                    m_arrPadPointGaugeStartY[m_arrPadPointGaugeStartX.Count - 1][2] = m_objPointGauge.ref_GaugeCenterY;
                    m_arrPadPointGaugeTolerance[m_arrPadPointGaugeStartX.Count - 1][2] = m_objPointGauge.ref_GaugeTolerance;
                    m_arrPadPointGaugeAngle[m_arrPadPointGaugeStartX.Count - 1][2] = m_objPointGauge.ref_GaugeAngle;
                }
                else if (line == 0 && lenghtMode == 2)
                {
                    /*
                     *          0=start1
                     * 3=start0           (1=end0)
                     *          2=End1
                     */

                    m_arrPadPointGaugeStartX[m_arrPadPointGaugeStartX.Count - 1][1] = m_objPointGauge.ref_GaugeCenterX;
                    m_arrPadPointGaugeStartY[m_arrPadPointGaugeStartX.Count - 1][1] = m_objPointGauge.ref_GaugeCenterY;
                    m_arrPadPointGaugeTolerance[m_arrPadPointGaugeStartX.Count - 1][1] = m_objPointGauge.ref_GaugeTolerance;
                    m_arrPadPointGaugeAngle[m_arrPadPointGaugeStartX.Count - 1][1] = m_objPointGauge.ref_GaugeAngle;

                }
                else if (line == 1 && lenghtMode == 1)
                {
                    /*
                     *          0=start0
                     * 3=start1           (1=end1)
                     *          2=End0
                     */

                    m_arrPadPointGaugeStartX[m_arrPadPointGaugeStartX.Count - 1][1] = m_objPointGauge.ref_GaugeCenterX;
                    m_arrPadPointGaugeStartY[m_arrPadPointGaugeStartX.Count - 1][1] = m_objPointGauge.ref_GaugeCenterY;
                    m_arrPadPointGaugeTolerance[m_arrPadPointGaugeStartX.Count - 1][1] = m_objPointGauge.ref_GaugeTolerance;
                    m_arrPadPointGaugeAngle[m_arrPadPointGaugeStartX.Count - 1][1] = m_objPointGauge.ref_GaugeAngle;
                }
                else if (line == 1 && lenghtMode == 2)
                {
                    /*
                     *          0=start1
                     * 3=start0           1=end0
                     *          (2=End1)
                     */

                    m_arrPadPointGaugeStartX[m_arrPadPointGaugeStartX.Count - 1][2] = m_objPointGauge.ref_GaugeCenterX;
                    m_arrPadPointGaugeStartY[m_arrPadPointGaugeStartX.Count - 1][2] = m_objPointGauge.ref_GaugeCenterY;
                    m_arrPadPointGaugeTolerance[m_arrPadPointGaugeStartX.Count - 1][2] = m_objPointGauge.ref_GaugeTolerance;
                    m_arrPadPointGaugeAngle[m_arrPadPointGaugeStartX.Count - 1][2] = m_objPointGauge.ref_GaugeAngle;
                }
            }

            // Check left right
            if (arrGaugeMeasurePoints.Count >= 2)
            {
                //if (arrGaugeMeasurePoints[1].X > 0 && arrGaugeMeasurePoints[0].X > 0 && arrGaugeMeasurePoints[1].Y > 0 && arrGaugeMeasurePoints[0].Y > 0
                //    && ((arrGaugeMeasurePoints[0].X - objROI.ref_ROI.TotalOrgX) > 0) && ((arrGaugeMeasurePoints[0].Y - objROI.ref_ROI.TotalOrgY) > 0) && ((arrGaugeMeasurePoints[1].X - objROI.ref_ROI.TotalOrgX) > 0) && ((arrGaugeMeasurePoints[1].Y - objROI.ref_ROI.TotalOrgY) > 0))
                if (arrGaugeMeasurePoints[1].X > 0 && arrGaugeMeasurePoints[0].X > 0 && 
                    arrGaugeMeasurePoints[1].Y > 0 && arrGaugeMeasurePoints[0].Y > 0 && 
                    ((arrGaugeMeasurePoints[0].X - objROI.ref_ROI.TotalOrgX) > m_intPadEdgeGaugePointToPackageEdgeTolerance) && 
                    ((arrGaugeMeasurePoints[0].Y - objROI.ref_ROI.TotalOrgY) > m_intPadEdgeGaugePointToPackageEdgeTolerance) && 
                    ((arrGaugeMeasurePoints[1].X - objROI.ref_ROI.TotalOrgX) > 0) && 
                    ((arrGaugeMeasurePoints[1].Y - objROI.ref_ROI.TotalOrgY) > 0))
                {
                    //if (line > 1)
                    //    fLineLength = (float)Math.Sqrt(Math.Pow(Math.Abs(arrGaugeMeasurePoints[1].X - arrGaugeMeasurePoints[0].X), 2) + Math.Pow(Math.Abs(arrGaugeMeasurePoints[1].Y - arrGaugeMeasurePoints[0].Y), 2));
                    //else if (line == 0 && lenghtMode == 1)
                    //    fLineLength = Math.Abs(arrGaugeMeasurePoints[1].Y - arrGaugeMeasurePoints[0].Y);
                    //else if (line == 0 && lenghtMode == 2)
                    //    fLineLength = Math.Abs(arrGaugeMeasurePoints[1].X - arrGaugeMeasurePoints[0].X);
                    //else if (line == 1 && lenghtMode == 1)
                    //    fLineLength = Math.Abs(arrGaugeMeasurePoints[1].X - arrGaugeMeasurePoints[0].X);
                    //else if (line == 1 && lenghtMode == 2)
                    //    fLineLength = Math.Abs(arrGaugeMeasurePoints[1].Y - arrGaugeMeasurePoints[0].Y);

                    if (intMeasureMode == 0)
                    {
                        fLineLength = (float)Math.Sqrt(Math.Pow(Math.Abs(arrGaugeMeasurePoints[1].X - arrGaugeMeasurePoints[0].X), 2) + Math.Pow(Math.Abs(arrGaugeMeasurePoints[1].Y - arrGaugeMeasurePoints[0].Y), 2));
                    }
                    else
                    {
                        Line objLine1 = new Line();
                        Line objLine2 = new Line();

                        objLine1.CalculateStraightLine(arrGaugeMeasurePoints[0], FeretAngle);
                        objLine2.CalculateStraightLine(arrGaugeMeasurePoints[1], FeretAngle + 90);

                        PointF pIntercept = Line.GetCrossPoint(objLine1,objLine2);
                        //if (line == 0 && lenghtMode == 1)
                        //    fLineLength = Math2.GetDistanceBtw2Points(arrGaugeMeasurePoints[0], pIntercept);
                        //else if (line == 0 && lenghtMode == 2)
                        //    fLineLength = Math2.GetDistanceBtw2Points(arrGaugeMeasurePoints[1], pIntercept);
                        //else if (line == 1 && lenghtMode == 1)
                        //    fLineLength = Math2.GetDistanceBtw2Points(arrGaugeMeasurePoints[1], pIntercept);
                        //else if (line == 1 && lenghtMode == 2)
                        //    fLineLength = Math2.GetDistanceBtw2Points(arrGaugeMeasurePoints[0], pIntercept);
                        if (line == 0)
                            fLineLength = Math2.GetDistanceBtw2Points(arrGaugeMeasurePoints[0], pIntercept);
                        else if (line == 1)
                            fLineLength = Math2.GetDistanceBtw2Points(arrGaugeMeasurePoints[1], pIntercept);
                        else
                            fLineLength = Math2.GetDistanceBtw2Points(arrGaugeMeasurePoints[1], pIntercept);
                    }

                    fNewCenterY = ((arrGaugeMeasurePoints[1].Y + arrGaugeMeasurePoints[0].Y) / 2) - objROI.ref_ROI.TotalOrgY;

                    fNewCenterX = ((arrGaugeMeasurePoints[1].X + arrGaugeMeasurePoints[0].X) / 2) - objROI.ref_ROI.TotalOrgX;
                    fpStart[line] = new PointF(arrGaugeMeasurePoints[0].X - objROI.ref_ROI.TotalOrgX, arrGaugeMeasurePoints[0].Y - objROI.ref_ROI.TotalOrgY);
                    fpEnd[line] = new PointF(arrGaugeMeasurePoints[1].X - objROI.ref_ROI.TotalOrgX, arrGaugeMeasurePoints[1].Y - objROI.ref_ROI.TotalOrgY);
                }
                else
                {
                    fLineLength = -1;
                }
                //if (line == 0 && lenghtMode == 1)
                //{
                //    fNewCenterY = ((arrGaugeMeasurePoints[1].Y + arrGaugeMeasurePoints[0].Y) / 2) - objROI.ref_ROI.TotalOrgY;

                //}
                //else if (line == 1 && lenghtMode == 1)
                //{
                //    fNewCenterX = ((arrGaugeMeasurePoints[1].X + arrGaugeMeasurePoints[0].X) / 2) - objROI.ref_ROI.TotalOrgX;
                //}

                //if (line == 0 && lenghtMode == 2)
                //{
                //    fNewCenterX = ((arrGaugeMeasurePoints[1].X + arrGaugeMeasurePoints[0].X) / 2) - objROI.ref_ROI.TotalOrgX;

                //}
                //else if (line == 1 && lenghtMode == 2)
                //{
                //    fNewCenterY = ((arrGaugeMeasurePoints[1].Y + arrGaugeMeasurePoints[0].Y) / 2) - objROI.ref_ROI.TotalOrgY;

                //}
            }
            else
            {
                fLineLength = -1;


            }

            //// check is 4 side measurement ok
            //for (int i = 0; i < arrGaugeMeasurePoints.Count; i++)
            //{
            //    if (arrGaugeMeasurePoints[i].X == 0 || arrGaugeMeasurePoints[i].Y == 0)
            //        return; // Return without update the fWidth and fHeight if get measurement point 0,0
            //}

            //fWidth = arrGaugeMeasurePoints[1].X - arrGaugeMeasurePoints[0].X;
            //fHeight = arrGaugeMeasurePoints[3].Y - arrGaugeMeasurePoints[2].Y;
            //fNewCenterX = ((arrGaugeMeasurePoints[1].X + arrGaugeMeasurePoints[0].X) / 2) - objROI.ref_ROI.TotalOrgX;
            //fNewCenterY = ((arrGaugeMeasurePoints[3].Y + arrGaugeMeasurePoints[2].Y) / 2) - objROI.ref_ROI.TotalOrgY;

        }
        private void UpdateBlobSizeAndCenterPointWithGauge_WithIndividualLineAndFeret(ROI objROI,
                                                         float fOriCenterX, float fOriCenterY,
                                                         ref float fWidth, ref float fHeight,
                                                         ref float fNewCenterX, ref float fNewCenterY,
                                                         int intThresholdValue,
           float WidthPercentStart, float WidthPercentEnd, float HeightPercentStart, float HeightPercentEnd,
           float InwardPercentStart, float InwardPercentEnd,
           int lineCount, int line, int lenghtMode, float FeretAngle, ref float fLineLength,
            ref int p1X, ref int p1Y, ref int p2X, ref int p2Y, ref int p3X, ref int p3Y, ref int p4X, ref int p4Y, ref List<PointF> fpStart, ref List<PointF> fpEnd, int intBlobNo)
        {
            BlobsFeatures m_stcBlobPad = (BlobsFeatures)m_arrTemplateBlobPads[intBlobNo];
            
            float fFeretAngle = FeretAngle;
            
                System.Drawing.Point p1_Feret = new System.Drawing.Point(objROI.ref_ROIPositionX + (int)Math.Round(fOriCenterX - fWidth / 2), objROI.ref_ROIPositionY + (int)Math.Round(fOriCenterY - fHeight / 2));
                System.Drawing.Point p2_Feret = new System.Drawing.Point(objROI.ref_ROIPositionX + (int)Math.Round(fOriCenterX + fWidth / 2), objROI.ref_ROIPositionY + (int)Math.Round(fOriCenterY - fHeight / 2));
                System.Drawing.Point p3_Feret = new System.Drawing.Point(objROI.ref_ROIPositionX + (int)Math.Round(fOriCenterX - fWidth / 2), objROI.ref_ROIPositionY + (int)Math.Round(fOriCenterY + fHeight / 2));
                System.Drawing.Point p4_Feret = new System.Drawing.Point(objROI.ref_ROIPositionX + (int)Math.Round(fOriCenterX + fWidth / 2), objROI.ref_ROIPositionY + (int)Math.Round(fOriCenterY + fHeight / 2));

                float newX1 = 0, newY1 = 0;
                float newX2 = 0, newY2 = 0;
                float newX3 = 0, newY3 = 0;
                float newX4 = 0, newY4 = 0;

            Math2.RotateWithAngleAccordingToReferencePoint(objROI.ref_ROIPositionX + fOriCenterX, objROI.ref_ROIPositionY + fOriCenterY, (float)p1_Feret.X, (float)p1_Feret.Y, fFeretAngle, ref newX1, ref newY1);
                Math2.RotateWithAngleAccordingToReferencePoint(objROI.ref_ROIPositionX + fOriCenterX, objROI.ref_ROIPositionY + fOriCenterY, (float)p3_Feret.X, (float)p3_Feret.Y, fFeretAngle, ref newX3, ref newY3);
                Math2.RotateWithAngleAccordingToReferencePoint(objROI.ref_ROIPositionX + fOriCenterX, objROI.ref_ROIPositionY + fOriCenterY, (float)p2_Feret.X, (float)p2_Feret.Y, fFeretAngle, ref newX2, ref newY2);
                Math2.RotateWithAngleAccordingToReferencePoint(objROI.ref_ROIPositionX + fOriCenterX, objROI.ref_ROIPositionY + fOriCenterY, (float)p4_Feret.X, (float)p4_Feret.Y, fFeretAngle, ref newX4, ref newY4);
            p1_Feret.X = (int)newX1;
            p1_Feret.Y = (int)newY1;
            p2_Feret.X = (int)newX2;
            p2_Feret.Y = (int)newY2;
            p3_Feret.X = (int)newX3;
            p3_Feret.Y = (int)newY3;
            p4_Feret.X = (int)newX4;
            p4_Feret.Y = (int)newY4;
           
            p1X = p1_Feret.X;
            p1Y = p1_Feret.Y;
            p2X = p2_Feret.X;
            p2Y = p2_Feret.Y;
            p3X = p3_Feret.X;
            p3Y = p3_Feret.Y;
            p4X = p4_Feret.X;
            p4Y = p4_Feret.Y;

            //System.Drawing.Point p1 = new System.Drawing.Point(p1X, p1Y);
            //System.Drawing.Point p2 = new System.Drawing.Point(p2X, p2Y);
            //System.Drawing.Point p3 = new System.Drawing.Point(p3X, p3Y);
            //System.Drawing.Point p4 = new System.Drawing.Point(p4X, p4Y);

            System.Drawing.Point p1 = new System.Drawing.Point(p1_Feret.X, p1_Feret.Y);
            System.Drawing.Point p2 = new System.Drawing.Point(p2_Feret.X, p2_Feret.Y);
            System.Drawing.Point p3 = new System.Drawing.Point(p3_Feret.X, p3_Feret.Y);
            System.Drawing.Point p4 = new System.Drawing.Point(p4_Feret.X, p4_Feret.Y);

            float StartX = 0;
            float StartY = 0;
            float EndX = 0;
            float EndY = 0;

            //BlobsFeatures m_stcBlobPad = (BlobsFeatures)m_arrTemplateBlobPads[intBlobNo];
            if (FeretAngle >= 0 && FeretAngle <= 90)
            {
                if (line == 0)
                {
                    StartX = (int)((p1.X + p3.X) / 2) + (int)((Math.Abs(p1.X - p3.X)) * (m_stcBlobPad.fWidthPercentStart1 / 100)) - (int)((Math.Abs(p1.X - p3.X)) * (m_stcBlobPad.fHeightPercentStart1 / 100));
                    StartY = (int)((p1.Y + p3.Y) / 2) + (int)((Math.Abs(p1.Y - p3.Y)) * (m_stcBlobPad.fHeightPercentStart1 / 100)) - (int)((Math.Abs(p1.Y - p3.Y)) * (m_stcBlobPad.fWidthPercentStart1 / 100));
                    EndX = (int)((p2.X + p4.X) / 2) + (int)((Math.Abs(p2.X - p4.X)) * (m_stcBlobPad.fWidthPercentEnd1 / 100)) - (int)((Math.Abs(p2.X - p4.X)) * (m_stcBlobPad.fHeightPercentEnd1 / 100));
                    EndY = (int)((p2.Y + p4.Y) / 2) + (int)((Math.Abs(p2.Y - p4.Y)) * (m_stcBlobPad.fHeightPercentEnd1 / 100)) - (int)((Math.Abs(p2.Y - p4.Y)) * (m_stcBlobPad.fWidthPercentEnd1 / 100));
                }
                else if (line == 1)
                {

                    StartX = (int)((p1.X + p2.X) / 2) + (int)((Math.Abs(p1.X - p2.X)) * (m_stcBlobPad.fWidthPercentStart2 / 100)) + (int)((Math.Abs(p1.X - p2.X)) * (m_stcBlobPad.fHeightPercentStart2 / 100));
                    StartY = (int)((p1.Y + p2.Y) / 2) + (int)((Math.Abs(p1.Y - p2.Y)) * (m_stcBlobPad.fHeightPercentStart2 / 100)) + (int)((Math.Abs(p1.Y - p2.Y)) * (m_stcBlobPad.fWidthPercentStart2 / 100));
                    EndX = (int)((p3.X + p4.X) / 2) + (int)((Math.Abs(p3.X - p4.X)) * (m_stcBlobPad.fWidthPercentEnd2 / 100)) + (int)((Math.Abs(p3.X - p4.X)) * (m_stcBlobPad.fHeightPercentEnd2 / 100));
                    EndY = (int)((p3.Y + p4.Y) / 2) + (int)((Math.Abs(p3.Y - p4.Y)) * (m_stcBlobPad.fHeightPercentEnd2 / 100)) + (int)((Math.Abs(p3.Y - p4.Y)) * (m_stcBlobPad.fWidthPercentEnd2 / 100));
                }
            }
            else if (FeretAngle > 90)
            {
                if (line == 0)
                {
                    StartX = (int)((p1.X + p3.X) / 2) + (int)((Math.Abs(p1.X - p3.X)) * (m_stcBlobPad.fWidthPercentStart1 / 100)) - (int)((Math.Abs(p1.X - p3.X)) * (m_stcBlobPad.fHeightPercentStart1 / 100));
                    StartY = (int)((p1.Y + p3.Y) / 2) - (int)((Math.Abs(p1.Y - p3.Y)) * (m_stcBlobPad.fHeightPercentStart1 / 100)) - (int)((Math.Abs(p1.Y - p3.Y)) * (m_stcBlobPad.fWidthPercentStart1 / 100));
                    EndX = (int)((p2.X + p4.X) / 2) + (int)((Math.Abs(p2.X - p4.X)) * (m_stcBlobPad.fWidthPercentEnd1 / 100)) - (int)((Math.Abs(p2.X - p4.X)) * (m_stcBlobPad.fHeightPercentEnd1 / 100));
                    EndY = (int)((p2.Y + p4.Y) / 2) - (int)((Math.Abs(p2.Y - p4.Y)) * (m_stcBlobPad.fHeightPercentEnd1 / 100)) - (int)((Math.Abs(p2.Y - p4.Y)) * (m_stcBlobPad.fWidthPercentEnd1 / 100));
                }
                else if (line == 1)
                {

                    StartX = (int)((p1.X + p2.X) / 2) - (int)((Math.Abs(p1.X - p2.X)) * (m_stcBlobPad.fWidthPercentStart2 / 100)) + (int)((Math.Abs(p1.X - p2.X)) * (m_stcBlobPad.fHeightPercentStart2 / 100));
                    StartY = (int)((p1.Y + p2.Y) / 2) + (int)((Math.Abs(p1.Y - p2.Y)) * (m_stcBlobPad.fHeightPercentStart2 / 100)) + (int)((Math.Abs(p1.Y - p2.Y)) * (m_stcBlobPad.fWidthPercentStart2 / 100));
                    EndX = (int)((p3.X + p4.X) / 2) - (int)((Math.Abs(p3.X - p4.X)) * (m_stcBlobPad.fWidthPercentEnd2 / 100)) + (int)((Math.Abs(p3.X - p4.X)) * (m_stcBlobPad.fHeightPercentEnd2 / 100));
                    EndY = (int)((p3.Y + p4.Y) / 2) + (int)((Math.Abs(p3.Y - p4.Y)) * (m_stcBlobPad.fHeightPercentEnd2 / 100)) + (int)((Math.Abs(p3.Y - p4.Y)) * (m_stcBlobPad.fWidthPercentEnd2 / 100));
                }
            }
            else if (FeretAngle < -90)
            {
                if (line == 0)
                {
                    StartX = (int)((p1.X + p3.X) / 2) - (int)((Math.Abs(p1.X - p3.X)) * (m_stcBlobPad.fWidthPercentStart1 / 100)) + (int)((Math.Abs(p1.X - p3.X)) * (m_stcBlobPad.fHeightPercentStart1 / 100));
                    StartY = (int)((p1.Y + p3.Y) / 2) + (int)((Math.Abs(p1.Y - p3.Y)) * (m_stcBlobPad.fHeightPercentStart1 / 100)) + (int)((Math.Abs(p1.Y - p3.Y)) * (m_stcBlobPad.fWidthPercentStart1 / 100));
                    EndX = (int)((p2.X + p4.X) / 2) - (int)((Math.Abs(p2.X - p4.X)) * (m_stcBlobPad.fWidthPercentEnd1 / 100)) + (int)((Math.Abs(p2.X - p4.X)) * (m_stcBlobPad.fHeightPercentEnd1 / 100));
                    EndY = (int)((p2.Y + p4.Y) / 2) + (int)((Math.Abs(p2.Y - p4.Y)) * (m_stcBlobPad.fHeightPercentEnd1 / 100)) + (int)((Math.Abs(p2.Y - p4.Y)) * (m_stcBlobPad.fWidthPercentEnd1 / 100));
                }
                else
                {
                    StartX = (int)((p1.X + p2.X) / 2) + (int)((Math.Abs(p1.X - p2.X)) * (m_stcBlobPad.fWidthPercentStart2 / 100)) - (int)((Math.Abs(p1.X - p2.X)) * (m_stcBlobPad.fHeightPercentStart2 / 100));
                    StartY = (int)((p1.Y + p2.Y) / 2) - (int)((Math.Abs(p1.Y - p2.Y)) * (m_stcBlobPad.fHeightPercentStart2 / 100)) - (int)((Math.Abs(p1.Y - p2.Y)) * (m_stcBlobPad.fWidthPercentStart2 / 100));
                    EndX = (int)((p3.X + p4.X) / 2) + (int)((Math.Abs(p3.X - p4.X)) * (m_stcBlobPad.fWidthPercentEnd2 / 100)) - (int)((Math.Abs(p3.X - p4.X)) * (m_stcBlobPad.fHeightPercentEnd2 / 100));
                    EndY = (int)((p3.Y + p4.Y) / 2) - (int)((Math.Abs(p3.Y - p4.Y)) * (m_stcBlobPad.fHeightPercentEnd2 / 100)) - (int)((Math.Abs(p3.Y - p4.Y)) * (m_stcBlobPad.fWidthPercentEnd2 / 100));
                }
            }
            else
            {
                if (line == 0)
                {
                    StartX = (int)((p1.X + p3.X) / 2) + (int)((Math.Abs(p1.X - p3.X)) * (m_stcBlobPad.fWidthPercentStart1 / 100)) + (int)((Math.Abs(p1.X - p3.X)) * (m_stcBlobPad.fHeightPercentStart1 / 100));
                    StartY = (int)((p1.Y + p3.Y) / 2) + (int)((Math.Abs(p1.Y - p3.Y)) * (m_stcBlobPad.fHeightPercentStart1 / 100)) + (int)((Math.Abs(p1.Y - p3.Y)) * (m_stcBlobPad.fWidthPercentStart1 / 100));
                    EndX = (int)((p2.X + p4.X) / 2) + (int)((Math.Abs(p2.X - p4.X)) * (m_stcBlobPad.fWidthPercentEnd1 / 100)) + (int)((Math.Abs(p2.X - p4.X)) * (m_stcBlobPad.fHeightPercentEnd1 / 100));
                    EndY = (int)((p2.Y + p4.Y) / 2) + (int)((Math.Abs(p2.Y - p4.Y)) * (m_stcBlobPad.fHeightPercentEnd1 / 100)) + (int)((Math.Abs(p2.Y - p4.Y)) * (m_stcBlobPad.fWidthPercentEnd1 / 100));
                }
                else
                {
                    StartX = (int)((p1.X + p2.X) / 2) + (int)((Math.Abs(p1.X - p2.X)) * (m_stcBlobPad.fWidthPercentStart2 / 100)) - (int)((Math.Abs(p1.X - p2.X)) * (m_stcBlobPad.fHeightPercentStart2 / 100));
                    StartY = (int)((p1.Y + p2.Y) / 2) + (int)((Math.Abs(p1.Y - p2.Y)) * (m_stcBlobPad.fHeightPercentStart2 / 100)) - (int)((Math.Abs(p1.Y - p2.Y)) * (m_stcBlobPad.fWidthPercentStart2 / 100));
                    EndX = (int)((p3.X + p4.X) / 2) + (int)((Math.Abs(p3.X - p4.X)) * (m_stcBlobPad.fWidthPercentEnd2 / 100)) - (int)((Math.Abs(p3.X - p4.X)) * (m_stcBlobPad.fHeightPercentEnd2 / 100));
                    EndY = (int)((p3.Y + p4.Y) / 2) + (int)((Math.Abs(p3.Y - p4.Y)) * (m_stcBlobPad.fHeightPercentEnd2 / 100)) - (int)((Math.Abs(p3.Y - p4.Y)) * (m_stcBlobPad.fWidthPercentEnd2 / 100));
                }
            }

            float RotatedX1 = 0;
            float RotatedX2 = 0;

            float RotatedY1 = 0;
            float RotatedY2 = 0;
            Point OriP1 = new System.Drawing.Point(objROI.ref_ROI.TotalOrgX + (int)Math.Round(fOriCenterX - fWidth / 2), objROI.ref_ROI.TotalOrgY + (int)Math.Round(fOriCenterY - fHeight / 2));
            Point OriP2 = new System.Drawing.Point(objROI.ref_ROI.TotalOrgX + (int)Math.Round(fOriCenterX + fWidth / 2), objROI.ref_ROI.TotalOrgY + (int)Math.Round(fOriCenterY - fHeight / 2));
            Point OriP3 = new System.Drawing.Point(objROI.ref_ROI.TotalOrgX + (int)Math.Round(fOriCenterX - fWidth / 2), objROI.ref_ROI.TotalOrgY + (int)Math.Round(fOriCenterY + fHeight / 2));
            Point OriP4 = new System.Drawing.Point(objROI.ref_ROI.TotalOrgX + (int)Math.Round(fOriCenterX + fWidth / 2), objROI.ref_ROI.TotalOrgY + (int)Math.Round(fOriCenterY + fHeight / 2));

            if (line == 2)
            {
                 
                Math2.RotateWithAngleAccordingToReferencePoint(objROI.ref_ROI.TotalOrgX + fOriCenterX, objROI.ref_ROI.TotalOrgY + fOriCenterY,
                        (float)(((OriP1.X + OriP2.X) / 2) + (((Math.Abs(OriP1.X - OriP2.X) / 2) / (line))) + (int)((Math.Abs(OriP1.X - OriP2.X)) * (m_stcBlobPad.fWidthPercentStart3 / 100))),
                        (float)(OriP1.Y + ((Math.Abs(OriP1.Y - OriP3.Y) * m_stcBlobPad.fHeightPercentStart3 / 100))), FeretAngle, ref RotatedX1, ref RotatedY1);

                Math2.RotateWithAngleAccordingToReferencePoint(objROI.ref_ROI.TotalOrgX + fOriCenterX, objROI.ref_ROI.TotalOrgY + fOriCenterY,
                    (float)(((OriP3.X + OriP4.X) / 2) + ((Math.Abs(OriP3.X - OriP4.X) / 2) / (line)) + (int)((Math.Abs(OriP3.X - OriP4.X)) * (m_stcBlobPad.fWidthPercentEnd3 / 100))),
                    (float)(OriP3.Y + ((Math.Abs(OriP1.Y - OriP3.Y) * m_stcBlobPad.fHeightPercentEnd3 / 100))), FeretAngle, ref RotatedX2, ref RotatedY2);

                StartX = (int)RotatedX1;
                StartY = (int)RotatedY1;
                EndX = (int)RotatedX2;
                EndY = (int)RotatedY2;
            }

            if (line == 3)
            {
                Math2.RotateWithAngleAccordingToReferencePoint(objROI.ref_ROI.TotalOrgX + fOriCenterX, objROI.ref_ROI.TotalOrgY + fOriCenterY,
                        (float)(((OriP1.X + OriP2.X) / 2) + (((Math.Abs(OriP1.X - OriP2.X) / 2) / (line))) + (int)((Math.Abs(OriP1.X - OriP2.X)) * (m_stcBlobPad.fWidthPercentStart4 / 100))),
                        (float)(OriP1.Y + ((Math.Abs(OriP1.Y - OriP3.Y) * m_stcBlobPad.fHeightPercentStart4 / 100))), fFeretAngle, ref RotatedX1, ref RotatedY1);

                Math2.RotateWithAngleAccordingToReferencePoint(objROI.ref_ROI.TotalOrgX + fOriCenterX, objROI.ref_ROI.TotalOrgY + fOriCenterY,
                    (float)(((OriP3.X + OriP4.X) / 2) + ((Math.Abs(OriP3.X - OriP4.X) / 2) / (line)) + (int)((Math.Abs(OriP3.X - OriP4.X)) * (m_stcBlobPad.fWidthPercentEnd4 / 100))),
                    (float)(OriP3.Y + ((Math.Abs(OriP1.Y - OriP3.Y) * m_stcBlobPad.fHeightPercentEnd4 / 100))), fFeretAngle, ref RotatedX2, ref RotatedY2);

                StartX = (int)RotatedX1;
                StartY = (int)RotatedY1;
                EndX = (int)RotatedX2;
                EndY = (int)RotatedY2;
            }

            if (line == 4)
            {
                Math2.RotateWithAngleAccordingToReferencePoint(objROI.ref_ROI.TotalOrgX + fOriCenterX, objROI.ref_ROI.TotalOrgY + fOriCenterY,
                        (float)(((OriP1.X + OriP2.X) / 2) + (((Math.Abs(OriP1.X - OriP2.X) / 2) / (line))) + (int)((Math.Abs(OriP1.X - OriP2.X)) * (m_stcBlobPad.fWidthPercentStart5 / 100))),
                        (float)(OriP1.Y + ((Math.Abs(OriP1.Y - OriP3.Y) * m_stcBlobPad.fHeightPercentStart5 / 100))), FeretAngle, ref RotatedX1, ref RotatedY1);

                Math2.RotateWithAngleAccordingToReferencePoint(objROI.ref_ROI.TotalOrgX + fOriCenterX, objROI.ref_ROI.TotalOrgY + fOriCenterY,
                    (float)(((OriP3.X + OriP4.X) / 2) + ((Math.Abs(OriP3.X - OriP4.X) / 2) / (line)) + (int)((Math.Abs(OriP3.X - OriP4.X)) * (m_stcBlobPad.fWidthPercentEnd5 / 100))),
                    (float)(OriP3.Y + ((Math.Abs(OriP1.Y - OriP3.Y) * m_stcBlobPad.fHeightPercentEnd5 / 100))), FeretAngle, ref RotatedX2, ref RotatedY2);

                StartX = (int)RotatedX1;
                StartY = (int)RotatedY1;
                EndX = (int)RotatedX2;
                EndY = (int)RotatedY2;
            }

            if (line == 5)
            {
                Math2.RotateWithAngleAccordingToReferencePoint(objROI.ref_ROI.TotalOrgX + fOriCenterX, objROI.ref_ROI.TotalOrgY + fOriCenterY,
                        (float)(((OriP1.X + OriP2.X) / 2) + (((Math.Abs(OriP1.X - OriP2.X) / 2) / (line))) + (int)((Math.Abs(OriP1.X - OriP2.X)) * (m_stcBlobPad.fWidthPercentStart6 / 100))),
                        (float)(OriP1.Y + ((Math.Abs(OriP1.Y - OriP3.Y) * m_stcBlobPad.fHeightPercentStart6 / 100))), FeretAngle, ref RotatedX1, ref RotatedY1);

                Math2.RotateWithAngleAccordingToReferencePoint(objROI.ref_ROI.TotalOrgX + fOriCenterX, objROI.ref_ROI.TotalOrgY + fOriCenterY,
                    (float)(((OriP3.X + OriP4.X) / 2) + ((Math.Abs(OriP3.X - OriP4.X) / 2) / (line)) + (int)((Math.Abs(OriP3.X - OriP4.X)) * (m_stcBlobPad.fWidthPercentEnd6 / 100))),
                    (float)(OriP3.Y + ((Math.Abs(OriP1.Y - OriP3.Y) * m_stcBlobPad.fHeightPercentEnd6 / 100))), FeretAngle, ref RotatedX2, ref RotatedY2);

                StartX = (int)RotatedX1;
                StartY = (int)RotatedY1;
                EndX = (int)RotatedX2;
                EndY = (int)RotatedY2;
            }

            if (line == 6)
            {
                Math2.RotateWithAngleAccordingToReferencePoint(objROI.ref_ROI.TotalOrgX + fOriCenterX, objROI.ref_ROI.TotalOrgY + fOriCenterY,
                        (float)(((OriP1.X + OriP2.X) / 2) + (((Math.Abs(OriP1.X - OriP2.X) / 2) / (line))) + (int)((Math.Abs(OriP1.X - OriP2.X)) * (m_stcBlobPad.fWidthPercentStart7 / 100))),
                        (float)(OriP1.Y + ((Math.Abs(OriP1.Y - OriP3.Y) * m_stcBlobPad.fHeightPercentStart7 / 100))), FeretAngle, ref RotatedX1, ref RotatedY1);

                Math2.RotateWithAngleAccordingToReferencePoint(objROI.ref_ROI.TotalOrgX + fOriCenterX, objROI.ref_ROI.TotalOrgY + fOriCenterY,
                    (float)(((OriP3.X + OriP4.X) / 2) + ((Math.Abs(OriP3.X - OriP4.X) / 2) / (line)) + (int)((Math.Abs(OriP3.X - OriP4.X)) * (m_stcBlobPad.fWidthPercentEnd7 / 100))),
                    (float)(OriP3.Y + ((Math.Abs(OriP1.Y - OriP3.Y) * m_stcBlobPad.fHeightPercentEnd7 / 100))), FeretAngle, ref RotatedX2, ref RotatedY2);

                StartX = (int)RotatedX1;
                StartY = (int)RotatedY1;
                EndX = (int)RotatedX2;
                EndY = (int)RotatedY2;
            }

            if (line == 7)
            {
                Math2.RotateWithAngleAccordingToReferencePoint(objROI.ref_ROI.TotalOrgX + fOriCenterX, objROI.ref_ROI.TotalOrgY + fOriCenterY,
                        (float)(((OriP1.X + OriP2.X) / 2) + (((Math.Abs(OriP1.X - OriP2.X) / 2) / (line))) + (int)((Math.Abs(OriP1.X - OriP2.X)) * (m_stcBlobPad.fWidthPercentStart8 / 100))),
                        (float)(OriP1.Y + ((Math.Abs(OriP1.Y - OriP3.Y) * m_stcBlobPad.fHeightPercentStart8 / 100))), FeretAngle, ref RotatedX1, ref RotatedY1);

                Math2.RotateWithAngleAccordingToReferencePoint(objROI.ref_ROI.TotalOrgX + fOriCenterX, objROI.ref_ROI.TotalOrgY + fOriCenterY,
                    (float)(((OriP3.X + OriP4.X) / 2) + ((Math.Abs(OriP3.X - OriP4.X) / 2) / (line)) + (int)((Math.Abs(OriP3.X - OriP4.X)) * (m_stcBlobPad.fWidthPercentEnd8 / 100))),
                    (float)(OriP3.Y + ((Math.Abs(OriP1.Y - OriP3.Y) * m_stcBlobPad.fHeightPercentEnd8 / 100))), FeretAngle, ref RotatedX2, ref RotatedY2);

                StartX = (int)RotatedX1;
                StartY = (int)RotatedY1;
                EndX = (int)RotatedX2;
                EndY = (int)RotatedY2;
            }

            if (line == 8)
            {
                Math2.RotateWithAngleAccordingToReferencePoint(objROI.ref_ROI.TotalOrgX + fOriCenterX, objROI.ref_ROI.TotalOrgY + fOriCenterY,
                        (float)(((OriP1.X + OriP2.X) / 2) + (((Math.Abs(OriP1.X - OriP2.X) / 2) / (line))) + (int)((Math.Abs(OriP1.X - OriP2.X)) * (m_stcBlobPad.fWidthPercentStart9 / 100))),
                        (float)(OriP1.Y + ((Math.Abs(OriP1.Y - OriP3.Y) * m_stcBlobPad.fHeightPercentStart9 / 100))), FeretAngle, ref RotatedX1, ref RotatedY1);

                Math2.RotateWithAngleAccordingToReferencePoint(objROI.ref_ROI.TotalOrgX + fOriCenterX, objROI.ref_ROI.TotalOrgY + fOriCenterY,
                    (float)(((OriP3.X + OriP4.X) / 2) + ((Math.Abs(OriP3.X - OriP4.X) / 2) / (line)) + (int)((Math.Abs(OriP3.X - OriP4.X)) * (m_stcBlobPad.fWidthPercentEnd9 / 100))),
                    (float)(OriP3.Y + ((Math.Abs(OriP1.Y - OriP3.Y) * m_stcBlobPad.fHeightPercentEnd9 / 100))), FeretAngle, ref RotatedX2, ref RotatedY2);

                StartX = (int)RotatedX1;
                StartY = (int)RotatedY1;
                EndX = (int)RotatedX2;
                EndY = (int)RotatedY2;
            }

            if (line == 9)
            {
                Math2.RotateWithAngleAccordingToReferencePoint(objROI.ref_ROI.TotalOrgX + fOriCenterX, objROI.ref_ROI.TotalOrgY + fOriCenterY,
                        (float)(((OriP1.X + OriP2.X) / 2) + (((Math.Abs(OriP1.X - OriP2.X) / 2) / (line))) + (int)((Math.Abs(OriP1.X - OriP2.X)) * (m_stcBlobPad.fWidthPercentStart10 / 100))),
                        (float)(OriP1.Y + ((Math.Abs(OriP1.Y - OriP3.Y) * m_stcBlobPad.fHeightPercentStart10 / 100))), FeretAngle, ref RotatedX1, ref RotatedY1);

                Math2.RotateWithAngleAccordingToReferencePoint(objROI.ref_ROI.TotalOrgX + fOriCenterX, objROI.ref_ROI.TotalOrgY + fOriCenterY,
                    (float)(((OriP3.X + OriP4.X) / 2) + ((Math.Abs(OriP3.X - OriP4.X) / 2) / (line)) + (int)((Math.Abs(OriP3.X - OriP4.X)) * (m_stcBlobPad.fWidthPercentEnd10 / 100))),
                    (float)(OriP3.Y + ((Math.Abs(OriP1.Y - OriP3.Y) * m_stcBlobPad.fHeightPercentEnd10 / 100))), FeretAngle, ref RotatedX2, ref RotatedY2);

                StartX = (int)RotatedX1;
                StartY = (int)RotatedY1;
                EndX = (int)RotatedX2;
                EndY = (int)RotatedY2;
            }

            if (line == 10)
            {
                Math2.RotateWithAngleAccordingToReferencePoint(objROI.ref_ROI.TotalOrgX + fOriCenterX, objROI.ref_ROI.TotalOrgY + fOriCenterY,
                        (float)(((OriP1.X + OriP2.X) / 2) + (((Math.Abs(OriP1.X - OriP2.X) / 2) / (line))) + (int)((Math.Abs(OriP1.X - OriP2.X)) * (m_stcBlobPad.fWidthPercentStart11 / 100))),
                        (float)(OriP1.Y + ((Math.Abs(OriP1.Y - OriP3.Y) * m_stcBlobPad.fHeightPercentStart11 / 100))), FeretAngle, ref RotatedX1, ref RotatedY1);

                Math2.RotateWithAngleAccordingToReferencePoint(objROI.ref_ROI.TotalOrgX + fOriCenterX, objROI.ref_ROI.TotalOrgY + fOriCenterY,
                    (float)(((OriP3.X + OriP4.X) / 2) + ((Math.Abs(OriP3.X - OriP4.X) / 2) / (line)) + (int)((Math.Abs(OriP3.X - OriP4.X)) * (m_stcBlobPad.fWidthPercentEnd11 / 100))),
                    (float)(OriP3.Y + ((Math.Abs(OriP1.Y - OriP3.Y) * m_stcBlobPad.fHeightPercentEnd11 / 100))), FeretAngle, ref RotatedX2, ref RotatedY2);

                StartX = (int)RotatedX1;
                StartY = (int)RotatedY1;
                EndX = (int)RotatedX2;
                EndY = (int)RotatedY2;
            }

            if (line == 11)
            {
                Math2.RotateWithAngleAccordingToReferencePoint(objROI.ref_ROI.TotalOrgX + fOriCenterX, objROI.ref_ROI.TotalOrgY + fOriCenterY,
                        (float)(((OriP1.X + OriP2.X) / 2) + (((Math.Abs(OriP1.X - OriP2.X) / 2) / (line))) + (int)((Math.Abs(OriP1.X - OriP2.X)) * (m_stcBlobPad.fWidthPercentStart12 / 100))),
                        (float)(OriP1.Y + ((Math.Abs(OriP1.Y - OriP3.Y) * m_stcBlobPad.fHeightPercentStart12 / 100))), FeretAngle, ref RotatedX1, ref RotatedY1);

                Math2.RotateWithAngleAccordingToReferencePoint(objROI.ref_ROI.TotalOrgX + fOriCenterX, objROI.ref_ROI.TotalOrgY + fOriCenterY,
                    (float)(((OriP3.X + OriP4.X) / 2) + ((Math.Abs(OriP3.X - OriP4.X) / 2) / (line)) + (int)((Math.Abs(OriP3.X - OriP4.X)) * (m_stcBlobPad.fWidthPercentEnd12 / 100))),
                    (float)(OriP3.Y + ((Math.Abs(OriP1.Y - OriP3.Y) * m_stcBlobPad.fHeightPercentEnd12 / 100))), FeretAngle, ref RotatedX2, ref RotatedY2);

                StartX = (int)RotatedX1;
                StartY = (int)RotatedY1;
                EndX = (int)RotatedX2;
                EndY = (int)RotatedY2;
            }
            float DiffY = Math.Abs(EndY - StartY);
            float DiffX = Math.Abs(EndX - StartX);
            float AdditionDiffY = EndY - StartY;
            float AdditionDiffX = EndX - StartX;
            float Length = (float)Math.Sqrt(Math.Pow(DiffY, 2) + Math.Pow(DiffX, 2));
            PointF pStart = new PointF(StartX, StartY);
            PointF pEnd = new PointF(EndX, EndY);

            float Angle = 0, AngleStart = 0, AngleEnd = 0;
            //if ((line == 0 && fWidth >= fHeight) || (line == 1 && fWidth <= fHeight)) // lime
            //{
            //    if (DiffX == 0)
            //        Angle = 90;
            //    else
            //    {
            //        Angle = (float)(Math.Atan(DiffY / DiffX) * 180 / Math.PI);
            //    }

            //    if (FeretAngle < 0)
            //    {
            //        if (Angle == 90)
            //        {
            //            AngleStart = -Angle;
            //            AngleEnd = Angle;
            //        }
            //        else
            //        {
            //            AngleStart = 180 - Angle;
            //            AngleStart = -AngleStart;
            //            AngleEnd = Angle;
            //        }
            //    }
            //    else
            //    {
            //        if (Angle == 90)
            //        {
            //            AngleStart = -Angle;
            //            AngleEnd = Angle;
            //        }
            //        else
            //        {
            //            AngleStart = -Angle;
            //            // AngleStart = -AngleStart;
            //            AngleEnd = 180 - Angle;
            //        }

            //    }
            //}

            //if ((line == 0 && fWidth <= fHeight) || (line == 1 && fWidth >= fHeight)) // blue
            //{
            //    if (DiffX == 0)
            //        Angle = 90;
            //    else
            //    {
            //        Angle = (float)(Math.Atan(DiffY / DiffX) * 180 / Math.PI);
            //    }

            //    if (FeretAngle < 0)
            //    {
            //        if (Angle == 90)
            //        {
            //            //fFeretAngle == -90
            //            AngleStart = Angle;
            //            AngleEnd = -Angle;
            //        }
            //        else
            //        {
            //            AngleStart = 180 - Angle;
            //            //AngleStart = -AngleStart;
            //            AngleEnd = -Angle;
            //        }
            //    }
            //    else
            //    {
            //        if (Angle == 90)
            //        {
            //            AngleStart = -Angle;
            //            AngleEnd = Angle;
            //        }
            //        else
            //        {
            //            AngleStart = 180 - Angle;
            //            AngleStart = -AngleStart;
            //            AngleEnd = Angle;
            //        }

            //    }
            //}

            //if (line > 1)
            {
                GetFeretAngle(pStart, pEnd, ref AngleStart, ref AngleEnd);
                ////if (FeretAngle != 90 && FeretAngle != -90 && FeretAngle != 180 && FeretAngle != 0)
                ////{
                ////    AngleStart = 90 - FeretAngle;
                ////    AngleStart = -AngleStart;
                ////    AngleEnd = 90 + FeretAngle;
                ////}
                ////else
                //{
                //    if (DiffX == 0)
                //        Angle = 90;
                //    else
                //    {
                //        AdditionDiffY = AdditionDiffY;
                //        AdditionDiffX = AdditionDiffX;
                //        //Angle = (float)(Math.Atan(AdditionDiffY / AdditionDiffX) * 180 / Math.PI);
                //        Angle = (float)(Math.Atan(DiffY / DiffX) * 180 / Math.PI);
                //        if (DiffY > DiffX)
                //        {
                //            Angle = -Angle;
                //        }
                //        float test = (float)(Math.Atan(DiffX / DiffY) * 180 / Math.PI);
                //    }

                //    if (AdditionDiffY >= 0 && AdditionDiffX < 0)
                //    {
                //        if (FeretAngle < 0)
                //        {
                //            if (Angle == 90)
                //            {
                //                AngleStart = -Angle;
                //                AngleEnd = Angle;
                //            }
                //            else
                //            {
                //                AngleStart = 180 - Angle;
                //                AngleStart = -AngleStart;
                //                AngleEnd = Angle;
                //            }
                //        }
                //        else
                //        {
                //            if (Angle == 90)
                //            {
                //                AngleStart = -Angle;
                //                AngleEnd = Angle;
                //            }
                //            else
                //            {
                //                AngleStart = -Angle;
                //                // AngleStart = -AngleStart;
                //                AngleEnd = 180 - Angle;
                //            }

                //        }
                //    }
                //    else if (AdditionDiffY < 0 && AdditionDiffX < 0)
                //    {
                //        if (FeretAngle < 0)
                //        {
                //            if (Angle == 90)
                //            {
                //                //fFeretAngle == -90
                //                AngleStart = Angle;
                //                AngleEnd = -Angle;
                //            }
                //            else
                //            {
                //                AngleStart = 180 - Angle;
                //                //AngleStart = -AngleStart;
                //                AngleEnd = -Angle;
                //            }
                //        }
                //        else
                //        {
                //            if (Angle == 90)
                //            {
                //                AngleStart = -Angle;
                //                AngleEnd = Angle;
                //            }
                //            else
                //            {
                //                AngleStart = Angle;//180 -
                //                //AngleStart = -AngleStart;
                //                AngleEnd = Angle - 180;//Angle
                //            }

                //        }
                //    }
                //    else if (AdditionDiffY >= 0 && AdditionDiffX >= 0)
                //    {
                //        if (FeretAngle < 0)
                //        {
                //            if (Angle == 90)
                //            {
                //                //fFeretAngle == -90
                //                AngleStart = Angle;
                //                AngleEnd = -Angle;
                //            }
                //            else
                //            {
                //                AngleStart = 180 - Angle;
                //                //AngleStart = -AngleStart;
                //                AngleEnd = -Angle;
                //            }
                //        }
                //        else
                //        {
                //            if (Angle == 90)
                //            {
                //                AngleStart = -Angle;
                //                AngleEnd = Angle;
                //            }
                //            else
                //            {
                //                AngleStart = 180 - Angle;//
                //                AngleStart = -AngleStart;
                //                AngleEnd = Angle;//
                //            }

                //        }
                //    }
                //    else if (AdditionDiffY < 0 && AdditionDiffX >= 0)
                //    {
                //        if (FeretAngle < 0)
                //        {
                //            if (Angle == 90)
                //            {
                //                AngleStart = -Angle;
                //                AngleEnd = Angle;
                //            }
                //            else
                //            {
                //                AngleStart = 180 - Angle;
                //                AngleStart = -AngleStart;
                //                AngleEnd = Angle;
                //            }
                //        }
                //        else
                //        {
                //            if (Angle == 90)
                //            {
                //                AngleStart = Angle;
                //                AngleEnd = -Angle;
                //            }
                //            else
                //            {
                //                AngleStart = 180 - Angle;
                //                // AngleStart = -AngleStart;
                //                AngleEnd = -Angle;
                //            }

                //        }
                //    }
                //}
            }

            float StartX_Rotated = 0;
            float StartY_Rotated = 0;
            float EndX_Rotated = 0;
            float EndY_Rotated = 0;
            Math2.RotateWithAngleAccordingToReferencePoint(objROI.ref_ROIPositionX + fOriCenterX, objROI.ref_ROIPositionY + fOriCenterY, StartX, StartY, -fFeretAngle, ref StartX_Rotated, ref StartY_Rotated);
            Math2.RotateWithAngleAccordingToReferencePoint(objROI.ref_ROIPositionX + fOriCenterX, objROI.ref_ROIPositionY + fOriCenterY, EndX, EndY, -fFeretAngle, ref EndX_Rotated, ref EndY_Rotated);

            float fX_Start = Math.Abs(StartX_Rotated - EndX_Rotated) * (InwardPercentStart / 100);
            float fX_End = Math.Abs(StartX_Rotated - EndX_Rotated) * (InwardPercentEnd / 100);
            float fY_Start = Math.Abs(StartY_Rotated - EndY_Rotated) * (InwardPercentStart / 100);
            float fY_End = Math.Abs(StartY_Rotated - EndY_Rotated) * (InwardPercentEnd / 100);

            float fStartX_Final = StartX_Rotated + fX_Start;
            float fStartY_Final = StartY_Rotated + fY_Start;
            float fEndX_Final = EndX_Rotated - fX_End;
            float fEndY_Final = EndY_Rotated - fY_End;
            if (StartX_Rotated > EndX_Rotated)
            {
                fStartX_Final = StartX_Rotated - fX_Start;
                fEndX_Final = EndX_Rotated + fX_End;
            }
            if (StartY_Rotated > EndY_Rotated)
            {
                fStartY_Final = StartY_Rotated - fY_Start;
                fEndY_Final = EndY_Rotated + fY_End;
            }
            Math2.RotateWithAngleAccordingToReferencePoint(objROI.ref_ROIPositionX + fOriCenterX, objROI.ref_ROIPositionY + fOriCenterY, fStartX_Final, fStartY_Final, fFeretAngle, ref StartX, ref StartY);
            Math2.RotateWithAngleAccordingToReferencePoint(objROI.ref_ROIPositionX + fOriCenterX, objROI.ref_ROIPositionY + fOriCenterY, fEndX_Final, fEndY_Final, fFeretAngle, ref EndX, ref EndY);
            
            List<PointF> arrGaugeMeasurePoints = new List<PointF>();

            // 2019-09-26 ZJYEOH : User now can select which TransChoice to use
            //m_objPointGauge.ref_GaugeThreshold = m_objPointGauge.AutoTuneThreshold(objROI);
            //if (m_objPointGauge.ref_GaugeTransChoice != 0)
            //    m_objPointGauge.ref_GaugeTransChoice = 0;   // Use Largest Amplitude

            //if (m_objPointGauge.ref_GaugeTransType != 1)
            //    m_objPointGauge.ref_GaugeTransType = 1;   // Use Largest Amplitude

            // Get Start Point
            m_objPointGauge.SetGaugePlacement(StartX, StartY, Math.Min(Length / 4, 10), AngleStart);
            m_objPointGauge.Measure(objROI);
            arrGaugeMeasurePoints.Add(m_objPointGauge.GetMeasurePoint(AngleStart, EndX, EndY, line <= 1));

            if ((arrGaugeMeasurePoints[arrGaugeMeasurePoints.Count - 1].X == 0 && arrGaugeMeasurePoints[arrGaugeMeasurePoints.Count - 1].Y == 0) ||
                (m_objPointGauge.ref_intMeasuredPointCount == 0))
            //if (m_objPointGauge.ref_intMeasuredPointCount == 0) // 27-06-2019 ZJYEOH: Measure again with longer length if cannot found any point
            {
                m_objPointGauge.SetGaugePlacement(StartX, StartY, Math.Max(Length / 4, 10), AngleStart);
                m_objPointGauge.Measure(objROI);
                arrGaugeMeasurePoints[arrGaugeMeasurePoints.Count - 1] = m_objPointGauge.GetMeasurePoint(AngleStart, EndX, EndY, line <= 1);

                if ((arrGaugeMeasurePoints[arrGaugeMeasurePoints.Count - 1].X == 0 && arrGaugeMeasurePoints[arrGaugeMeasurePoints.Count - 1].Y == 0) ||
                    (m_objPointGauge.ref_intMeasuredPointCount == 0))
                //if (m_objPointGauge.ref_intMeasuredPointCount == 0) // 27-06-2019 ZJYEOH: Measure again with longer length if cannot found any point
                {
                    m_objPointGauge.SetGaugePlacement(StartX, StartY, Length / 2, AngleStart);
                    m_objPointGauge.Measure(objROI);
                    arrGaugeMeasurePoints[arrGaugeMeasurePoints.Count - 1] = m_objPointGauge.GetMeasurePoint(AngleStart, EndX, EndY, line <= 1);

                    if ((arrGaugeMeasurePoints[arrGaugeMeasurePoints.Count - 1].X == 0 && arrGaugeMeasurePoints[arrGaugeMeasurePoints.Count - 1].Y == 0) ||
                        (m_objPointGauge.ref_intMeasuredPointCount == 0))
                    //if (m_objPointGauge.ref_intMeasuredPointCount == 0)  // 18-10-2019 ZJYEOH: Set back point gauge tolerance to default if still cannot found point, so that drawing for line profile will not draw wrong dimension
                    {
                        m_objPointGauge.SetGaugePlacement(StartX, StartY, Math.Min(Length / 4, 10), AngleStart);
                    }
                }
            }

            // Get End Point
            m_objPointGauge.SetGaugePlacement(EndX, EndY, Math.Min(Length / 4, 10), AngleEnd);
            m_objPointGauge.Measure(objROI);
            arrGaugeMeasurePoints.Add(m_objPointGauge.GetMeasurePoint(AngleEnd, StartX, StartY, line <= 1));

            if ((arrGaugeMeasurePoints[arrGaugeMeasurePoints.Count - 1].X == 0 && arrGaugeMeasurePoints[arrGaugeMeasurePoints.Count - 1].Y == 0) ||
                (m_objPointGauge.ref_intMeasuredPointCount == 0))
            //if (m_objPointGauge.ref_intMeasuredPointCount == 0)  // 27-06-2019 ZJYEOH: Measure again with longer length if cannot found any point
            {
                m_objPointGauge.SetGaugePlacement(EndX, EndY, Math.Max(Length / 4, 10), AngleEnd);
                m_objPointGauge.Measure(objROI);
                arrGaugeMeasurePoints[arrGaugeMeasurePoints.Count - 1] = m_objPointGauge.GetMeasurePoint(AngleEnd, StartX, StartY, line <= 1);

                if ((arrGaugeMeasurePoints[arrGaugeMeasurePoints.Count - 1].X == 0 && arrGaugeMeasurePoints[arrGaugeMeasurePoints.Count - 1].Y == 0) ||
                    (m_objPointGauge.ref_intMeasuredPointCount == 0))  // 27-06-2019 ZJYEOH: Measure again with longer length if cannot found any point
                {
                    m_objPointGauge.SetGaugePlacement(EndX, EndY, Length / 2, AngleEnd);
                    m_objPointGauge.Measure(objROI);
                    arrGaugeMeasurePoints[arrGaugeMeasurePoints.Count - 1] = m_objPointGauge.GetMeasurePoint(AngleEnd, StartX, StartY, line <= 1);

                    if ((arrGaugeMeasurePoints[arrGaugeMeasurePoints.Count - 1].X == 0 && arrGaugeMeasurePoints[arrGaugeMeasurePoints.Count - 1].Y == 0) ||
                        (m_objPointGauge.ref_intMeasuredPointCount == 0))
                    //if (m_objPointGauge.ref_intMeasuredPointCount == 0)  // 18-10-2019 ZJYEOH: Set back point gauge tolerance to default if still cannot found point, so that drawing for line profile will not draw wrong dimension
                    {
                        m_objPointGauge.SetGaugePlacement(EndX, EndY, Math.Min(Length / 4, 10), AngleEnd);
                    }
                }
            }


            // Check left right
            if (arrGaugeMeasurePoints.Count >= 2)
            {
                //if (arrGaugeMeasurePoints[1].X > 0 && arrGaugeMeasurePoints[0].X > 0 && arrGaugeMeasurePoints[1].Y > 0 && arrGaugeMeasurePoints[0].Y > 0
                //    && ((arrGaugeMeasurePoints[0].X - objROI.ref_ROI.TotalOrgX) > 0) && ((arrGaugeMeasurePoints[0].Y - objROI.ref_ROI.TotalOrgY) > 0) && ((arrGaugeMeasurePoints[1].X - objROI.ref_ROI.TotalOrgX) > 0) && ((arrGaugeMeasurePoints[1].Y - objROI.ref_ROI.TotalOrgY) > 0))
                if (arrGaugeMeasurePoints[1].X > 0 && arrGaugeMeasurePoints[0].X > 0 &&
                    arrGaugeMeasurePoints[1].Y > 0 && arrGaugeMeasurePoints[0].Y > 0 &&
                    ((arrGaugeMeasurePoints[0].X - objROI.ref_ROI.TotalOrgX) > m_intPadEdgeGaugePointToPackageEdgeTolerance) &&
                    ((arrGaugeMeasurePoints[0].Y - objROI.ref_ROI.TotalOrgY) > m_intPadEdgeGaugePointToPackageEdgeTolerance) &&
                    ((arrGaugeMeasurePoints[1].X - objROI.ref_ROI.TotalOrgX) > 0) &&
                    ((arrGaugeMeasurePoints[1].Y - objROI.ref_ROI.TotalOrgY) > 0))
                {
                    fLineLength = (float)Math.Sqrt(Math.Pow(Math.Abs(arrGaugeMeasurePoints[1].X - arrGaugeMeasurePoints[0].X), 2) + Math.Pow(Math.Abs(arrGaugeMeasurePoints[1].Y - arrGaugeMeasurePoints[0].Y), 2));

                    fNewCenterY = ((arrGaugeMeasurePoints[1].Y + arrGaugeMeasurePoints[0].Y) / 2) - objROI.ref_ROI.TotalOrgY;

                    fNewCenterX = ((arrGaugeMeasurePoints[1].X + arrGaugeMeasurePoints[0].X) / 2) - objROI.ref_ROI.TotalOrgX;
                    fpStart[line] = new PointF(arrGaugeMeasurePoints[0].X - objROI.ref_ROI.TotalOrgX, arrGaugeMeasurePoints[0].Y - objROI.ref_ROI.TotalOrgY);
                    fpEnd[line] = new PointF(arrGaugeMeasurePoints[1].X - objROI.ref_ROI.TotalOrgX, arrGaugeMeasurePoints[1].Y - objROI.ref_ROI.TotalOrgY);
                }
                else
                {
                    fLineLength = -1;
                }
                //if (line == 0 && lenghtMode == 1)
                //{
                //    fNewCenterY = ((arrGaugeMeasurePoints[1].Y + arrGaugeMeasurePoints[0].Y) / 2) - objROI.ref_ROI.TotalOrgY;

                //}
                //else if (line == 1 && lenghtMode == 1)
                //{
                //    fNewCenterX = ((arrGaugeMeasurePoints[1].X + arrGaugeMeasurePoints[0].X) / 2) - objROI.ref_ROI.TotalOrgX;
                //}

                //if (line == 0 && lenghtMode == 2)
                //{
                //    fNewCenterX = ((arrGaugeMeasurePoints[1].X + arrGaugeMeasurePoints[0].X) / 2) - objROI.ref_ROI.TotalOrgX;

                //}
                //else if (line == 1 && lenghtMode == 2)
                //{
                //    fNewCenterY = ((arrGaugeMeasurePoints[1].Y + arrGaugeMeasurePoints[0].Y) / 2) - objROI.ref_ROI.TotalOrgY;

                //}
            }
            else
            {
                fLineLength = -1;


            }

            //// check is 4 side measurement ok
            //for (int i = 0; i < arrGaugeMeasurePoints.Count; i++)
            //{
            //    if (arrGaugeMeasurePoints[i].X == 0 || arrGaugeMeasurePoints[i].Y == 0)
            //        return; // Return without update the fWidth and fHeight if get measurement point 0,0
            //}

            //fWidth = arrGaugeMeasurePoints[1].X - arrGaugeMeasurePoints[0].X;
            //fHeight = arrGaugeMeasurePoints[3].Y - arrGaugeMeasurePoints[2].Y;
            //fNewCenterX = ((arrGaugeMeasurePoints[1].X + arrGaugeMeasurePoints[0].X) / 2) - objROI.ref_ROI.TotalOrgX;
            //fNewCenterY = ((arrGaugeMeasurePoints[3].Y + arrGaugeMeasurePoints[2].Y) / 2) - objROI.ref_ROI.TotalOrgY;

        }
        private void GetFeretAngle(PointF pStart, PointF pEnd, ref float fAngleStart, ref float fAngleEnd)
        {
            Line objLine = new Line();
            objLine.CalculateStraightLine(pStart, pEnd);

            //fAngleStart = (float)objLine.ref_dAngle - 90;
            //fAngleEnd = 180 - fAngleStart;
            ////fAngleEnd = 90 + (float)objLine.ref_dAngle;
            float fAngle = (float)objLine.ref_dAngle - 90;
            if ((pStart.X - pEnd.X) < 0)
            {
                if (fAngle < -90 || fAngle > 90)
                {
                    fAngleStart = (float)objLine.ref_dAngle - 90;
                    fAngleEnd = 90 + (float)objLine.ref_dAngle;
                }
                else
                {
                    fAngleEnd = (float)objLine.ref_dAngle - 90;
                    fAngleStart = 90 + (float)objLine.ref_dAngle;
                }
            }
            else if ((pStart.X - pEnd.X) > 0)
            {
                if (fAngle < -90 || fAngle > 90)
                {
                    fAngleEnd = (float)objLine.ref_dAngle - 90;
                    fAngleStart = 90 + (float)objLine.ref_dAngle;
                }
                else
                {
                    fAngleStart = (float)objLine.ref_dAngle - 90;
                    fAngleEnd = 90 + (float)objLine.ref_dAngle;
                }
            }
            else
            {
                if ((pStart.Y - pEnd.Y) < 0)
                {
                    if (fAngle < 0)
                    {
                        fAngleStart = (float)objLine.ref_dAngle - 90;
                        fAngleEnd = 90 + (float)objLine.ref_dAngle;
                    }
                    else
                    {
                        fAngleEnd = (float)objLine.ref_dAngle - 90;
                        fAngleStart = 90 + (float)objLine.ref_dAngle;
                    }
                }
                else
                {
                    if (fAngle < 0)
                    {
                        fAngleEnd = (float)objLine.ref_dAngle - 90;
                        fAngleStart = 90 + (float)objLine.ref_dAngle;
                    }
                    else
                    {
                        fAngleStart = (float)objLine.ref_dAngle - 90;
                        fAngleEnd = 90 + (float)objLine.ref_dAngle;
                    }
                }
            }
        }

        // ---------------------- Use gauge to measure pad dimension ---------------------------------------------------

        private void UpdateBlobSizeAndCenterPointWithGauge(ROI objROI,
                                                                 float fOriCenterX, float fOriCenterY,
                                                                 ref float fWidth, ref float fHeight,
                                                                 ref float fNewCenterX, ref float fNewCenterY,
                                                                 int intThresholdValue)
        {
            List<PointF> arrGaugeMeasurePoints = new List<PointF>();

            // 2019-09-26 ZJYEOH : User now can select which TransChoice to use
            //m_objPointGauge.ref_GaugeThreshold = m_objPointGauge.AutoTuneThreshold(objROI);
            //if (m_objPointGauge.ref_GaugeTransChoice != 0)
            //    m_objPointGauge.ref_GaugeTransChoice = 0;   // Use Largest Amplitude

            //if (m_objPointGauge.ref_GaugeTransType != 1)
            //    m_objPointGauge.ref_GaugeTransType = 1;   // Use Largest Amplitude

            // Get Pad left edge point // Gauge Tolerance is 10 pix or lesser.
            m_objPointGauge.SetGaugePlacement(objROI.ref_ROI.TotalOrgX + fOriCenterX - fWidth / 2, objROI.ref_ROI.TotalOrgY + fOriCenterY, Math.Min(fWidth / 4, 10), 180);
            m_objPointGauge.Measure(objROI);
            arrGaugeMeasurePoints.Add(m_objPointGauge.GetMeasurePoint());

            if (m_objPointGauge.ref_intMeasuredPointCount == 0) // 27-06-2019 ZJYEOH: Measure again with longer length if cannot found any point
            {
                m_objPointGauge.SetGaugePlacement(objROI.ref_ROI.TotalOrgX + fOriCenterX - fWidth / 2, objROI.ref_ROI.TotalOrgY + fOriCenterY, Math.Max(fWidth / 4, 10), 180);
                m_objPointGauge.Measure(objROI);
                arrGaugeMeasurePoints[arrGaugeMeasurePoints.Count - 1] = m_objPointGauge.GetMeasurePoint();

                if (m_objPointGauge.ref_intMeasuredPointCount == 0) // 27-06-2019 ZJYEOH: Measure again with longer length if cannot found any point
                {
                    m_objPointGauge.SetGaugePlacement(objROI.ref_ROI.TotalOrgX + fOriCenterX - fWidth / 2, objROI.ref_ROI.TotalOrgY + fOriCenterY, fWidth / 2, 180);
                    m_objPointGauge.Measure(objROI);
                    arrGaugeMeasurePoints[arrGaugeMeasurePoints.Count - 1] = m_objPointGauge.GetMeasurePoint();
                }
            }

            // Get Pad right edge point
            m_objPointGauge.SetGaugePlacement(objROI.ref_ROI.TotalOrgX + fOriCenterX + fWidth / 2, objROI.ref_ROI.TotalOrgY + fOriCenterY, Math.Min(fWidth / 4, 10), 0);
            m_objPointGauge.Measure(objROI);
            arrGaugeMeasurePoints.Add(m_objPointGauge.GetMeasurePoint());

            if (m_objPointGauge.ref_intMeasuredPointCount == 0)  // 27-06-2019 ZJYEOH: Measure again with longer length if cannot found any point
            {
                m_objPointGauge.SetGaugePlacement(objROI.ref_ROI.TotalOrgX + fOriCenterX + fWidth / 2, objROI.ref_ROI.TotalOrgY + fOriCenterY, Math.Max(fWidth / 4, 10), 0);
                m_objPointGauge.Measure(objROI);
                arrGaugeMeasurePoints[arrGaugeMeasurePoints.Count - 1] = m_objPointGauge.GetMeasurePoint();

                if (m_objPointGauge.ref_intMeasuredPointCount == 0)  // 27-06-2019 ZJYEOH: Measure again with longer length if cannot found any point
                {
                    m_objPointGauge.SetGaugePlacement(objROI.ref_ROI.TotalOrgX + fOriCenterX + fWidth / 2, objROI.ref_ROI.TotalOrgY + fOriCenterY, fWidth / 2, 0);
                    m_objPointGauge.Measure(objROI);
                    arrGaugeMeasurePoints[arrGaugeMeasurePoints.Count - 1] = m_objPointGauge.GetMeasurePoint();
                }
            }

            // Get Pad top edge point
            m_objPointGauge.SetGaugePlacement(objROI.ref_ROI.TotalOrgX + fOriCenterX, objROI.ref_ROI.TotalOrgY + fOriCenterY - fHeight / 2, Math.Min(fHeight / 4, 10), -90);
            m_objPointGauge.Measure(objROI);
            arrGaugeMeasurePoints.Add(m_objPointGauge.GetMeasurePoint());

            if (m_objPointGauge.ref_intMeasuredPointCount == 0) // 27-06-2019 ZJYEOH: Measure again with longer length if cannot found any point
            {
                m_objPointGauge.SetGaugePlacement(objROI.ref_ROI.TotalOrgX + fOriCenterX, objROI.ref_ROI.TotalOrgY + fOriCenterY - fHeight / 2, Math.Max(fHeight / 4, 10), -90);
                m_objPointGauge.Measure(objROI);
                arrGaugeMeasurePoints[arrGaugeMeasurePoints.Count - 1] = m_objPointGauge.GetMeasurePoint();

                if (m_objPointGauge.ref_intMeasuredPointCount == 0) // 27-06-2019 ZJYEOH: Measure again with longer length if cannot found any point
                {
                    m_objPointGauge.SetGaugePlacement(objROI.ref_ROI.TotalOrgX + fOriCenterX, objROI.ref_ROI.TotalOrgY + fOriCenterY - fHeight / 2, fWidth / 2, -90);
                    m_objPointGauge.Measure(objROI);
                    arrGaugeMeasurePoints[arrGaugeMeasurePoints.Count - 1] = m_objPointGauge.GetMeasurePoint();
                }
            }

            // Get Pad right edge point
            m_objPointGauge.SetGaugePlacement(objROI.ref_ROI.TotalOrgX + fOriCenterX, objROI.ref_ROI.TotalOrgY + fOriCenterY + fHeight / 2, Math.Min(fHeight / 4, 10), 90);
            m_objPointGauge.Measure(objROI);
            arrGaugeMeasurePoints.Add(m_objPointGauge.GetMeasurePoint());

            if (m_objPointGauge.ref_intMeasuredPointCount == 0) // 27-06-2019 ZJYEOH: Measure again with longer length if cannot found any point
            {
                m_objPointGauge.SetGaugePlacement(objROI.ref_ROI.TotalOrgX + fOriCenterX, objROI.ref_ROI.TotalOrgY + fOriCenterY + fHeight / 2, Math.Max(fHeight / 4, 10), 90);
                m_objPointGauge.Measure(objROI);
                arrGaugeMeasurePoints[arrGaugeMeasurePoints.Count - 1] = m_objPointGauge.GetMeasurePoint();

                if (m_objPointGauge.ref_intMeasuredPointCount == 0) // 27-06-2019 ZJYEOH: Measure again with longer length if cannot found any point
                {
                    m_objPointGauge.SetGaugePlacement(objROI.ref_ROI.TotalOrgX + fOriCenterX, objROI.ref_ROI.TotalOrgY + fOriCenterY + fHeight / 2, fWidth / 2, 90);
                    m_objPointGauge.Measure(objROI);
                    arrGaugeMeasurePoints[arrGaugeMeasurePoints.Count - 1] = m_objPointGauge.GetMeasurePoint();
                }
            }

            // Check left right
            if (arrGaugeMeasurePoints.Count >= 2)
            {
                if (arrGaugeMeasurePoints[0].X > 0 && arrGaugeMeasurePoints[1].X > 0)
                {
                    fWidth = arrGaugeMeasurePoints[1].X - arrGaugeMeasurePoints[0].X;
                    fNewCenterX = ((arrGaugeMeasurePoints[1].X + arrGaugeMeasurePoints[0].X) / 2) - objROI.ref_ROI.TotalOrgX;
                }
            }

            if (arrGaugeMeasurePoints.Count >= 4)
            {
                if (arrGaugeMeasurePoints[2].Y > 0 && arrGaugeMeasurePoints[3].Y > 0)
                {
                    fHeight = arrGaugeMeasurePoints[3].Y - arrGaugeMeasurePoints[2].Y;
                    fNewCenterY = ((arrGaugeMeasurePoints[3].Y + arrGaugeMeasurePoints[2].Y) / 2) - objROI.ref_ROI.TotalOrgY;
                }
            }
            //// check is 4 side measurement ok
            //for (int i = 0; i < arrGaugeMeasurePoints.Count; i++)
            //{
            //    if (arrGaugeMeasurePoints[i].X == 0 || arrGaugeMeasurePoints[i].Y == 0)
            //        return; // Return without update the fWidth and fHeight if get measurement point 0,0
            //}

            //fWidth = arrGaugeMeasurePoints[1].X - arrGaugeMeasurePoints[0].X;
            //fHeight = arrGaugeMeasurePoints[3].Y - arrGaugeMeasurePoints[2].Y;
            //fNewCenterX = ((arrGaugeMeasurePoints[1].X + arrGaugeMeasurePoints[0].X) / 2) - objROI.ref_ROI.TotalOrgX;
            //fNewCenterY = ((arrGaugeMeasurePoints[3].Y + arrGaugeMeasurePoints[2].Y) / 2) - objROI.ref_ROI.TotalOrgY;

        }

        public void DrawPointGauge(Graphics g)
        {
            m_objPointGauge.DrawGauge(g);
        }

        public void DrawPointGauge_AllPadsPoint(Graphics g, float fScaleX, float fScaleY)
        {
            try
            {
                for (int i = 0; i < m_arrPadEdgeGaugePoints.Count; i++)
                {
                    if (m_arrPadEdgeGaugePoints[i].Count >= 4)
                    {
                        g.DrawString((i + 1).ToString(), m_Font, new SolidBrush(Color.Red),
                                    m_arrPadEdgeGaugePoints[i][0].X * fScaleX,
                                    m_arrPadEdgeGaugePoints[i][1].Y * fScaleY);
                    }

                    for (int j = 0; j < m_arrPadEdgeGaugePoints[i].Count; j++)
                    {
                        if (m_arrPadEdgeGaugePointsFound[i][j])
                        {
                            g.DrawLine(new Pen(Color.Lime, 2f), m_arrPadEdgeGaugePoints[i][j].X * fScaleX - 5,
                                                            m_arrPadEdgeGaugePoints[i][j].Y * fScaleY,
                                                            m_arrPadEdgeGaugePoints[i][j].X * fScaleX + 5,
                                                            m_arrPadEdgeGaugePoints[i][j].Y * fScaleY);

                            g.DrawLine(new Pen(Color.Lime, 2f), m_arrPadEdgeGaugePoints[i][j].X * fScaleX,
                                                            m_arrPadEdgeGaugePoints[i][j].Y * fScaleY - 5,
                                                            m_arrPadEdgeGaugePoints[i][j].X * fScaleX,
                                                            m_arrPadEdgeGaugePoints[i][j].Y * fScaleY + 5);
                        }
                        else
                        {
                            g.DrawLine(new Pen(Color.Red, 2f), m_arrPadEdgeGaugePoints[i][j].X * fScaleX - 5,
                                                              m_arrPadEdgeGaugePoints[i][j].Y * fScaleY,
                                                              m_arrPadEdgeGaugePoints[i][j].X * fScaleX + 5,
                                                              m_arrPadEdgeGaugePoints[i][j].Y * fScaleY);

                            g.DrawLine(new Pen(Color.Red, 2f), m_arrPadEdgeGaugePoints[i][j].X * fScaleX,
                                                            m_arrPadEdgeGaugePoints[i][j].Y * fScaleY - 5,
                                                            m_arrPadEdgeGaugePoints[i][j].X * fScaleX,
                                                            m_arrPadEdgeGaugePoints[i][j].Y * fScaleY + 5);
                        }
                    }

                    m_objSettingPointGauge.DrawGauge(g);
                }


             

            }
            catch
            {

            }
        }

        // ============ Group ID Feature  =================================================================================================
        public void AssignBlobsToGroupID()  // No working yet.
        {
            /*
              * Algorithm
              * loop learning pad with current template pads
              * Find the closest XY dimension between learning pad and template pad
              * if found, Assign the template pad group id to learn pad
              * if no found, assign to group id 1
              * 
              */
            float fWidth = 0, fHeight = 0;
            int intArea = 0;

            for (int i = 0; i < m_arrTemplateBlobPads.Count; i++)
            {
                // Loop Template BlobPads
                float fClosestDimension = float.MaxValue;
                int intClosestDimensionIndex = 0;
                int intLengthMode = 0;
                for (int t = 0; t < m_arrBackupTemplateBlobPads.Count; t++)
                {
                    // Get different dimension between sample and template
                    float fDiffDimension = Math.Abs(((BlobsFeatures)m_arrTemplateBlobPads[i]).fWidth - ((ToleranceBlobsFeatures)m_arrBackupTemplateBlobPads[t]).fLearnWidth) +
                                           Math.Abs(((BlobsFeatures)m_arrTemplateBlobPads[i]).fHeight - ((ToleranceBlobsFeatures)m_arrBackupTemplateBlobPads[t]).fLearnHeight);

                    // compare closest dimension
                    if (fDiffDimension < fClosestDimension)
                    {
                        fClosestDimension = fDiffDimension;
                        intClosestDimensionIndex = t;
                        intLengthMode = 0;
                    }

                    float fDiffDimension2 = Math.Abs(((BlobsFeatures)m_arrTemplateBlobPads[i]).fHeight - ((ToleranceBlobsFeatures)m_arrBackupTemplateBlobPads[t]).fLearnWidth) +
                                           Math.Abs(((BlobsFeatures)m_arrTemplateBlobPads[i]).fWidth - ((ToleranceBlobsFeatures)m_arrBackupTemplateBlobPads[t]).fLearnHeight);

                    // compare closest dimension
                    if (fDiffDimension2 < fClosestDimension)
                    {
                        fClosestDimension = fDiffDimension2;
                        intClosestDimensionIndex = t;
                        intLengthMode = 1;
                    }
                }

                if (intClosestDimensionIndex >= 0)
                {
                    BlobsFeatures m_stcBlobPad = (BlobsFeatures)m_arrTemplateBlobPads[i];
                    m_stcBackupTemplateBlobPad = (ToleranceBlobsFeatures)m_arrBackupTemplateBlobPads[intClosestDimensionIndex];

                    m_stcBlobPad.intGroupID = m_stcBackupTemplateBlobPad.intGroupID;
                    m_stcBlobPad.intLengthMode = intLengthMode;
                    m_arrTemplateBlobPads.RemoveAt(intClosestDimensionIndex);
                    m_arrTemplateBlobPads.Insert(intClosestDimensionIndex, m_stcBlobPad);
                }
            }
        }

        public void SetGroupPadToArrayForDrawing(int intGroupNo)
        {
            m_intSelectedGroupNoForGrouping = intGroupNo;

            m_arrSelectedPadForGrouping.Clear();
            for (int i = 0; i < m_arrTemplateBlobPads.Count; i++)
            {
                BlobsFeatures m_stcBlobPad = (BlobsFeatures)m_arrTemplateBlobPads[i];

                if (m_stcBlobPad.intGroupID == intGroupNo)
                {
                    m_arrSelectedPadForGrouping.Add(i);
                }
            }
        }

        public void UpdateNewGroupNoListToTemplate()
        {
            List<List<int>> arrPadGroupList = new List<List<int>>();

            bool blnBreak = false;
            int intAddCount = m_arrSelectedPadForGrouping.Count;
            for (int intGroupIndex = 0; intGroupIndex < m_arrTemplateBlobPads.Count; intGroupIndex++)
            {
                arrPadGroupList.Add(new List<int>());
                for (int i = 0; i < m_arrTemplateBlobPads.Count; i++)
                {
                    bool blnFound = false;
                    for (int j = 0; j < m_arrSelectedPadForGrouping.Count; j++)
                    {
                        if (i == m_arrSelectedPadForGrouping[j])
                        {
                            blnFound = true;
                            break;
                        }
                    }

                    if (!blnFound)
                    {
                        BlobsFeatures m_stcBlobPad = (BlobsFeatures)m_arrTemplateBlobPads[i];

                        if (m_stcBlobPad.intGroupID == intGroupIndex)
                        {
                            arrPadGroupList[intGroupIndex].Add(i);
                            intAddCount++;
                        }
                    }



                    if (intAddCount >= m_arrTemplateBlobPads.Count)
                    {
                        arrPadGroupList.Add(m_arrSelectedPadForGrouping);
                        blnBreak = true;
                        break;
                    }
                }

                if (blnBreak)
                    break;
            }

            // Sorting group list base on Pad No from small to big.
            List<List<int>> arrSortedPadGroupList = new List<List<int>>();
            for (int i = 0; i < arrPadGroupList.Count; i++)
            {
                if (arrPadGroupList[i].Count > 0)
                {
                    int intSelectedIndex = arrSortedPadGroupList.Count;
                    for (int j = 0; j < arrSortedPadGroupList.Count; j++)
                    {
                        if (arrPadGroupList[i][0] < arrSortedPadGroupList[j][0])
                        {
                            intSelectedIndex = j;
                            break;
                        }
                    }

                    arrSortedPadGroupList.Insert(intSelectedIndex, arrPadGroupList[i]);
                }
            }

            for (int i = 0; i < arrSortedPadGroupList.Count; i++)
            {
                for (int j = 0; j < arrSortedPadGroupList[i].Count; j++)
                {
                    BlobsFeatures m_stcBlobPad = (BlobsFeatures)m_arrTemplateBlobPads[arrSortedPadGroupList[i][j]];

                    m_stcBlobPad.intGroupID = i;

                    m_arrTemplateBlobPads.RemoveAt(arrSortedPadGroupList[i][j]);
                    m_arrTemplateBlobPads.Insert(arrSortedPadGroupList[i][j], m_stcBlobPad);

                }
            }
        }


        // =============================================================================================================
        private void WriteDebug(string strWrite)
        {
            if (m_blnWriteDebug)
            {
                if (m_objPosTL == null)
                {
                    string strFileName = "DebugPad_" + DateTime.Now.Year + "_" + DateTime.Now.Month + "_" + DateTime.Now.Day + "_" + DateTime.Now.Minute + "(" + m_intPadROIDirection.ToString() + ")";
                    m_objPosTL = new TrackLog("D:\\DebugFile\\", strFileName);
                    m_intDebugHour = DateTime.Now.Minute;
                }

                if (DateTime.Now.Minute != m_intDebugHour)
                {
                    string strFileName = "DebugPad_" + DateTime.Now.Year + "_" + DateTime.Now.Month + "_" + DateTime.Now.Day + "_" + DateTime.Now.Minute + "(" + m_intPadROIDirection.ToString() + ")";
                    m_objPosTL = new TrackLog("D:\\DebugFile\\", strFileName);
                    m_intDebugHour = DateTime.Now.Minute;
                }

                m_objPosTL.WriteLine(strWrite);
            }
        }

        public List<List<string>> GetDefectList()
        {
            List<List<string>> arrDefectList = new List<List<string>>();

            int intCount = 0;

            //Join, extra, contamination
            for (int i = 0; i < m_arrExtraBlobs.Count; i++)
            {
                arrDefectList.Add(new List<string>());
                arrDefectList[intCount].Add(m_arrExtraBlobs[i].intFailMask.ToString());
                arrDefectList[intCount].Add(m_arrExtraBlobs[i].strDefectName);
                arrDefectList[intCount].Add(m_arrExtraBlobs[i].fWidthInMM.ToString("F4"));
                arrDefectList[intCount].Add(m_arrExtraBlobs[i].fHeightInMM.ToString("F4"));
                arrDefectList[intCount].Add(m_arrExtraBlobs[i].fAreaInMM2.ToString("F6"));
                intCount++;
            }

            //2019-10-10 ZJYEOH : No need display this as Broken display at other place
            ////Broken, scratch
            //for (int i = 0; i < m_arrPadDefectList.Count; i++)
            //{
            //    arrDefectList.Add(new List<string>());
            //    arrDefectList[intCount].Add(m_arrPadDefectList[i].ref_intFailCriteria.ToString());
            //    arrDefectList[intCount].Add(m_arrPadDefectList[i].ref_strName);
            //    arrDefectList[intCount].Add(m_arrPadDefectList[i].ref_fWidthInMM.ToString("F4"));
            //    arrDefectList[intCount].Add(m_arrPadDefectList[i].ref_fHeightInMM.ToString("F4"));
            //    arrDefectList[intCount].Add(m_arrPadDefectList[i].ref_fAreaInMM2.ToString("F6"));
            //    intCount++;
            //}

            return arrDefectList;
        }
        public List<List<string>> GetColorDefectList()
        {
            List<List<string>> arrDefectList = new List<List<string>>();

            int intCount = 0;

            for (int i = 0; i < m_arrColorDefectList.Count; i++)
            {
                arrDefectList.Add(new List<string>());
                arrDefectList[intCount].Add(m_arrColorDefectList[i].ref_intFailCriteria.ToString());
                arrDefectList[intCount].Add(m_arrColorDefectList[i].ref_strName);
                arrDefectList[intCount].Add(m_arrColorDefectList[i].ref_fWidthInMM.ToString("F4"));
                arrDefectList[intCount].Add(m_arrColorDefectList[i].ref_fHeightInMM.ToString("F4"));
                arrDefectList[intCount].Add(m_arrColorDefectList[i].ref_fAreaInMM2.ToString("F6"));
                intCount++;
            }

            return arrDefectList;
        }
        public void SavePadToleranceToFile(string strPath, bool blnNewFile, string strSectionName, bool blnNewSection)
        {
            XmlParser objFile = new XmlParser(strPath, blnNewFile);

            objFile.WriteSectionElement(strSectionName, blnNewSection);

            objFile.WriteElement1Value("MinSpanX", m_fMinSpanX);
            objFile.WriteElement1Value("MaxSpanX", m_fMaxSpanX);
            objFile.WriteElement1Value("MinSpanY", m_fMinSpanY);
            objFile.WriteElement1Value("MaxSpanY", m_fMaxSpanY);
            objFile.WriteElement1Value("EdgeDistanceMin_Top", m_fEdgeDistanceMin_Top);
            objFile.WriteElement1Value("EdgeDistanceMax_Top", m_fEdgeDistanceMax_Top);
            objFile.WriteElement1Value("EdgeDistanceMin_Right", m_fEdgeDistanceMin_Right);
            objFile.WriteElement1Value("EdgeDistanceMax_Right", m_fEdgeDistanceMax_Right);
            objFile.WriteElement1Value("EdgeDistanceMin_Bottom", m_fEdgeDistanceMin_Bottom);
            objFile.WriteElement1Value("EdgeDistanceMax_Bottom", m_fEdgeDistanceMax_Bottom);
            objFile.WriteElement1Value("EdgeDistanceMin_Left", m_fEdgeDistanceMin_Left);
            objFile.WriteElement1Value("EdgeDistanceMax_Left", m_fEdgeDistanceMax_Left);

            objFile.WriteElement1Value("ForeignMaterialMaxTotalArea", m_fTotalExtraPadSetArea);
            objFile.WriteElement1Value("ForeignMaterialMaxArea", m_fExtraPadSetArea);
            objFile.WriteElement1Value("ForeignMaterialMaxLength", m_fExtraPadSetLength);
            objFile.WriteElement1Value("TotalPads", m_arrTemplateBlobPads.Count);
            objFile.WriteElement1Value("TotalGroupPads", m_arrGroupTemplateBlobPads.Count);

            for (int p = 0; p < m_arrTemplateBlobPads.Count; p++)
            {
                BlobsFeatures m_stcBlobPad = (BlobsFeatures)m_arrTemplateBlobPads[p];

                objFile.WriteElement1Value("Pad" + p.ToString(), "");
                objFile.WriteElement2Value("MaxOffset", m_stcBlobPad.fOffSet);
                objFile.WriteElement2Value("MinArea", m_stcBlobPad.fMinArea);
                objFile.WriteElement2Value("MaxArea", m_stcBlobPad.fMaxArea);
                objFile.WriteElement2Value("MinWidth", m_stcBlobPad.fMinWidth);
                objFile.WriteElement2Value("MaxWidth", m_stcBlobPad.fMaxWidth);
                objFile.WriteElement2Value("MinHeight", m_stcBlobPad.fMinLength);
                objFile.WriteElement2Value("MaxHeight", m_stcBlobPad.fMaxLength);
                objFile.WriteElement2Value("MinPitch", m_stcBlobPad.fMinPitch);
                objFile.WriteElement2Value("MaxPitch", m_stcBlobPad.fMaxPitch);
                objFile.WriteElement2Value("MinGap", m_stcBlobPad.fMinGap);
                objFile.WriteElement2Value("MaxGap", m_stcBlobPad.fMaxGap);
                objFile.WriteElement2Value("MaxBrokenArea", m_stcBlobPad.fMaxBroken);
                objFile.WriteElement2Value("MaxBrokenLength", m_stcBlobPad.fMaxBrokenLength);
                objFile.WriteElement2Value("MaxExcessArea", m_stcBlobPad.fMaxExcess);
                objFile.WriteElement2Value("MaxSmearLength", m_stcBlobPad.fMaxSmearLength);

                objFile.WriteElement2Value("MaxEdgeLimitTop", m_stcBlobPad.fEdgeLimitTop);
                objFile.WriteElement2Value("MaxEdgeLimitRight", m_stcBlobPad.fEdgeLimitRight);
                objFile.WriteElement2Value("MaxEdgeLimitBottom", m_stcBlobPad.fEdgeLimitBottom);
                objFile.WriteElement2Value("MaxEdgeLimitLeft", m_stcBlobPad.fEdgeLimitLeft);

                objFile.WriteElement2Value("MaxStandOffTop", m_stcBlobPad.fMaxStandOffTop);
                objFile.WriteElement2Value("MaxStandOffBottom", m_stcBlobPad.fMaxStandOffBottom);
                objFile.WriteElement2Value("MaxStandOffLeft", m_stcBlobPad.fMaxStandOffLeft);
                objFile.WriteElement2Value("MaxStandOffRight", m_stcBlobPad.fMaxStandOffRight);
                
                objFile.WriteElement2Value("OffsetOffSet", m_stcBlobPad.fOffsetOffSet);
                objFile.WriteElement2Value("WidthOffet", m_stcBlobPad.fWidthOffset);
                objFile.WriteElement2Value("HeightOffet", m_stcBlobPad.fHeightOffset);
                objFile.WriteElement2Value("PitchOffet", m_stcBlobPad.fPitchOffset);
                objFile.WriteElement2Value("GapOffet", m_stcBlobPad.fGapOffset);

                objFile.WriteElement2Value("EdgeDistanceTopOffset", m_stcBlobPad.fEdgeDistanceTopOffset);
                objFile.WriteElement2Value("EdgeDistanceRightOffset", m_stcBlobPad.fEdgeDistanceRightOffset);
                objFile.WriteElement2Value("EdgeDistanceBottomOffset", m_stcBlobPad.fEdgeDistanceBottomOffset);
                objFile.WriteElement2Value("EdgeDistanceLeftOffset", m_stcBlobPad.fEdgeDistanceLeftOffset);

                objFile.WriteElement2Value("EdgeLimitTopOffset", m_stcBlobPad.fEdgeLimitTopOffset);
                objFile.WriteElement2Value("EdgeLimitRightOffset", m_stcBlobPad.fEdgeLimitRightOffset);
                objFile.WriteElement2Value("EdgeLimitBottomOffset", m_stcBlobPad.fEdgeLimitBottomOffset);
                objFile.WriteElement2Value("EdgeLimitLeftOffset", m_stcBlobPad.fEdgeLimitLeftOffset);

                objFile.WriteElement2Value("StandOffTopOffset", m_stcBlobPad.fStandOffTopOffset);
                objFile.WriteElement2Value("StandOffBottomOffset", m_stcBlobPad.fStandOffBottomOffset);
                objFile.WriteElement2Value("StandOffLeftOffset", m_stcBlobPad.fStandOffLeftOffset);
                objFile.WriteElement2Value("StandOffRightOffset", m_stcBlobPad.fStandOffRightOffset);

                objFile.WriteElement2Value("MinLine3", m_stcBlobPad.fMinLine3);
                objFile.WriteElement2Value("MaxLine3", m_stcBlobPad.fMaxLine3);
                objFile.WriteElement2Value("MinLine4", m_stcBlobPad.fMinLine4);
                objFile.WriteElement2Value("MaxLine4", m_stcBlobPad.fMaxLine4);
                objFile.WriteElement2Value("MinLine5", m_stcBlobPad.fMinLine5);
                objFile.WriteElement2Value("MaxLine5", m_stcBlobPad.fMaxLine5);
                objFile.WriteElement2Value("MinLine6", m_stcBlobPad.fMinLine6);
                objFile.WriteElement2Value("MaxLine6", m_stcBlobPad.fMaxLine6);
                objFile.WriteElement2Value("MinLine7", m_stcBlobPad.fMinLine7);
                objFile.WriteElement2Value("MaxLine7", m_stcBlobPad.fMaxLine7);
                objFile.WriteElement2Value("MinLine8", m_stcBlobPad.fMinLine8);
                objFile.WriteElement2Value("MaxLine8", m_stcBlobPad.fMaxLine8);
                objFile.WriteElement2Value("MinLine9", m_stcBlobPad.fMinLine9);
                objFile.WriteElement2Value("MaxLine9", m_stcBlobPad.fMaxLine9);
                objFile.WriteElement2Value("MinLine10", m_stcBlobPad.fMinLine10);
                objFile.WriteElement2Value("MaxLine10", m_stcBlobPad.fMaxLine10);
                objFile.WriteElement2Value("MinLine11", m_stcBlobPad.fMinLine11);
                objFile.WriteElement2Value("MaxLine11", m_stcBlobPad.fMaxLine11);
                objFile.WriteElement2Value("MinLine12", m_stcBlobPad.fMinLine12);
                objFile.WriteElement2Value("MaxLine12", m_stcBlobPad.fMaxLine12);

                objFile.WriteElement2Value("LengthMode", m_stcBlobPad.intLengthMode);
            }

            for (int p = 0; p < m_arrGroupTemplateBlobPads.Count; p++)
            {
                BlobsFeatures m_stcBlobPad = (BlobsFeatures)m_arrGroupTemplateBlobPads[p];

                objFile.WriteElement1Value("GroupPad" + p.ToString(), "");
                objFile.WriteElement2Value("MaxOffset", m_stcBlobPad.fOffSet);
                objFile.WriteElement2Value("MinArea", m_stcBlobPad.fMinArea);
                objFile.WriteElement2Value("MaxArea", m_stcBlobPad.fMaxArea);
                objFile.WriteElement2Value("MinWidth", m_stcBlobPad.fMinWidth);
                objFile.WriteElement2Value("MaxWidth", m_stcBlobPad.fMaxWidth);
                objFile.WriteElement2Value("MinHeight", m_stcBlobPad.fMinLength);
                objFile.WriteElement2Value("MaxHeight", m_stcBlobPad.fMaxLength);
                objFile.WriteElement2Value("MinPitch", m_stcBlobPad.fMinPitch);
                objFile.WriteElement2Value("MaxPitch", m_stcBlobPad.fMaxPitch);
                objFile.WriteElement2Value("MinGap", m_stcBlobPad.fMinGap);
                objFile.WriteElement2Value("MaxGap", m_stcBlobPad.fMaxGap);
                objFile.WriteElement2Value("MaxBrokenArea", m_stcBlobPad.fMaxBroken);
                objFile.WriteElement2Value("MaxBrokenLength", m_stcBlobPad.fMaxBrokenLength);
                objFile.WriteElement2Value("MaxExcessArea", m_stcBlobPad.fMaxExcess);
                objFile.WriteElement2Value("MaxSmearLength", m_stcBlobPad.fMaxSmearLength);

                objFile.WriteElement2Value("MaxEdgeLimitTop", m_stcBlobPad.fEdgeLimitTop);
                objFile.WriteElement2Value("MaxEdgeLimitRight", m_stcBlobPad.fEdgeLimitRight);
                objFile.WriteElement2Value("MaxEdgeLimitBottom", m_stcBlobPad.fEdgeLimitBottom);
                objFile.WriteElement2Value("MaxEdgeLimitLeft", m_stcBlobPad.fEdgeLimitLeft);

                objFile.WriteElement2Value("MaxStandOffTop", m_stcBlobPad.fMaxStandOffTop);
                objFile.WriteElement2Value("MaxStandOffBottom", m_stcBlobPad.fMaxStandOffBottom);
                objFile.WriteElement2Value("MaxStandOffLeft", m_stcBlobPad.fMaxStandOffLeft);
                objFile.WriteElement2Value("MaxStandOffRight", m_stcBlobPad.fMaxStandOffRight);
                
                objFile.WriteElement2Value("OffsetOffSet", m_stcBlobPad.fOffsetOffSet);
                objFile.WriteElement2Value("WidthOffet", m_stcBlobPad.fWidthOffset);
                objFile.WriteElement2Value("HeightOffet", m_stcBlobPad.fHeightOffset);
                objFile.WriteElement2Value("PitchOffet", m_stcBlobPad.fPitchOffset);
                objFile.WriteElement2Value("GapOffet", m_stcBlobPad.fGapOffset);

                objFile.WriteElement2Value("EdgeDistanceTopOffset", m_stcBlobPad.fEdgeDistanceTopOffset);
                objFile.WriteElement2Value("EdgeDistanceRightOffset", m_stcBlobPad.fEdgeDistanceRightOffset);
                objFile.WriteElement2Value("EdgeDistanceBottomOffset", m_stcBlobPad.fEdgeDistanceBottomOffset);
                objFile.WriteElement2Value("EdgeDistanceLeftOffset", m_stcBlobPad.fEdgeDistanceLeftOffset);

                objFile.WriteElement2Value("EdgeLimitTopOffset", m_stcBlobPad.fEdgeLimitTopOffset);
                objFile.WriteElement2Value("EdgeLimitRightOffset", m_stcBlobPad.fEdgeLimitRightOffset);
                objFile.WriteElement2Value("EdgeLimitBottomOffset", m_stcBlobPad.fEdgeLimitBottomOffset);
                objFile.WriteElement2Value("EdgeLimitLeftOffset", m_stcBlobPad.fEdgeLimitLeftOffset);

                objFile.WriteElement2Value("StandOffTopOffset", m_stcBlobPad.fStandOffTopOffset);
                objFile.WriteElement2Value("StandOffBottomOffset", m_stcBlobPad.fStandOffBottomOffset);
                objFile.WriteElement2Value("StandOffLeftOffset", m_stcBlobPad.fStandOffLeftOffset);
                objFile.WriteElement2Value("StandOffRightOffset", m_stcBlobPad.fStandOffRightOffset);

                objFile.WriteElement2Value("MinLine3", m_stcBlobPad.fMinLine3);
                objFile.WriteElement2Value("MaxLine3", m_stcBlobPad.fMaxLine3);
                objFile.WriteElement2Value("MinLine4", m_stcBlobPad.fMinLine4);
                objFile.WriteElement2Value("MaxLine4", m_stcBlobPad.fMaxLine4);
                objFile.WriteElement2Value("MinLine5", m_stcBlobPad.fMinLine5);
                objFile.WriteElement2Value("MaxLine5", m_stcBlobPad.fMaxLine5);
                objFile.WriteElement2Value("MinLine6", m_stcBlobPad.fMinLine6);
                objFile.WriteElement2Value("MaxLine6", m_stcBlobPad.fMaxLine6);
                objFile.WriteElement2Value("MinLine7", m_stcBlobPad.fMinLine7);
                objFile.WriteElement2Value("MaxLine7", m_stcBlobPad.fMaxLine7);
                objFile.WriteElement2Value("MinLine8", m_stcBlobPad.fMinLine8);
                objFile.WriteElement2Value("MaxLine8", m_stcBlobPad.fMaxLine8);
                objFile.WriteElement2Value("MinLine9", m_stcBlobPad.fMinLine9);
                objFile.WriteElement2Value("MaxLine9", m_stcBlobPad.fMaxLine9);
                objFile.WriteElement2Value("MinLine10", m_stcBlobPad.fMinLine10);
                objFile.WriteElement2Value("MaxLine10", m_stcBlobPad.fMaxLine10);
                objFile.WriteElement2Value("MinLine11", m_stcBlobPad.fMinLine11);
                objFile.WriteElement2Value("MaxLine11", m_stcBlobPad.fMaxLine11);
                objFile.WriteElement2Value("MinLine12", m_stcBlobPad.fMinLine12);
                objFile.WriteElement2Value("MaxLine12", m_stcBlobPad.fMaxLine12);

                objFile.WriteElement2Value("LengthMode", m_stcBlobPad.intLengthMode);
            }

            objFile.WriteEndElement();
        }

        public void SavePackageToleranceToFile(string strPath, bool blnNewFile, string strSectionName, bool blnNewSection)
        {
            XmlParser objFile = new XmlParser(strPath, blnNewFile);

            objFile.WriteSectionElement(strSectionName + "Package", blnNewSection);

            objFile.WriteElement1Value("PackageSetting", "");

            objFile.WriteElement2Value("PackageWidthOffsetMM", m_fPackageWidthOffsetMM);
            objFile.WriteElement2Value("PackageHeightOffsetMM", m_fPackageHeightOffsetMM);
            objFile.WriteElement2Value("PackageThicknessOffsetMM", m_fPackageThicknessOffsetMM);

            objFile.WriteElement2Value("UnitWidth", m_fUnitWidth);
            objFile.WriteElement2Value("UnitHeight", m_fUnitHeight);
            objFile.WriteElement2Value("UnitThickness", m_fUnitThickness);
            objFile.WriteElement2Value("UnitWidthMin", m_fUnitWidthMin);
            objFile.WriteElement2Value("UnitWidthMax", m_fUnitWidthMax);
            objFile.WriteElement2Value("UnitHeightMin", m_fUnitHeightMin);
            objFile.WriteElement2Value("UnitHeightMax", m_fUnitHeightMax);
            objFile.WriteElement2Value("UnitThicknessMin", m_fUnitThicknessMin);
            objFile.WriteElement2Value("UnitThicknessMax", m_fUnitThicknessMax);

            objFile.WriteElement2Value("UnitSizeLength", m_fUnitSizeLength);
            objFile.WriteElement2Value("CrackLength", m_fCrackLength);
            objFile.WriteElement2Value("ScratchLength", m_fScratchLength);
            objFile.WriteElement2Value("ScratchArea", m_fScratchArea);
            objFile.WriteElement2Value("ChipArea", m_fChipArea);
            objFile.WriteElement2Value("ContaminationLength", m_fContaminationLength);
            objFile.WriteElement2Value("SolderMeltLength", m_fSolderMeltLength);
            objFile.WriteElement2Value("VoidLength", m_fVoidLength);
            objFile.WriteElement2Value("VoidArea", m_fVoidArea);
            objFile.WriteElement2Value("CrackLength", m_fCrackLength);
            objFile.WriteElement2Value("CrackArea", m_fCrackArea);
            objFile.WriteElement2Value("ForeignMaterialArea", m_fForeignMaterialArea);
            objFile.WriteElement2Value("MoldFlashLength_Real", m_fMoldFlashLength);
            objFile.WriteElement2Value("MoldFlashWidth", m_fMoldFlashWidth);
            objFile.WriteElement2Value("MoldFlashLength", m_fMoldFlashArea);
            objFile.WriteElement2Value("MoldFlashTotalArea", m_fMoldFlashTotalArea);
            objFile.WriteElement2Value("InCompletePlateLength", m_fInCompletePlateLength);
            objFile.WriteElement2Value("PadBrokenLength", m_fPadBrokenLength);

            objFile.WriteElement2Value("MoldFlashDefectDimensionFailCondition", m_intMoldFlashDefectDimensionFailCondition);
            objFile.WriteElement2Value("BrightDefectDimensionFailCondition", m_intBrightDefectDimensionFailCondition);
            objFile.WriteElement2Value("ForeignMaterialBrightDefectDimensionFailCondition", m_intForeignMaterialBrightDefectDimensionFailCondition);
            objFile.WriteElement2Value("DarkDefectDimensionFailCondition", m_intDarkDefectDimensionFailCondition);
            objFile.WriteElement2Value("CrackDarkDefectDimensionFailCondition", m_intCrackDarkDefectDimensionFailCondition);

            objFile.WriteElement2Value("BrightLength", m_fBrightLength);
            objFile.WriteElement2Value("BrightWidth", m_fBrightWidth);
            objFile.WriteElement2Value("BrightArea", m_fBrightArea);
            objFile.WriteElement2Value("BrightTotalArea", m_fBrightTotalArea);
            objFile.WriteElement2Value("DarkLength", m_fDarkLength);
            objFile.WriteElement2Value("DarkWidth", m_fDarkWidth);
            objFile.WriteElement2Value("DarkArea", m_fDarkArea);
            objFile.WriteElement2Value("DarkTotalArea", m_fDarkTotalArea);
            objFile.WriteElement2Value("BrightChippedOffArea", m_fBrightChippedOffArea);
            objFile.WriteElement2Value("DarkChippedOffArea", m_fDarkChippedOffArea);
            objFile.WriteElement2Value("DarkVerticalCrack", m_fDarkVerticalCrack);
            objFile.WriteElement2Value("DarkHorizontalCrack", m_fDarkHorizontalCrack);
            objFile.WriteElement2Value("BrightVerticalForeignMaterial", m_fBrightVerticalForeignMaterial);
            objFile.WriteElement2Value("BrightHorizontalForeignMaterial", m_fBrightHorizontalForeignMaterial);

            objFile.WriteEndElement();
        }

        public void SaveUnitPositionToleranceToFile(string strPath, bool blnNewFile, string strSectionName, bool blnNewSection)
        {
            XmlParser objFile = new XmlParser(strPath, blnNewFile);

            objFile.WriteSectionElement(strSectionName + "Position", blnNewSection);
            objFile.WriteElement1Value("AngleTolerance", m_fAngleTolerance);
            objFile.WriteElement1Value("XTolerance", m_fXTolerance);
            objFile.WriteElement1Value("YTolerance", m_fYTolerance);

            objFile.WriteEndElement();
        }

        public void LoadPadToleranceFromFile(string strFilePath, string strSectionName)
        {
            XmlParser objFile = new XmlParser(strFilePath);

            objFile.GetFirstSection(strSectionName);
            m_fMinSpanX = objFile.GetValueAsFloat("MinSpanX", 0, 1);
            m_fMaxSpanX = objFile.GetValueAsFloat("MaxSpanX", 0, 1);
            m_fMinSpanY = objFile.GetValueAsFloat("MinSpanY", 0, 1);
            m_fMaxSpanY = objFile.GetValueAsFloat("MaxSpanY", 0, 1);
            m_fEdgeDistanceMin_Top = objFile.GetValueAsFloat("EdgeDistanceMin_Top", 0, 1);
            m_fEdgeDistanceMax_Top = objFile.GetValueAsFloat("EdgeDistanceMax_Top", 0, 1);
            m_fEdgeDistanceMin_Right = objFile.GetValueAsFloat("EdgeDistanceMin_Right", 0, 1);
            m_fEdgeDistanceMax_Right = objFile.GetValueAsFloat("EdgeDistanceMax_Right", 0, 1);
            m_fEdgeDistanceMin_Bottom = objFile.GetValueAsFloat("EdgeDistanceMin_Bottom", 0, 1);
            m_fEdgeDistanceMax_Bottom = objFile.GetValueAsFloat("EdgeDistanceMax_Bottom", 0, 1);
            m_fEdgeDistanceMin_Left = objFile.GetValueAsFloat("EdgeDistanceMin_Left", 0, 1);
            m_fEdgeDistanceMax_Left = objFile.GetValueAsFloat("EdgeDistanceMax_Left", 0, 1);
            m_fTotalExtraPadSetArea = objFile.GetValueAsFloat("ForeignMaterialMaxTotalArea", 0.004f, 1);
            m_fExtraPadSetArea = objFile.GetValueAsFloat("ForeignMaterialMaxArea", 0.004f, 1);
            m_fExtraPadSetLength = objFile.GetValueAsFloat("ForeignMaterialMaxLength", 0.004f, 1);

            int intTotalPads = objFile.GetValueAsInt("TotalPads", 0, 1);

            STTrackLog.WriteLine("m_arrTemplateBlobPads.Count = " + m_arrTemplateBlobPads.Count.ToString());
            STTrackLog.WriteLine("intTotalPads = " + intTotalPads.ToString());
            //if (m_arrTemplateBlobPads.Count == intTotalPads)
            {
                for (int p = 0; p < intTotalPads; p++)
                {
                    if (p >= m_arrTemplateBlobPads.Count)//2021-12-07 ZJYEOH: break if pad in file more than template pad
                        break;

                    BlobsFeatures m_stcBlobPad = (BlobsFeatures)m_arrTemplateBlobPads[p];

                    objFile.GetSecondSection("Pad" + p.ToString());
                    m_stcBlobPad.fOffSet = objFile.GetValueAsFloat("MaxOffset", 0, 2);
                    m_stcBlobPad.fMinArea = objFile.GetValueAsFloat("MinArea", 0, 2);
                    m_stcBlobPad.fMaxArea = objFile.GetValueAsFloat("MaxArea", 0, 2);
                    m_stcBlobPad.fMinWidth = objFile.GetValueAsFloat("MinWidth", 0, 2);
                    m_stcBlobPad.fMaxWidth = objFile.GetValueAsFloat("MaxWidth", 0, 2);
                    m_stcBlobPad.fMinLength = objFile.GetValueAsFloat("MinHeight", 0, 2);
                    m_stcBlobPad.fMaxLength = objFile.GetValueAsFloat("MaxHeight", 0, 2);
                    m_stcBlobPad.fMinPitch = objFile.GetValueAsFloat("MinPitch", 0, 2);
                    m_stcBlobPad.fMaxPitch = objFile.GetValueAsFloat("MaxPitch", 0, 2);
                    m_stcBlobPad.fMinGap = objFile.GetValueAsFloat("MinGap", 0, 2);
                    m_stcBlobPad.fMaxGap = objFile.GetValueAsFloat("MaxGap", 0, 2);
                    m_stcBlobPad.fMaxBroken = objFile.GetValueAsFloat("MaxBrokenArea", 0, 2);
                    m_stcBlobPad.fMaxBrokenLength = objFile.GetValueAsFloat("MaxBrokenLength", 0, 2);
                    m_stcBlobPad.fMaxExcess = objFile.GetValueAsFloat("MaxExcessArea", 0, 2);
                    m_stcBlobPad.fMaxSmearLength = objFile.GetValueAsFloat("MaxSmearLength", 0, 2);

                    m_stcBlobPad.fEdgeLimitTop = objFile.GetValueAsFloat("MaxEdgeLimitTop", 0, 2);
                    m_stcBlobPad.fEdgeLimitRight = objFile.GetValueAsFloat("MaxEdgeLimitRight", 0, 2);
                    m_stcBlobPad.fEdgeLimitBottom = objFile.GetValueAsFloat("MaxEdgeLimitBottom", 0, 2);
                    m_stcBlobPad.fEdgeLimitLeft = objFile.GetValueAsFloat("MaxEdgeLimitLeft", 0, 2);

                    m_stcBlobPad.fMaxStandOffTop = objFile.GetValueAsFloat("MaxStandOffTop", 0, 2);
                    m_stcBlobPad.fMaxStandOffBottom = objFile.GetValueAsFloat("MaxStandOffBottom", 0, 2);
                    m_stcBlobPad.fMaxStandOffLeft = objFile.GetValueAsFloat("MaxStandOffLeft", 0, 2);
                    m_stcBlobPad.fMaxStandOffRight = objFile.GetValueAsFloat("MaxStandOffRight", 0, 2);
                    
                    m_stcBlobPad.fOffsetOffSet = objFile.GetValueAsFloat("OffsetOffSet", 0, 2);
                    m_stcBlobPad.fWidthOffset = objFile.GetValueAsFloat("WidthOffset", 0, 2);
                    m_stcBlobPad.fHeightOffset = objFile.GetValueAsFloat("HeightOffset", 0, 2);
                    m_stcBlobPad.fPitchOffset = objFile.GetValueAsFloat("PitchOffset", 0, 2);
                    m_stcBlobPad.fGapOffset = objFile.GetValueAsFloat("GapOffset", 0, 2);
                    
                    m_stcBlobPad.fEdgeDistanceTopOffset = objFile.GetValueAsFloat("EdgeDistanceTopOffset", 0, 2);
                    m_stcBlobPad.fEdgeDistanceRightOffset = objFile.GetValueAsFloat("EdgeDistanceRightOffset", 0, 2);
                    m_stcBlobPad.fEdgeDistanceBottomOffset = objFile.GetValueAsFloat("EdgeDistanceBottomOffset", 0, 2);
                    m_stcBlobPad.fEdgeDistanceLeftOffset = objFile.GetValueAsFloat("EdgeDistanceLeftOffset", 0, 2);

                    m_stcBlobPad.fEdgeLimitTopOffset = objFile.GetValueAsFloat("EdgeLimitTopOffset", 0, 2);
                    m_stcBlobPad.fEdgeLimitRightOffset = objFile.GetValueAsFloat("EdgeLimitRightOffset", 0, 2);
                    m_stcBlobPad.fEdgeLimitBottomOffset = objFile.GetValueAsFloat("EdgeLimitBottomOffset", 0, 2);
                    m_stcBlobPad.fEdgeLimitLeftOffset = objFile.GetValueAsFloat("EdgeLimitLeftOffset", 0, 2);

                    m_stcBlobPad.fStandOffTopOffset = objFile.GetValueAsFloat("StandOffTopOffset", 0, 2);
                    m_stcBlobPad.fStandOffBottomOffset = objFile.GetValueAsFloat("StandOffBottomOffset", 0, 2);
                    m_stcBlobPad.fStandOffLeftOffset = objFile.GetValueAsFloat("StandOffLeftOffset", 0, 2);
                    m_stcBlobPad.fStandOffRightOffset = objFile.GetValueAsFloat("StandOffRightOffset", 0, 2);

                    m_stcBlobPad.fMinLine3 = objFile.GetValueAsFloat("MinLine3", 0, 2);
                    m_stcBlobPad.fMaxLine3 = objFile.GetValueAsFloat("MaxLine3", 0, 2);
                    m_stcBlobPad.fMinLine4 = objFile.GetValueAsFloat("MinLine4", 0, 2);
                    m_stcBlobPad.fMaxLine4 = objFile.GetValueAsFloat("MaxLine4", 0, 2);
                    m_stcBlobPad.fMinLine5 = objFile.GetValueAsFloat("MinLine5", 0, 2);
                    m_stcBlobPad.fMaxLine5 = objFile.GetValueAsFloat("MaxLine5", 0, 2);
                    m_stcBlobPad.fMinLine6 = objFile.GetValueAsFloat("MinLine6", 0, 2);
                    m_stcBlobPad.fMaxLine6 = objFile.GetValueAsFloat("MaxLine6", 0, 2);
                    m_stcBlobPad.fMinLine7 = objFile.GetValueAsFloat("MinLine7", 0, 2);
                    m_stcBlobPad.fMaxLine7 = objFile.GetValueAsFloat("MaxLine7", 0, 2);
                    m_stcBlobPad.fMinLine8 = objFile.GetValueAsFloat("MinLine8", 0, 2);
                    m_stcBlobPad.fMaxLine8 = objFile.GetValueAsFloat("MaxLine8", 0, 2);
                    m_stcBlobPad.fMinLine9 = objFile.GetValueAsFloat("MinLine9", 0, 2);
                    m_stcBlobPad.fMaxLine9 = objFile.GetValueAsFloat("MaxLine9", 0, 2);
                    m_stcBlobPad.fMinLine10 = objFile.GetValueAsFloat("MinLine10", 0, 2);
                    m_stcBlobPad.fMaxLine10 = objFile.GetValueAsFloat("MaxLine10", 0, 2);
                    m_stcBlobPad.fMinLine11 = objFile.GetValueAsFloat("MinLine11", 0, 2);
                    m_stcBlobPad.fMaxLine11 = objFile.GetValueAsFloat("MaxLine11", 0, 2);
                    m_stcBlobPad.fMinLine12 = objFile.GetValueAsFloat("MinLine12", 0, 2);
                    m_stcBlobPad.fMaxLine12 = objFile.GetValueAsFloat("MaxLine12", 0, 2);

                    m_stcBlobPad.intLengthMode = objFile.GetValueAsInt("LengthMode", 0, 2);

                    m_arrTemplateBlobPads[p] = m_stcBlobPad;

                }
            }

            int intTotalGroupPads = objFile.GetValueAsInt("TotalGroupPads", 0, 1);

            //if (m_arrGroupTemplateBlobPads.Count == intTotalGroupPads)
            {
                for (int p = 0; p < intTotalGroupPads; p++)
                {
                    if (p > m_arrGroupTemplateBlobPads.Count)
                        break;

                    BlobsFeatures m_stcBlobPad = (BlobsFeatures)m_arrGroupTemplateBlobPads[p];

                    objFile.GetSecondSection("GroupPad" + p.ToString());
                    m_stcBlobPad.fOffSet = objFile.GetValueAsFloat("MaxOffset", 0, 2);
                    m_stcBlobPad.fMinArea = objFile.GetValueAsFloat("MinArea", 0, 2);
                    m_stcBlobPad.fMaxArea = objFile.GetValueAsFloat("MaxArea", 0, 2);
                    m_stcBlobPad.fMinWidth = objFile.GetValueAsFloat("MinWidth", 0, 2);
                    m_stcBlobPad.fMaxWidth = objFile.GetValueAsFloat("MaxWidth", 0, 2);
                    m_stcBlobPad.fMinLength = objFile.GetValueAsFloat("MinHeight", 0, 2);
                    m_stcBlobPad.fMaxLength = objFile.GetValueAsFloat("MaxHeight", 0, 2);
                    m_stcBlobPad.fMinPitch = objFile.GetValueAsFloat("MinPitch", 0, 2);
                    m_stcBlobPad.fMaxPitch = objFile.GetValueAsFloat("MaxPitch", 0, 2);
                    m_stcBlobPad.fMinGap = objFile.GetValueAsFloat("MinGap", 0, 2);
                    m_stcBlobPad.fMaxGap = objFile.GetValueAsFloat("MaxGap", 0, 2);
                    m_stcBlobPad.fMaxBroken = objFile.GetValueAsFloat("MaxBrokenArea", 0, 2);
                    m_stcBlobPad.fMaxBrokenLength = objFile.GetValueAsFloat("MaxBrokenLength", 0, 2);

                    m_stcBlobPad.fEdgeLimitTop = objFile.GetValueAsFloat("MaxEdgeLimitTop", 0, 2);
                    m_stcBlobPad.fEdgeLimitRight = objFile.GetValueAsFloat("MaxEdgeLimitRight", 0, 2);
                    m_stcBlobPad.fEdgeLimitBottom = objFile.GetValueAsFloat("MaxEdgeLimitBottom", 0, 2);
                    m_stcBlobPad.fEdgeLimitLeft = objFile.GetValueAsFloat("MaxEdgeLimitLeft", 0, 2);

                    m_stcBlobPad.fMaxStandOffTop = objFile.GetValueAsFloat("MaxStandOffTop", 0, 2);
                    m_stcBlobPad.fMaxStandOffBottom = objFile.GetValueAsFloat("MaxStandOffBottom", 0, 2);
                    m_stcBlobPad.fMaxStandOffLeft = objFile.GetValueAsFloat("MaxStandOffLeft", 0, 2);
                    m_stcBlobPad.fMaxStandOffRight = objFile.GetValueAsFloat("MaxStandOffRight", 0, 2);

                    m_stcBlobPad.fMaxExcess = objFile.GetValueAsFloat("MaxExcessArea", 0, 2);
                    m_stcBlobPad.fMaxSmearLength = objFile.GetValueAsFloat("MaxSmearLength", 0, 2);
                    m_stcBlobPad.fOffsetOffSet = objFile.GetValueAsFloat("OffsetOffSet", 0, 2);
                    m_stcBlobPad.fWidthOffset = objFile.GetValueAsFloat("WidthOffset", 0, 2);
                    m_stcBlobPad.fHeightOffset = objFile.GetValueAsFloat("HeightOffset", 0, 2);
                    m_stcBlobPad.fPitchOffset = objFile.GetValueAsFloat("PitchOffset", 0, 2);
                    m_stcBlobPad.fGapOffset = objFile.GetValueAsFloat("GapOffset", 0, 2);

                    m_stcBlobPad.fEdgeDistanceTopOffset = objFile.GetValueAsFloat("EdgeDistanceTopOffset", 0, 2);
                    m_stcBlobPad.fEdgeDistanceRightOffset = objFile.GetValueAsFloat("EdgeDistanceRightOffset", 0, 2);
                    m_stcBlobPad.fEdgeDistanceBottomOffset = objFile.GetValueAsFloat("EdgeDistanceBottomOffset", 0, 2);
                    m_stcBlobPad.fEdgeDistanceLeftOffset = objFile.GetValueAsFloat("EdgeDistanceLeftOffset", 0, 2);

                    m_stcBlobPad.fEdgeLimitTopOffset = objFile.GetValueAsFloat("EdgeLimitTopOffset", 0, 2);
                    m_stcBlobPad.fEdgeLimitRightOffset = objFile.GetValueAsFloat("EdgeLimitRightOffset", 0, 2);
                    m_stcBlobPad.fEdgeLimitBottomOffset = objFile.GetValueAsFloat("EdgeLimitBottomOffset", 0, 2);
                    m_stcBlobPad.fEdgeLimitLeftOffset = objFile.GetValueAsFloat("EdgeLimitLeftOffset", 0, 2);

                    m_stcBlobPad.fStandOffTopOffset = objFile.GetValueAsFloat("StandOffTopOffset", 0, 2);
                    m_stcBlobPad.fStandOffBottomOffset = objFile.GetValueAsFloat("StandOffBottomOffset", 0, 2);
                    m_stcBlobPad.fStandOffLeftOffset = objFile.GetValueAsFloat("StandOffLeftOffset", 0, 2);
                    m_stcBlobPad.fStandOffRightOffset = objFile.GetValueAsFloat("StandOffRightOffset", 0, 2);

                    m_stcBlobPad.fMinLine3 = objFile.GetValueAsFloat("MinLine3", 0, 2);
                    m_stcBlobPad.fMaxLine3 = objFile.GetValueAsFloat("MaxLine3", 0, 2);
                    m_stcBlobPad.fMinLine4 = objFile.GetValueAsFloat("MinLine4", 0, 2);
                    m_stcBlobPad.fMaxLine4 = objFile.GetValueAsFloat("MaxLine4", 0, 2);
                    m_stcBlobPad.fMinLine5 = objFile.GetValueAsFloat("MinLine5", 0, 2);
                    m_stcBlobPad.fMaxLine5 = objFile.GetValueAsFloat("MaxLine5", 0, 2);
                    m_stcBlobPad.fMinLine6 = objFile.GetValueAsFloat("MinLine6", 0, 2);
                    m_stcBlobPad.fMaxLine6 = objFile.GetValueAsFloat("MaxLine6", 0, 2);
                    m_stcBlobPad.fMinLine7 = objFile.GetValueAsFloat("MinLine7", 0, 2);
                    m_stcBlobPad.fMaxLine7 = objFile.GetValueAsFloat("MaxLine7", 0, 2);
                    m_stcBlobPad.fMinLine8 = objFile.GetValueAsFloat("MinLine8", 0, 2);
                    m_stcBlobPad.fMaxLine8 = objFile.GetValueAsFloat("MaxLine8", 0, 2);
                    m_stcBlobPad.fMinLine9 = objFile.GetValueAsFloat("MinLine9", 0, 2);
                    m_stcBlobPad.fMaxLine9 = objFile.GetValueAsFloat("MaxLine9", 0, 2);
                    m_stcBlobPad.fMinLine10 = objFile.GetValueAsFloat("MinLine10", 0, 2);
                    m_stcBlobPad.fMaxLine10 = objFile.GetValueAsFloat("MaxLine10", 0, 2);
                    m_stcBlobPad.fMinLine11 = objFile.GetValueAsFloat("MinLine11", 0, 2);
                    m_stcBlobPad.fMaxLine11 = objFile.GetValueAsFloat("MaxLine11", 0, 2);
                    m_stcBlobPad.fMinLine12 = objFile.GetValueAsFloat("MinLine12", 0, 2);
                    m_stcBlobPad.fMaxLine12 = objFile.GetValueAsFloat("MaxLine12", 0, 2);
                    m_stcBlobPad.intLengthMode = objFile.GetValueAsInt("LengthMode", 0, 2);

                    m_arrGroupTemplateBlobPads[p] = m_stcBlobPad;

                }
            }
        }

        public void LoadPackageToleranceFromFile(string strFilePath, string strSectionName)
        {
            XmlParser objFile = new XmlParser(strFilePath);

            objFile.GetFirstSection(strSectionName + "Package");
            objFile.GetSecondSection("PackageSetting");

            //PackageSize Offset
            m_fPackageWidthOffsetMM = objFile.GetValueAsFloat("PackageWidthOffsetMM", 0, 2);
            m_fPackageHeightOffsetMM = objFile.GetValueAsFloat("PackageHeightOffsetMM", 0, 2);
            m_fPackageThicknessOffsetMM = objFile.GetValueAsFloat("PackageThicknessOffsetMM", 0, 2);

            m_fUnitWidth = objFile.GetValueAsFloat("UnitWidth", 0, 2);
            m_fUnitHeight = objFile.GetValueAsFloat("UnitHeight", 0, 2);
            m_fUnitThickness = objFile.GetValueAsFloat("UnitThickness", 0, 2);
            m_fUnitWidthMin = objFile.GetValueAsFloat("UnitWidthMin", 0, 2);
            m_fUnitWidthMax = objFile.GetValueAsFloat("UnitWidthMax", 0, 2);
            m_fUnitHeightMin = objFile.GetValueAsFloat("UnitHeightMin", 0, 2);
            m_fUnitHeightMax = objFile.GetValueAsFloat("UnitHeightMax", 0, 2);
            m_fUnitThicknessMin = objFile.GetValueAsFloat("UnitThicknessMin", 0, 2);
            m_fUnitThicknessMax = objFile.GetValueAsFloat("UnitThicknessMax", 0, 2);

            m_fUnitSizeLength = objFile.GetValueAsFloat("UnitSizeLength", 0, 2);
            m_fCrackLength = objFile.GetValueAsFloat("CrackLength", 0, 2);
            m_fScratchLength = objFile.GetValueAsFloat("ScratchLength", 0, 2);
            m_fScratchArea = objFile.GetValueAsFloat("ScratchArea", 0, 2);
            m_fChipArea = objFile.GetValueAsFloat("ChipArea", 0, 2);
            m_fContaminationLength = objFile.GetValueAsFloat("ContaminationLength", 0, 2);
            m_fSolderMeltLength = objFile.GetValueAsFloat("SolderMeltLength", 0, 2);
            m_fVoidLength = objFile.GetValueAsFloat("VoidLength", 0, 2);
            m_fVoidArea = objFile.GetValueAsFloat("VoidArea", 0, 2);
            m_fCrackLength = objFile.GetValueAsFloat("CrackLength", 0, 2);
            m_fCrackArea = objFile.GetValueAsFloat("CrackArea", 0, 2);
            m_fForeignMaterialArea = objFile.GetValueAsFloat("ForeignMaterialArea", 0, 2);
            m_fMoldFlashLength = objFile.GetValueAsFloat("MoldFlashLength_Real", 0, 2);
            m_fMoldFlashWidth = objFile.GetValueAsFloat("MoldFlashWidth", 0, 2);
            m_fMoldFlashArea = objFile.GetValueAsFloat("MoldFlashLength", 0, 2);
            m_fMoldFlashTotalArea = objFile.GetValueAsFloat("MoldFlashTotalArea", 0, 2);
            m_fInCompletePlateLength = objFile.GetValueAsFloat("InCompletePlateLength", 0, 2);
            m_fPadBrokenLength = objFile.GetValueAsFloat("PadBrokenLength", 0, 2);

            m_intMoldFlashDefectDimensionFailCondition = objFile.GetValueAsInt("MoldFlashDefectDimensionFailCondition", 0, 2);
            m_intBrightDefectDimensionFailCondition = objFile.GetValueAsInt("BrightDefectDimensionFailCondition", 0, 2);
            m_intForeignMaterialBrightDefectDimensionFailCondition = objFile.GetValueAsInt("ForeignMaterialBrightDefectDimensionFailCondition", 0, 2);
            m_intDarkDefectDimensionFailCondition = objFile.GetValueAsInt("DarkDefectDimensionFailCondition", 0, 2);
            m_intCrackDarkDefectDimensionFailCondition = objFile.GetValueAsInt("CrackDarkDefectDimensionFailCondition", 0, 2);

            m_fBrightLength = objFile.GetValueAsFloat("BrightLength", 0, 2);
            m_fBrightWidth = objFile.GetValueAsFloat("BrightWidth", 0, 2);
            m_fBrightArea = objFile.GetValueAsFloat("BrightArea", 0, 2);
            m_fBrightTotalArea = objFile.GetValueAsFloat("BrightTotalArea", 0, 2);
            m_fDarkLength = objFile.GetValueAsFloat("DarkLength", 0, 2);
            m_fDarkWidth = objFile.GetValueAsFloat("DarkWidth", 0, 2);
            m_fDarkArea = objFile.GetValueAsFloat("DarkArea", 0, 2);
            m_fDarkTotalArea = objFile.GetValueAsFloat("DarkTotalArea", 0, 2);
            m_fBrightChippedOffArea = objFile.GetValueAsFloat("BrightChippedOffArea", 0, 2);
            m_fDarkChippedOffArea = objFile.GetValueAsFloat("DarkChippedOffArea", 0, 2);
            m_fDarkVerticalCrack = objFile.GetValueAsFloat("DarkVerticalCrack", 0, 2);
            m_fDarkHorizontalCrack = objFile.GetValueAsFloat("DarkHorizontalCrack", 0, 2);
            m_fBrightVerticalForeignMaterial = objFile.GetValueAsFloat("BrightVerticalForeignMaterial", 0, 2);
            m_fBrightHorizontalForeignMaterial = objFile.GetValueAsFloat("BrightHorizontalForeignMaterial", 0, 2);

        }

        public void LoadUnitPositionToleranceFromFile(string strFilePath, string strSectionName)
        {
            XmlParser objFile = new XmlParser(strFilePath);

            objFile.GetFirstSection(strSectionName + "Position");
            m_fAngleTolerance = objFile.GetValueAsFloat("AngleTolerance", 2, 1);
            m_fXTolerance = objFile.GetValueAsFloat("XTolerance", 2, 1);
            m_fYTolerance = objFile.GetValueAsFloat("YTolerance", 2, 1);

        }

        public bool InspectPackage_BrightField(ROI objImage1UnitToleranceROI, ROI objImage1UnitROI, ROI objMoldFlashROI, ROI objChipROI, int intPadIndex)
        {
            // Return if Inspect Package (Option Form) is OFF.
            if (!m_blnInspectPackage)
                return true;

            //m_blnInspectLock = true;
            //m_strTrack2 += "TK,";
            lock (m_objLockBlobs)
            {
                bool blnResult = true;
                bool blnDebugImage = false;
                if (blnDebugImage)
                {
                    objImage1UnitToleranceROI.SaveImage("D:\\TS\\objImage1UnitToleranceROI.bmp");// debug
                    objImage1UnitROI.SaveImage("D:\\TS\\objImage1UnitROI.bmp");// debug
                    if (objMoldFlashROI != null)
                        objMoldFlashROI.SaveImage("D:\\TS\\objMoldFlashROI.bmp");// debug
                    if (objChipROI != null)
                        objChipROI.SaveImage("D:\\TS\\objChipROI.bmp");// debug 
                }

                //Subtract Package Dont Care Area
                if (m_blnWantDontCareArea_Package)
                {
                    ROI objDontCareROI = new ROI();
                    objDontCareROI.LoadROISetting(0, 0, objImage1UnitROI.ref_ROIWidth, objImage1UnitROI.ref_ROIHeight);
                    objDontCareROI.AttachImage(m_objPackageDontCareImageWhite);
                    ROI.SubtractROI(objImage1UnitROI, objDontCareROI);
                    objDontCareROI.Dispose();
                }

                try
                {
                    if (m_blnUseDetailDefectCriteria)
                    {

                        // Check Chipped off and scratches
                        if (blnResult)
                            blnResult = CheckImageScratchAndChipDefect(objImage1UnitToleranceROI, objImage1UnitROI, 1, intPadIndex);// ,blnPadPkg);
                                                                                                                                    //blnResult = CheckImageScratchDefect_GradientNClosing(objImage1UnitToleranceROI, objImage1UnitROI, 1);// ,blnPadPkg);

                        if (blnResult)
                        {
                            if (m_blnWantLinkMoldFlashDefect)
                            {
                                if (m_objRectGauge4L.GetGaugeTiltAngle() == 0)
                                    blnResult = CheckImageMoldFlashDefect_Area_WithLinkFunction(objImage1UnitROI, objMoldFlashROI, intPadIndex); //CheckImageMoldFlashDefect
                                else
                                    blnResult = CheckImageMoldFlashDefect_Area_TiltAngle_WithLinkFunction(objImage1UnitROI, objMoldFlashROI, intPadIndex); //CheckImageMoldFlashDefect
                            }
                            else
                            {
                                if (m_objRectGauge4L.GetGaugeTiltAngle() == 0)
                                    blnResult = CheckImageMoldFlashDefect_Area(objImage1UnitROI, objMoldFlashROI, intPadIndex); //CheckImageMoldFlashDefect
                                else
                                    blnResult = CheckImageMoldFlashDefect_Area_TiltAngle(objImage1UnitROI, objMoldFlashROI, intPadIndex); //CheckImageMoldFlashDefect
                            }
                        }
                    }
                    else
                    {
                        if (blnResult)
                            blnResult = CheckImageBrightDefect_Simple(objImage1UnitToleranceROI, objImage1UnitROI, m_intPadPkgBrightFieldImageViewNo + 1, intPadIndex); //2020-01-09 ZJYEOH : Should not fixed to 1
                        if (blnResult && m_blnSeperateForeignMaterialDefectSetting)
                            blnResult = CheckImageBrightForeignMateriaDefect(objImage1UnitToleranceROI, objImage1UnitROI, m_intPadPkgBrightFieldImageViewNo + 1, intPadIndex); //2020-01-09 ZJYEOH : Should not fixed to 1
                        if (blnResult)
                        {
                            if (m_blnSeperateChippedOffDefectSetting && ((m_intFailPkgOptionMask & 0x200000) != 0))
                                blnResult = CheckImageChipDefect_SimpleMode(objImage1UnitToleranceROI, /*objImage1UnitROI*/objChipROI, m_intPadPkgBrightFieldImageViewNo + 1);//2020-01-09 ZJYEOH : Should not fixed to 1
                        }

                        if (blnResult)
                        {
                            if (m_blnSeperateMoldFlashDefectSetting)
                            {
                                if (m_blnWantLinkMoldFlashDefect)
                                {
                                    if (m_objRectGauge4L.GetGaugeTiltAngle() == 0)
                                        blnResult = CheckImageMoldFlashDefect_Area_WithLinkFunction(objImage1UnitROI, objMoldFlashROI, intPadIndex); //CheckImageMoldFlashDefect
                                    else
                                        blnResult = CheckImageMoldFlashDefect_Area_TiltAngle_WithLinkFunction(objImage1UnitROI, objMoldFlashROI, intPadIndex); //CheckImageMoldFlashDefect
                                }
                                else
                                {
                                    if (m_objRectGauge4L.GetGaugeTiltAngle() == 0)
                                        blnResult = CheckImageMoldFlashDefect_Area(objImage1UnitROI, objMoldFlashROI, intPadIndex); //CheckImageMoldFlashDefect
                                    else
                                        blnResult = CheckImageMoldFlashDefect_Area_TiltAngle(objImage1UnitROI, objMoldFlashROI, intPadIndex); //CheckImageMoldFlashDefect
                                }
                            }
                        }
                    }
                }
                catch (Exception ex)
                {
                    m_strErrorMessage = "*" + ex.ToString();
                    blnResult = false;
                }

                //m_blnInspectLock = false;
                //m_strTrack2 += "F9,";
                return blnResult;
            }
        }

        public bool InspectPackage_DarkField(ROI objImage2UnitToleranceROI, ROI objImage1UnitROI, ROI objROI, ROI objChipROI, int intPadIndex)
        {
            // Return if Inspect Package (Option Form) is OFF.
            if (!m_blnInspectPackage)
                return true;

            //m_blnInspectLock = true;
            //m_strTrack2 += "T5,";
            lock (m_objLockBlobs)
            {
                bool blnResult = true;
                bool blnDebugImage = false;

                if (blnDebugImage)
                {
                    objImage2UnitToleranceROI.SaveImage("D:\\TS\\objImage2UnitToleranceROI.bmp");
                    objImage1UnitROI.SaveImage("D:\\TS\\objImage1UnitROI.bmp");// debug
                    objROI.SaveImage("D:\\TS\\objROI.bmp");
                    m_objPackageDontCareImageBlack.SaveImage("D:\\TS\\m_objPackageDontCareImageBlack.bmp");
                    if (objChipROI != null)
                        objChipROI.SaveImage("D:\\TS\\objChipROI.bmp");// debug 
                }

                //Subtract Package Dont Care Area
                if (m_blnWantDontCareArea_Package)
                {
                    ROI objDontCareROI = new ROI();
                    objDontCareROI.LoadROISetting(0, 0, objImage1UnitROI.ref_ROIWidth, objImage1UnitROI.ref_ROIHeight);
                    objDontCareROI.AttachImage(m_objPackageDontCareImageBlack);
                    ROI.LogicOperationAddROI(objImage1UnitROI, objDontCareROI);
                    objDontCareROI.Dispose();
                }

                try
                {
                    if (m_blnUseDetailDefectCriteria)
                    {
                        if (blnResult)
                            blnResult = CheckImageScratchAndChipDefect(objImage2UnitToleranceROI, objImage1UnitROI, 2, intPadIndex);//, blnPadPkg);

                        //if (blnResult)
                        //    blnResult = CheckImageMoldFlashDefect(objImage1UnitROI, objMoldFlashROI, 2);  // 2019 01 11 - JBTAN: Mold flash only have threshold for Image 1 currently

                        if (blnResult)
                        {
                            if (m_objRectGauge4L.GetGaugeTiltAngle() == 0)
                                blnResult = CheckCrackDefect(objImage1UnitROI, objROI.ref_ROITotalX, objROI.ref_ROITotalY, 2);
                            else
                                blnResult = CheckCrackDefect_TiltAngle(objImage1UnitROI, objROI.ref_ROITotalX, objROI.ref_ROITotalY, 2, intPadIndex);
                        }

                        if (blnResult)
                        {
                            if (m_objRectGauge4L.GetGaugeTiltAngle() == 0)
                                blnResult = CheckVoidDefect(objImage1UnitROI, objROI.ref_ROITotalX, objROI.ref_ROITotalY, 2, 255);
                            else
                                blnResult = CheckVoidDefect_TiltAngle(objImage1UnitROI, objROI.ref_ROITotalX, objROI.ref_ROITotalY, 2, 255, intPadIndex);
                        }
                    }
                    else
                    {
                        if (blnResult)
                            blnResult = CheckImageDarkDefect_Simple(objImage2UnitToleranceROI, objImage1UnitROI, m_intPadPkgDarkFieldImageViewNo + 1, intPadIndex);//2020-09-01 ZJYEOH : Added + 1 to m_intPadPkgDarkFieldImageViewNo

                        if (blnResult)
                        {
                            if (m_blnSeperateChippedOffDefectSetting && ((m_intFailPkgOptionMask & 0x100000) != 0))
                                blnResult = CheckImageChipDefect_SimpleMode(objImage2UnitToleranceROI, /*objImage1UnitROI*/objChipROI, m_intPadPkgDarkFieldImageViewNo + 1); //2020-09-01 ZJYEOH : Added + 1 to m_intPadPkgDarkFieldImageViewNo
                        }

                        if (blnResult)
                        {
                            if (m_blnSeperateCrackDefectSetting)
                            {
                                if (m_blnWantLinkCrackDefect)
                                {
                                    if (m_objRectGauge4L.GetGaugeTiltAngle() == 0)
                                        blnResult = CheckCrackDefect_SimpleMode_WithLinkFunction(objImage1UnitROI, objROI.ref_ROITotalX, objROI.ref_ROITotalY, m_intPadPkgDarkFieldImageViewNo + 1);//2020-09-01 ZJYEOH : Added + 1 to m_intPadPkgDarkFieldImageViewNo
                                    else
                                        blnResult = CheckCrackDefect_SimpleMode_TiltAngle_WithLinkFunction(objImage1UnitROI, objROI.ref_ROITotalX, objROI.ref_ROITotalY, m_intPadPkgDarkFieldImageViewNo + 1, intPadIndex);//2020-09-01 ZJYEOH : Added + 1 to m_intPadPkgDarkFieldImageViewNo
                                }
                                else
                                {
                                    if (m_objRectGauge4L.GetGaugeTiltAngle() == 0)
                                        blnResult = CheckCrackDefect_SimpleMode(objImage1UnitROI, objROI.ref_ROITotalX, objROI.ref_ROITotalY, m_intPadPkgDarkFieldImageViewNo + 1);//2020-09-01 ZJYEOH : Added + 1 to m_intPadPkgDarkFieldImageViewNo
                                    else
                                        blnResult = CheckCrackDefect_SimpleMode_TiltAngle(objImage1UnitROI, objROI.ref_ROITotalX, objROI.ref_ROITotalY, m_intPadPkgDarkFieldImageViewNo + 1, intPadIndex);//2020-09-01 ZJYEOH : Added + 1 to m_intPadPkgDarkFieldImageViewNo
                                }
                            }
                        }
                    }
                }
                catch (Exception ex)
                {
                    m_strErrorMessage = "*" + ex.ToString();
                    blnResult = false;
                }
                //m_blnInspectLock = false;
                //m_strTrack2 += "F10,";

                return blnResult;
            }
        }

        private bool IsImage1UnitChippedOff2_Area_SimpleMode(ROI objImage1UnitROI, int ROITotalX, int ROITotalY, int intImageIndex)
        {
            /*
             * Algoritm:
             * 
             *
             * 
             * 
             * 
             * 
             */


            bool blnResult = true;
            bool blnDebugImage = false;

            // Get Chipped off setting length in pixel
            //int intCeilChipLengthLeft = (int)Math.Ceiling(m_fChipStartPixelFromLeft);//* m_fMMToPixelXValue
            //int intCeilChipLengthTop = (int)Math.Ceiling(m_fChipStartPixelFromEdge);
            //int intCeilChipLengthRight = (int)Math.Ceiling(m_fChipStartPixelFromRight);
            //int intCeilChipLengthBottom = (int)Math.Ceiling(m_fChipStartPixelFromBottom);

            int intCeilChipLengthLeft = 0;
            int intCeilChipLengthTop = 0;
            int intCeilChipLengthRight = 0;
            int intCeilChipLengthBottom = 0;

            if (intImageIndex == 1)    // White field defect (Scratches, contamination, chip)
            {
                intCeilChipLengthTop = (int)Math.Ceiling(m_fChipStartPixelFromEdge);
                intCeilChipLengthRight = (int)Math.Ceiling(m_fChipStartPixelFromRight);
                intCeilChipLengthBottom = (int)Math.Ceiling(m_fChipStartPixelFromBottom);
                intCeilChipLengthLeft = (int)Math.Ceiling(m_fChipStartPixelFromLeft);
                
            }
            else // Black field defect (Crack, void, chip)
            {
                intCeilChipLengthTop = (int)Math.Ceiling(m_fChipStartPixelFromEdge_Dark);
                intCeilChipLengthRight = (int)Math.Ceiling(m_fChipStartPixelFromRight_Dark);
                intCeilChipLengthBottom = (int)Math.Ceiling(m_fChipStartPixelFromBottom_Dark);
                intCeilChipLengthLeft = (int)Math.Ceiling(m_fChipStartPixelFromLeft_Dark);

            }

            int intCeilChipLengthLeft_Extend = 0;
            int intCeilChipLengthTop_Extend = 0;
            int intCeilChipLengthRight_Extend = 0;
            int intCeilChipLengthBottom_Extend = 0;

            if (intImageIndex == 1)    // White field defect (Scratches, contamination, chip)
            {
                intCeilChipLengthTop_Extend = (int)Math.Ceiling(m_fChipStartPixelExtendFromEdge);
                intCeilChipLengthRight_Extend = (int)Math.Ceiling(m_fChipStartPixelExtendFromRight);
                intCeilChipLengthBottom_Extend = (int)Math.Ceiling(m_fChipStartPixelExtendFromBottom);
                intCeilChipLengthLeft_Extend = (int)Math.Ceiling(m_fChipStartPixelExtendFromLeft);

            }
            else // Black field defect (Crack, void, chip)
            {
                intCeilChipLengthTop_Extend = (int)Math.Ceiling(m_fChipStartPixelExtendFromEdge_Dark);
                intCeilChipLengthRight_Extend = (int)Math.Ceiling(m_fChipStartPixelExtendFromRight_Dark);
                intCeilChipLengthBottom_Extend = (int)Math.Ceiling(m_fChipStartPixelExtendFromBottom_Dark);
                intCeilChipLengthLeft_Extend = (int)Math.Ceiling(m_fChipStartPixelExtendFromLeft_Dark);

            }

            ROI objChippedOffROI = new ROI();
            objChippedOffROI.AttachImage(objImage1UnitROI); // m_objInsSurfacePkgImage1 is sample image after double threshold
            //objChippedOffROI.LoadROISetting(objImage1UnitROI.ref_ROITotalX,
            //                                            objImage1UnitROI.ref_ROITotalY,
            //                                            objImage1UnitROI.ref_ROIWidth,
            //                                            objImage1UnitROI.ref_ROIHeight);
            objChippedOffROI.LoadROISetting(0, 0, objImage1UnitROI.ref_ROIWidth, objImage1UnitROI.ref_ROIHeight);
            objChippedOffROI.CopyToImage(ref m_objInsChipOffPkgImage1); // Copy sample image to another image memory so that image can be modified without affect the original image.
            objChippedOffROI.AttachImage(m_objInsChipOffPkgImage1);
            objChippedOffROI.LoadROISetting(0, 0, m_objInsChipOffPkgImage1.ref_intImageWidth, m_objInsChipOffPkgImage1.ref_intImageHeight);

            if (intImageIndex == 1)
                FillChipLineLimitToCorner_4Edges(m_objInsChipOffPkgImage1, intCeilChipLengthLeft - intCeilChipLengthLeft_Extend,
                                                                           intCeilChipLengthTop - intCeilChipLengthTop_Extend,
                                                                           intCeilChipLengthRight - intCeilChipLengthRight_Extend,
                                                                           intCeilChipLengthBottom - intCeilChipLengthBottom_Extend,
                                                                           0);
            else
                FillChipLineLimitToCorner_4Edges(m_objInsChipOffPkgImage1, intCeilChipLengthLeft - intCeilChipLengthLeft_Extend,
                                                                           intCeilChipLengthTop - intCeilChipLengthTop_Extend,
                                                                           intCeilChipLengthRight - intCeilChipLengthRight_Extend,
                                                                           intCeilChipLengthBottom - intCeilChipLengthBottom_Extend,
                                                                           255);


            bool blnBlackOnWhite;
            if (intImageIndex == 1)
                blnBlackOnWhite = false;
            else
                blnBlackOnWhite = true;

            switch (intImageIndex)
            {
                case 1: // Image 1 (Grab 1 & Grab 2 Merged)
                    {
                        m_objImage1ChipOffEBlobs.BuildObjects_Filter_GetElement(objChippedOffROI, blnBlackOnWhite, true, 0, 125,
                            (int)Math.Floor(m_fSurfaceMinArea), 999999, false, 0x0F);
                    }
                    break;
                case 2: // Image 2 (Grab 3)
                    {
                        m_objImage1ChipOffEBlobs.BuildObjects_Filter_GetElement(objChippedOffROI, blnBlackOnWhite, true, 0, 125,
                            (int)Math.Floor(m_fImage2SurfaceMinArea), 999999, false, 0x0F);
                    }
                    break;
            }
            if (blnDebugImage)
            {
                objImage1UnitROI.SaveImage("D:\\TS\\objImage1UnitROI.bmp");// debug
                objChippedOffROI.SaveImage("D:\\TS\\objChippedOffROI.bmp");// debug 
            }

            if (m_objImage1ChipOffEBlobs.ref_intNumSelectedObject > 0)
            {
                float fDefectLengthPixelLeft = intCeilChipLengthLeft - intCeilChipLengthLeft_Extend;
                float fDefectLengthPixelTop = intCeilChipLengthTop - intCeilChipLengthTop_Extend;
                float fDefectLengthPixelRight = intCeilChipLengthRight - intCeilChipLengthRight_Extend;
                float fDefectLengthPixelBottom = intCeilChipLengthBottom - intCeilChipLengthBottom_Extend;
                int intObjectArea = 0;
                float fObjectHeight = 0, fObjectWidth = 0, fObjectCenterX = 0, fObjectCenterY = 0;
                float fStartX, fStartY, fEndX, fEndY;
                float fOuterStartX = 1;
                float fOuterStartY = 1;
                float fOuterEndX = objChippedOffROI.ref_ROIWidth;
                float fOuterEndY = objChippedOffROI.ref_ROIHeight;
                // float fTolerance = 2f;
              
                //intCeilChipLengthLeft += intCeilChipLengthLeft_Extend;
                //intCeilChipLengthTop += intCeilChipLengthTop_Extend;
                //intCeilChipLengthRight += intCeilChipLengthRight_Extend;
                //intCeilChipLengthBottom += intCeilChipLengthBottom_Extend;
                float fToleranceLeft = fDefectLengthPixelLeft / 2;
                float fToleranceTop = fDefectLengthPixelTop / 2;
                float fToleranceRight = fDefectLengthPixelRight / 2;
                float fToleranceBottom = fDefectLengthPixelBottom / 2;
                float fInterStartX = fDefectLengthPixelLeft;
                float fInterStartY = fDefectLengthPixelTop;
                float fInterEndX = (float)objChippedOffROI.ref_ROIWidth - fDefectLengthPixelRight - 1;
                float fInterEndY = (float)objChippedOffROI.ref_ROIHeight - fDefectLengthPixelBottom - 1;
                int intFailCount = 0;

                for (int i = 0; i < m_objImage1ChipOffEBlobs.ref_intNumSelectedObject; i++)
                {
                    fObjectCenterX = m_objImage1ChipOffEBlobs.ref_arrLimitCenterX[i];
                    fObjectCenterY = m_objImage1ChipOffEBlobs.ref_arrLimitCenterY[i];
                    fObjectWidth = m_objImage1ChipOffEBlobs.ref_arrWidth[i];
                    fObjectHeight = m_objImage1ChipOffEBlobs.ref_arrHeight[i];
                    intObjectArea = m_objImage1ChipOffEBlobs.ref_arrArea[i];


                    fStartX = fObjectCenterX - (fObjectWidth / 2);
                    fStartY = fObjectCenterY - (fObjectHeight / 2);
                    fEndX = fObjectCenterX + (fObjectWidth / 2);
                    fEndY = fObjectCenterY + (fObjectHeight / 2);

                    bool blnDefect = false;
                    float fAddX = 0;
                    float fAddY = 0;

                    if (fStartX < fInterStartX) // Possible Left Chipped
                    {
                        if (fStartY < fInterStartY) // Possible Top Chipped
                        {
                            if (fStartX < fStartY)  // Confirm Left Chipped
                            {
                                if (fDefectLengthPixelLeft > 0)
                                    blnDefect = true;
                            }
                            else // Confirm Top Chipped
                            {
                                if (fDefectLengthPixelTop > 0)
                                    blnDefect = true;
                            }
                        }
                        else if (fEndY > fInterEndY)    // Possible Bottom Chipped
                        {
                            if (fStartX < (objChippedOffROI.ref_ROIHeight - fEndY)) // Confirm Left Chipped
                            {
                                if (fDefectLengthPixelLeft > 0)
                                    blnDefect = true;
                            }
                            else // Confirm BOttom Chipped
                            {
                                if (fDefectLengthPixelBottom > 0)
                                    blnDefect = true;
                            }
                        }
                        else // Confirm Left Chipped
                        {
                            if (fDefectLengthPixelLeft > 0)
                                blnDefect = true;
                        }
                    }

                    if (!blnDefect && fEndX > fInterEndX) // Possible Right Chipped
                    {
                        if (fStartY < fInterStartY) // Possible Top Chipped
                        {
                            if (fStartY < (objChippedOffROI.ref_ROIWidth - fEndX))  // Confirm Top Chipped
                            {
                                if (fDefectLengthPixelTop > 0)
                                    blnDefect = true;
                            }
                            else // Confirm Right Chipped
                            {
                                if (fDefectLengthPixelRight > 0)
                                    blnDefect = true;
                            }
                        }
                        else if (fEndY > fInterEndY)    // Possible Bottom Chipped
                        {
                            if ((objChippedOffROI.ref_ROIWidth - fEndX) < (objChippedOffROI.ref_ROIHeight - fEndY)) // Confirm Right Chipped
                            {
                                if (fDefectLengthPixelRight > 0)
                                    blnDefect = true;
                            }
                            else // Confirm BOttom Chipped
                            {
                                if (fDefectLengthPixelBottom > 0)
                                    blnDefect = true;
                            }
                        }
                        else // Confirm Right Chipped
                        {
                            if (fDefectLengthPixelRight > 0)
                                blnDefect = true;
                        }
                    }

                    if (!blnDefect && fStartY < fInterStartY) // Possible Top chipped
                    {
                        if (fStartX < fInterStartX) // Possible Left Chipped
                        {
                            if (fStartX < fStartY)  // Confirm Left Chipped
                            {
                                if (fDefectLengthPixelLeft > 0)
                                    blnDefect = true;
                            }
                            else // Confirm Top Chipped
                            {
                                if (fDefectLengthPixelTop > 0)
                                    blnDefect = true;
                            }
                        }
                        else if (fEndX > fInterEndX)    // Possible Right Chipped
                        {
                            if (fStartY < (objChippedOffROI.ref_ROIWidth - fEndX)) // Confirm Top Chipped
                            {
                                if (fDefectLengthPixelTop > 0)
                                    blnDefect = true;
                            }
                            else // Confirm Right Chipped
                            {
                                if (fDefectLengthPixelRight > 0)
                                    blnDefect = true;
                            }
                        }
                        else // Confirm Top Chipped
                        {
                            if (fDefectLengthPixelTop > 0)
                                blnDefect = true;
                        }
                    }

                    // 2021 07 27 - CCENG: + 1 to make sure outside the chip area defect will be included.
                    //                   : for example, the fEndY is 166.5, but the fInternEndY is 166. 
                    if (!blnDefect && fEndY > (fInterEndY + 1)) // Possible Bottom Chipped  
                    {
                        if (fStartX < fInterStartX) // Possible Left Chipped
                        {
                            if (fStartX < (objChippedOffROI.ref_ROIHeight - fEndY))  // Confirm Left Chipped
                            {
                                if (fDefectLengthPixelLeft > 0)
                                    blnDefect = true;
                            }
                            else // Confirm Bottom Chipped
                            {
                                if (fDefectLengthPixelBottom > 0)
                                    blnDefect = true;
                            }
                        }
                        else if (fEndX > fInterEndX)    // Possible Right Chipped
                        {
                            if ((objChippedOffROI.ref_ROIWidth - fEndX) < (objChippedOffROI.ref_ROIHeight - fEndY)) // Confirm Right Chipped
                            {
                                if (fDefectLengthPixelRight > 0)
                                    blnDefect = true;
                            }
                            else // Confirm BOttom Chipped
                            {
                                if (fDefectLengthPixelBottom > 0)
                                    blnDefect = true;
                            }
                        }
                        else // Confirm Bottom Chipped
                        {
                            if (fDefectLengthPixelBottom > 0)
                                blnDefect = true;
                        }
                    }

                    float fWidthMM = (fObjectWidth + fAddX) / m_fMMToPixelXValue;
                    float fHeightMM = (fObjectHeight + fAddY) / m_fMMToPixelYValue; // 11-04-2019 ZJYEOH : Changed m_fMMToPixelXValue to m_fMMToPixelYValue
                    float fAreaInMM = intObjectArea / m_fMMToPixelXValue / m_fMMToPixelYValue;
                    float fChipAreaLimit;
                    if (intImageIndex == 1)
                        fChipAreaLimit = m_fBrightChippedOffArea;
                    else
                        fChipAreaLimit = m_fDarkChippedOffArea;

                    if (blnDefect && fAreaInMM > fChipAreaLimit)
                    {
                        intFailCount++;


                        //0x02
                        m_intFailPkgResultMask |= 0x04; // Fail image 1 chipped off

                        Defect objDefect = new Defect();
                        objDefect.ref_intImageNo = intImageIndex;

                        objDefect.ref_strName = "Chipped Off";

                        objDefect.ref_intFailMask = 0x04;//0x02
                        objDefect.ref_fCenterX = ROITotalX + objChippedOffROI.ref_ROITotalX + fObjectCenterX;
                        objDefect.ref_fCenterY = ROITotalY + objChippedOffROI.ref_ROITotalY + fObjectCenterY;
                        objDefect.ref_fStartX = ROITotalX + fStartX;
                        objDefect.ref_fStartY = ROITotalY + fStartY;
                        objDefect.ref_fEndX = ROITotalX + fEndX;
                        objDefect.ref_fEndY = ROITotalY + fEndY;
                        objDefect.ref_fWidth = fObjectWidth + fAddX;
                        objDefect.ref_fHeight = fObjectHeight + fAddY;
                        objDefect.ref_fArea = intObjectArea;
                        objDefect.ref_fWidthInMM = fWidthMM;
                        objDefect.ref_fHeightInMM = fHeightMM;
                        objDefect.ref_fAreaInMM2 = fAreaInMM;

                        //if (blnFailWidth)
                        //{
                        //    objDefect.ref_fFailValue = fWidthMM;
                        //    objDefect.ref_intFailCriteria |= 0x01;
                        //}
                        //else
                        //{
                        //    objDefect.ref_fFailValue = fHeightMM;
                        //    objDefect.ref_intFailCriteria |= 0x02;
                        //}

                        objDefect.ref_fFailValue = fAreaInMM;
                        objDefect.ref_intFailCriteria |= 0x04;

                        m_arrPkgDefectList.Add(objDefect);

                        if (blnResult)
                            blnResult = false;
                    }

                }

                //for (int i = 0; i < m_objImage1ChipOffEBlobs.ref_intNumSelectedObject; i++)
                //{
                //    fObjectCenterX = m_objImage1ChipOffEBlobs.ref_arrLimitCenterX[i];
                //    fObjectCenterY = m_objImage1ChipOffEBlobs.ref_arrLimitCenterY[i];
                //    fObjectWidth = m_objImage1ChipOffEBlobs.ref_arrWidth[i];
                //    fObjectHeight = m_objImage1ChipOffEBlobs.ref_arrHeight[i];
                //    intObjectArea = m_objImage1ChipOffEBlobs.ref_arrArea[i];


                //    fStartX = fObjectCenterX - (fObjectWidth / 2);
                //    fStartY = fObjectCenterY - (fObjectHeight / 2);
                //    fEndX = fObjectCenterX + (fObjectWidth / 2);
                //    fEndY = fObjectCenterY + (fObjectHeight / 2);

                //    bool blnDefect = false;
                //    float fAddX = 0;
                //    float fAddY = 0;
                //    bool blnFailWidth = false;

                //    if (fStartX < fInterStartX) // Possible Left Chipped
                //    {
                //        if (fStartY < fInterStartY) // Possible Top Chipped
                //        {
                //            if (fStartX < fStartY)  // Confirm Left Chipped
                //            {
                //                if (fObjectWidth >= fDefectLengthPixelLeft)  // Is Chipped over setting min value
                //                {
                //                    blnDefect = true;
                //                    blnFailWidth = true;
                //                }
                //                else if ((fObjectCenterX - fObjectWidth / 2) > 0)
                //                {
                //                    //if (fObjectWidth == intCeilChipLengthX - fTolerance)    // Is Chipped same length with chip setting + tolerance
                //                    if (fObjectWidth >= intCeilChipLengthLeft - fToleranceLeft)    // Is Chipped over chip setting - tolerance
                //                    {
                //                        //if ((fTolerance - (fObjectCenterX + fObjectWidth / 2)) <= fTolerance) // Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                //                        if ((fToleranceLeft - (fObjectCenterX + fObjectWidth / 2)) <= fToleranceLeft) // Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                //                        {
                //                            blnDefect = true;
                //                            blnFailWidth = true;
                //                            fAddX = fObjectCenterX - fObjectWidth / 2;
                //                        }
                //                    }
                //                }
                //            }
                //            else // Confirm Top Chipped
                //            {
                //                if (fObjectHeight >= fDefectLengthPixelTop) // Is Chipped over setting min value
                //                {
                //                    blnDefect = true;
                //                }
                //                else if ((fObjectCenterY - fObjectHeight / 2) > 0)
                //                {
                //                    //if (fObjectHeight == intCeilChipLengthY - fTolerance) // Is Chipped same length with chip setting + tolerance
                //                    if (fObjectHeight >= intCeilChipLengthTop - fToleranceTop)    // Is Chipped over chip setting - tolerance
                //                    {
                //                        //if ((fInterStartY - (fObjectCenterY + fObjectHeight / 2)) <= fTolerance)// Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                //                        if ((fInterStartY - (fObjectCenterY + fObjectHeight / 2)) <= fToleranceTop)// Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                //                        {
                //                            blnDefect = true;
                //                            fAddY = fObjectCenterY - fObjectHeight / 2;
                //                        }
                //                    }
                //                }

                //            }
                //        }
                //        else if (fEndY > fInterEndY)    // Possible Bottom Chipped
                //        {
                //            if (fStartX < (objChippedOffROI.ref_ROIHeight - fEndY)) // Confirm Left Chipped
                //            {
                //                if (fObjectWidth >= fDefectLengthPixelBottom)  // Is Chipped over setting min value
                //                {
                //                    blnDefect = true;
                //                    blnFailWidth = true;
                //                }
                //                else if ((fObjectCenterX - fObjectWidth / 2) > 0)   // Need to make sure object size not touching Unit edge if object size less than setting min value.
                //                {
                //                    //if (fObjectWidth == intCeilChipLengthX - fTolerance)    // Is Chipped same length with chip setting + tolerance
                //                    if (fObjectWidth >= intCeilChipLengthBottom - fToleranceBottom)    // Is Chipped over chip setting - tolerance
                //                    {
                //                        //if ((fInterStartX - (fObjectCenterX + fObjectWidth / 2)) <= fTolerance) // Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                //                        if ((fInterStartX - (fObjectCenterX + fObjectWidth / 2)) <= fToleranceBottom) // Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                //                        {
                //                            blnDefect = true;
                //                            blnFailWidth = true;
                //                            fAddX = fObjectCenterX - fObjectWidth / 2;
                //                        }
                //                    }
                //                }
                //            }
                //            else // Confirm BOttom Chipped
                //            {
                //                if (fObjectHeight >= fDefectLengthPixelBottom) // Is Chipped over setting min value
                //                {
                //                    blnDefect = true;
                //                }
                //                else if ((objChippedOffROI.ref_ROIHeight - fEndY) > 0)   // Make sure object no touch outerEndY
                //                {
                //                    //if (fObjectHeight == intCeilChipLengthY - fTolerance) // Is Chipped same length with chip setting + tolerance
                //                    if (fObjectHeight >= intCeilChipLengthBottom - fToleranceBottom)    // Is Chipped over chip setting - tolerance
                //                    {
                //                        //if (((fObjectCenterY - fObjectHeight / 2) - fInterEndY) <= fTolerance)// Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                //                        //if (((fObjectCenterY - fObjectHeight / 2) - fInterEndY) <= fToleranceBottom)// Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                //                        if ((fStartY - fInterEndY) <= 0.5) // Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                //                        {
                //                            blnDefect = true;
                //                            fAddY = objChippedOffROI.ref_ROIHeight - (fObjectCenterY + fObjectHeight / 2);
                //                        }
                //                    }
                //                }
                //            }
                //        }
                //        else // Confirm Left Chipped
                //        {
                //            if (fObjectWidth >= fDefectLengthPixelLeft)  // Is Chipped over setting min value
                //            {
                //                blnDefect = true;
                //                blnFailWidth = true;
                //            }
                //            else if ((fObjectCenterX - fObjectWidth / 2) > 0)
                //            {
                //                //if (fObjectWidth == intCeilChipLengthX - fTolerance)    // Is Chipped same length with chip setting + tolerance
                //                if (fObjectWidth >= intCeilChipLengthLeft - fToleranceLeft)    // Is Chipped over chip setting - tolerance
                //                {
                //                    //if ((fInterStartX - (fObjectCenterX + fObjectWidth / 2)) <= fTolerance) // Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                //                    if ((fInterStartX - (fObjectCenterX + fObjectWidth / 2)) <= fToleranceLeft) // Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                //                    {
                //                        blnDefect = true;
                //                        blnFailWidth = true;
                //                        fAddX = fObjectCenterX - fObjectWidth / 2;
                //                    }
                //                }
                //            }

                //        }
                //    }

                //    if (!blnDefect && fEndX > fInterEndX) // Possible Right Chipped
                //    {
                //        if (fStartY < fInterStartY) // Possible Top Chipped
                //        {
                //            if (fStartY < (objChippedOffROI.ref_ROIWidth - fEndX))  // Confirm Top Chipped
                //            {
                //                if (fObjectHeight >= fDefectLengthPixelTop)  // Is Chipped over setting min value
                //                {
                //                    blnDefect = true;
                //                }
                //                else if ((fObjectCenterY - fObjectHeight / 2) > 0)
                //                {
                //                    //if (fObjectHeight == intCeilChipLengthY - fTolerance) // Is Chipped same length with chip setting + tolerance
                //                    if (fObjectHeight >= intCeilChipLengthTop - fToleranceTop)    // Is Chipped over chip setting - tolerance
                //                    {
                //                        //if ((fInterStartY - (fObjectCenterY + fObjectHeight / 2)) <= fTolerance)// Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                //                        if ((fInterStartY - (fObjectCenterY + fObjectHeight / 2)) <= fToleranceTop)// Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                //                        {
                //                            blnDefect = true;
                //                            fAddY = fObjectCenterY - fObjectHeight / 2;
                //                        }
                //                    }
                //                }
                //            }
                //            else // Confirm Right Chipped
                //            {
                //                if (fObjectWidth >= fDefectLengthPixelRight) // Is Chipped over setting min value
                //                {
                //                    blnDefect = true;
                //                    blnFailWidth = true;
                //                }
                //                else if ((objChippedOffROI.ref_ROIWidth - fEndX) > 0)   // Make sure object no touch outerEndX
                //                {
                //                    //if (fObjectWidth == intCeilChipLengthX - fTolerance)    // Is Chipped same length with chip setting + tolerance
                //                    if (fObjectWidth >= intCeilChipLengthRight - fToleranceRight)    // Is Chipped over chip setting - tolerance
                //                    {
                //                        //if (((fObjectCenterX - fObjectWidth / 2) - fInterEndX) <= fTolerance) // Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                //                        //if (((fObjectCenterX - fObjectWidth / 2) - fInterEndX) <= fToleranceRight) // Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                //                        if ((fStartX - fInterEndX) <= 0.5) // Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                //                        {
                //                            blnDefect = true;
                //                            blnFailWidth = true;
                //                            fAddX = objChippedOffROI.ref_ROIWidth - (fObjectCenterX + fObjectWidth / 2);
                //                        }
                //                    }
                //                }
                //            }
                //        }
                //        else if (fEndY > fInterEndY)    // Possible Bottom Chipped
                //        {
                //            if ((objChippedOffROI.ref_ROIWidth - fEndX) < (objChippedOffROI.ref_ROIHeight - fEndY)) // Confirm Right Chipped
                //            {
                //                if (fObjectWidth >= fDefectLengthPixelRight)  // Is Chipped over setting min value
                //                {
                //                    blnDefect = true;
                //                    blnFailWidth = true;
                //                }
                //                else if ((objChippedOffROI.ref_ROIWidth - fEndX) > 0)   // Make sure object no touch outerEndX
                //                {
                //                    //if (fObjectWidth == intCeilChipLengthX - fTolerance)    // Is Chipped same length with chip setting + tolerance
                //                    if (fObjectWidth >= intCeilChipLengthRight - fToleranceRight)    // Is Chipped over chip setting - tolerance
                //                    {
                //                        //if (((fObjectCenterX - fObjectWidth / 2) - fInterEndX) <= fTolerance) // Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                //                        //if (((fObjectCenterX - fObjectWidth / 2) - fInterEndX) <= fToleranceRight) // Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                //                        if ((fStartX - fInterEndX) <= 0.5) // Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                //                        {
                //                            blnDefect = true;
                //                            blnFailWidth = true;
                //                            fAddX = objChippedOffROI.ref_ROIWidth - (fObjectCenterX + fObjectWidth / 2);
                //                        }
                //                    }
                //                }
                //            }
                //            else // Confirm BOttom Chipped
                //            {
                //                if (fObjectHeight >= fDefectLengthPixelBottom) // Is Chipped over setting min value
                //                {
                //                    blnDefect = true;
                //                }
                //                else if ((objChippedOffROI.ref_ROIHeight - fEndY) > 0)   // Make sure object no touch outerEndY
                //                {
                //                    //if (fObjectHeight == intCeilChipLengthY - fTolerance) // Is Chipped same length with chip setting + tolerance
                //                    if (fObjectHeight >= intCeilChipLengthBottom - fToleranceBottom)    // Is Chipped over chip setting - tolerance
                //                    {
                //                        //if (((fObjectCenterY - fObjectHeight / 2) - fInterEndY) <= fTolerance)// Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                //                        //if (((fObjectCenterY - fObjectHeight / 2) - fInterEndY) <= fToleranceBottom)// Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                //                        if ((fStartY - fInterEndY) <= 0.5) // Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                //                        {
                //                            blnDefect = true;
                //                            fAddY = objChippedOffROI.ref_ROIHeight - (fObjectCenterY + fObjectHeight / 2);
                //                        }
                //                    }
                //                }
                //            }
                //        }
                //        else // Confirm Right Chipped
                //        {
                //            if (fObjectWidth >= fDefectLengthPixelRight)  // Is Chipped over setting min value
                //            {
                //                blnDefect = true;
                //                blnFailWidth = true;
                //            }
                //            else if ((objChippedOffROI.ref_ROIWidth - fEndX) > 0)   // Make sure object no touch outerEndX
                //            {
                //                if (fObjectWidth >= intCeilChipLengthRight - fToleranceRight)    // Is Chipped same length with chip setting + tolerance
                //                {
                //                    //if (((fObjectCenterX - fObjectWidth / 2) - fInterEndX) <= fTolerance) // Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                //                    //if (((fObjectCenterX - fObjectWidth / 2) - fInterEndX) <= fToleranceRight) // Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                //                    if ((fStartX - fInterEndX) <= 0.5) // Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                //                    {
                //                        blnDefect = true;
                //                        blnFailWidth = true;
                //                        fAddX = objChippedOffROI.ref_ROIWidth - (fObjectCenterX + fObjectWidth / 2);
                //                    }
                //                }
                //            }
                //        }
                //    }

                //    if (!blnDefect && fStartY < fInterStartY) // Possible Top chipped
                //    {
                //        if (fStartX < fInterStartX) // Possible Left Chipped
                //        {
                //            if (fStartX < fStartY)  // Confirm Left Chipped
                //            {
                //                if (fObjectWidth >= fDefectLengthPixelLeft)  // Is Chipped over setting min value
                //                {
                //                    blnDefect = true;
                //                    blnFailWidth = true;
                //                }
                //                else if ((fObjectCenterX - fObjectWidth / 2) > 0)
                //                {
                //                    //if (fObjectWidth == intCeilChipLengthX - fTolerance)    // Is Chipped same length with chip setting + tolerance
                //                    if (fObjectWidth >= intCeilChipLengthLeft - fToleranceLeft)    // Is Chipped over chip setting - tolerance
                //                    {
                //                        //if ((fInterStartX - (fObjectCenterX + fObjectWidth / 2)) <= fTolerance) // Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                //                        if ((fInterStartX - (fObjectCenterX + fObjectWidth / 2)) <= fToleranceLeft) // Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                //                        {
                //                            blnDefect = true;
                //                            blnFailWidth = true;
                //                            fAddX = fObjectCenterX - fObjectWidth / 2;
                //                        }
                //                    }
                //                }

                //            }
                //            else // Confirm Top Chipped
                //            {
                //                if (fObjectHeight >= fDefectLengthPixelTop) // Is Chipped over setting min value
                //                {
                //                    blnDefect = true;
                //                }
                //                else if ((fObjectCenterY - fObjectHeight / 2) > 0)
                //                {
                //                    //if (fObjectHeight == intCeilChipLengthY - fTolerance) // Is Chipped same length with chip setting + tolerance
                //                    if (fObjectHeight >= intCeilChipLengthTop - fToleranceTop)    // Is Chipped over chip setting - tolerance
                //                    {
                //                        //if ((fInterStartY - (fObjectCenterY + fObjectHeight / 2)) <= fTolerance)// Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                //                        if ((fInterStartY - (fObjectCenterY + fObjectHeight / 2)) <= fToleranceTop)// Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                //                        {
                //                            blnDefect = true;
                //                            fAddY = fObjectCenterY - fObjectHeight / 2;
                //                        }
                //                    }
                //                }
                //            }
                //        }
                //        else if (fEndX > fInterEndX)    // Possible Right Chipped
                //        {
                //            if (fStartY < (objChippedOffROI.ref_ROIWidth - fEndX)) // Confirm Top Chipped
                //            {
                //                if (fObjectHeight >= fDefectLengthPixelTop)  // Is Chipped over setting min value
                //                {
                //                    blnDefect = true;
                //                }
                //                else if ((fObjectCenterY - fObjectHeight / 2) > 0)
                //                {
                //                    //if (fObjectHeight == intCeilChipLengthY - fTolerance) // Is Chipped same length with chip setting + tolerance
                //                    if (fObjectHeight >= intCeilChipLengthTop - fToleranceTop)    // Is Chipped over chip setting - tolerance
                //                    {
                //                        //if ((fInterStartY - (fObjectCenterY + fObjectHeight / 2)) <= fTolerance)// Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                //                        if ((fInterStartY - (fObjectCenterY + fObjectHeight / 2)) <= fToleranceTop)// Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                //                        {
                //                            blnDefect = true;
                //                            fAddY = fObjectCenterY - fObjectHeight / 2;
                //                        }
                //                    }
                //                }
                //            }
                //            else // Confirm Right Chipped
                //            {
                //                if (fObjectWidth >= fDefectLengthPixelRight) // Is Chipped over setting min value
                //                {
                //                    blnDefect = true;
                //                    blnFailWidth = true;
                //                }
                //                else if ((objChippedOffROI.ref_ROIWidth - fEndX) > 0)   // Make sure object no touch outerEndX
                //                {
                //                    //if (fObjectWidth == intCeilChipLengthX - fTolerance)    // Is Chipped same length with chip setting + tolerance
                //                    if (fObjectWidth >= intCeilChipLengthRight - fToleranceRight)    // Is Chipped over chip setting - tolerance
                //                    {
                //                        //if (((fObjectCenterX - fObjectWidth / 2) - fInterEndX) <= fTolerance) // Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                //                        //if (((fObjectCenterX - fObjectWidth / 2) - fInterEndX) <= fToleranceRight) // Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                //                        if ((fStartX - fInterEndX) <= 0.5) // Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                //                        {
                //                            blnDefect = true;
                //                            blnFailWidth = true;
                //                            fAddX = objChippedOffROI.ref_ROIWidth - (fObjectCenterX + fObjectWidth / 2);
                //                        }
                //                    }
                //                }
                //            }
                //        }
                //        else // Confirm Top Chipped
                //        {
                //            if (fObjectHeight >= fDefectLengthPixelTop)  // Is Chipped over setting min value
                //            {
                //                blnDefect = true;
                //            }
                //            else if ((fObjectCenterY - fObjectHeight / 2) > 0)
                //            {
                //                //if (fObjectHeight == intCeilChipLengthY - fTolerance) // Is Chipped same length with chip setting + tolerance
                //                if (fObjectHeight >= intCeilChipLengthTop - fToleranceTop)    // Is Chipped over chip setting - tolerance
                //                {
                //                    //if ((fInterStartY - (fObjectCenterY + fObjectHeight / 2)) <= fTolerance)// Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                //                    if ((fInterStartY - (fObjectCenterY + fObjectHeight / 2)) <= fToleranceTop)// Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                //                    {
                //                        blnDefect = true;
                //                        fAddY = fObjectCenterY - fObjectHeight / 2;
                //                    }
                //                }
                //            }
                //        }
                //    }

                //// 2021 07 27 - CCENG: + 1 to make sure outside the chip area defect will be included.
                ////                   : for example, the fEndY is 166.5, but the fInternEndY is 166. 
                //    if (!blnDefect && fEndY > (fInterEndY + 1)) // Possible Bottom Chipped
                //    {
                //        if (fStartX < fInterStartX) // Possible Left Chipped
                //        {
                //            if (fStartX < (objChippedOffROI.ref_ROIHeight - fEndY))  // Confirm Left Chipped
                //            {
                //                if (fObjectWidth >= fDefectLengthPixelLeft)  // Is Chipped over setting min value
                //                {
                //                    blnDefect = true;
                //                    blnFailWidth = true;
                //                }
                //                else if ((fObjectCenterX - fObjectWidth / 2) > 0)
                //                {
                //                    //if (fObjectWidth == intCeilChipLengthX - fTolerance)    // Is Chipped same length with chip setting + tolerance
                //                    if (fObjectWidth >= intCeilChipLengthLeft - fToleranceLeft)    // Is Chipped over chip setting - tolerance
                //                    {
                //                        //if ((fInterStartX - (fObjectCenterX + fObjectWidth / 2)) <= fTolerance) // Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                //                        if ((fInterStartX - (fObjectCenterX + fObjectWidth / 2)) <= fToleranceLeft) // Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                //                        {
                //                            blnDefect = true;
                //                            blnFailWidth = true;
                //                            fAddX = fObjectCenterX - fObjectWidth / 2;
                //                        }
                //                    }
                //                }

                //            }
                //            else // Confirm Bottom Chipped
                //            {
                //                if (fObjectHeight >= fDefectLengthPixelBottom) // Is Chipped over setting min value
                //                {
                //                    blnDefect = true;
                //                }
                //                else if ((objChippedOffROI.ref_ROIHeight - fEndY) > 0)   // Make sure object no touch outerEndY
                //                {
                //                    //if (fObjectHeight == intCeilChipLengthY - fTolerance) // Is Chipped same length with chip setting + tolerance
                //                    if (fObjectHeight >= intCeilChipLengthBottom - fToleranceBottom)    // Is Chipped over chip setting - tolerance
                //                    {
                //                        //if (((fObjectCenterY - fObjectHeight / 2) - fInterEndY) <= fTolerance)// Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                //                        //if (((fObjectCenterY - fObjectHeight / 2) - fInterEndY) <= fToleranceBottom)// Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                //                        if ((fStartY - fInterEndY) <= 0.5) // Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                //                        {
                //                            blnDefect = true;
                //                            fAddY = objChippedOffROI.ref_ROIHeight - (fObjectCenterY + fObjectHeight / 2);
                //                        }
                //                    }
                //                }
                //            }
                //        }
                //        else if (fEndX > fInterEndX)    // Possible Right Chipped
                //        {
                //            if ((objChippedOffROI.ref_ROIWidth - fEndX) < (objChippedOffROI.ref_ROIHeight - fEndY)) // Confirm Right Chipped
                //            {
                //                if (fObjectWidth >= fDefectLengthPixelRight)  // Is Chipped over setting min value
                //                {
                //                    blnDefect = true;
                //                    blnFailWidth = true;
                //                }
                //                else if ((objChippedOffROI.ref_ROIWidth - fEndX) > 0)   // Make sure object no touch outerEndX
                //                {
                //                    //if (fObjectWidth == intCeilChipLengthX - fTolerance)    // Is Chipped same length with chip setting + tolerance
                //                    if (fObjectWidth >= intCeilChipLengthRight - fToleranceRight)    // Is Chipped over chip setting - tolerance
                //                    {
                //                        //if (((fObjectCenterX - fObjectWidth / 2) - fInterEndX) <= fTolerance) // Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                //                        //if (((fObjectCenterX - fObjectWidth / 2) - fInterEndX) <= fToleranceRight) // Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                //                        if ((fStartX - fInterEndX) <= 0.5) // Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                //                        {
                //                            blnDefect = true;
                //                            blnFailWidth = true;
                //                            fAddX = objChippedOffROI.ref_ROIWidth - (fObjectCenterX + fObjectWidth / 2);
                //                        }
                //                    }
                //                }
                //            }
                //            else // Confirm BOttom Chipped
                //            {
                //                if (fObjectHeight >= fDefectLengthPixelBottom) // Is Chipped over setting min value
                //                {
                //                    blnDefect = true;
                //                }
                //                else if ((objChippedOffROI.ref_ROIHeight - fEndY) > 0)   // Make sure object no touch outerEndY
                //                {
                //                    //if (fObjectHeight == intCeilChipLengthY - fTolerance) // Is Chipped same length with chip setting + tolerance
                //                    if (fObjectHeight >= intCeilChipLengthBottom - fToleranceBottom)    // Is Chipped over chip setting - tolerance
                //                    {
                //                        //if (((fObjectCenterY - fObjectHeight / 2) - fInterEndY) <= fTolerance)// Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                //                        //if (((fObjectCenterY - fObjectHeight / 2) - fInterEndY) <= fToleranceBottom)// Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                //                        if ((fStartY - fInterEndY) <= 0.5) // Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                //                        {
                //                            blnDefect = true;
                //                            fAddY = objChippedOffROI.ref_ROIHeight - (fObjectCenterY + fObjectHeight / 2);
                //                        }
                //                    }
                //                }
                //            }
                //        }
                //        else // Confirm Bottom Chipped
                //        {
                //            if (fObjectHeight >= fDefectLengthPixelBottom)  // Is Chipped over setting min value
                //            {
                //                blnDefect = true;
                //            }
                //            else if ((objChippedOffROI.ref_ROIHeight - fEndY) > 0)   // Make sure object no touch outerEndY
                //            {
                //                //if (fObjectHeight == intCeilChipLengthY - fTolerance) // Is Chipped same length with chip setting + tolerance
                //                if (fObjectHeight >= intCeilChipLengthBottom - fToleranceBottom)    // Is Chipped over chip setting - tolerance
                //                {
                //                    //if (((fObjectCenterY - fObjectHeight / 2) - fInterEndY) <= fTolerance)// Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                //                    //if (((fObjectCenterY - fObjectHeight / 2) - fInterEndY) <= fToleranceBottom)// Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                //                    if ((fStartY - fInterEndY) <= 0.5) // Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                //                    {
                //                        blnDefect = true;
                //                        fAddY = objChippedOffROI.ref_ROIHeight - (fObjectCenterY + fObjectHeight / 2);
                //                    }
                //                }
                //            }
                //        }
                //    }

                //    float fWidthMM = (fObjectWidth + fAddX) / m_fMMToPixelXValue;
                //    float fHeightMM = (fObjectHeight + fAddY) / m_fMMToPixelYValue; // 11-04-2019 ZJYEOH : Changed m_fMMToPixelXValue to m_fMMToPixelYValue
                //    float fAreaInMM = intObjectArea / m_fMMToPixelXValue / m_fMMToPixelYValue;
                //    float fChipAreaLimit;
                //    if (intImageIndex == 1)
                //        fChipAreaLimit = m_fBrightChippedOffArea;
                //    else
                //        fChipAreaLimit = m_fDarkChippedOffArea;

                //    if (blnDefect && fAreaInMM > fChipAreaLimit)
                //    {
                //        intFailCount++;


                //        //0x02
                //        m_intFailPkgResultMask |= 0x04; // Fail image 1 chipped off

                //        Defect objDefect = new Defect();
                //        objDefect.ref_intImageNo = intImageIndex;

                //        objDefect.ref_strName = "Chipped Off";

                //        objDefect.ref_intFailMask = 0x04;//0x02
                //        objDefect.ref_fCenterX = ROITotalX + objChippedOffROI.ref_ROITotalX + fObjectCenterX;
                //        objDefect.ref_fCenterY = ROITotalY + objChippedOffROI.ref_ROITotalY + fObjectCenterY;
                //        objDefect.ref_fStartX = ROITotalX + fStartX;
                //        objDefect.ref_fStartY = ROITotalY + fStartY;
                //        objDefect.ref_fEndX = ROITotalX + fEndX;
                //        objDefect.ref_fEndY = ROITotalY + fEndY;
                //        objDefect.ref_fWidth = fObjectWidth + fAddX;
                //        objDefect.ref_fHeight = fObjectHeight + fAddY;
                //        objDefect.ref_fArea = intObjectArea;
                //        objDefect.ref_fWidthInMM = fWidthMM;
                //        objDefect.ref_fHeightInMM = fHeightMM;
                //        objDefect.ref_fAreaInMM2 = fAreaInMM;

                //        //if (blnFailWidth)
                //        //{
                //        //    objDefect.ref_fFailValue = fWidthMM;
                //        //    objDefect.ref_intFailCriteria |= 0x01;
                //        //}
                //        //else
                //        //{
                //        //    objDefect.ref_fFailValue = fHeightMM;
                //        //    objDefect.ref_intFailCriteria |= 0x02;
                //        //}

                //        objDefect.ref_fFailValue = fAreaInMM;
                //        objDefect.ref_intFailCriteria |= 0x04;

                //        m_arrPkgDefectList.Add(objDefect);

                //        if (blnResult)
                //            blnResult = false;
                //    }

                //}
            }

            objChippedOffROI.Dispose();

            return blnResult;
        }
        private bool IsImage1UnitChippedOff2_Area_SimpleMode_TiltAngle(ROI objImage1UnitROI, int ROITotalX, int ROITotalY, int intImageIndex)
        {
            /*
             * Algoritm:
             * 
             *
             * 
             * 
             * 
             * 
             */
            
            bool blnResult = true;
            bool blnDebugImage = false;
            bool blnBlackOnWhite;
            if (intImageIndex == 1)
                blnBlackOnWhite = false;
            else
                blnBlackOnWhite = true;
            // Get Chipped off setting length in pixel
            //int intCeilChipLengthLeft = (int)Math.Ceiling(m_fChipStartPixelFromLeft);//* m_fMMToPixelXValue
            //int intCeilChipLengthTop = (int)Math.Ceiling(m_fChipStartPixelFromEdge);
            //int intCeilChipLengthRight = (int)Math.Ceiling(m_fChipStartPixelFromRight);
            //int intCeilChipLengthBottom = (int)Math.Ceiling(m_fChipStartPixelFromBottom);

            int intCeilChipLengthLeft = 0;
            int intCeilChipLengthTop = 0;
            int intCeilChipLengthRight = 0;
            int intCeilChipLengthBottom = 0;

            if (intImageIndex == 1)    // White field defect (Scratches, contamination, chip)
            {
                intCeilChipLengthTop = (int)Math.Ceiling(m_fChipStartPixelFromEdge);
                intCeilChipLengthRight = (int)Math.Ceiling(m_fChipStartPixelFromRight);
                intCeilChipLengthBottom = (int)Math.Ceiling(m_fChipStartPixelFromBottom);
                intCeilChipLengthLeft = (int)Math.Ceiling(m_fChipStartPixelFromLeft);

            }
            else // Black field defect (Crack, void, chip)
            {
                intCeilChipLengthTop = (int)Math.Ceiling(m_fChipStartPixelFromEdge_Dark);
                intCeilChipLengthRight = (int)Math.Ceiling(m_fChipStartPixelFromRight_Dark);
                intCeilChipLengthBottom = (int)Math.Ceiling(m_fChipStartPixelFromBottom_Dark);
                intCeilChipLengthLeft = (int)Math.Ceiling(m_fChipStartPixelFromLeft_Dark);

            }

            int intCeilChipLengthLeft_Extend = 0;
            int intCeilChipLengthTop_Extend = 0;
            int intCeilChipLengthRight_Extend = 0;
            int intCeilChipLengthBottom_Extend = 0;

            if (intImageIndex == 1)    // White field defect (Scratches, contamination, chip)
            {
                intCeilChipLengthTop_Extend = (int)Math.Ceiling(m_fChipStartPixelExtendFromEdge);
                intCeilChipLengthRight_Extend = (int)Math.Ceiling(m_fChipStartPixelExtendFromRight);
                intCeilChipLengthBottom_Extend = (int)Math.Ceiling(m_fChipStartPixelExtendFromBottom);
                intCeilChipLengthLeft_Extend = (int)Math.Ceiling(m_fChipStartPixelExtendFromLeft);

            }
            else // Black field defect (Crack, void, chip)
            {
                intCeilChipLengthTop_Extend = (int)Math.Ceiling(m_fChipStartPixelExtendFromEdge_Dark);
                intCeilChipLengthRight_Extend = (int)Math.Ceiling(m_fChipStartPixelExtendFromRight_Dark);
                intCeilChipLengthBottom_Extend = (int)Math.Ceiling(m_fChipStartPixelExtendFromBottom_Dark);
                intCeilChipLengthLeft_Extend = (int)Math.Ceiling(m_fChipStartPixelExtendFromLeft_Dark);

            }

            ROI objChippedOffROI = new ROI();
            objChippedOffROI.AttachImage(objImage1UnitROI); // m_objInsSurfacePkgImage1 is sample image after double threshold
            //objChippedOffROI.LoadROISetting(objImage1UnitROI.ref_ROITotalX,
            //                                            objImage1UnitROI.ref_ROITotalY,
            //                                            objImage1UnitROI.ref_ROIWidth,
            //                                            objImage1UnitROI.ref_ROIHeight);
            objChippedOffROI.LoadROISetting(0, 0, objImage1UnitROI.ref_ROIWidth, objImage1UnitROI.ref_ROIHeight);
            objChippedOffROI.CopyToImage(ref m_objInsChipOffPkgImage1); // Copy sample image to another image memory so that image can be modified without affect the original image.
            objChippedOffROI.AttachImage(m_objInsChipOffPkgImage1);
            objChippedOffROI.LoadROISetting(0, 0, m_objInsChipOffPkgImage1.ref_intImageWidth, m_objInsChipOffPkgImage1.ref_intImageHeight);

            if (intImageIndex == 1)
                FillChipLineLimitToCorner_4Edges_TiltAngle(m_objInsChipOffPkgImage1, intCeilChipLengthLeft, intCeilChipLengthTop, intCeilChipLengthRight, intCeilChipLengthBottom, 0);
            else
                FillChipLineLimitToCorner_4Edges_TiltAngle(m_objInsChipOffPkgImage1, intCeilChipLengthLeft, intCeilChipLengthTop, intCeilChipLengthRight, intCeilChipLengthBottom, 255);

            switch (intImageIndex)
            {
                case 1: // Image 1 (Grab 1 & Grab 2 Merged)
                    {
                        //2019-09-23 ZJYEOH : Subtract tilt dont care area 
                        if (m_intPadROIDirection == 1) // Top
                        {
                            if (blnDebugImage)
                                objChippedOffROI.SaveImage("D:\\TS\\ChippedOff_objChippedOffROIOriTop.bmp");

                            #region Doncare outside the Unit
                            ROI DontCareTop = new ROI();
                            DontCareTop.LoadROISetting(0, 0, objChippedOffROI.ref_ROIWidth, objChippedOffROI.ref_ROIHeight);
                            DontCareTop.AttachImage(m_ImgTilt_Top_L);
                            EasyImage.Oper(EArithmeticLogicOperation.Subtract, objChippedOffROI.ref_ROI, DontCareTop.ref_ROI, objChippedOffROI.ref_ROI);
                            DontCareTop.LoadROISetting(m_ImgTilt_Top_R.ref_intImageWidth - objChippedOffROI.ref_ROIWidth, 0, objChippedOffROI.ref_ROIWidth, objChippedOffROI.ref_ROIHeight);
                            DontCareTop.AttachImage(m_ImgTilt_Top_R);
                            EasyImage.Oper(EArithmeticLogicOperation.Subtract, objChippedOffROI.ref_ROI, DontCareTop.ref_ROI, objChippedOffROI.ref_ROI);
                            if (blnDebugImage)
                                objChippedOffROI.SaveImage("D:\\TS\\ChippedOff_objChippedOffROITop.bmp");
                            DontCareTop.Dispose();
                            #endregion

                            #region Dontcare Inner according Chipped Off ROI Setting
                            ROI ChipInnerROI = new ROI();

                            ImageDrawing DontCareImg = new ImageDrawing(objImage1UnitROI.ref_ROIWidth, objImage1UnitROI.ref_ROIHeight);
                            ROI DontCareTop1 = new ROI();
                            ROI DontCareTop2 = new ROI();
                            ROI DontCareTop3 = new ROI();

                            DontCareTop3.LoadROISetting(0, 0, objChippedOffROI.ref_ROIWidth - intCeilChipLengthLeft + intCeilChipLengthLeft_Extend - intCeilChipLengthRight + intCeilChipLengthRight_Extend,
                                objChippedOffROI.ref_ROIHeight - intCeilChipLengthTop + intCeilChipLengthTop_Extend - intCeilChipLengthBottom + intCeilChipLengthBottom_Extend);
                            DontCareTop3.AttachImage(DontCareImg);
                            ChipInnerROI.LoadROISetting(intCeilChipLengthLeft - intCeilChipLengthLeft_Extend,
                                intCeilChipLengthTop - intCeilChipLengthTop_Extend,
                                objChippedOffROI.ref_ROIWidth - intCeilChipLengthLeft + intCeilChipLengthLeft_Extend - intCeilChipLengthRight + intCeilChipLengthRight_Extend,
                                objChippedOffROI.ref_ROIHeight - intCeilChipLengthTop + intCeilChipLengthTop_Extend - intCeilChipLengthBottom + intCeilChipLengthBottom_Extend);

                            ChipInnerROI.AttachImage(objChippedOffROI);
                            DontCareTop1.LoadROISetting(0, 0,
                                objChippedOffROI.ref_ROIWidth - intCeilChipLengthLeft + intCeilChipLengthLeft_Extend - intCeilChipLengthRight + intCeilChipLengthRight_Extend,
                                objChippedOffROI.ref_ROIHeight - intCeilChipLengthTop + intCeilChipLengthTop_Extend - intCeilChipLengthBottom + intCeilChipLengthBottom_Extend);
                            DontCareTop1.AttachImage(m_ImgTiltInverted_Top_L);

                            DontCareTop2.LoadROISetting(m_ImgTiltInverted_Top_R.ref_intImageWidth - (objChippedOffROI.ref_ROIWidth - intCeilChipLengthLeft + intCeilChipLengthLeft_Extend - intCeilChipLengthRight + intCeilChipLengthRight_Extend),
                                0,
                                objChippedOffROI.ref_ROIWidth - intCeilChipLengthLeft + intCeilChipLengthLeft_Extend - intCeilChipLengthRight + intCeilChipLengthRight_Extend,
                                objChippedOffROI.ref_ROIHeight - intCeilChipLengthTop + intCeilChipLengthTop_Extend - intCeilChipLengthBottom + intCeilChipLengthBottom_Extend);
                            DontCareTop2.AttachImage(m_ImgTiltInverted_Top_R);
                            if (blnDebugImage)
                                DontCareTop1.SaveImage("D:\\TS\\DontCareTop1.bmp");
                            if (blnDebugImage)
                                DontCareTop2.SaveImage("D:\\TS\\DontCareTop2.bmp");
                            EasyImage.Oper(EArithmeticLogicOperation.LogicalAnd, DontCareTop1.ref_ROI, DontCareTop2.ref_ROI, DontCareTop3.ref_ROI);
                            if (blnDebugImage)
                                DontCareTop3.SaveImage("D:\\TS\\DontCareTop3.bmp");

                            EasyImage.Oper(EArithmeticLogicOperation.Subtract, ChipInnerROI.ref_ROI, DontCareTop3.ref_ROI, ChipInnerROI.ref_ROI);
                            if (blnDebugImage)
                                objChippedOffROI.SaveImage("D:\\TS\\ChippedOff_objChippedOffROITop1.bmp");

                            m_objImage1ChipOffEBlobs.BuildObjects_Filter_GetElement(objChippedOffROI, blnBlackOnWhite, true, 0, 125,
                                 (int)Math.Floor(m_fSurfaceMinArea), objChippedOffROI.ref_ROIHeight * objChippedOffROI.ref_ROIWidth, false, 0x0F);

                            #endregion

                            #region Dontcare Inner according Chipped Off ROI Setting + 2 Pixels
                            // 2 Pixel
                            DontCareTop3.LoadROISetting(0, 0,
                                objChippedOffROI.ref_ROIWidth - intCeilChipLengthLeft + intCeilChipLengthLeft_Extend - intCeilChipLengthRight + intCeilChipLengthRight_Extend + 4,
                                objChippedOffROI.ref_ROIHeight - intCeilChipLengthTop + intCeilChipLengthTop_Extend - intCeilChipLengthBottom + intCeilChipLengthBottom_Extend + 4);
                            DontCareTop3.AttachImage(DontCareImg);
                            ChipInnerROI.LoadROISetting(intCeilChipLengthLeft - intCeilChipLengthLeft_Extend - 2,
                                intCeilChipLengthTop - intCeilChipLengthTop_Extend - 2,
                                objChippedOffROI.ref_ROIWidth - intCeilChipLengthLeft + intCeilChipLengthLeft_Extend - intCeilChipLengthRight + intCeilChipLengthRight_Extend + 4,
                                objChippedOffROI.ref_ROIHeight - intCeilChipLengthTop + intCeilChipLengthTop_Extend - intCeilChipLengthBottom + intCeilChipLengthBottom_Extend + 4);

                            ChipInnerROI.AttachImage(objChippedOffROI);
                            DontCareTop1.LoadROISetting(0, 0, 
                                objChippedOffROI.ref_ROIWidth - intCeilChipLengthLeft + intCeilChipLengthLeft_Extend - intCeilChipLengthRight + intCeilChipLengthRight_Extend + 4,
                                objChippedOffROI.ref_ROIHeight - intCeilChipLengthTop + intCeilChipLengthTop_Extend - intCeilChipLengthBottom + intCeilChipLengthBottom_Extend + 4);
                            DontCareTop1.AttachImage(m_ImgTiltInverted_Top_L);

                            DontCareTop2.LoadROISetting(m_ImgTiltInverted_Top_R.ref_intImageWidth - (objChippedOffROI.ref_ROIWidth - intCeilChipLengthLeft + intCeilChipLengthLeft_Extend - intCeilChipLengthRight + intCeilChipLengthRight_Extend + 4),
                                0,
                                objChippedOffROI.ref_ROIWidth - intCeilChipLengthLeft + intCeilChipLengthLeft_Extend - intCeilChipLengthRight + intCeilChipLengthRight_Extend + 4,
                                objChippedOffROI.ref_ROIHeight - intCeilChipLengthTop + intCeilChipLengthTop_Extend - intCeilChipLengthBottom + intCeilChipLengthBottom_Extend + 4);
                            DontCareTop2.AttachImage(m_ImgTiltInverted_Top_R);
                            if (blnDebugImage)
                                DontCareTop1.SaveImage("D:\\TS\\DontCareTop12.bmp");
                            if (blnDebugImage)
                                DontCareTop2.SaveImage("D:\\TS\\DontCareTop22.bmp");
                            EasyImage.Oper(EArithmeticLogicOperation.LogicalAnd, DontCareTop1.ref_ROI, DontCareTop2.ref_ROI, DontCareTop3.ref_ROI);
                            if (blnDebugImage)
                                DontCareTop3.SaveImage("D:\\TS\\DontCareTop32.bmp");

                            EasyImage.Oper(EArithmeticLogicOperation.Subtract, ChipInnerROI.ref_ROI, DontCareTop3.ref_ROI, ChipInnerROI.ref_ROI);
                            if (blnDebugImage)
                                objChippedOffROI.SaveImage("D:\\TS\\ChippedOff_objChippedOffROITop2.bmp");

                            m_objImage1ChipOffEBlobsFor2Pixel.BuildObjects_Filter_GetElement(objChippedOffROI, blnBlackOnWhite, true, 0, 125,
                               (int)Math.Floor(m_fSurfaceMinArea), objChippedOffROI.ref_ROIHeight * objChippedOffROI.ref_ROIWidth, false, 0x0F);

                            DontCareTop1.Dispose();
                            DontCareTop2.Dispose();
                            DontCareTop3.Dispose();
                            ChipInnerROI.Dispose();
                            DontCareImg.Dispose();
                            #endregion
                        }
                        if (m_intPadROIDirection == 2) // Right
                        {
                            if (blnDebugImage)
                                objChippedOffROI.SaveImage("D:\\TS\\ChippedOff_objChippedOffROIOriRight.bmp");
                            #region Doncare outside the Unit
                            ROI DontCareRight = new ROI();
                            DontCareRight.LoadROISetting(m_ImgTilt_Top_R.ref_intImageWidth - objChippedOffROI.ref_ROIWidth, 0, objChippedOffROI.ref_ROIWidth, objChippedOffROI.ref_ROIHeight);
                            DontCareRight.AttachImage(m_ImgTilt_Right_T);
                            EasyImage.Oper(EArithmeticLogicOperation.Subtract, objChippedOffROI.ref_ROI, DontCareRight.ref_ROI, objChippedOffROI.ref_ROI);
                            DontCareRight.LoadROISetting(m_ImgTilt_Top_R.ref_intImageWidth - objChippedOffROI.ref_ROIWidth, m_ImgTilt_Top_R.ref_intImageHeight - objChippedOffROI.ref_ROIHeight, objChippedOffROI.ref_ROIWidth, objChippedOffROI.ref_ROIHeight);
                            DontCareRight.AttachImage(m_ImgTilt_Right_B);
                            EasyImage.Oper(EArithmeticLogicOperation.Subtract, objChippedOffROI.ref_ROI, DontCareRight.ref_ROI, objChippedOffROI.ref_ROI);
                            if (blnDebugImage)
                                objChippedOffROI.SaveImage("D:\\TS\\ChippedOff_objChippedOffROIRight.bmp");
                            DontCareRight.Dispose();
                            #endregion

                            #region Dontcare Inner according Chipped Off ROI Setting
                            ROI ChipInnerROI = new ROI();

                            ImageDrawing DontCareImg = new ImageDrawing(objImage1UnitROI.ref_ROIWidth, objImage1UnitROI.ref_ROIHeight);
                            ROI DontCareRight1 = new ROI();
                            ROI DontCareRight2 = new ROI();
                            ROI DontCareRight3 = new ROI();

                            DontCareRight3.LoadROISetting(0, 0,
                                objChippedOffROI.ref_ROIWidth - intCeilChipLengthLeft + intCeilChipLengthLeft_Extend - intCeilChipLengthRight + intCeilChipLengthRight_Extend,
                                objChippedOffROI.ref_ROIHeight - intCeilChipLengthTop + intCeilChipLengthTop_Extend - intCeilChipLengthBottom + intCeilChipLengthBottom_Extend);
                            DontCareRight3.AttachImage(DontCareImg);
                            ChipInnerROI.LoadROISetting(intCeilChipLengthLeft - intCeilChipLengthLeft_Extend,
                                intCeilChipLengthTop - intCeilChipLengthTop_Extend,
                                objChippedOffROI.ref_ROIWidth - intCeilChipLengthLeft + intCeilChipLengthLeft_Extend - intCeilChipLengthRight + intCeilChipLengthRight_Extend,
                                objChippedOffROI.ref_ROIHeight - intCeilChipLengthTop + intCeilChipLengthTop_Extend - intCeilChipLengthBottom + intCeilChipLengthBottom_Extend);

                            ChipInnerROI.AttachImage(objChippedOffROI);
                            DontCareRight1.LoadROISetting(m_ImgTiltInverted_Right_T.ref_intImageWidth - (objChippedOffROI.ref_ROIWidth - intCeilChipLengthLeft + intCeilChipLengthLeft_Extend - intCeilChipLengthRight + intCeilChipLengthRight_Extend),
                                0,
                                objChippedOffROI.ref_ROIWidth - intCeilChipLengthLeft + intCeilChipLengthLeft_Extend - intCeilChipLengthRight + intCeilChipLengthRight_Extend,
                                objChippedOffROI.ref_ROIHeight - intCeilChipLengthTop + intCeilChipLengthTop_Extend - intCeilChipLengthBottom + intCeilChipLengthBottom_Extend);
                            DontCareRight1.AttachImage(m_ImgTiltInverted_Right_T);

                            DontCareRight2.LoadROISetting(m_ImgTiltInverted_Right_B.ref_intImageWidth - (objChippedOffROI.ref_ROIWidth - intCeilChipLengthLeft + intCeilChipLengthLeft_Extend - intCeilChipLengthRight + intCeilChipLengthRight_Extend),
                                m_ImgTiltInverted_Right_B.ref_intImageHeight - (objChippedOffROI.ref_ROIHeight - intCeilChipLengthTop + intCeilChipLengthTop_Extend - intCeilChipLengthBottom + intCeilChipLengthBottom_Extend),
                                objChippedOffROI.ref_ROIWidth - intCeilChipLengthLeft + intCeilChipLengthLeft_Extend - intCeilChipLengthRight + intCeilChipLengthRight_Extend,
                                objChippedOffROI.ref_ROIHeight - intCeilChipLengthTop + intCeilChipLengthTop_Extend - intCeilChipLengthBottom + intCeilChipLengthBottom_Extend);
                            DontCareRight2.AttachImage(m_ImgTiltInverted_Right_B);
                            if (blnDebugImage)
                                DontCareRight1.SaveImage("D:\\TS\\DontCareRight1.bmp");
                            if (blnDebugImage)
                                DontCareRight2.SaveImage("D:\\TS\\DontCareRight2.bmp");
                            EasyImage.Oper(EArithmeticLogicOperation.LogicalAnd, DontCareRight1.ref_ROI, DontCareRight2.ref_ROI, DontCareRight3.ref_ROI);
                            if (blnDebugImage)
                                DontCareRight3.SaveImage("D:\\TS\\DontCareRight3.bmp");

                            EasyImage.Oper(EArithmeticLogicOperation.Subtract, ChipInnerROI.ref_ROI, DontCareRight3.ref_ROI, ChipInnerROI.ref_ROI);
                            if (blnDebugImage)
                                objChippedOffROI.SaveImage("D:\\TS\\ChippedOff_objChippedOffROIRight1.bmp");

                            m_objImage1ChipOffEBlobs.BuildObjects_Filter_GetElement(objChippedOffROI, blnBlackOnWhite, true, 0, 125,
                            (int)Math.Floor(m_fSurfaceMinArea), objChippedOffROI.ref_ROIHeight * objChippedOffROI.ref_ROIWidth, false, 0x0F);
                            #endregion

                            #region Dontcare Inner according Chipped Off ROI Setting + 2 Pixels
                            // 2 Pixel
                            DontCareRight3.LoadROISetting(0, 0,
                                objChippedOffROI.ref_ROIWidth - intCeilChipLengthLeft + intCeilChipLengthLeft_Extend - intCeilChipLengthRight + intCeilChipLengthRight_Extend + 4,
                                objChippedOffROI.ref_ROIHeight - intCeilChipLengthTop + intCeilChipLengthTop_Extend - intCeilChipLengthBottom + intCeilChipLengthBottom_Extend + 4);
                            DontCareRight3.AttachImage(DontCareImg);
                            ChipInnerROI.LoadROISetting(intCeilChipLengthLeft - intCeilChipLengthLeft_Extend - 2,
                                intCeilChipLengthTop - intCeilChipLengthTop_Extend - 2,
                                objChippedOffROI.ref_ROIWidth - intCeilChipLengthLeft + intCeilChipLengthLeft_Extend - intCeilChipLengthRight + intCeilChipLengthRight_Extend + 4,
                                objChippedOffROI.ref_ROIHeight - intCeilChipLengthTop + intCeilChipLengthTop_Extend - intCeilChipLengthBottom + intCeilChipLengthBottom_Extend + 4);

                            ChipInnerROI.AttachImage(objChippedOffROI);
                            DontCareRight1.LoadROISetting(m_ImgTiltInverted_Right_T.ref_intImageWidth - (objChippedOffROI.ref_ROIWidth - intCeilChipLengthLeft + intCeilChipLengthLeft_Extend - intCeilChipLengthRight + intCeilChipLengthRight_Extend + 4),
                                0,
                                objChippedOffROI.ref_ROIWidth - intCeilChipLengthLeft + intCeilChipLengthLeft_Extend - intCeilChipLengthRight + intCeilChipLengthRight_Extend + 4,
                                objChippedOffROI.ref_ROIHeight - intCeilChipLengthTop + intCeilChipLengthTop_Extend - intCeilChipLengthBottom + intCeilChipLengthBottom_Extend + 4);
                            DontCareRight1.AttachImage(m_ImgTiltInverted_Right_T);

                            DontCareRight2.LoadROISetting(m_ImgTiltInverted_Right_B.ref_intImageWidth - (objChippedOffROI.ref_ROIWidth - intCeilChipLengthLeft + intCeilChipLengthLeft_Extend - intCeilChipLengthRight + intCeilChipLengthRight_Extend + 4),
                                m_ImgTiltInverted_Right_B.ref_intImageHeight - (objChippedOffROI.ref_ROIHeight - intCeilChipLengthTop + intCeilChipLengthTop_Extend - intCeilChipLengthBottom + intCeilChipLengthBottom_Extend + 4),
                                objChippedOffROI.ref_ROIWidth - intCeilChipLengthLeft + intCeilChipLengthLeft_Extend - intCeilChipLengthRight + intCeilChipLengthRight_Extend + 4,
                                objChippedOffROI.ref_ROIHeight - intCeilChipLengthTop + intCeilChipLengthTop_Extend - intCeilChipLengthBottom + intCeilChipLengthBottom_Extend + 4);
                            DontCareRight2.AttachImage(m_ImgTiltInverted_Right_B);
                            if (blnDebugImage)
                                DontCareRight1.SaveImage("D:\\TS\\DontCareRight12.bmp");
                            if (blnDebugImage)
                                DontCareRight2.SaveImage("D:\\TS\\DontCareRight22.bmp");
                            EasyImage.Oper(EArithmeticLogicOperation.LogicalAnd, DontCareRight1.ref_ROI, DontCareRight2.ref_ROI, DontCareRight3.ref_ROI);
                            if (blnDebugImage)
                                DontCareRight3.SaveImage("D:\\TS\\DontCareRight32.bmp");

                            EasyImage.Oper(EArithmeticLogicOperation.Subtract, ChipInnerROI.ref_ROI, DontCareRight3.ref_ROI, ChipInnerROI.ref_ROI);
                            if (blnDebugImage)
                                objChippedOffROI.SaveImage("D:\\TS\\ChippedOff_objChippedOffROIRight2.bmp");

                            m_objImage1ChipOffEBlobsFor2Pixel.BuildObjects_Filter_GetElement(objChippedOffROI, blnBlackOnWhite, true, 0, 125,
                            (int)Math.Floor(m_fSurfaceMinArea), objChippedOffROI.ref_ROIHeight * objChippedOffROI.ref_ROIWidth, false, 0x0F);

                            DontCareRight1.Dispose();
                            DontCareRight2.Dispose();
                            DontCareRight3.Dispose();
                            ChipInnerROI.Dispose();
                            DontCareImg.Dispose();
                            #endregion

                        }
                        if (m_intPadROIDirection == 3) // Bottom
                        {
                            if (blnDebugImage)
                                objChippedOffROI.SaveImage("D:\\TS\\ChippedOff_objChippedOffROIOriBottom.bmp");
                            #region Doncare outside the Unit
                            ROI DontCareBottom = new ROI();

                            DontCareBottom.LoadROISetting(0, m_ImgTilt_Top_R.ref_intImageHeight - objChippedOffROI.ref_ROIHeight, objChippedOffROI.ref_ROIWidth, objChippedOffROI.ref_ROIHeight);
                            DontCareBottom.AttachImage(m_ImgTilt_Bottom_L);
                            EasyImage.Oper(EArithmeticLogicOperation.Subtract, objChippedOffROI.ref_ROI, DontCareBottom.ref_ROI, objChippedOffROI.ref_ROI);
                            DontCareBottom.LoadROISetting(m_ImgTilt_Top_R.ref_intImageWidth - objChippedOffROI.ref_ROIWidth, m_ImgTilt_Top_R.ref_intImageHeight - objChippedOffROI.ref_ROIHeight, objChippedOffROI.ref_ROIWidth, objChippedOffROI.ref_ROIHeight);
                            DontCareBottom.AttachImage(m_ImgTilt_Bottom_R);
                            EasyImage.Oper(EArithmeticLogicOperation.Subtract, objChippedOffROI.ref_ROI, DontCareBottom.ref_ROI, objChippedOffROI.ref_ROI);
                            if (blnDebugImage)
                                objChippedOffROI.SaveImage("D:\\TS\\ChippedOff_objChippedOffROIBottom.bmp");
                            DontCareBottom.Dispose();
                            #endregion

                            #region Dontcare Inner according Chipped Off ROI Setting
                            ROI ChipInnerROI = new ROI();

                            ImageDrawing DontCareImg = new ImageDrawing(objImage1UnitROI.ref_ROIWidth, objImage1UnitROI.ref_ROIHeight);
                            ROI DontCareBottom1 = new ROI();
                            ROI DontCareBottom2 = new ROI();
                            ROI DontCareBottom3 = new ROI();

                            DontCareBottom3.LoadROISetting(0, 0, 
                                objChippedOffROI.ref_ROIWidth - intCeilChipLengthLeft + intCeilChipLengthLeft_Extend - intCeilChipLengthRight + intCeilChipLengthRight_Extend,
                                objChippedOffROI.ref_ROIHeight - intCeilChipLengthTop + intCeilChipLengthTop_Extend - intCeilChipLengthBottom + intCeilChipLengthBottom_Extend);
                            DontCareBottom3.AttachImage(DontCareImg);
                            ChipInnerROI.LoadROISetting(intCeilChipLengthLeft - intCeilChipLengthLeft_Extend,
                                intCeilChipLengthTop - intCeilChipLengthTop_Extend,
                                objChippedOffROI.ref_ROIWidth - intCeilChipLengthLeft + intCeilChipLengthLeft_Extend - intCeilChipLengthRight + intCeilChipLengthRight_Extend,
                                objChippedOffROI.ref_ROIHeight - intCeilChipLengthTop + intCeilChipLengthTop_Extend - intCeilChipLengthBottom + intCeilChipLengthBottom_Extend);

                            ChipInnerROI.AttachImage(objChippedOffROI);
                            DontCareBottom1.LoadROISetting(0,
                                m_ImgTiltInverted_Bottom_L.ref_intImageHeight - (objChippedOffROI.ref_ROIHeight - intCeilChipLengthTop + intCeilChipLengthTop_Extend - intCeilChipLengthBottom + intCeilChipLengthBottom_Extend),
                                objChippedOffROI.ref_ROIWidth - intCeilChipLengthLeft + intCeilChipLengthLeft_Extend - intCeilChipLengthRight + intCeilChipLengthRight_Extend,
                                objChippedOffROI.ref_ROIHeight - intCeilChipLengthTop + intCeilChipLengthTop_Extend - intCeilChipLengthBottom + intCeilChipLengthBottom_Extend);
                            DontCareBottom1.AttachImage(m_ImgTiltInverted_Bottom_L);

                            DontCareBottom2.LoadROISetting(m_ImgTiltInverted_Bottom_R.ref_intImageWidth - (objChippedOffROI.ref_ROIWidth - intCeilChipLengthLeft + intCeilChipLengthLeft_Extend - intCeilChipLengthRight + intCeilChipLengthRight_Extend),
                                m_ImgTiltInverted_Bottom_R.ref_intImageHeight - (objChippedOffROI.ref_ROIHeight - intCeilChipLengthTop + intCeilChipLengthTop_Extend - intCeilChipLengthBottom + intCeilChipLengthBottom_Extend),
                                objChippedOffROI.ref_ROIWidth - intCeilChipLengthLeft + intCeilChipLengthLeft_Extend - intCeilChipLengthRight + intCeilChipLengthRight_Extend,
                                objChippedOffROI.ref_ROIHeight - intCeilChipLengthTop + intCeilChipLengthTop_Extend - intCeilChipLengthBottom + intCeilChipLengthBottom_Extend);
                            DontCareBottom2.AttachImage(m_ImgTiltInverted_Bottom_R);
                            if (blnDebugImage)
                                DontCareBottom1.SaveImage("D:\\TS\\DontCareBottom1.bmp");
                            if (blnDebugImage)
                                DontCareBottom2.SaveImage("D:\\TS\\DontCareBottom2.bmp");
                            EasyImage.Oper(EArithmeticLogicOperation.LogicalAnd, DontCareBottom1.ref_ROI, DontCareBottom2.ref_ROI, DontCareBottom3.ref_ROI);
                            if (blnDebugImage)
                                DontCareBottom3.SaveImage("D:\\TS\\DontCareBottom3.bmp");

                            EasyImage.Oper(EArithmeticLogicOperation.Subtract, ChipInnerROI.ref_ROI, DontCareBottom3.ref_ROI, ChipInnerROI.ref_ROI);
                            if (blnDebugImage)
                                objChippedOffROI.SaveImage("D:\\TS\\ChippedOff_objChippedOffROIBottom1.bmp");

                            m_objImage1ChipOffEBlobs.BuildObjects_Filter_GetElement(objChippedOffROI, blnBlackOnWhite, true, 0, 125,
                            (int)Math.Floor(m_fSurfaceMinArea), objChippedOffROI.ref_ROIHeight * objChippedOffROI.ref_ROIWidth, false, 0x0F);
                            #endregion

                            #region Dontcare Inner according Chipped Off ROI Setting + 2 Pixels
                            // 2 Pixel
                            DontCareBottom3.LoadROISetting(0, 0,
                                objChippedOffROI.ref_ROIWidth - intCeilChipLengthLeft + intCeilChipLengthLeft_Extend - intCeilChipLengthRight + intCeilChipLengthRight_Extend + 4,
                                objChippedOffROI.ref_ROIHeight - intCeilChipLengthTop + intCeilChipLengthTop_Extend - intCeilChipLengthBottom + intCeilChipLengthBottom_Extend + 4);
                            DontCareBottom3.AttachImage(DontCareImg);
                            ChipInnerROI.LoadROISetting(intCeilChipLengthLeft - intCeilChipLengthLeft_Extend - 2,
                                intCeilChipLengthTop - intCeilChipLengthTop_Extend - 2,
                                objChippedOffROI.ref_ROIWidth - intCeilChipLengthLeft + intCeilChipLengthLeft_Extend - intCeilChipLengthRight + intCeilChipLengthRight_Extend + 4,
                                objChippedOffROI.ref_ROIHeight - intCeilChipLengthTop + intCeilChipLengthTop_Extend - intCeilChipLengthBottom + intCeilChipLengthBottom_Extend + 4);

                            ChipInnerROI.AttachImage(objChippedOffROI);
                            DontCareBottom1.LoadROISetting(0,
                                m_ImgTiltInverted_Bottom_L.ref_intImageHeight - (objChippedOffROI.ref_ROIHeight - intCeilChipLengthTop + intCeilChipLengthTop_Extend - intCeilChipLengthBottom + intCeilChipLengthBottom_Extend + 4),
                                objChippedOffROI.ref_ROIWidth - intCeilChipLengthLeft + intCeilChipLengthLeft_Extend - intCeilChipLengthRight + intCeilChipLengthRight_Extend + 4,
                                objChippedOffROI.ref_ROIHeight - intCeilChipLengthTop + intCeilChipLengthTop_Extend - intCeilChipLengthBottom + intCeilChipLengthBottom_Extend + 4);
                            DontCareBottom1.AttachImage(m_ImgTiltInverted_Bottom_L);

                            DontCareBottom2.LoadROISetting(m_ImgTiltInverted_Bottom_R.ref_intImageWidth - (objChippedOffROI.ref_ROIWidth - intCeilChipLengthLeft + intCeilChipLengthLeft_Extend - intCeilChipLengthRight + intCeilChipLengthRight_Extend + 4),
                                m_ImgTiltInverted_Bottom_R.ref_intImageHeight - (objChippedOffROI.ref_ROIHeight - intCeilChipLengthTop + intCeilChipLengthTop_Extend - intCeilChipLengthBottom + intCeilChipLengthBottom_Extend + 4),
                                objChippedOffROI.ref_ROIWidth - intCeilChipLengthLeft + intCeilChipLengthLeft_Extend - intCeilChipLengthRight + intCeilChipLengthRight_Extend + 4,
                                objChippedOffROI.ref_ROIHeight - intCeilChipLengthTop + intCeilChipLengthTop_Extend - intCeilChipLengthBottom + intCeilChipLengthBottom_Extend + 4);
                            DontCareBottom2.AttachImage(m_ImgTiltInverted_Bottom_R);
                            if (blnDebugImage)
                                DontCareBottom1.SaveImage("D:\\TS\\DontCareBottom12.bmp");
                            if (blnDebugImage)
                                DontCareBottom2.SaveImage("D:\\TS\\DontCareBottom22.bmp");
                            EasyImage.Oper(EArithmeticLogicOperation.LogicalAnd, DontCareBottom1.ref_ROI, DontCareBottom2.ref_ROI, DontCareBottom3.ref_ROI);
                            if (blnDebugImage)
                                DontCareBottom3.SaveImage("D:\\TS\\DontCareBottom32.bmp");

                            EasyImage.Oper(EArithmeticLogicOperation.Subtract, ChipInnerROI.ref_ROI, DontCareBottom3.ref_ROI, ChipInnerROI.ref_ROI);
                            if (blnDebugImage)
                                objChippedOffROI.SaveImage("D:\\TS\\ChippedOff_objChippedOffROIBottom2.bmp");

                            m_objImage1ChipOffEBlobsFor2Pixel.BuildObjects_Filter_GetElement(objChippedOffROI, blnBlackOnWhite, true, 0, 125,
                            (int)Math.Floor(m_fSurfaceMinArea), objChippedOffROI.ref_ROIHeight * objChippedOffROI.ref_ROIWidth, false, 0x0F);

                            DontCareBottom1.Dispose();
                            DontCareBottom2.Dispose();
                            DontCareBottom3.Dispose();
                            ChipInnerROI.Dispose();
                            DontCareImg.Dispose();
                            #endregion
                        }
                        if (m_intPadROIDirection == 4) // Left
                        {
                            if (blnDebugImage)
                                objChippedOffROI.SaveImage("D:\\TS\\ChippedOff_objChippedOffROIOriLeft.bmp");
                            #region Doncare outside the Unit
                            ROI DontCareLeft = new ROI();

                            DontCareLeft.LoadROISetting(0, 0, objChippedOffROI.ref_ROIWidth, objChippedOffROI.ref_ROIHeight);
                            DontCareLeft.AttachImage(m_ImgTilt_Left_T);
                            EasyImage.Oper(EArithmeticLogicOperation.Subtract, objChippedOffROI.ref_ROI, DontCareLeft.ref_ROI, objChippedOffROI.ref_ROI);
                            DontCareLeft.LoadROISetting(0, m_ImgTilt_Top_R.ref_intImageHeight - objChippedOffROI.ref_ROIHeight, objChippedOffROI.ref_ROIWidth, objChippedOffROI.ref_ROIHeight);
                            DontCareLeft.AttachImage(m_ImgTilt_Left_B);
                            EasyImage.Oper(EArithmeticLogicOperation.Subtract, objChippedOffROI.ref_ROI, DontCareLeft.ref_ROI, objChippedOffROI.ref_ROI);
                            if (blnDebugImage)
                                objChippedOffROI.SaveImage("D:\\TS\\ChippedOff_objChippedOffROILeft.bmp");
                            DontCareLeft.Dispose();
                            #endregion

                            #region Dontcare Inner according Chipped Off ROI Setting
                            ROI ChipInnerROI = new ROI();

                            ImageDrawing DontCareImg = new ImageDrawing(objImage1UnitROI.ref_ROIWidth, objImage1UnitROI.ref_ROIHeight);
                            ROI DontCareLeft1 = new ROI();
                            ROI DontCareLeft2 = new ROI();
                            ROI DontCareLeft3 = new ROI();

                            DontCareLeft3.LoadROISetting(0, 0,
                                objChippedOffROI.ref_ROIWidth - intCeilChipLengthLeft + intCeilChipLengthLeft_Extend - intCeilChipLengthRight + intCeilChipLengthRight_Extend,
                                objChippedOffROI.ref_ROIHeight - intCeilChipLengthTop + intCeilChipLengthTop_Extend - intCeilChipLengthBottom + intCeilChipLengthBottom_Extend);
                            DontCareLeft3.AttachImage(DontCareImg);
                            ChipInnerROI.LoadROISetting(intCeilChipLengthLeft - intCeilChipLengthLeft_Extend,
                                intCeilChipLengthTop - intCeilChipLengthTop_Extend,
                                objChippedOffROI.ref_ROIWidth - intCeilChipLengthLeft + intCeilChipLengthLeft_Extend - intCeilChipLengthRight + intCeilChipLengthRight_Extend,
                                objChippedOffROI.ref_ROIHeight - intCeilChipLengthTop + intCeilChipLengthTop_Extend - intCeilChipLengthBottom + intCeilChipLengthBottom_Extend);

                            ChipInnerROI.AttachImage(objChippedOffROI);
                            DontCareLeft1.LoadROISetting(0, 0,
                                objChippedOffROI.ref_ROIWidth - intCeilChipLengthLeft + intCeilChipLengthLeft_Extend - intCeilChipLengthRight + intCeilChipLengthRight_Extend,
                                objChippedOffROI.ref_ROIHeight - intCeilChipLengthTop + intCeilChipLengthTop_Extend - intCeilChipLengthBottom + intCeilChipLengthBottom_Extend);
                            DontCareLeft1.AttachImage(m_ImgTiltInverted_Left_T);

                            DontCareLeft2.LoadROISetting(0,
                                m_ImgTiltInverted_Left_B.ref_intImageHeight - (objChippedOffROI.ref_ROIHeight - intCeilChipLengthTop + intCeilChipLengthTop_Extend - intCeilChipLengthBottom + intCeilChipLengthBottom_Extend),
                                objChippedOffROI.ref_ROIWidth - intCeilChipLengthLeft + intCeilChipLengthLeft_Extend - intCeilChipLengthRight + intCeilChipLengthRight_Extend,
                                objChippedOffROI.ref_ROIHeight - intCeilChipLengthTop + intCeilChipLengthTop_Extend - intCeilChipLengthBottom + intCeilChipLengthBottom_Extend);
                            DontCareLeft2.AttachImage(m_ImgTiltInverted_Left_B);
                            if (blnDebugImage)
                                DontCareLeft1.SaveImage("D:\\TS\\DontCareLeft1.bmp");
                            if (blnDebugImage)
                                DontCareLeft2.SaveImage("D:\\TS\\DontCareLeft2.bmp");
                            EasyImage.Oper(EArithmeticLogicOperation.LogicalAnd, DontCareLeft1.ref_ROI, DontCareLeft2.ref_ROI, DontCareLeft3.ref_ROI);
                            if (blnDebugImage)
                                DontCareLeft3.SaveImage("D:\\TS\\DontCareLeft3.bmp");

                            EasyImage.Oper(EArithmeticLogicOperation.Subtract, ChipInnerROI.ref_ROI, DontCareLeft3.ref_ROI, ChipInnerROI.ref_ROI);
                            if (blnDebugImage)
                                objChippedOffROI.SaveImage("D:\\TS\\ChippedOff_objChippedOffROILeft1.bmp");

                            m_objImage1ChipOffEBlobs.BuildObjects_Filter_GetElement(objChippedOffROI, blnBlackOnWhite, true, 0, 125,
                            (int)Math.Floor(m_fSurfaceMinArea), objChippedOffROI.ref_ROIHeight * objChippedOffROI.ref_ROIWidth, false, 0x0F);
                            #endregion

                            #region Dontcare Inner according Chipped Off ROI Setting + 2 Pixels
                            // 2 Pixel
                            DontCareLeft3.LoadROISetting(0, 0,
                                objChippedOffROI.ref_ROIWidth - intCeilChipLengthLeft + intCeilChipLengthLeft_Extend - intCeilChipLengthRight + intCeilChipLengthRight_Extend + 4,
                                objChippedOffROI.ref_ROIHeight - intCeilChipLengthTop + intCeilChipLengthTop_Extend - intCeilChipLengthBottom + intCeilChipLengthBottom_Extend + 4);
                            DontCareLeft3.AttachImage(DontCareImg);
                            ChipInnerROI.LoadROISetting(intCeilChipLengthLeft - intCeilChipLengthLeft_Extend - 2,
                                intCeilChipLengthTop - intCeilChipLengthTop_Extend - 2,
                                objChippedOffROI.ref_ROIWidth - intCeilChipLengthLeft + intCeilChipLengthLeft_Extend - intCeilChipLengthRight + intCeilChipLengthRight_Extend + 4,
                                objChippedOffROI.ref_ROIHeight - intCeilChipLengthTop + intCeilChipLengthTop_Extend - intCeilChipLengthBottom + intCeilChipLengthBottom_Extend + 4);

                            ChipInnerROI.AttachImage(objChippedOffROI);
                            DontCareLeft1.LoadROISetting(0, 0,
                                objChippedOffROI.ref_ROIWidth - intCeilChipLengthLeft + intCeilChipLengthLeft_Extend - intCeilChipLengthRight + intCeilChipLengthRight_Extend + 4,
                                objChippedOffROI.ref_ROIHeight - intCeilChipLengthTop + intCeilChipLengthTop_Extend - intCeilChipLengthBottom + intCeilChipLengthBottom_Extend + 4);
                            DontCareLeft1.AttachImage(m_ImgTiltInverted_Left_T);

                            DontCareLeft2.LoadROISetting(0,
                                m_ImgTiltInverted_Left_B.ref_intImageHeight - (objChippedOffROI.ref_ROIHeight - intCeilChipLengthTop + intCeilChipLengthTop_Extend - intCeilChipLengthBottom + intCeilChipLengthBottom_Extend + 4),
                                objChippedOffROI.ref_ROIWidth - intCeilChipLengthLeft + intCeilChipLengthLeft_Extend - intCeilChipLengthRight + intCeilChipLengthRight_Extend + 4,
                                objChippedOffROI.ref_ROIHeight - intCeilChipLengthTop + intCeilChipLengthTop_Extend - intCeilChipLengthBottom + intCeilChipLengthBottom_Extend + 4);
                            DontCareLeft2.AttachImage(m_ImgTiltInverted_Left_B);
                            if (blnDebugImage)
                                DontCareLeft1.SaveImage("D:\\TS\\DontCareLeft12.bmp");
                            if (blnDebugImage)
                                DontCareLeft2.SaveImage("D:\\TS\\DontCareLeft22.bmp");
                            EasyImage.Oper(EArithmeticLogicOperation.LogicalAnd, DontCareLeft1.ref_ROI, DontCareLeft2.ref_ROI, DontCareLeft3.ref_ROI);
                            if (blnDebugImage)
                                DontCareLeft3.SaveImage("D:\\TS\\DontCareLeft32.bmp");

                            EasyImage.Oper(EArithmeticLogicOperation.Subtract, ChipInnerROI.ref_ROI, DontCareLeft3.ref_ROI, ChipInnerROI.ref_ROI);
                            if (blnDebugImage)
                                objChippedOffROI.SaveImage("D:\\TS\\ChippedOff_objChippedOffROILeft2.bmp");

                            m_objImage1ChipOffEBlobsFor2Pixel.BuildObjects_Filter_GetElement(objChippedOffROI, blnBlackOnWhite, true, 0, 125,
                         (int)Math.Floor(m_fSurfaceMinArea), objChippedOffROI.ref_ROIHeight * objChippedOffROI.ref_ROIWidth, false, 0x0F);

                            DontCareLeft1.Dispose();
                            DontCareLeft2.Dispose();
                            DontCareLeft3.Dispose();
                            ChipInnerROI.Dispose();
                            DontCareImg.Dispose();
                            #endregion
                        }
                    }
                    break;
                case 2: // Image 2 (Grab 3)
                    {
                        //2019-09-23 ZJYEOH : Subtract tilt dont care area 
                        if (m_intPadROIDirection == 1) // Top
                        {
                            if (blnDebugImage)
                                objChippedOffROI.SaveImage("D:\\TS\\ChippedOff_objChippedOffROIOriTop.bmp");

                            #region Doncare outside the Unit
                            ROI DontCareTop = new ROI();

                            DontCareTop.LoadROISetting(0, 0, objChippedOffROI.ref_ROIWidth, objChippedOffROI.ref_ROIHeight);
                            DontCareTop.AttachImage(m_ImgTilt_Top_L);
                            EasyImage.Oper(EArithmeticLogicOperation.Add, objChippedOffROI.ref_ROI, DontCareTop.ref_ROI, objChippedOffROI.ref_ROI);
                            DontCareTop.LoadROISetting(m_ImgTilt_Top_R.ref_intImageWidth - objChippedOffROI.ref_ROIWidth, 0, objChippedOffROI.ref_ROIWidth, objChippedOffROI.ref_ROIHeight);
                            DontCareTop.AttachImage(m_ImgTilt_Top_R);
                            EasyImage.Oper(EArithmeticLogicOperation.Add, objChippedOffROI.ref_ROI, DontCareTop.ref_ROI, objChippedOffROI.ref_ROI);
                            if (blnDebugImage)
                                objChippedOffROI.SaveImage("D:\\TS\\CheckChippedOffDefect_SimpleMode_objChippedOffROITop.bmp");
                            DontCareTop.Dispose();
                            #endregion

                            #region Dontcare Inner according Chipped Off ROI Setting
                            ROI ChipInnerROI = new ROI();

                            ImageDrawing DontCareImg = new ImageDrawing(objImage1UnitROI.ref_ROIWidth, objImage1UnitROI.ref_ROIHeight);
                            ROI DontCareTop1 = new ROI();
                            ROI DontCareTop2 = new ROI();
                            ROI DontCareTop3 = new ROI();

                            DontCareTop3.LoadROISetting(0, 0,
                                objChippedOffROI.ref_ROIWidth - intCeilChipLengthLeft + intCeilChipLengthLeft_Extend - intCeilChipLengthRight + intCeilChipLengthRight_Extend,
                                objChippedOffROI.ref_ROIHeight - intCeilChipLengthTop + intCeilChipLengthTop_Extend - intCeilChipLengthBottom + intCeilChipLengthBottom_Extend);
                            DontCareTop3.AttachImage(DontCareImg);
                            ChipInnerROI.LoadROISetting(intCeilChipLengthLeft - intCeilChipLengthLeft_Extend,
                                intCeilChipLengthTop - intCeilChipLengthTop_Extend,
                                objChippedOffROI.ref_ROIWidth - intCeilChipLengthLeft + intCeilChipLengthLeft_Extend - intCeilChipLengthRight + intCeilChipLengthRight_Extend,
                                objChippedOffROI.ref_ROIHeight - intCeilChipLengthTop + intCeilChipLengthTop_Extend - intCeilChipLengthBottom + intCeilChipLengthBottom_Extend);

                            ChipInnerROI.AttachImage(objChippedOffROI);
                            DontCareTop1.LoadROISetting(0, 0,
                                objChippedOffROI.ref_ROIWidth - intCeilChipLengthLeft + intCeilChipLengthLeft_Extend - intCeilChipLengthRight + intCeilChipLengthRight_Extend,
                                objChippedOffROI.ref_ROIHeight - intCeilChipLengthTop + intCeilChipLengthTop_Extend - intCeilChipLengthBottom + intCeilChipLengthBottom_Extend);
                            DontCareTop1.AttachImage(m_ImgTiltInverted_Top_L);

                            DontCareTop2.LoadROISetting(m_ImgTiltInverted_Top_R.ref_intImageWidth - (objChippedOffROI.ref_ROIWidth - intCeilChipLengthLeft + intCeilChipLengthLeft_Extend - intCeilChipLengthRight + intCeilChipLengthRight_Extend),
                                0,
                                objChippedOffROI.ref_ROIWidth - intCeilChipLengthLeft + intCeilChipLengthLeft_Extend - intCeilChipLengthRight + intCeilChipLengthRight_Extend,
                                objChippedOffROI.ref_ROIHeight - intCeilChipLengthTop + intCeilChipLengthTop_Extend - intCeilChipLengthBottom + intCeilChipLengthBottom_Extend);
                            DontCareTop2.AttachImage(m_ImgTiltInverted_Top_R);
                            if (blnDebugImage)
                                DontCareTop1.SaveImage("D:\\TS\\DontCareTop1.bmp");
                            if (blnDebugImage)
                                DontCareTop2.SaveImage("D:\\TS\\DontCareTop2.bmp");
                            EasyImage.Oper(EArithmeticLogicOperation.LogicalAnd, DontCareTop1.ref_ROI, DontCareTop2.ref_ROI, DontCareTop3.ref_ROI);
                            if (blnDebugImage)
                                DontCareTop3.SaveImage("D:\\TS\\DontCareTop3.bmp");

                            EasyImage.Oper(EArithmeticLogicOperation.Add, ChipInnerROI.ref_ROI, DontCareTop3.ref_ROI, ChipInnerROI.ref_ROI);
                            if (blnDebugImage)
                                objChippedOffROI.SaveImage("D:\\TS\\ChippedOff_objChippedOffROITop1.bmp");

                            m_objImage1ChipOffEBlobs.BuildObjects_Filter_GetElement(objChippedOffROI, blnBlackOnWhite, true, 0, 125,
                                 (int)Math.Floor(m_fImage2SurfaceMinArea), objChippedOffROI.ref_ROIHeight * objChippedOffROI.ref_ROIWidth, false, 0x0F);

                            #endregion

                            #region Dontcare Inner according Chipped Off ROI Setting + 2 Pixels
                            // 2 Pixel
                            DontCareTop3.LoadROISetting(0, 0,
                                objChippedOffROI.ref_ROIWidth - intCeilChipLengthLeft + intCeilChipLengthLeft_Extend - intCeilChipLengthRight + intCeilChipLengthRight_Extend + 4,
                                objChippedOffROI.ref_ROIHeight - intCeilChipLengthTop + intCeilChipLengthTop_Extend - intCeilChipLengthBottom + intCeilChipLengthBottom_Extend + 4);
                            DontCareTop3.AttachImage(DontCareImg);
                            ChipInnerROI.LoadROISetting(intCeilChipLengthLeft - intCeilChipLengthLeft_Extend - 2,
                                intCeilChipLengthTop - intCeilChipLengthTop_Extend - 2,
                                objChippedOffROI.ref_ROIWidth - intCeilChipLengthLeft + intCeilChipLengthLeft_Extend - intCeilChipLengthRight + intCeilChipLengthRight_Extend + 4,
                                objChippedOffROI.ref_ROIHeight - intCeilChipLengthTop + intCeilChipLengthTop_Extend - intCeilChipLengthBottom + intCeilChipLengthBottom_Extend + 4);

                            ChipInnerROI.AttachImage(objChippedOffROI);
                            DontCareTop1.LoadROISetting(0, 0,
                                objChippedOffROI.ref_ROIWidth - intCeilChipLengthLeft + intCeilChipLengthLeft_Extend - intCeilChipLengthRight + intCeilChipLengthRight_Extend + 4,
                                objChippedOffROI.ref_ROIHeight - intCeilChipLengthTop + intCeilChipLengthTop_Extend - intCeilChipLengthBottom + intCeilChipLengthBottom_Extend + 4);
                            DontCareTop1.AttachImage(m_ImgTiltInverted_Top_L);

                            DontCareTop2.LoadROISetting(m_ImgTiltInverted_Top_R.ref_intImageWidth - (objChippedOffROI.ref_ROIWidth - intCeilChipLengthLeft + intCeilChipLengthLeft_Extend - intCeilChipLengthRight + intCeilChipLengthRight_Extend + 4),
                                0,
                                objChippedOffROI.ref_ROIWidth - intCeilChipLengthLeft + intCeilChipLengthLeft_Extend - intCeilChipLengthRight + intCeilChipLengthRight_Extend + 4,
                                objChippedOffROI.ref_ROIHeight - intCeilChipLengthTop + intCeilChipLengthTop_Extend - intCeilChipLengthBottom + intCeilChipLengthBottom_Extend + 4);
                            DontCareTop2.AttachImage(m_ImgTiltInverted_Top_R);
                            if (blnDebugImage)
                                DontCareTop1.SaveImage("D:\\TS\\DontCareTop12.bmp");
                            if (blnDebugImage)
                                DontCareTop2.SaveImage("D:\\TS\\DontCareTop22.bmp");
                            EasyImage.Oper(EArithmeticLogicOperation.LogicalAnd, DontCareTop1.ref_ROI, DontCareTop2.ref_ROI, DontCareTop3.ref_ROI);
                            if (blnDebugImage)
                                DontCareTop3.SaveImage("D:\\TS\\DontCareTop32.bmp");

                            EasyImage.Oper(EArithmeticLogicOperation.Add, ChipInnerROI.ref_ROI, DontCareTop3.ref_ROI, ChipInnerROI.ref_ROI);
                            if (blnDebugImage)
                                objChippedOffROI.SaveImage("D:\\TS\\ChippedOff_objChippedOffROITop2.bmp");

                            m_objImage1ChipOffEBlobsFor2Pixel.BuildObjects_Filter_GetElement(objChippedOffROI, blnBlackOnWhite, true, 0, 125,
                               (int)Math.Floor(m_fImage2SurfaceMinArea), objChippedOffROI.ref_ROIHeight * objChippedOffROI.ref_ROIWidth, false, 0x0F);

                            DontCareTop1.Dispose();
                            DontCareTop2.Dispose();
                            DontCareTop3.Dispose();
                            ChipInnerROI.Dispose();
                            DontCareImg.Dispose();
                            #endregion
                        }
                        if (m_intPadROIDirection == 2) // Right
                        {
                            if (blnDebugImage)
                                objChippedOffROI.SaveImage("D:\\TS\\ChippedOff_objChippedOffROIOriRight.bmp");

                            #region Doncare outside the Unit
                            ROI DontCareRight = new ROI();
                            DontCareRight.LoadROISetting(m_ImgTilt_Top_R.ref_intImageWidth - objChippedOffROI.ref_ROIWidth, 0, objChippedOffROI.ref_ROIWidth, objChippedOffROI.ref_ROIHeight);
                            DontCareRight.AttachImage(m_ImgTilt_Right_T);
                            EasyImage.Oper(EArithmeticLogicOperation.Add, objChippedOffROI.ref_ROI, DontCareRight.ref_ROI, objChippedOffROI.ref_ROI);
                            DontCareRight.LoadROISetting(m_ImgTilt_Top_R.ref_intImageWidth - objChippedOffROI.ref_ROIWidth, m_ImgTilt_Top_R.ref_intImageHeight - objChippedOffROI.ref_ROIHeight, objChippedOffROI.ref_ROIWidth, objChippedOffROI.ref_ROIHeight);
                            DontCareRight.AttachImage(m_ImgTilt_Right_B);
                            EasyImage.Oper(EArithmeticLogicOperation.Add, objChippedOffROI.ref_ROI, DontCareRight.ref_ROI, objChippedOffROI.ref_ROI);
                            if (blnDebugImage)
                                objChippedOffROI.SaveImage("D:\\TS\\CheckChippedOffDefect_SimpleMode_objChippedOffROIRight.bmp");
                            DontCareRight.Dispose();
                            #endregion

                            #region Dontcare Inner according Chipped Off ROI Setting
                            ROI ChipInnerROI = new ROI();

                            ImageDrawing DontCareImg = new ImageDrawing(objImage1UnitROI.ref_ROIWidth, objImage1UnitROI.ref_ROIHeight);
                            ROI DontCareRight1 = new ROI();
                            ROI DontCareRight2 = new ROI();
                            ROI DontCareRight3 = new ROI();

                            DontCareRight3.LoadROISetting(0, 0,
                                objChippedOffROI.ref_ROIWidth - intCeilChipLengthLeft + intCeilChipLengthLeft_Extend - intCeilChipLengthRight + intCeilChipLengthRight_Extend,
                                objChippedOffROI.ref_ROIHeight - intCeilChipLengthTop + intCeilChipLengthTop_Extend - intCeilChipLengthBottom + intCeilChipLengthBottom_Extend);
                            DontCareRight3.AttachImage(DontCareImg);
                            ChipInnerROI.LoadROISetting(intCeilChipLengthLeft - intCeilChipLengthLeft_Extend,
                                intCeilChipLengthTop - intCeilChipLengthTop_Extend,
                                objChippedOffROI.ref_ROIWidth - intCeilChipLengthLeft + intCeilChipLengthLeft_Extend - intCeilChipLengthRight + intCeilChipLengthRight_Extend,
                                objChippedOffROI.ref_ROIHeight - intCeilChipLengthTop + intCeilChipLengthTop_Extend - intCeilChipLengthBottom + intCeilChipLengthBottom_Extend);

                            ChipInnerROI.AttachImage(objChippedOffROI);
                            DontCareRight1.LoadROISetting(m_ImgTiltInverted_Right_T.ref_intImageWidth - (objChippedOffROI.ref_ROIWidth - intCeilChipLengthLeft + intCeilChipLengthLeft_Extend - intCeilChipLengthRight + intCeilChipLengthRight_Extend),
                                0,
                                objChippedOffROI.ref_ROIWidth - intCeilChipLengthLeft + intCeilChipLengthLeft_Extend - intCeilChipLengthRight + intCeilChipLengthRight_Extend,
                                objChippedOffROI.ref_ROIHeight - intCeilChipLengthTop + intCeilChipLengthTop_Extend - intCeilChipLengthBottom + intCeilChipLengthBottom_Extend);
                            DontCareRight1.AttachImage(m_ImgTiltInverted_Right_T);

                            DontCareRight2.LoadROISetting(m_ImgTiltInverted_Right_B.ref_intImageWidth - (objChippedOffROI.ref_ROIWidth - intCeilChipLengthLeft + intCeilChipLengthLeft_Extend - intCeilChipLengthRight + intCeilChipLengthRight_Extend),
                                m_ImgTiltInverted_Right_B.ref_intImageHeight - (objChippedOffROI.ref_ROIHeight - intCeilChipLengthTop + intCeilChipLengthTop_Extend - intCeilChipLengthBottom + intCeilChipLengthBottom_Extend),
                                objChippedOffROI.ref_ROIWidth - intCeilChipLengthLeft + intCeilChipLengthLeft_Extend - intCeilChipLengthRight + intCeilChipLengthRight_Extend,
                                objChippedOffROI.ref_ROIHeight - intCeilChipLengthTop + intCeilChipLengthTop_Extend - intCeilChipLengthBottom + intCeilChipLengthBottom_Extend);
                            DontCareRight2.AttachImage(m_ImgTiltInverted_Right_B);
                            if (blnDebugImage)
                                DontCareRight1.SaveImage("D:\\TS\\DontCareRight1.bmp");
                            if (blnDebugImage)
                                DontCareRight2.SaveImage("D:\\TS\\DontCareRight2.bmp");
                            EasyImage.Oper(EArithmeticLogicOperation.LogicalAnd, DontCareRight1.ref_ROI, DontCareRight2.ref_ROI, DontCareRight3.ref_ROI);
                            if (blnDebugImage)
                                DontCareRight3.SaveImage("D:\\TS\\DontCareRight3.bmp");

                            EasyImage.Oper(EArithmeticLogicOperation.Add, ChipInnerROI.ref_ROI, DontCareRight3.ref_ROI, ChipInnerROI.ref_ROI);
                            if (blnDebugImage)
                                objChippedOffROI.SaveImage("D:\\TS\\ChippedOff_objChippedOffROIRight1.bmp");

                            m_objImage1ChipOffEBlobs.BuildObjects_Filter_GetElement(objChippedOffROI, blnBlackOnWhite, true, 0, 125,
                            (int)Math.Floor(m_fImage2SurfaceMinArea), objChippedOffROI.ref_ROIHeight * objChippedOffROI.ref_ROIWidth, false, 0x0F);
                            #endregion

                            #region Dontcare Inner according Chipped Off ROI Setting + 2 Pixels
                            // 2 Pixel
                            DontCareRight3.LoadROISetting(0, 0,
                                objChippedOffROI.ref_ROIWidth - intCeilChipLengthLeft + intCeilChipLengthLeft_Extend - intCeilChipLengthRight + intCeilChipLengthRight_Extend + 4,
                                objChippedOffROI.ref_ROIHeight - intCeilChipLengthTop + intCeilChipLengthTop_Extend - intCeilChipLengthBottom + intCeilChipLengthBottom_Extend + 4);
                            DontCareRight3.AttachImage(DontCareImg);
                            ChipInnerROI.LoadROISetting(intCeilChipLengthLeft - intCeilChipLengthLeft_Extend - 2,
                                intCeilChipLengthTop - intCeilChipLengthTop_Extend - 2,
                                objChippedOffROI.ref_ROIWidth - intCeilChipLengthLeft + intCeilChipLengthLeft_Extend - intCeilChipLengthRight + intCeilChipLengthRight_Extend + 4,
                                objChippedOffROI.ref_ROIHeight - intCeilChipLengthTop + intCeilChipLengthTop_Extend - intCeilChipLengthBottom + intCeilChipLengthBottom_Extend + 4);

                            ChipInnerROI.AttachImage(objChippedOffROI);
                            DontCareRight1.LoadROISetting(m_ImgTiltInverted_Right_T.ref_intImageWidth - (objChippedOffROI.ref_ROIWidth - intCeilChipLengthLeft + intCeilChipLengthLeft_Extend - intCeilChipLengthRight + intCeilChipLengthRight_Extend + 4),
                                0,
                                objChippedOffROI.ref_ROIWidth - intCeilChipLengthLeft + intCeilChipLengthLeft_Extend - intCeilChipLengthRight + intCeilChipLengthRight_Extend + 4,
                                objChippedOffROI.ref_ROIHeight - intCeilChipLengthTop + intCeilChipLengthTop_Extend - intCeilChipLengthBottom + intCeilChipLengthBottom_Extend + 4);
                            DontCareRight1.AttachImage(m_ImgTiltInverted_Right_T);

                            DontCareRight2.LoadROISetting(m_ImgTiltInverted_Right_B.ref_intImageWidth - (objChippedOffROI.ref_ROIWidth - intCeilChipLengthLeft + intCeilChipLengthLeft_Extend - intCeilChipLengthRight + intCeilChipLengthRight_Extend + 4),
                                m_ImgTiltInverted_Right_B.ref_intImageHeight - (objChippedOffROI.ref_ROIHeight - intCeilChipLengthTop + intCeilChipLengthTop_Extend - intCeilChipLengthBottom + intCeilChipLengthBottom_Extend + 4),
                                objChippedOffROI.ref_ROIWidth - intCeilChipLengthLeft + intCeilChipLengthLeft_Extend - intCeilChipLengthRight + intCeilChipLengthRight_Extend + 4,
                                objChippedOffROI.ref_ROIHeight - intCeilChipLengthTop + intCeilChipLengthTop_Extend - intCeilChipLengthBottom + intCeilChipLengthBottom_Extend + 4);
                            DontCareRight2.AttachImage(m_ImgTiltInverted_Right_B);
                            if (blnDebugImage)
                                DontCareRight1.SaveImage("D:\\TS\\DontCareRight12.bmp");
                            if (blnDebugImage)
                                DontCareRight2.SaveImage("D:\\TS\\DontCareRight22.bmp");
                            EasyImage.Oper(EArithmeticLogicOperation.LogicalAnd, DontCareRight1.ref_ROI, DontCareRight2.ref_ROI, DontCareRight3.ref_ROI);
                            if (blnDebugImage)
                                DontCareRight3.SaveImage("D:\\TS\\DontCareRight32.bmp");

                            EasyImage.Oper(EArithmeticLogicOperation.Add, ChipInnerROI.ref_ROI, DontCareRight3.ref_ROI, ChipInnerROI.ref_ROI);
                            if (blnDebugImage)
                                objChippedOffROI.SaveImage("D:\\TS\\ChippedOff_objChippedOffROIRight2.bmp");

                            m_objImage1ChipOffEBlobsFor2Pixel.BuildObjects_Filter_GetElement(objChippedOffROI, blnBlackOnWhite, true, 0, 125,
                            (int)Math.Floor(m_fImage2SurfaceMinArea), objChippedOffROI.ref_ROIHeight * objChippedOffROI.ref_ROIWidth, false, 0x0F);

                            DontCareRight1.Dispose();
                            DontCareRight2.Dispose();
                            DontCareRight3.Dispose();
                            ChipInnerROI.Dispose();
                            DontCareImg.Dispose();
                            #endregion

                        }
                        if (m_intPadROIDirection == 3) // Bottom
                        {
                            if (blnDebugImage)
                                objChippedOffROI.SaveImage("D:\\TS\\ChippedOff_objChippedOffROIOriBottom.bmp");

                            #region Doncare outside the Unit
                            ROI DontCareBottom = new ROI();

                            DontCareBottom.LoadROISetting(0, m_ImgTilt_Top_R.ref_intImageHeight - objChippedOffROI.ref_ROIHeight, objChippedOffROI.ref_ROIWidth, objChippedOffROI.ref_ROIHeight);
                            DontCareBottom.AttachImage(m_ImgTilt_Bottom_L);
                            EasyImage.Oper(EArithmeticLogicOperation.Add, objChippedOffROI.ref_ROI, DontCareBottom.ref_ROI, objChippedOffROI.ref_ROI);
                            DontCareBottom.LoadROISetting(m_ImgTilt_Top_R.ref_intImageWidth - objChippedOffROI.ref_ROIWidth, m_ImgTilt_Top_R.ref_intImageHeight - objChippedOffROI.ref_ROIHeight, objChippedOffROI.ref_ROIWidth, objChippedOffROI.ref_ROIHeight);
                            DontCareBottom.AttachImage(m_ImgTilt_Bottom_R);
                            EasyImage.Oper(EArithmeticLogicOperation.Add, objChippedOffROI.ref_ROI, DontCareBottom.ref_ROI, objChippedOffROI.ref_ROI);
                            if (blnDebugImage)
                                objChippedOffROI.SaveImage("D:\\TS\\CheckChippedOffDefect_SimpleMode_objChippedOffROIBottom.bmp");
                            DontCareBottom.Dispose();
                            #endregion

                            #region Dontcare Inner according Chipped Off ROI Setting
                            ROI ChipInnerROI = new ROI();

                            ImageDrawing DontCareImg = new ImageDrawing(objImage1UnitROI.ref_ROIWidth, objImage1UnitROI.ref_ROIHeight);
                            ROI DontCareBottom1 = new ROI();
                            ROI DontCareBottom2 = new ROI();
                            ROI DontCareBottom3 = new ROI();

                            DontCareBottom3.LoadROISetting(0, 0,
                                objChippedOffROI.ref_ROIWidth - intCeilChipLengthLeft + intCeilChipLengthLeft_Extend - intCeilChipLengthRight + intCeilChipLengthRight_Extend,
                                objChippedOffROI.ref_ROIHeight - intCeilChipLengthTop + intCeilChipLengthTop_Extend - intCeilChipLengthBottom + intCeilChipLengthBottom_Extend);
                            DontCareBottom3.AttachImage(DontCareImg);
                            ChipInnerROI.LoadROISetting(intCeilChipLengthLeft - intCeilChipLengthLeft_Extend,
                                intCeilChipLengthTop - intCeilChipLengthTop_Extend,
                                objChippedOffROI.ref_ROIWidth - intCeilChipLengthLeft + intCeilChipLengthLeft_Extend - intCeilChipLengthRight + intCeilChipLengthRight_Extend,
                                objChippedOffROI.ref_ROIHeight - intCeilChipLengthTop + intCeilChipLengthTop_Extend - intCeilChipLengthBottom + intCeilChipLengthBottom_Extend);

                            ChipInnerROI.AttachImage(objChippedOffROI);
                            DontCareBottom1.LoadROISetting(0,
                                m_ImgTiltInverted_Bottom_L.ref_intImageHeight - (objChippedOffROI.ref_ROIHeight - intCeilChipLengthTop + intCeilChipLengthTop_Extend - intCeilChipLengthBottom + intCeilChipLengthBottom_Extend),
                                objChippedOffROI.ref_ROIWidth - intCeilChipLengthLeft + intCeilChipLengthLeft_Extend - intCeilChipLengthRight + intCeilChipLengthRight_Extend,
                                objChippedOffROI.ref_ROIHeight - intCeilChipLengthTop + intCeilChipLengthTop_Extend - intCeilChipLengthBottom + intCeilChipLengthBottom_Extend);
                            DontCareBottom1.AttachImage(m_ImgTiltInverted_Bottom_L);

                            DontCareBottom2.LoadROISetting(m_ImgTiltInverted_Bottom_R.ref_intImageWidth - (objChippedOffROI.ref_ROIWidth - intCeilChipLengthLeft + intCeilChipLengthLeft_Extend - intCeilChipLengthRight + intCeilChipLengthRight_Extend),
                                m_ImgTiltInverted_Bottom_R.ref_intImageHeight - (objChippedOffROI.ref_ROIHeight - intCeilChipLengthTop + intCeilChipLengthTop_Extend - intCeilChipLengthBottom + intCeilChipLengthBottom_Extend),
                                objChippedOffROI.ref_ROIWidth - intCeilChipLengthLeft + intCeilChipLengthLeft_Extend - intCeilChipLengthRight + intCeilChipLengthRight_Extend,
                                objChippedOffROI.ref_ROIHeight - intCeilChipLengthTop + intCeilChipLengthTop_Extend - intCeilChipLengthBottom + intCeilChipLengthBottom_Extend);
                            DontCareBottom2.AttachImage(m_ImgTiltInverted_Bottom_R);
                            if (blnDebugImage)
                                DontCareBottom1.SaveImage("D:\\TS\\DontCareBottom1.bmp");
                            if (blnDebugImage)
                                DontCareBottom2.SaveImage("D:\\TS\\DontCareBottom2.bmp");
                            EasyImage.Oper(EArithmeticLogicOperation.LogicalAnd, DontCareBottom1.ref_ROI, DontCareBottom2.ref_ROI, DontCareBottom3.ref_ROI);
                            if (blnDebugImage)
                                DontCareBottom3.SaveImage("D:\\TS\\DontCareBottom3.bmp");

                            EasyImage.Oper(EArithmeticLogicOperation.Add, ChipInnerROI.ref_ROI, DontCareBottom3.ref_ROI, ChipInnerROI.ref_ROI);
                            if (blnDebugImage)
                                objChippedOffROI.SaveImage("D:\\TS\\ChippedOff_objChippedOffROIBottom1.bmp");

                            m_objImage1ChipOffEBlobs.BuildObjects_Filter_GetElement(objChippedOffROI, blnBlackOnWhite, true, 0, 125,
                            (int)Math.Floor(m_fImage2SurfaceMinArea), objChippedOffROI.ref_ROIHeight * objChippedOffROI.ref_ROIWidth, false, 0x0F);
                            #endregion

                            #region Dontcare Inner according Chipped Off ROI Setting + 2 Pixels
                            // 2 Pixel
                            DontCareBottom3.LoadROISetting(0, 0,
                                objChippedOffROI.ref_ROIWidth - intCeilChipLengthLeft + intCeilChipLengthLeft_Extend - intCeilChipLengthRight + intCeilChipLengthRight_Extend + 4,
                                objChippedOffROI.ref_ROIHeight - intCeilChipLengthTop + intCeilChipLengthTop_Extend - intCeilChipLengthBottom + intCeilChipLengthBottom_Extend + 4);
                            DontCareBottom3.AttachImage(DontCareImg);
                            ChipInnerROI.LoadROISetting(intCeilChipLengthLeft - intCeilChipLengthLeft_Extend - 2,
                                intCeilChipLengthTop - intCeilChipLengthTop_Extend - 2,
                                objChippedOffROI.ref_ROIWidth - intCeilChipLengthLeft + intCeilChipLengthLeft_Extend - intCeilChipLengthRight + intCeilChipLengthRight_Extend + 4,
                                objChippedOffROI.ref_ROIHeight - intCeilChipLengthTop + intCeilChipLengthTop_Extend - intCeilChipLengthBottom + intCeilChipLengthBottom_Extend + 4);

                            ChipInnerROI.AttachImage(objChippedOffROI);
                            DontCareBottom1.LoadROISetting(0,
                                m_ImgTiltInverted_Bottom_L.ref_intImageHeight - (objChippedOffROI.ref_ROIHeight - intCeilChipLengthTop + intCeilChipLengthTop_Extend - intCeilChipLengthBottom + intCeilChipLengthBottom_Extend + 4),
                                objChippedOffROI.ref_ROIWidth - intCeilChipLengthLeft + intCeilChipLengthLeft_Extend - intCeilChipLengthRight + intCeilChipLengthRight_Extend + 4,
                                objChippedOffROI.ref_ROIHeight - intCeilChipLengthTop + intCeilChipLengthTop_Extend - intCeilChipLengthBottom + intCeilChipLengthBottom_Extend + 4);
                            DontCareBottom1.AttachImage(m_ImgTiltInverted_Bottom_L);

                            DontCareBottom2.LoadROISetting(m_ImgTiltInverted_Bottom_R.ref_intImageWidth - (objChippedOffROI.ref_ROIWidth - intCeilChipLengthLeft + intCeilChipLengthLeft_Extend - intCeilChipLengthRight + intCeilChipLengthRight_Extend + 4),
                                m_ImgTiltInverted_Bottom_R.ref_intImageHeight - (objChippedOffROI.ref_ROIHeight - intCeilChipLengthTop + intCeilChipLengthTop_Extend - intCeilChipLengthBottom + intCeilChipLengthBottom_Extend + 4),
                                objChippedOffROI.ref_ROIWidth - intCeilChipLengthLeft + intCeilChipLengthLeft_Extend - intCeilChipLengthRight + intCeilChipLengthRight_Extend + 4,
                                objChippedOffROI.ref_ROIHeight - intCeilChipLengthTop + intCeilChipLengthTop_Extend - intCeilChipLengthBottom + intCeilChipLengthBottom_Extend + 4);
                            DontCareBottom2.AttachImage(m_ImgTiltInverted_Bottom_R);
                            if (blnDebugImage)
                                DontCareBottom1.SaveImage("D:\\TS\\DontCareBottom12.bmp");
                            if (blnDebugImage)
                                DontCareBottom2.SaveImage("D:\\TS\\DontCareBottom22.bmp");
                            EasyImage.Oper(EArithmeticLogicOperation.LogicalAnd, DontCareBottom1.ref_ROI, DontCareBottom2.ref_ROI, DontCareBottom3.ref_ROI);
                            if (blnDebugImage)
                                DontCareBottom3.SaveImage("D:\\TS\\DontCareBottom32.bmp");

                            EasyImage.Oper(EArithmeticLogicOperation.Add, ChipInnerROI.ref_ROI, DontCareBottom3.ref_ROI, ChipInnerROI.ref_ROI);
                            if (blnDebugImage)
                                objChippedOffROI.SaveImage("D:\\TS\\ChippedOff_objChippedOffROIBottom2.bmp");

                            m_objImage1ChipOffEBlobsFor2Pixel.BuildObjects_Filter_GetElement(objChippedOffROI, blnBlackOnWhite, true, 0, 125,
                            (int)Math.Floor(m_fImage2SurfaceMinArea), objChippedOffROI.ref_ROIHeight * objChippedOffROI.ref_ROIWidth, false, 0x0F);

                            DontCareBottom1.Dispose();
                            DontCareBottom2.Dispose();
                            DontCareBottom3.Dispose();
                            ChipInnerROI.Dispose();
                            DontCareImg.Dispose();
                            #endregion
                        }
                        if (m_intPadROIDirection == 4) // Left
                        {
                            if (blnDebugImage)
                                objChippedOffROI.SaveImage("D:\\TS\\ChippedOff_objChippedOffROIOriLeft.bmp");

                            #region Doncare outside the Unit
                            ROI DontCareLeft = new ROI();

                            DontCareLeft.LoadROISetting(0, 0, objChippedOffROI.ref_ROIWidth, objChippedOffROI.ref_ROIHeight);
                            DontCareLeft.AttachImage(m_ImgTilt_Left_T);
                            EasyImage.Oper(EArithmeticLogicOperation.Add, objChippedOffROI.ref_ROI, DontCareLeft.ref_ROI, objChippedOffROI.ref_ROI);
                            DontCareLeft.LoadROISetting(0, m_ImgTilt_Top_R.ref_intImageHeight - objChippedOffROI.ref_ROIHeight, objChippedOffROI.ref_ROIWidth, objChippedOffROI.ref_ROIHeight);
                            DontCareLeft.AttachImage(m_ImgTilt_Left_B);
                            EasyImage.Oper(EArithmeticLogicOperation.Add, objChippedOffROI.ref_ROI, DontCareLeft.ref_ROI, objChippedOffROI.ref_ROI);
                            if (blnDebugImage)
                                objChippedOffROI.SaveImage("D:\\TS\\CheckChippedOffDefect_SimpleMode_objChippedOffROILeft.bmp");
                            DontCareLeft.Dispose();
                            #endregion

                            #region Dontcare Inner according Chipped Off ROI Setting
                            ROI ChipInnerROI = new ROI();

                            ImageDrawing DontCareImg = new ImageDrawing(objImage1UnitROI.ref_ROIWidth, objImage1UnitROI.ref_ROIHeight);
                            ROI DontCareLeft1 = new ROI();
                            ROI DontCareLeft2 = new ROI();
                            ROI DontCareLeft3 = new ROI();

                            DontCareLeft3.LoadROISetting(0, 0,
                                objChippedOffROI.ref_ROIWidth - intCeilChipLengthLeft + intCeilChipLengthLeft_Extend - intCeilChipLengthRight + intCeilChipLengthRight_Extend,
                                objChippedOffROI.ref_ROIHeight - intCeilChipLengthTop + intCeilChipLengthTop_Extend - intCeilChipLengthBottom + intCeilChipLengthBottom_Extend);
                            DontCareLeft3.AttachImage(DontCareImg);
                            ChipInnerROI.LoadROISetting(intCeilChipLengthLeft - intCeilChipLengthLeft_Extend,
                                intCeilChipLengthTop - intCeilChipLengthTop_Extend,
                                objChippedOffROI.ref_ROIWidth - intCeilChipLengthLeft + intCeilChipLengthLeft_Extend - intCeilChipLengthRight + intCeilChipLengthRight_Extend,
                                objChippedOffROI.ref_ROIHeight - intCeilChipLengthTop + intCeilChipLengthTop_Extend - intCeilChipLengthBottom + intCeilChipLengthBottom_Extend);

                            ChipInnerROI.AttachImage(objChippedOffROI);
                            DontCareLeft1.LoadROISetting(0, 0,
                                objChippedOffROI.ref_ROIWidth - intCeilChipLengthLeft + intCeilChipLengthLeft_Extend - intCeilChipLengthRight + intCeilChipLengthRight_Extend,
                                objChippedOffROI.ref_ROIHeight - intCeilChipLengthTop + intCeilChipLengthTop_Extend - intCeilChipLengthBottom + intCeilChipLengthBottom_Extend);
                            DontCareLeft1.AttachImage(m_ImgTiltInverted_Left_T);

                            DontCareLeft2.LoadROISetting(0,
                                m_ImgTiltInverted_Left_B.ref_intImageHeight - (objChippedOffROI.ref_ROIHeight - intCeilChipLengthTop + intCeilChipLengthTop_Extend - intCeilChipLengthBottom + intCeilChipLengthBottom_Extend),
                                objChippedOffROI.ref_ROIWidth - intCeilChipLengthLeft + intCeilChipLengthLeft_Extend - intCeilChipLengthRight + intCeilChipLengthRight_Extend,
                                objChippedOffROI.ref_ROIHeight - intCeilChipLengthTop + intCeilChipLengthTop_Extend - intCeilChipLengthBottom + intCeilChipLengthBottom_Extend);
                            DontCareLeft2.AttachImage(m_ImgTiltInverted_Left_B);
                            if (blnDebugImage)
                                DontCareLeft1.SaveImage("D:\\TS\\DontCareLeft1.bmp");
                            if (blnDebugImage)
                                DontCareLeft2.SaveImage("D:\\TS\\DontCareLeft2.bmp");
                            EasyImage.Oper(EArithmeticLogicOperation.LogicalAnd, DontCareLeft1.ref_ROI, DontCareLeft2.ref_ROI, DontCareLeft3.ref_ROI);
                            if (blnDebugImage)
                                DontCareLeft3.SaveImage("D:\\TS\\DontCareLeft3.bmp");

                            EasyImage.Oper(EArithmeticLogicOperation.Add, ChipInnerROI.ref_ROI, DontCareLeft3.ref_ROI, ChipInnerROI.ref_ROI);
                            if (blnDebugImage)
                                objChippedOffROI.SaveImage("D:\\TS\\ChippedOff_objChippedOffROILeft1.bmp");

                            m_objImage1ChipOffEBlobs.BuildObjects_Filter_GetElement(objChippedOffROI, blnBlackOnWhite, true, 0, 125,
                            (int)Math.Floor(m_fImage2SurfaceMinArea), objChippedOffROI.ref_ROIHeight * objChippedOffROI.ref_ROIWidth, false, 0x0F);

                            #endregion

                            #region Dontcare Inner according Chipped Off ROI Setting + 2 Pixels
                            // 2 Pixel
                            DontCareLeft3.LoadROISetting(0, 0,
                                objChippedOffROI.ref_ROIWidth - intCeilChipLengthLeft + intCeilChipLengthLeft_Extend - intCeilChipLengthRight + intCeilChipLengthRight_Extend + 4,
                                objChippedOffROI.ref_ROIHeight - intCeilChipLengthTop + intCeilChipLengthTop_Extend - intCeilChipLengthBottom + intCeilChipLengthBottom_Extend + 4);
                            DontCareLeft3.AttachImage(DontCareImg);
                            ChipInnerROI.LoadROISetting(intCeilChipLengthLeft - intCeilChipLengthLeft_Extend - 2,
                                intCeilChipLengthTop - intCeilChipLengthTop_Extend - 2,
                                objChippedOffROI.ref_ROIWidth - intCeilChipLengthLeft + intCeilChipLengthLeft_Extend - intCeilChipLengthRight + intCeilChipLengthRight_Extend + 4,
                                objChippedOffROI.ref_ROIHeight - intCeilChipLengthTop + intCeilChipLengthTop_Extend - intCeilChipLengthBottom + intCeilChipLengthBottom_Extend + 4);

                            ChipInnerROI.AttachImage(objChippedOffROI);
                            DontCareLeft1.LoadROISetting(0, 0,
                                objChippedOffROI.ref_ROIWidth - intCeilChipLengthLeft + intCeilChipLengthLeft_Extend - intCeilChipLengthRight + intCeilChipLengthRight_Extend + 4,
                                objChippedOffROI.ref_ROIHeight - intCeilChipLengthTop + intCeilChipLengthTop_Extend - intCeilChipLengthBottom + intCeilChipLengthBottom_Extend + 4);
                            DontCareLeft1.AttachImage(m_ImgTiltInverted_Left_T);

                            DontCareLeft2.LoadROISetting(0,
                                m_ImgTiltInverted_Left_B.ref_intImageHeight - (objChippedOffROI.ref_ROIHeight - intCeilChipLengthTop + intCeilChipLengthTop_Extend - intCeilChipLengthBottom + intCeilChipLengthBottom_Extend + 4),
                                objChippedOffROI.ref_ROIWidth - intCeilChipLengthLeft + intCeilChipLengthLeft_Extend - intCeilChipLengthRight + intCeilChipLengthRight_Extend + 4,
                                objChippedOffROI.ref_ROIHeight - intCeilChipLengthTop + intCeilChipLengthTop_Extend - intCeilChipLengthBottom + intCeilChipLengthBottom_Extend + 4);
                            DontCareLeft2.AttachImage(m_ImgTiltInverted_Left_B);
                            if (blnDebugImage)
                                DontCareLeft1.SaveImage("D:\\TS\\DontCareLeft12.bmp");
                            if (blnDebugImage)
                                DontCareLeft2.SaveImage("D:\\TS\\DontCareLeft22.bmp");
                            EasyImage.Oper(EArithmeticLogicOperation.LogicalAnd, DontCareLeft1.ref_ROI, DontCareLeft2.ref_ROI, DontCareLeft3.ref_ROI);
                            if (blnDebugImage)
                                DontCareLeft3.SaveImage("D:\\TS\\DontCareLeft32.bmp");

                            EasyImage.Oper(EArithmeticLogicOperation.Add, ChipInnerROI.ref_ROI, DontCareLeft3.ref_ROI, ChipInnerROI.ref_ROI);
                            if (blnDebugImage)
                                objChippedOffROI.SaveImage("D:\\TS\\ChippedOff_objChippedOffROILeft2.bmp");

                            m_objImage1ChipOffEBlobsFor2Pixel.BuildObjects_Filter_GetElement(objChippedOffROI, blnBlackOnWhite, true, 0, 125,
                         (int)Math.Floor(m_fImage2SurfaceMinArea), objChippedOffROI.ref_ROIHeight * objChippedOffROI.ref_ROIWidth, false, 0x0F);

                            DontCareLeft1.Dispose();
                            DontCareLeft2.Dispose();
                            DontCareLeft3.Dispose();
                            ChipInnerROI.Dispose();
                            DontCareImg.Dispose();
                            #endregion
                        }
                    }
                    break;
            }

            //switch (intImageIndex)
            //{
            //    case 1: // Image 1 (Grab 1 & Grab 2 Merged)
            //        {
            //            m_objImage1ChipOffEBlobs.BuildObjects_Filter_GetElement(objChippedOffROI, blnBlackOnWhite, true, 0, 125,
            //                (int)Math.Floor(m_fSurfaceMinArea), objChippedOffROI.ref_ROIHeight * objChippedOffROI.ref_ROIWidth, false, 0x0F);
            //        }
            //        break;
            //    case 2: // Image 2 (Grab 3)
            //        {
            //            m_objImage1ChipOffEBlobs.BuildObjects_Filter_GetElement(objChippedOffROI, blnBlackOnWhite, true, 0, 125,
            //                (int)Math.Floor(m_fImage2SurfaceMinArea), objChippedOffROI.ref_ROIHeight * objChippedOffROI.ref_ROIWidth, false, 0x0F);
            //        }
            //        break;
            //}
            if (blnDebugImage)
            {
                objImage1UnitROI.SaveImage("D:\\TS\\objImage1UnitROI" + m_intPadROIDirection + ".bmp");// debug
                objChippedOffROI.SaveImage("D:\\TS\\objChippedOffROI" + m_intPadROIDirection + ".bmp");// debug 
            }
            
            if (m_objImage1ChipOffEBlobs.ref_intNumSelectedObject > 0)
            {
                float fDefectLengthPixelLeft = intCeilChipLengthLeft;
                float fDefectLengthPixelTop = intCeilChipLengthTop;
                float fDefectLengthPixelRight = intCeilChipLengthRight;
                float fDefectLengthPixelBottom = intCeilChipLengthBottom;
                int intObjectArea = 0;
                float fObjectHeight = 0, fObjectWidth = 0, fObjectCenterX = 0, fObjectCenterY = 0;
                float fStartX, fStartY, fEndX, fEndY;
                float fOuterStartX = 1;
                float fOuterStartY = 1;
                float fOuterEndX = objChippedOffROI.ref_ROIWidth;
                float fOuterEndY = objChippedOffROI.ref_ROIHeight;
                float fInterStartX = fDefectLengthPixelLeft;
                float fInterStartY = fDefectLengthPixelTop;
                float fInterEndX = (float)objChippedOffROI.ref_ROIWidth - fDefectLengthPixelRight - 1;
                float fInterEndY = (float)objChippedOffROI.ref_ROIHeight - fDefectLengthPixelBottom - 1;
                // float fTolerance = 2f;
                fDefectLengthPixelLeft = intCeilChipLengthLeft + intCeilChipLengthLeft_Extend;
                fDefectLengthPixelTop = intCeilChipLengthTop + intCeilChipLengthTop_Extend;
                fDefectLengthPixelRight = intCeilChipLengthRight + intCeilChipLengthRight_Extend;
                fDefectLengthPixelBottom = intCeilChipLengthBottom + intCeilChipLengthBottom_Extend;
                intCeilChipLengthLeft += intCeilChipLengthLeft_Extend;
                intCeilChipLengthTop += intCeilChipLengthTop_Extend;
                intCeilChipLengthRight += intCeilChipLengthRight_Extend;
                intCeilChipLengthBottom += intCeilChipLengthBottom_Extend;
                float fToleranceLeft = fDefectLengthPixelLeft / 2;
                float fToleranceTop = fDefectLengthPixelTop / 2;
                float fToleranceRight = fDefectLengthPixelRight / 2;
                float fToleranceBottom = fDefectLengthPixelBottom / 2;
                int intFailCount = 0;
                List<int> arrMatchIndex = new List<int>();
                for (int i = 0; i < m_objImage1ChipOffEBlobsFor2Pixel.ref_intNumSelectedObject; i++)
                {
                    for (int j = 0; j < m_objImage1ChipOffEBlobs.ref_intNumSelectedObject; j++)
                    {
                        if ((m_objImage1ChipOffEBlobsFor2Pixel.ref_arrLimitCenterX[i] == m_objImage1ChipOffEBlobs.ref_arrLimitCenterX[j]) && (m_objImage1ChipOffEBlobsFor2Pixel.ref_arrLimitCenterY[i] == m_objImage1ChipOffEBlobs.ref_arrLimitCenterY[j]))
                        {
                            if (m_objImage1ChipOffEBlobsFor2Pixel.ref_arrArea[i] == m_objImage1ChipOffEBlobs.ref_arrArea[j])
                                arrMatchIndex.Add(j);
                        }
                    }
                }

                List<int> arrFinalMatchIndex = new List<int>();
                for (int i = 0; i < m_objImage1ChipOffEBlobs.ref_intNumSelectedObject; i++)
                {
                    int MatchCount = 0;
                    for (int j = 0; j < arrMatchIndex.Count; j++)
                    {
                        if (arrMatchIndex[j] == i)
                        {
                            MatchCount++;
                            break;
                        }
                    }
                    if (MatchCount == 0)
                        arrFinalMatchIndex.Add(i);
                }
                for (int i = 0; i < arrFinalMatchIndex.Count; i++)
                {
                    fObjectCenterX = m_objImage1ChipOffEBlobs.ref_arrLimitCenterX[arrFinalMatchIndex[i]];
                    fObjectCenterY = m_objImage1ChipOffEBlobs.ref_arrLimitCenterY[arrFinalMatchIndex[i]];
                    fObjectWidth = m_objImage1ChipOffEBlobs.ref_arrWidth[arrFinalMatchIndex[i]];
                    fObjectHeight = m_objImage1ChipOffEBlobs.ref_arrHeight[arrFinalMatchIndex[i]];
                    intObjectArea = m_objImage1ChipOffEBlobs.ref_arrArea[arrFinalMatchIndex[i]];


                    fStartX = fObjectCenterX - (fObjectWidth / 2);
                    fStartY = fObjectCenterY - (fObjectHeight / 2);
                    fEndX = fObjectCenterX + (fObjectWidth / 2);
                    fEndY = fObjectCenterY + (fObjectHeight / 2);

                    bool blnDefect = false;
                    float fAddX = 0;
                    float fAddY = 0;
                    bool blnFailWidth = false;

                    float fWidthMM = (fObjectWidth + fAddX) / m_fMMToPixelXValue;
                    float fHeightMM = (fObjectHeight + fAddY) / m_fMMToPixelYValue; // 11-04-2019 ZJYEOH : Changed m_fMMToPixelXValue to m_fMMToPixelYValue
                    float fAreaInMM = intObjectArea / m_fMMToPixelXValue / m_fMMToPixelYValue;
                    float fChipAreaLimit;
                    if (intImageIndex == 1)
                        fChipAreaLimit = m_fBrightChippedOffArea;
                    else
                        fChipAreaLimit = m_fDarkChippedOffArea;

                    Defect objDefect = new Defect();
                    objDefect.ref_intImageNo = intImageIndex;

                    objDefect.ref_strName = "Chipped Off";

                    objDefect.ref_fCenterX = ROITotalX + objChippedOffROI.ref_ROITotalX + fObjectCenterX;
                    objDefect.ref_fCenterY = ROITotalY + objChippedOffROI.ref_ROITotalY + fObjectCenterY;
                    objDefect.ref_fStartX = ROITotalX + fStartX;
                    objDefect.ref_fStartY = ROITotalY + fStartY;
                    objDefect.ref_fEndX = ROITotalX + fEndX;
                    objDefect.ref_fEndY = ROITotalY + fEndY;
                    objDefect.ref_fWidth = fObjectWidth + fAddX;
                    objDefect.ref_fHeight = fObjectHeight + fAddY;
                    objDefect.ref_fArea = intObjectArea;
                    objDefect.ref_fWidthInMM = fWidthMM;
                    objDefect.ref_fHeightInMM = fHeightMM;
                    objDefect.ref_fAreaInMM2 = fAreaInMM;

                    objDefect.ref_fFailValue = fAreaInMM;

                    if (fAreaInMM > fChipAreaLimit)//(blnDefect && fAreaInMM > fChipAreaLimit)
                    {
                        intFailCount++;


                        //0x02
                        m_intFailPkgResultMask |= 0x04; // Fail image 1 chipped off

                        //Defect objDefect = new Defect();
                        //objDefect.ref_intImageNo = intImageIndex;

                        //objDefect.ref_strName = "Chipped Off";

                        objDefect.ref_intFailMask = 0x04;//0x02
                        //objDefect.ref_fCenterX = ROITotalX + objChippedOffROI.ref_ROITotalX + fObjectCenterX;
                        //objDefect.ref_fCenterY = ROITotalY + objChippedOffROI.ref_ROITotalY + fObjectCenterY;
                        //objDefect.ref_fStartX = ROITotalX + fStartX;
                        //objDefect.ref_fStartY = ROITotalY + fStartY;
                        //objDefect.ref_fEndX = ROITotalX + fEndX;
                        //objDefect.ref_fEndY = ROITotalY + fEndY;
                        //objDefect.ref_fWidth = fObjectWidth + fAddX;
                        //objDefect.ref_fHeight = fObjectHeight + fAddY;
                        //objDefect.ref_fArea = intObjectArea;
                        //objDefect.ref_fWidthInMM = fWidthMM;
                        //objDefect.ref_fHeightInMM = fHeightMM;
                        //objDefect.ref_fAreaInMM2 = fAreaInMM;

                        ////if (blnFailWidth)
                        ////{
                        ////    objDefect.ref_fFailValue = fWidthMM;
                        ////    objDefect.ref_intFailCriteria |= 0x01;
                        ////}
                        ////else
                        ////{
                        ////    objDefect.ref_fFailValue = fHeightMM;
                        ////    objDefect.ref_intFailCriteria |= 0x02;
                        ////}

                        //objDefect.ref_fFailValue = fAreaInMM;
                        objDefect.ref_intFailCriteria |= 0x04;

                        //m_arrPkgDefectList.Add(objDefect);

                        if (blnResult)
                            blnResult = false;
                    }
                    m_arrPkgDefectList.Add(objDefect);
                }
            }

            objChippedOffROI.Dispose();

            return blnResult;
        }
        private bool IsImage1UnitChippedOff2_Area(ROI objImage1UnitROI, int ROITotalX, int ROITotalY, int intImageIndex)
        {
            /*
             * Algoritm:
             * 
             *
             * 
             * 
             * 
             * 
             */


            bool blnResult = true;
            bool blnDebugImage = false;

            // Get Chipped off setting length in pixel
            int intCeilChipLengthLeft = (int)Math.Ceiling(m_fChipStartPixelFromLeft);//* m_fMMToPixelXValue
            int intCeilChipLengthTop = (int)Math.Ceiling(m_fChipStartPixelFromEdge);
            int intCeilChipLengthRight = (int)Math.Ceiling(m_fChipStartPixelFromRight);
            int intCeilChipLengthBottom = (int)Math.Ceiling(m_fChipStartPixelFromBottom);

            ROI objChippedOffROI = new ROI();
            objChippedOffROI.AttachImage(objImage1UnitROI); // m_objInsSurfacePkgImage1 is sample image after double threshold
            //objChippedOffROI.LoadROISetting(objImage1UnitROI.ref_ROITotalX,
            //                                            objImage1UnitROI.ref_ROITotalY,
            //                                            objImage1UnitROI.ref_ROIWidth,
            //                                            objImage1UnitROI.ref_ROIHeight);
            objChippedOffROI.LoadROISetting(0, 0, objImage1UnitROI.ref_ROIWidth, objImage1UnitROI.ref_ROIHeight);
            objChippedOffROI.CopyToImage(ref m_objInsChipOffPkgImage1); // Copy sample image to another image memory so that image can be modified without affect the original image.
            objChippedOffROI.AttachImage(m_objInsChipOffPkgImage1);
            objChippedOffROI.LoadROISetting(0, 0, m_objInsChipOffPkgImage1.ref_intImageWidth, m_objInsChipOffPkgImage1.ref_intImageHeight);

            if (intImageIndex == 1)
                FillChipLineLimitToCorner_4Edges(m_objInsChipOffPkgImage1, intCeilChipLengthLeft, intCeilChipLengthTop, intCeilChipLengthRight, intCeilChipLengthBottom, 0);
            else
                FillChipLineLimitToCorner_4Edges(m_objInsChipOffPkgImage1, intCeilChipLengthLeft, intCeilChipLengthTop, intCeilChipLengthRight, intCeilChipLengthBottom, 255);


            bool blnBlackOnWhite;
            if (intImageIndex == 1)
                blnBlackOnWhite = false;
            else
                blnBlackOnWhite = true;

            switch (intImageIndex)
            {
                case 1: // Image 1 (Grab 1 & Grab 2 Merged)
                    {
                        m_objImage1ChipOffEBlobs.BuildObjects_Filter_GetElement(objChippedOffROI, blnBlackOnWhite, true, 0, 125,
                            (int)Math.Floor(m_fSurfaceMinArea), 999999, false, 0x0F);
                    }
                    break;
                case 2: // Image 2 (Grab 3)
                    {
                        m_objImage1ChipOffEBlobs.BuildObjects_Filter_GetElement(objChippedOffROI, blnBlackOnWhite, true, 0, 125,
                            (int)Math.Floor(m_fImage2SurfaceMinArea), 999999, false, 0x0F);
                    }
                    break;
            }
            if (blnDebugImage)
            {
                objImage1UnitROI.SaveImage("D:\\TS\\objImage1UnitROI.bmp");// debug
                objChippedOffROI.SaveImage("D:\\TS\\objChippedOffROI.bmp");// debug 
            }

            if (m_objImage1ChipOffEBlobs.ref_intNumSelectedObject > 0)
            {
                float fDefectLengthPixelLeft = m_fChipStartPixelFromLeft;
                float fDefectLengthPixelTop = m_fChipStartPixelFromEdge;
                float fDefectLengthPixelRight = m_fChipStartPixelFromRight;
                float fDefectLengthPixelBottom = m_fChipStartPixelFromBottom;
                int intObjectArea = 0;
                float fObjectHeight = 0, fObjectWidth = 0, fObjectCenterX = 0, fObjectCenterY = 0;
                float fStartX, fStartY, fEndX, fEndY;
                float fOuterStartX = 1;
                float fOuterStartY = 1;
                float fOuterEndX = objChippedOffROI.ref_ROIWidth;
                float fOuterEndY = objChippedOffROI.ref_ROIHeight;
                float fInterStartX = fDefectLengthPixelLeft;
                float fInterStartY = fDefectLengthPixelTop;
                float fInterEndX = (float)objChippedOffROI.ref_ROIWidth - fDefectLengthPixelRight - 1;
                float fInterEndY = (float)objChippedOffROI.ref_ROIHeight - fDefectLengthPixelBottom - 1;
                // float fTolerance = 2f;
                float fToleranceLeft = fDefectLengthPixelLeft / 2;
                float fToleranceTop = fDefectLengthPixelTop / 2;
                float fToleranceRight = fDefectLengthPixelRight / 2;
                float fToleranceBottom = fDefectLengthPixelBottom / 2;
                int intFailCount = 0;

                for (int i = 0; i < m_objImage1ChipOffEBlobs.ref_intNumSelectedObject; i++)
                {
                    fObjectCenterX = m_objImage1ChipOffEBlobs.ref_arrLimitCenterX[i];
                    fObjectCenterY = m_objImage1ChipOffEBlobs.ref_arrLimitCenterY[i];
                    fObjectWidth = m_objImage1ChipOffEBlobs.ref_arrWidth[i];
                    fObjectHeight = m_objImage1ChipOffEBlobs.ref_arrHeight[i];
                    intObjectArea = m_objImage1ChipOffEBlobs.ref_arrArea[i];


                    fStartX = fObjectCenterX - (fObjectWidth / 2);
                    fStartY = fObjectCenterY - (fObjectHeight / 2);
                    fEndX = fObjectCenterX + (fObjectWidth / 2);
                    fEndY = fObjectCenterY + (fObjectHeight / 2);

                    bool blnDefect = false;
                    float fAddX = 0;
                    float fAddY = 0;
                    bool blnFailWidth = false;

                    if (fStartX < fInterStartX) // Possible Left Chipped
                    {
                        if (fStartY < fInterStartY) // Possible Top Chipped
                        {
                            if (fStartX < fStartY)  // Confirm Left Chipped
                            {
                                if (fObjectWidth >= fDefectLengthPixelLeft)  // Is Chipped over setting min value
                                {
                                    blnDefect = true;
                                    blnFailWidth = true;
                                }
                                else if ((fObjectCenterX - fObjectWidth / 2) > 0)
                                {
                                    //if (fObjectWidth == intCeilChipLengthX - fTolerance)    // Is Chipped same length with chip setting + tolerance
                                    if (fObjectWidth >= intCeilChipLengthLeft - fToleranceLeft)    // Is Chipped over chip setting - tolerance
                                    {
                                        //if ((fTolerance - (fObjectCenterX + fObjectWidth / 2)) <= fTolerance) // Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                                        if ((fToleranceLeft - (fObjectCenterX + fObjectWidth / 2)) <= fToleranceLeft) // Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                                        {
                                            blnDefect = true;
                                            blnFailWidth = true;
                                            fAddX = fObjectCenterX - fObjectWidth / 2;
                                        }
                                    }
                                }
                            }
                            else // Confirm Top Chipped
                            {
                                if (fObjectHeight >= fDefectLengthPixelTop) // Is Chipped over setting min value
                                {
                                    blnDefect = true;
                                }
                                else if ((fObjectCenterY - fObjectHeight / 2) > 0)
                                {
                                    //if (fObjectHeight == intCeilChipLengthY - fTolerance) // Is Chipped same length with chip setting + tolerance
                                    if (fObjectHeight >= intCeilChipLengthTop - fToleranceTop)    // Is Chipped over chip setting - tolerance
                                    {
                                        //if ((fInterStartY - (fObjectCenterY + fObjectHeight / 2)) <= fTolerance)// Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                                        if ((fInterStartY - (fObjectCenterY + fObjectHeight / 2)) <= fToleranceTop)// Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                                        {
                                            blnDefect = true;
                                            fAddY = fObjectCenterY - fObjectHeight / 2;
                                        }
                                    }
                                }

                            }
                        }
                        else if (fEndY > fInterEndY)    // Possible Bottom Chipped
                        {
                            if (fStartX < (objChippedOffROI.ref_ROIHeight - fEndY)) // Confirm Left Chipped
                            {
                                if (fObjectWidth >= fDefectLengthPixelBottom)  // Is Chipped over setting min value
                                {
                                    blnDefect = true;
                                    blnFailWidth = true;
                                }
                                else if ((fObjectCenterX - fObjectWidth / 2) > 0)   // Need to make sure object size not touching Unit edge if object size less than setting min value.
                                {
                                    //if (fObjectWidth == intCeilChipLengthX - fTolerance)    // Is Chipped same length with chip setting + tolerance
                                    if (fObjectWidth >= intCeilChipLengthBottom - fToleranceBottom)    // Is Chipped over chip setting - tolerance
                                    {
                                        //if ((fInterStartX - (fObjectCenterX + fObjectWidth / 2)) <= fTolerance) // Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                                        if ((fInterStartX - (fObjectCenterX + fObjectWidth / 2)) <= fToleranceBottom) // Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                                        {
                                            blnDefect = true;
                                            blnFailWidth = true;
                                            fAddX = fObjectCenterX - fObjectWidth / 2;
                                        }
                                    }
                                }
                            }
                            else // Confirm BOttom Chipped
                            {
                                if (fObjectHeight >= fDefectLengthPixelBottom) // Is Chipped over setting min value
                                {
                                    blnDefect = true;
                                }
                                else if ((objChippedOffROI.ref_ROIHeight - fEndY) > 0)   // Make sure object no touch outerEndY
                                {
                                    //if (fObjectHeight == intCeilChipLengthY - fTolerance) // Is Chipped same length with chip setting + tolerance
                                    if (fObjectHeight >= intCeilChipLengthBottom - fToleranceBottom)    // Is Chipped over chip setting - tolerance
                                    {
                                        //if (((fObjectCenterY - fObjectHeight / 2) - fInterEndY) <= fTolerance)// Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                                        //if (((fObjectCenterY - fObjectHeight / 2) - fInterEndY) <= fToleranceBottom)// Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                                        if ((fStartY - fInterEndY) <= 0.5) // Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                                        {
                                            blnDefect = true;
                                            fAddY = objChippedOffROI.ref_ROIHeight - (fObjectCenterY + fObjectHeight / 2);
                                        }
                                    }
                                }
                            }
                        }
                        else // Confirm Left Chipped
                        {
                            if (fObjectWidth >= fDefectLengthPixelLeft)  // Is Chipped over setting min value
                            {
                                blnDefect = true;
                                blnFailWidth = true;
                            }
                            else if ((fObjectCenterX - fObjectWidth / 2) > 0)
                            {
                                //if (fObjectWidth == intCeilChipLengthX - fTolerance)    // Is Chipped same length with chip setting + tolerance
                                if (fObjectWidth >= intCeilChipLengthLeft - fToleranceLeft)    // Is Chipped over chip setting - tolerance
                                {
                                    //if ((fInterStartX - (fObjectCenterX + fObjectWidth / 2)) <= fTolerance) // Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                                    if ((fInterStartX - (fObjectCenterX + fObjectWidth / 2)) <= fToleranceLeft) // Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                                    {
                                        blnDefect = true;
                                        blnFailWidth = true;
                                        fAddX = fObjectCenterX - fObjectWidth / 2;
                                    }
                                }
                            }

                        }
                    }

                    if (!blnDefect && fEndX > fInterEndX) // Possible Right Chipped
                    {
                        if (fStartY < fInterStartY) // Possible Top Chipped
                        {
                            if (fStartY < (objChippedOffROI.ref_ROIWidth - fEndX))  // Confirm Top Chipped
                            {
                                if (fObjectHeight >= fDefectLengthPixelTop)  // Is Chipped over setting min value
                                {
                                    blnDefect = true;
                                }
                                else if ((fObjectCenterY - fObjectHeight / 2) > 0)
                                {
                                    //if (fObjectHeight == intCeilChipLengthY - fTolerance) // Is Chipped same length with chip setting + tolerance
                                    if (fObjectHeight >= intCeilChipLengthTop - fToleranceTop)    // Is Chipped over chip setting - tolerance
                                    {
                                        //if ((fInterStartY - (fObjectCenterY + fObjectHeight / 2)) <= fTolerance)// Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                                        if ((fInterStartY - (fObjectCenterY + fObjectHeight / 2)) <= fToleranceTop)// Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                                        {
                                            blnDefect = true;
                                            fAddY = fObjectCenterY - fObjectHeight / 2;
                                        }
                                    }
                                }
                            }
                            else // Confirm Right Chipped
                            {
                                if (fObjectWidth >= fDefectLengthPixelRight) // Is Chipped over setting min value
                                {
                                    blnDefect = true;
                                    blnFailWidth = true;
                                }
                                else if ((objChippedOffROI.ref_ROIWidth - fEndX) > 0)   // Make sure object no touch outerEndX
                                {
                                    //if (fObjectWidth == intCeilChipLengthX - fTolerance)    // Is Chipped same length with chip setting + tolerance
                                    if (fObjectWidth >= intCeilChipLengthRight - fToleranceRight)    // Is Chipped over chip setting - tolerance
                                    {
                                        //if (((fObjectCenterX - fObjectWidth / 2) - fInterEndX) <= fTolerance) // Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                                        //if (((fObjectCenterX - fObjectWidth / 2) - fInterEndX) <= fToleranceRight) // Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                                        if ((fStartX - fInterEndX) <= 0.5) // Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                                        {
                                            blnDefect = true;
                                            blnFailWidth = true;
                                            fAddX = objChippedOffROI.ref_ROIWidth - (fObjectCenterX + fObjectWidth / 2);
                                        }
                                    }
                                }
                            }
                        }
                        else if (fEndY > fInterEndY)    // Possible Bottom Chipped
                        {
                            if ((objChippedOffROI.ref_ROIWidth - fEndX) < (objChippedOffROI.ref_ROIHeight - fEndY)) // Confirm Right Chipped
                            {
                                if (fObjectWidth >= fDefectLengthPixelRight)  // Is Chipped over setting min value
                                {
                                    blnDefect = true;
                                    blnFailWidth = true;
                                }
                                else if ((objChippedOffROI.ref_ROIWidth - fEndX) > 0)   // Make sure object no touch outerEndX
                                {
                                    //if (fObjectWidth == intCeilChipLengthX - fTolerance)    // Is Chipped same length with chip setting + tolerance
                                    if (fObjectWidth >= intCeilChipLengthRight - fToleranceRight)    // Is Chipped over chip setting - tolerance
                                    {
                                        //if (((fObjectCenterX - fObjectWidth / 2) - fInterEndX) <= fTolerance) // Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                                        //if (((fObjectCenterX - fObjectWidth / 2) - fInterEndX) <= fToleranceRight) // Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                                        if ((fStartX - fInterEndX) <= 0.5) // Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                                        {
                                            blnDefect = true;
                                            blnFailWidth = true;
                                            fAddX = objChippedOffROI.ref_ROIWidth - (fObjectCenterX + fObjectWidth / 2);
                                        }
                                    }
                                }
                            }
                            else // Confirm BOttom Chipped
                            {
                                if (fObjectHeight >= fDefectLengthPixelBottom) // Is Chipped over setting min value
                                {
                                    blnDefect = true;
                                }
                                else if ((objChippedOffROI.ref_ROIHeight - fEndY) > 0)   // Make sure object no touch outerEndY
                                {
                                    //if (fObjectHeight == intCeilChipLengthY - fTolerance) // Is Chipped same length with chip setting + tolerance
                                    if (fObjectHeight >= intCeilChipLengthBottom - fToleranceBottom)    // Is Chipped over chip setting - tolerance
                                    {
                                        //if (((fObjectCenterY - fObjectHeight / 2) - fInterEndY) <= fTolerance)// Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                                        //if (((fObjectCenterY - fObjectHeight / 2) - fInterEndY) <= fToleranceBottom)// Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                                        if ((fStartY - fInterEndY) <= 0.5) // Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                                        {
                                            blnDefect = true;
                                            fAddY = objChippedOffROI.ref_ROIHeight - (fObjectCenterY + fObjectHeight / 2);
                                        }
                                    }
                                }
                            }
                        }
                        else // Confirm Right Chipped
                        {
                            if (fObjectWidth >= fDefectLengthPixelRight)  // Is Chipped over setting min value
                            {
                                blnDefect = true;
                                blnFailWidth = true;
                            }
                            else if ((objChippedOffROI.ref_ROIWidth - fEndX) > 0)   // Make sure object no touch outerEndX
                            {
                                if (fObjectWidth >= intCeilChipLengthRight - fToleranceRight)    // Is Chipped same length with chip setting + tolerance
                                {
                                    //if (((fObjectCenterX - fObjectWidth / 2) - fInterEndX) <= fTolerance) // Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                                    //if (((fObjectCenterX - fObjectWidth / 2) - fInterEndX) <= fToleranceRight) // Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                                    if ((fStartX - fInterEndX) <= 0.5) // Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                                    {
                                        blnDefect = true;
                                        blnFailWidth = true;
                                        fAddX = objChippedOffROI.ref_ROIWidth - (fObjectCenterX + fObjectWidth / 2);
                                    }
                                }
                            }
                        }
                    }

                    if (!blnDefect && fStartY < fInterStartY) // Possible Top chipped
                    {
                        if (fStartX < fInterStartX) // Possible Left Chipped
                        {
                            if (fStartX < fStartY)  // Confirm Left Chipped
                            {
                                if (fObjectWidth >= fDefectLengthPixelLeft)  // Is Chipped over setting min value
                                {
                                    blnDefect = true;
                                    blnFailWidth = true;
                                }
                                else if ((fObjectCenterX - fObjectWidth / 2) > 0)
                                {
                                    //if (fObjectWidth == intCeilChipLengthX - fTolerance)    // Is Chipped same length with chip setting + tolerance
                                    if (fObjectWidth >= intCeilChipLengthLeft - fToleranceLeft)    // Is Chipped over chip setting - tolerance
                                    {
                                        //if ((fInterStartX - (fObjectCenterX + fObjectWidth / 2)) <= fTolerance) // Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                                        if ((fInterStartX - (fObjectCenterX + fObjectWidth / 2)) <= fToleranceLeft) // Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                                        {
                                            blnDefect = true;
                                            blnFailWidth = true;
                                            fAddX = fObjectCenterX - fObjectWidth / 2;
                                        }
                                    }
                                }

                            }
                            else // Confirm Top Chipped
                            {
                                if (fObjectHeight >= fDefectLengthPixelTop) // Is Chipped over setting min value
                                {
                                    blnDefect = true;
                                }
                                else if ((fObjectCenterY - fObjectHeight / 2) > 0)
                                {
                                    //if (fObjectHeight == intCeilChipLengthY - fTolerance) // Is Chipped same length with chip setting + tolerance
                                    if (fObjectHeight >= intCeilChipLengthTop - fToleranceTop)    // Is Chipped over chip setting - tolerance
                                    {
                                        //if ((fInterStartY - (fObjectCenterY + fObjectHeight / 2)) <= fTolerance)// Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                                        if ((fInterStartY - (fObjectCenterY + fObjectHeight / 2)) <= fToleranceTop)// Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                                        {
                                            blnDefect = true;
                                            fAddY = fObjectCenterY - fObjectHeight / 2;
                                        }
                                    }
                                }
                            }
                        }
                        else if (fEndX > fInterEndX)    // Possible Right Chipped
                        {
                            if (fStartY < (objChippedOffROI.ref_ROIWidth - fEndX)) // Confirm Top Chipped
                            {
                                if (fObjectHeight >= fDefectLengthPixelTop)  // Is Chipped over setting min value
                                {
                                    blnDefect = true;
                                }
                                else if ((fObjectCenterY - fObjectHeight / 2) > 0)
                                {
                                    //if (fObjectHeight == intCeilChipLengthY - fTolerance) // Is Chipped same length with chip setting + tolerance
                                    if (fObjectHeight >= intCeilChipLengthTop - fToleranceTop)    // Is Chipped over chip setting - tolerance
                                    {
                                        //if ((fInterStartY - (fObjectCenterY + fObjectHeight / 2)) <= fTolerance)// Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                                        if ((fInterStartY - (fObjectCenterY + fObjectHeight / 2)) <= fToleranceTop)// Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                                        {
                                            blnDefect = true;
                                            fAddY = fObjectCenterY - fObjectHeight / 2;
                                        }
                                    }
                                }
                            }
                            else // Confirm Right Chipped
                            {
                                if (fObjectWidth >= fDefectLengthPixelRight) // Is Chipped over setting min value
                                {
                                    blnDefect = true;
                                    blnFailWidth = true;
                                }
                                else if ((objChippedOffROI.ref_ROIWidth - fEndX) > 0)   // Make sure object no touch outerEndX
                                {
                                    //if (fObjectWidth == intCeilChipLengthX - fTolerance)    // Is Chipped same length with chip setting + tolerance
                                    if (fObjectWidth >= intCeilChipLengthRight - fToleranceRight)    // Is Chipped over chip setting - tolerance
                                    {
                                        //if (((fObjectCenterX - fObjectWidth / 2) - fInterEndX) <= fTolerance) // Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                                        //if (((fObjectCenterX - fObjectWidth / 2) - fInterEndX) <= fToleranceRight) // Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                                        if ((fStartX - fInterEndX) <= 0.5) // Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                                        {
                                            blnDefect = true;
                                            blnFailWidth = true;
                                            fAddX = objChippedOffROI.ref_ROIWidth - (fObjectCenterX + fObjectWidth / 2);
                                        }
                                    }
                                }
                            }
                        }
                        else // Confirm Top Chipped
                        {
                            if (fObjectHeight >= fDefectLengthPixelTop)  // Is Chipped over setting min value
                            {
                                blnDefect = true;
                            }
                            else if ((fObjectCenterY - fObjectHeight / 2) > 0)
                            {
                                //if (fObjectHeight == intCeilChipLengthY - fTolerance) // Is Chipped same length with chip setting + tolerance
                                if (fObjectHeight >= intCeilChipLengthTop - fToleranceTop)    // Is Chipped over chip setting - tolerance
                                {
                                    //if ((fInterStartY - (fObjectCenterY + fObjectHeight / 2)) <= fTolerance)// Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                                    if ((fInterStartY - (fObjectCenterY + fObjectHeight / 2)) <= fToleranceTop)// Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                                    {
                                        blnDefect = true;
                                        fAddY = fObjectCenterY - fObjectHeight / 2;
                                    }
                                }
                            }
                        }
                    }

                    if (!blnDefect && fEndY > fInterEndY) // Possible Bottom Chipped
                    {
                        if (fStartX < fInterStartX) // Possible Left Chipped
                        {
                            if (fStartX < (objChippedOffROI.ref_ROIHeight - fEndY))  // Confirm Left Chipped
                            {
                                if (fObjectWidth >= fDefectLengthPixelLeft)  // Is Chipped over setting min value
                                {
                                    blnDefect = true;
                                    blnFailWidth = true;
                                }
                                else if ((fObjectCenterX - fObjectWidth / 2) > 0)
                                {
                                    //if (fObjectWidth == intCeilChipLengthX - fTolerance)    // Is Chipped same length with chip setting + tolerance
                                    if (fObjectWidth >= intCeilChipLengthLeft - fToleranceLeft)    // Is Chipped over chip setting - tolerance
                                    {
                                        //if ((fInterStartX - (fObjectCenterX + fObjectWidth / 2)) <= fTolerance) // Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                                        if ((fInterStartX - (fObjectCenterX + fObjectWidth / 2)) <= fToleranceLeft) // Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                                        {
                                            blnDefect = true;
                                            blnFailWidth = true;
                                            fAddX = fObjectCenterX - fObjectWidth / 2;
                                        }
                                    }
                                }

                            }
                            else // Confirm Bottom Chipped
                            {
                                if (fObjectHeight >= fDefectLengthPixelBottom) // Is Chipped over setting min value
                                {
                                    blnDefect = true;
                                }
                                else if ((objChippedOffROI.ref_ROIHeight - fEndY) > 0)   // Make sure object no touch outerEndY
                                {
                                    //if (fObjectHeight == intCeilChipLengthY - fTolerance) // Is Chipped same length with chip setting + tolerance
                                    if (fObjectHeight >= intCeilChipLengthBottom - fToleranceBottom)    // Is Chipped over chip setting - tolerance
                                    {
                                        //if (((fObjectCenterY - fObjectHeight / 2) - fInterEndY) <= fTolerance)// Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                                        //if (((fObjectCenterY - fObjectHeight / 2) - fInterEndY) <= fToleranceBottom)// Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                                        if ((fStartY - fInterEndY) <= 0.5) // Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                                        {
                                            blnDefect = true;
                                            fAddY = objChippedOffROI.ref_ROIHeight - (fObjectCenterY + fObjectHeight / 2);
                                        }
                                    }
                                }
                            }
                        }
                        else if (fEndX > fInterEndX)    // Possible Right Chipped
                        {
                            if ((objChippedOffROI.ref_ROIWidth - fEndX) < (objChippedOffROI.ref_ROIHeight - fEndY)) // Confirm Right Chipped
                            {
                                if (fObjectWidth >= fDefectLengthPixelRight)  // Is Chipped over setting min value
                                {
                                    blnDefect = true;
                                    blnFailWidth = true;
                                }
                                else if ((objChippedOffROI.ref_ROIWidth - fEndX) > 0)   // Make sure object no touch outerEndX
                                {
                                    //if (fObjectWidth == intCeilChipLengthX - fTolerance)    // Is Chipped same length with chip setting + tolerance
                                    if (fObjectWidth >= intCeilChipLengthRight - fToleranceRight)    // Is Chipped over chip setting - tolerance
                                    {
                                        //if (((fObjectCenterX - fObjectWidth / 2) - fInterEndX) <= fTolerance) // Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                                        //if (((fObjectCenterX - fObjectWidth / 2) - fInterEndX) <= fToleranceRight) // Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                                        if ((fStartX - fInterEndX) <= 0.5) // Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                                        {
                                            blnDefect = true;
                                            blnFailWidth = true;
                                            fAddX = objChippedOffROI.ref_ROIWidth - (fObjectCenterX + fObjectWidth / 2);
                                        }
                                    }
                                }
                            }
                            else // Confirm BOttom Chipped
                            {
                                if (fObjectHeight >= fDefectLengthPixelBottom) // Is Chipped over setting min value
                                {
                                    blnDefect = true;
                                }
                                else if ((objChippedOffROI.ref_ROIHeight - fEndY) > 0)   // Make sure object no touch outerEndY
                                {
                                    //if (fObjectHeight == intCeilChipLengthY - fTolerance) // Is Chipped same length with chip setting + tolerance
                                    if (fObjectHeight >= intCeilChipLengthBottom - fToleranceBottom)    // Is Chipped over chip setting - tolerance
                                    {
                                        //if (((fObjectCenterY - fObjectHeight / 2) - fInterEndY) <= fTolerance)// Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                                        //if (((fObjectCenterY - fObjectHeight / 2) - fInterEndY) <= fToleranceBottom)// Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                                        if ((fStartY - fInterEndY) <= 0.5) // Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                                        {
                                            blnDefect = true;
                                            fAddY = objChippedOffROI.ref_ROIHeight - (fObjectCenterY + fObjectHeight / 2);
                                        }
                                    }
                                }
                            }
                        }
                        else // Confirm Bottom Chipped
                        {
                            if (fObjectHeight >= fDefectLengthPixelBottom)  // Is Chipped over setting min value
                            {
                                blnDefect = true;
                            }
                            else if ((objChippedOffROI.ref_ROIHeight - fEndY) > 0)   // Make sure object no touch outerEndY
                            {
                                //if (fObjectHeight == intCeilChipLengthY - fTolerance) // Is Chipped same length with chip setting + tolerance
                                if (fObjectHeight >= intCeilChipLengthBottom - fToleranceBottom)    // Is Chipped over chip setting - tolerance
                                {
                                    //if (((fObjectCenterY - fObjectHeight / 2) - fInterEndY) <= fTolerance)// Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                                    //if (((fObjectCenterY - fObjectHeight / 2) - fInterEndY) <= fToleranceBottom)// Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                                    if ((fStartY - fInterEndY) <= 0.5) // Does chipped area reach to Limit Setting point (InterStart,InterEnd)
                                    {
                                        blnDefect = true;
                                        fAddY = objChippedOffROI.ref_ROIHeight - (fObjectCenterY + fObjectHeight / 2);
                                    }
                                }
                            }
                        }
                    }

                    float fWidthMM = (fObjectWidth + fAddX) / m_fMMToPixelXValue;
                    float fHeightMM = (fObjectHeight + fAddY) / m_fMMToPixelYValue; // 11-04-2019 ZJYEOH : Changed m_fMMToPixelXValue to m_fMMToPixelYValue
                    float fAreaInMM = intObjectArea / m_fMMToPixelXValue / m_fMMToPixelYValue;

                    if (blnDefect && fAreaInMM > m_fChipArea)
                    {
                        intFailCount++;


                        //0x02
                        m_intFailPkgResultMask |= 0x04; // Fail image 1 chipped off

                        Defect objDefect = new Defect();
                        objDefect.ref_intImageNo = intImageIndex;

                        objDefect.ref_strName = "Chipped Off";

                        objDefect.ref_intFailMask = 0x04;//0x02
                        objDefect.ref_fCenterX = ROITotalX + objChippedOffROI.ref_ROITotalX + fObjectCenterX;
                        objDefect.ref_fCenterY = ROITotalY + objChippedOffROI.ref_ROITotalY + fObjectCenterY;
                        objDefect.ref_fStartX = ROITotalX + fStartX;
                        objDefect.ref_fStartY = ROITotalY + fStartY;
                        objDefect.ref_fEndX = ROITotalX + fEndX;
                        objDefect.ref_fEndY = ROITotalY + fEndY;
                        objDefect.ref_fWidth = fObjectWidth + fAddX;
                        objDefect.ref_fHeight = fObjectHeight + fAddY;
                        objDefect.ref_fArea = intObjectArea;
                        objDefect.ref_fWidthInMM = fWidthMM;
                        objDefect.ref_fHeightInMM = fHeightMM;
                        objDefect.ref_fAreaInMM2 = fAreaInMM;

                        //if (blnFailWidth)
                        //{
                        //    objDefect.ref_fFailValue = fWidthMM;
                        //    objDefect.ref_intFailCriteria |= 0x01;
                        //}
                        //else
                        //{
                        //    objDefect.ref_fFailValue = fHeightMM;
                        //    objDefect.ref_intFailCriteria |= 0x02;
                        //}

                        objDefect.ref_fFailValue = fAreaInMM;
                        objDefect.ref_intFailCriteria |= 0x04;

                        m_arrPkgDefectList.Add(objDefect);

                        if (blnResult)
                            blnResult = false;
                    }

                }
            }

            objChippedOffROI.Dispose();

            return blnResult;
        }
        private void FillChipLineLimitToCorner_4Edges(ImageDrawing objImage,
            //int intChippedOffToleranceX, int intChippedOffToleranceY, int intChippedOffToleranceX2, int intChippedOffToleranceY2,
            int intChippedOffToleranceLeft, int intChippedOffToleranceTop, int intChippedOffToleranceRight, int intChippedOffToleranceBottom,
            int intChipLineLimitPixelValue)
        {
            if (objImage.ref_intImageHeight == 0 || objImage.ref_intImageWidth == 0)
                return;

            int intStartX1 = 0;
            int intStartY1 = 0;
            int intEndX1 = objImage.ref_intImageWidth - 1;
            int intEndY1 = objImage.ref_intImageHeight - 1;

            //int intStartX2 = intChippedOffToleranceX;
            //int intStartY2 = intChippedOffToleranceY;
            //int intEndX2 = objImage.ref_intImageWidth - intChippedOffToleranceX2 - 1;
            //int intEndY2 = objImage.ref_intImageHeight - intChippedOffToleranceY2 - 1;

            int intStartX2 = 0;
            int intStartY2 = 0;
            int intEndX2 = 0;
            int intEndY2 = 0;

            if (intChipLineLimitPixelValue == 0)
            {
                //intStartX2 = intChippedOffToleranceLeft - (int)m_fChipStartPixelExtendFromLeft;
                //intStartY2 = intChippedOffToleranceTop - (int)m_fChipStartPixelExtendFromEdge;
                //intEndX2 = objImage.ref_intImageWidth - intChippedOffToleranceRight + (int)m_fChipStartPixelExtendFromRight - 1;
                //intEndY2 = objImage.ref_intImageHeight - intChippedOffToleranceBottom + (int)m_fChipStartPixelExtendFromBottom - 1;

                intStartX2 = intChippedOffToleranceLeft;
                intStartY2 = intChippedOffToleranceTop;
                intEndX2 = objImage.ref_intImageWidth - intChippedOffToleranceRight - 1;
                intEndY2 = objImage.ref_intImageHeight - intChippedOffToleranceBottom - 1;
            }
            else
            {
                //intStartX2 = intChippedOffToleranceLeft - (int)m_fChipStartPixelExtendFromLeft_Dark;
                //intStartY2 = intChippedOffToleranceTop - (int)m_fChipStartPixelExtendFromEdge_Dark;
                //intEndX2 = objImage.ref_intImageWidth - intChippedOffToleranceRight + (int)m_fChipStartPixelExtendFromRight_Dark - 1;
                //intEndY2 = objImage.ref_intImageHeight - intChippedOffToleranceBottom + (int)m_fChipStartPixelExtendFromBottom_Dark - 1;

                intStartX2 = intChippedOffToleranceLeft;
                intStartY2 = intChippedOffToleranceTop;
                intEndX2 = objImage.ref_intImageWidth - intChippedOffToleranceRight - 1;
                intEndY2 = objImage.ref_intImageHeight - intChippedOffToleranceBottom - 1;
            }

            Line objLine1 = new Line();
            Line objLine2 = new Line();
            Line objLine3 = new Line();
            Line objLine4 = new Line();
            objLine1.CalculateStraightLine(new PointF(intStartX1, intStartY1), new PointF(intStartX2, intStartY2));
            objLine2.CalculateStraightLine(new PointF(intEndX1, intStartY1), new PointF(intEndX2, intStartY2));
            objLine3.CalculateStraightLine(new PointF(intStartX1, intEndY1), new PointF(intStartX2, intEndY2));
            objLine4.CalculateStraightLine(new PointF(intEndX1, intEndY1), new PointF(intEndX2, intEndY2));
            int x, y;
            EBW8 darkPixel = new EBW8((byte)intChipLineLimitPixelValue);

            // -------- separate corner with dark line -------------------------------------------
            if ((intStartX2 - intStartX1) >= (intStartY2 - intStartY1))
            {
                for (x = intStartX1; x <= intStartX2; x++)
                {
                    y = (int)Math.Round(objLine1.GetPointY(x), 0, MidpointRounding.AwayFromZero);

                    if (!(y >= 0 && y < objImage.ref_objMainImage.Height &&
                         x >= 0 && x < objImage.ref_objMainImage.Width))
                    {
                        continue;
                    }

                    if (y < objImage.ref_objMainImage.Height)
                        objImage.ref_objMainImage.SetPixel(darkPixel, x, y);
                }
            }
            else
            {
                for (y = intStartY1; y <= intStartY2; y++)
                {
                    x = (int)Math.Round(objLine1.GetPointX(y), 0, MidpointRounding.AwayFromZero);

                    if (!(y >= 0 && y < objImage.ref_objMainImage.Height &&
                         x >= 0 && x < objImage.ref_objMainImage.Width))
                    {
                        continue;
                    }

                    if (x < objImage.ref_objMainImage.Width)
                        objImage.ref_objMainImage.SetPixel(darkPixel, x, y);
                }
            }

            if ((intEndX1 - intEndX2) >= (intStartY2 - intStartY1))
            {
                for (x = intEndX2; x <= intEndX1; x++)
                {
                    y = (int)Math.Round(objLine2.GetPointY(x), 0, MidpointRounding.AwayFromZero);

                    if (!(y >= 0 && y < objImage.ref_objMainImage.Height &&
                         x >= 0 && x < objImage.ref_objMainImage.Width))
                    {
                        continue;
                    }

                    if (y < objImage.ref_objMainImage.Height)
                        objImage.ref_objMainImage.SetPixel(darkPixel, x, y);
                }
            }
            else
            {
                for (y = intStartY1; y <= intStartY2; y++)
                {
                    x = (int)Math.Round(objLine2.GetPointX(y), 0, MidpointRounding.AwayFromZero);

                    if (!(y >= 0 && y < objImage.ref_objMainImage.Height &&
                         x >= 0 && x < objImage.ref_objMainImage.Width))
                    {
                        continue;
                    }

                    if (x < objImage.ref_objMainImage.Width)
                        objImage.ref_objMainImage.SetPixel(darkPixel, x, y);
                }
            }

            if ((intStartX2 - intStartX1) >= (intEndY1 - intEndY2))
            {
                for (x = intStartX1; x <= intStartX2; x++)
                {
                    y = (int)Math.Round(objLine3.GetPointY(x), 0, MidpointRounding.AwayFromZero);

                    if (!(y >= 0 && y < objImage.ref_objMainImage.Height &&
                         x >= 0 && x < objImage.ref_objMainImage.Width))
                    {
                        continue;
                    }

                    if (y < objImage.ref_objMainImage.Height)
                        objImage.ref_objMainImage.SetPixel(darkPixel, x, y);
                }
            }
            else
            {
                for (y = intEndY2; y <= intEndY1; y++)
                {
                    x = (int)Math.Round(objLine3.GetPointX(y), 0, MidpointRounding.AwayFromZero);

                    if (!(y >= 0 && y < objImage.ref_objMainImage.Height &&
                         x >= 0 && x < objImage.ref_objMainImage.Width))
                    {
                        continue;
                    }

                    if (x < objImage.ref_objMainImage.Width)
                        objImage.ref_objMainImage.SetPixel(darkPixel, x, y);
                }
            }

            if ((intEndX1 - intEndX2) >= (intEndY1 - intEndY2))
            {
                for (x = intEndX2; x <= intEndX1; x++)
                {
                    y = (int)Math.Round(objLine4.GetPointY(x), 0, MidpointRounding.AwayFromZero);

                    if (!(y >= 0 && y < objImage.ref_objMainImage.Height &&
                         x >= 0 && x < objImage.ref_objMainImage.Width))
                    {
                        continue;
                    }

                    if (y < objImage.ref_objMainImage.Height)
                        objImage.ref_objMainImage.SetPixel(darkPixel, x, y);
                }
            }
            else
            {
                for (y = intEndY2; y <= intEndY1; y++)
                {
                    x = (int)Math.Round(objLine4.GetPointX(y), 0, MidpointRounding.AwayFromZero);

                    if (!(y >= 0 && y < objImage.ref_objMainImage.Height &&
                         x >= 0 && x < objImage.ref_objMainImage.Width))
                    {
                        continue;
                    }

                    if (x < objImage.ref_objMainImage.Width)
                        objImage.ref_objMainImage.SetPixel(darkPixel, x, y);
                }
            }

            // ------------------- Set limit with dark pixel --------------------------------------------------
            for (x = intStartX2; x < intEndX2; x++)
            {
                objImage.ref_objMainImage.SetPixel(darkPixel, x, intStartY2);
            }
            int intEnd = intEndY2;
            for (x = intStartX2; x < intEndX2; x++)
            {
                objImage.ref_objMainImage.SetPixel(darkPixel, x, intEnd);
            }
            for (y = intStartY2; y < intEndY2; y++)
            {
                objImage.ref_objMainImage.SetPixel(darkPixel, intStartX2, y);
            }
            intEnd = intEndX2;
            for (y = intStartY2; y < intEndY2; y++)
            {
                objImage.ref_objMainImage.SetPixel(darkPixel, intEnd, y);
            }
        }
        private void FillChipLineLimitToCorner_4Edges_TiltAngle(ImageDrawing objImage,
            int intChippedOffToleranceLeft, int intChippedOffToleranceTop, int intChippedOffToleranceRight, int intChippedOffToleranceBottom,
            int intChipLineLimitPixelValue)
        {
            if (objImage.ref_intImageHeight == 0 || objImage.ref_intImageWidth == 0)
                return;

            int intStartX1 = 0;
            int intStartY1 = 0;
            int intEndX1 = objImage.ref_intImageWidth - 1;
            int intEndY1 = objImage.ref_intImageHeight - 1;
            
            int intStartX2 = 0;
            int intStartY2 = 0;
            int intEndX2 = 0;
            int intEndY2 = 0;

            Point pCornerTL = new Point();
            Point pCornerTR = new Point();
            Point pCornerBL = new Point();
            Point pCornerBR = new Point();

            Line objLine1 = new Line();
            Line objLine2 = new Line();
            Line objLine3 = new Line();
            Line objLine4 = new Line();

            //objLine1.CalculateStraightLine(new PointF(intStartX1, intStartY1), new PointF(intStartX2, intStartY2));
            //objLine2.CalculateStraightLine(new PointF(intEndX1, intStartY1), new PointF(intEndX2, intStartY2));
            //objLine3.CalculateStraightLine(new PointF(intStartX1, intEndY1), new PointF(intStartX2, intEndY2));
            //objLine4.CalculateStraightLine(new PointF(intEndX1, intEndY1), new PointF(intEndX2, intEndY2));

            int x, y;
            EBW8 darkPixel = new EBW8((byte)intChipLineLimitPixelValue);
            switch (m_intPadROIDirection)
            {
                case 0:
                case 1:
                    if (intChipLineLimitPixelValue == 0)
                    {
                        int intInnerWidth = objImage.ref_intImageWidth - (intChippedOffToleranceLeft - (int)(m_fChipStartPixelExtendFromLeft) + intChippedOffToleranceRight - (int)m_fChipStartPixelExtendFromRight);
                        int intInnerHeight = objImage.ref_intImageHeight - (intChippedOffToleranceTop - (int)m_fChipStartPixelExtendFromEdge + intChippedOffToleranceBottom - (int)m_fChipStartPixelExtendFromBottom);
                        float fAngle = m_objRectGauge4L.GetGaugeTiltAngle();

                        int intSmallInnerWidth = (int)Math.Round(intInnerHeight * Math.Tan(fAngle / 180 * Math.PI));

                        pCornerTL = new Point(intChippedOffToleranceLeft - (int)m_fChipStartPixelExtendFromLeft, intChippedOffToleranceTop - (int)m_fChipStartPixelExtendFromEdge);
                        pCornerTR = new Point(objImage.ref_intImageWidth - intChippedOffToleranceRight + (int)m_fChipStartPixelExtendFromRight - 1, intChippedOffToleranceTop - (int)m_fChipStartPixelExtendFromEdge);
                        pCornerBL = new Point(intChippedOffToleranceLeft - (int)m_fChipStartPixelExtendFromLeft + intSmallInnerWidth, objImage.ref_intImageHeight - intChippedOffToleranceBottom + (int)m_fChipStartPixelExtendFromBottom - 1);
                        pCornerBR = new Point(objImage.ref_intImageWidth - intChippedOffToleranceRight + (int)m_fChipStartPixelExtendFromRight - 1 - intSmallInnerWidth, objImage.ref_intImageHeight - intChippedOffToleranceBottom + (int)m_fChipStartPixelExtendFromBottom - 1);
                    }
                    else
                    {
                        int intInnerWidth = objImage.ref_intImageWidth - (intChippedOffToleranceLeft - (int)m_fChipStartPixelExtendFromLeft_Dark + intChippedOffToleranceRight - (int)m_fChipStartPixelExtendFromRight_Dark);
                        int intInnerHeight = objImage.ref_intImageHeight - (intChippedOffToleranceTop - (int)m_fChipStartPixelExtendFromEdge_Dark + intChippedOffToleranceBottom - (int)m_fChipStartPixelExtendFromBottom_Dark);
                        float fAngle = m_objRectGauge4L.GetGaugeTiltAngle();

                        int intSmallInnerWidth = (int)Math.Round(intInnerHeight * Math.Tan(fAngle / 180 * Math.PI));

                        pCornerTL = new Point(intChippedOffToleranceLeft - (int)m_fChipStartPixelExtendFromLeft_Dark, intChippedOffToleranceTop - (int)m_fChipStartPixelExtendFromEdge_Dark);
                        pCornerTR = new Point(objImage.ref_intImageWidth - intChippedOffToleranceRight + (int)m_fChipStartPixelExtendFromRight_Dark - 1, intChippedOffToleranceTop - (int)m_fChipStartPixelExtendFromEdge_Dark);
                        pCornerBL = new Point(intChippedOffToleranceLeft - (int)m_fChipStartPixelExtendFromLeft_Dark + intSmallInnerWidth, objImage.ref_intImageHeight - intChippedOffToleranceBottom + (int)m_fChipStartPixelExtendFromBottom_Dark - 1);
                        pCornerBR = new Point(objImage.ref_intImageWidth - intChippedOffToleranceRight + (int)m_fChipStartPixelExtendFromRight_Dark - 1 - intSmallInnerWidth, objImage.ref_intImageHeight - intChippedOffToleranceBottom + (int)m_fChipStartPixelExtendFromBottom_Dark - 1);
                    }
                    break;
                case 2:
                    if (intChipLineLimitPixelValue == 0)
                    {
                        int intInnerWidth = objImage.ref_intImageWidth - (intChippedOffToleranceLeft - (int)m_fChipStartPixelExtendFromLeft + intChippedOffToleranceRight - (int)m_fChipStartPixelExtendFromRight);
                        int intInnerHeight = objImage.ref_intImageHeight - (intChippedOffToleranceTop - (int)m_fChipStartPixelExtendFromEdge + intChippedOffToleranceBottom - (int)m_fChipStartPixelExtendFromBottom);
                        float fAngle = m_objRectGauge4L.GetGaugeTiltAngle();

                        int intSmallInnerHeight = (int)Math.Round(intInnerWidth * Math.Tan(fAngle / 180 * Math.PI));

                        pCornerTL = new Point(intChippedOffToleranceLeft - (int)m_fChipStartPixelExtendFromLeft, intChippedOffToleranceTop - (int)m_fChipStartPixelExtendFromEdge + intSmallInnerHeight);
                        pCornerTR = new Point(objImage.ref_intImageWidth - intChippedOffToleranceRight + (int)m_fChipStartPixelExtendFromRight - 1, intChippedOffToleranceTop - (int)m_fChipStartPixelExtendFromEdge);
                        pCornerBL = new Point(intChippedOffToleranceLeft - (int)m_fChipStartPixelExtendFromLeft, objImage.ref_intImageHeight - intChippedOffToleranceBottom + (int)m_fChipStartPixelExtendFromBottom - 1 - intSmallInnerHeight);
                        pCornerBR = new Point(objImage.ref_intImageWidth - intChippedOffToleranceRight + (int)m_fChipStartPixelExtendFromRight - 1, objImage.ref_intImageHeight - intChippedOffToleranceBottom + (int)m_fChipStartPixelExtendFromBottom - 1);
                    }
                    else
                    {
                        int intInnerWidth = objImage.ref_intImageWidth - (intChippedOffToleranceLeft - (int)m_fChipStartPixelExtendFromLeft_Dark + intChippedOffToleranceRight - (int)m_fChipStartPixelExtendFromRight_Dark);
                        int intInnerHeight = objImage.ref_intImageHeight - (intChippedOffToleranceTop - (int)m_fChipStartPixelExtendFromEdge_Dark + intChippedOffToleranceBottom - (int)m_fChipStartPixelExtendFromBottom_Dark);
                        float fAngle = m_objRectGauge4L.GetGaugeTiltAngle();

                        int intSmallInnerHeight = (int)Math.Round(intInnerWidth * Math.Tan(fAngle / 180 * Math.PI));

                        pCornerTL = new Point(intChippedOffToleranceLeft - (int)m_fChipStartPixelExtendFromLeft_Dark, intChippedOffToleranceTop - (int)m_fChipStartPixelExtendFromEdge_Dark + intSmallInnerHeight);
                        pCornerTR = new Point(objImage.ref_intImageWidth - intChippedOffToleranceRight + (int)m_fChipStartPixelExtendFromRight_Dark - 1, intChippedOffToleranceTop - (int)m_fChipStartPixelExtendFromEdge_Dark);
                        pCornerBL = new Point(intChippedOffToleranceLeft - (int)m_fChipStartPixelExtendFromLeft_Dark, objImage.ref_intImageHeight - intChippedOffToleranceBottom + (int)m_fChipStartPixelExtendFromBottom_Dark - 1 - intSmallInnerHeight);
                        pCornerBR = new Point(objImage.ref_intImageWidth - intChippedOffToleranceRight + (int)m_fChipStartPixelExtendFromRight_Dark - 1, objImage.ref_intImageHeight - intChippedOffToleranceBottom + (int)m_fChipStartPixelExtendFromBottom_Dark - 1);
                    }

                    break;
                case 3:
                    if (intChipLineLimitPixelValue == 0)
                    {
                        int intInnerWidth = objImage.ref_intImageWidth - (intChippedOffToleranceLeft - (int)m_fChipStartPixelExtendFromLeft + intChippedOffToleranceRight - (int)m_fChipStartPixelExtendFromRight);
                        int intInnerHeight = objImage.ref_intImageHeight - (intChippedOffToleranceTop - (int)m_fChipStartPixelExtendFromEdge + intChippedOffToleranceBottom - (int)m_fChipStartPixelExtendFromBottom);
                        float fAngle = m_objRectGauge4L.GetGaugeTiltAngle();

                        int intSmallInnerWidth = (int)Math.Round(intInnerHeight * Math.Tan(fAngle / 180 * Math.PI));

                        pCornerTL = new Point(intChippedOffToleranceLeft - (int)m_fChipStartPixelExtendFromLeft + intSmallInnerWidth, intChippedOffToleranceTop - (int)m_fChipStartPixelExtendFromEdge);
                        pCornerTR = new Point(objImage.ref_intImageWidth - intChippedOffToleranceRight + (int)m_fChipStartPixelExtendFromRight - 1 - intSmallInnerWidth, intChippedOffToleranceTop - (int)m_fChipStartPixelExtendFromEdge);
                        pCornerBL = new Point(intChippedOffToleranceLeft - (int)m_fChipStartPixelExtendFromLeft, objImage.ref_intImageHeight - intChippedOffToleranceBottom + (int)m_fChipStartPixelExtendFromBottom - 1);
                        pCornerBR = new Point(objImage.ref_intImageWidth - intChippedOffToleranceRight + (int)m_fChipStartPixelExtendFromRight - 1, objImage.ref_intImageHeight - intChippedOffToleranceBottom + (int)m_fChipStartPixelExtendFromBottom - 1);
                    }
                    else
                    {
                        int intInnerWidth = objImage.ref_intImageWidth - (intChippedOffToleranceLeft - (int)m_fChipStartPixelExtendFromLeft_Dark + intChippedOffToleranceRight - (int)m_fChipStartPixelExtendFromRight_Dark);
                        int intInnerHeight = objImage.ref_intImageHeight - (intChippedOffToleranceTop - (int)m_fChipStartPixelExtendFromEdge_Dark + intChippedOffToleranceBottom - (int)m_fChipStartPixelExtendFromBottom_Dark);
                        float fAngle = m_objRectGauge4L.GetGaugeTiltAngle();

                        int intSmallInnerWidth = (int)Math.Round(intInnerHeight * Math.Tan(fAngle / 180 * Math.PI));

                        pCornerTL = new Point(intChippedOffToleranceLeft - (int)m_fChipStartPixelExtendFromLeft_Dark + intSmallInnerWidth, intChippedOffToleranceTop - (int)m_fChipStartPixelExtendFromEdge_Dark);
                        pCornerTR = new Point(objImage.ref_intImageWidth - intChippedOffToleranceRight + (int)m_fChipStartPixelExtendFromRight_Dark - 1 - intSmallInnerWidth, intChippedOffToleranceTop - (int)m_fChipStartPixelExtendFromEdge_Dark);
                        pCornerBL = new Point(intChippedOffToleranceLeft - (int)m_fChipStartPixelExtendFromLeft_Dark, objImage.ref_intImageHeight - intChippedOffToleranceBottom + (int)m_fChipStartPixelExtendFromBottom_Dark - 1);
                        pCornerBR = new Point(objImage.ref_intImageWidth - intChippedOffToleranceRight + (int)m_fChipStartPixelExtendFromRight_Dark - 1, objImage.ref_intImageHeight - intChippedOffToleranceBottom + (int)m_fChipStartPixelExtendFromBottom_Dark - 1);
                    }
                    break;
                case 4:
                    if (intChipLineLimitPixelValue == 0)
                    {
                        int intInnerWidth = objImage.ref_intImageWidth - (intChippedOffToleranceLeft - (int)m_fChipStartPixelExtendFromLeft + intChippedOffToleranceRight - (int)m_fChipStartPixelExtendFromRight);
                        int intInnerHeight = objImage.ref_intImageHeight - (intChippedOffToleranceTop - (int)m_fChipStartPixelExtendFromEdge + intChippedOffToleranceBottom - (int)m_fChipStartPixelExtendFromBottom);
                        float fAngle = m_objRectGauge4L.GetGaugeTiltAngle();

                        int intSmallInnerHeight = (int)Math.Round(intInnerWidth * Math.Tan(fAngle / 180 * Math.PI));

                        pCornerTL = new Point(intChippedOffToleranceLeft - (int)m_fChipStartPixelExtendFromLeft, intChippedOffToleranceTop - (int)m_fChipStartPixelExtendFromEdge);
                        pCornerTR = new Point(objImage.ref_intImageWidth - intChippedOffToleranceRight + (int)m_fChipStartPixelExtendFromRight - 1, intChippedOffToleranceTop - (int)m_fChipStartPixelExtendFromEdge + intSmallInnerHeight);
                        pCornerBL = new Point(intChippedOffToleranceLeft - (int)m_fChipStartPixelExtendFromLeft, objImage.ref_intImageHeight - intChippedOffToleranceBottom + (int)m_fChipStartPixelExtendFromBottom - 1);
                        pCornerBR = new Point(objImage.ref_intImageWidth - intChippedOffToleranceRight + (int)m_fChipStartPixelExtendFromRight - 1, objImage.ref_intImageHeight - intChippedOffToleranceBottom + (int)m_fChipStartPixelExtendFromBottom - 1 - intSmallInnerHeight);
                    }
                    else
                    {
                        int intInnerWidth = objImage.ref_intImageWidth - (intChippedOffToleranceLeft - (int)m_fChipStartPixelExtendFromLeft_Dark + intChippedOffToleranceRight - (int)m_fChipStartPixelExtendFromRight_Dark);
                        int intInnerHeight = objImage.ref_intImageHeight - (intChippedOffToleranceTop - (int)m_fChipStartPixelExtendFromEdge_Dark + intChippedOffToleranceBottom - (int)m_fChipStartPixelExtendFromBottom_Dark);
                        float fAngle = m_objRectGauge4L.GetGaugeTiltAngle();

                        int intSmallInnerHeight = (int)Math.Round(intInnerWidth * Math.Tan(fAngle / 180 * Math.PI));

                        pCornerTL = new Point(intChippedOffToleranceLeft - (int)m_fChipStartPixelExtendFromLeft_Dark, intChippedOffToleranceTop - (int)m_fChipStartPixelExtendFromEdge_Dark);
                        pCornerTR = new Point(objImage.ref_intImageWidth - intChippedOffToleranceRight + (int)m_fChipStartPixelExtendFromRight_Dark - 1, intChippedOffToleranceTop - (int)m_fChipStartPixelExtendFromEdge_Dark + intSmallInnerHeight);
                        pCornerBL = new Point(intChippedOffToleranceLeft - (int)m_fChipStartPixelExtendFromLeft_Dark, objImage.ref_intImageHeight - intChippedOffToleranceBottom + (int)m_fChipStartPixelExtendFromBottom_Dark - 1);
                        pCornerBR = new Point(objImage.ref_intImageWidth - intChippedOffToleranceRight + (int)m_fChipStartPixelExtendFromRight_Dark - 1, objImage.ref_intImageHeight - intChippedOffToleranceBottom + (int)m_fChipStartPixelExtendFromBottom_Dark - 1 - intSmallInnerHeight);
                    }

                    break;
            }
            //switch (m_intPadROIDirection)
            //{
            //    case 0:
            //    case 1:
            //        if (intChipLineLimitPixelValue == 0)
            //        {
            //            //intStartX2 = intChippedOffToleranceLeft + (int)m_fChipStartPixelExtendFromLeft;
            //            //intStartY2 = intChippedOffToleranceTop + (int)m_fChipStartPixelExtendFromEdge;
            //            //intEndX2 = objImage.ref_intImageWidth - intChippedOffToleranceRight - (int)m_fChipStartPixelExtendFromRight - 1;
            //            //intEndY2 = objImage.ref_intImageHeight - intChippedOffToleranceBottom - (int)m_fChipStartPixelExtendFromBottom - 1;

            //            int intInnerWidth = objImage.ref_intImageWidth - (intChippedOffToleranceLeft + (int)m_fChipStartPixelExtendFromLeft + intChippedOffToleranceRight + (int)m_fChipStartPixelExtendFromRight);
            //            int intInnerHeight = objImage.ref_intImageHeight - (intChippedOffToleranceTop + (int)m_fChipStartPixelExtendFromEdge + intChippedOffToleranceBottom + (int)m_fChipStartPixelExtendFromBottom);
            //            float fAngle = m_objRectGauge4L.GetGaugeTiltAngle();

            //            int intSmallInnerWidth = (int)Math.Round(intInnerHeight * Math.Tan(fAngle / 180 * Math.PI));

            //            pCornerTL = new Point(intChippedOffToleranceLeft + (int)m_fChipStartPixelExtendFromLeft, intChippedOffToleranceTop + (int)m_fChipStartPixelExtendFromEdge);
            //            pCornerTR = new Point(objImage.ref_intImageWidth - intChippedOffToleranceRight - (int)m_fChipStartPixelExtendFromRight - 1, intChippedOffToleranceTop + (int)m_fChipStartPixelExtendFromEdge);
            //            pCornerBL = new Point(intChippedOffToleranceLeft + (int)m_fChipStartPixelExtendFromLeft + intSmallInnerWidth, objImage.ref_intImageHeight - intChippedOffToleranceBottom - (int)m_fChipStartPixelExtendFromBottom - 1);
            //            pCornerBR = new Point(objImage.ref_intImageWidth - intChippedOffToleranceRight - (int)m_fChipStartPixelExtendFromRight - 1 - intSmallInnerWidth, objImage.ref_intImageHeight - intChippedOffToleranceBottom - (int)m_fChipStartPixelExtendFromBottom - 1);
            //        }
            //        else
            //        {
            //            //intStartX2 = intChippedOffToleranceLeft + (int)m_fChipStartPixelExtendFromLeft_Dark;
            //            //intStartY2 = intChippedOffToleranceTop + (int)m_fChipStartPixelExtendFromEdge_Dark;
            //            //intEndX2 = objImage.ref_intImageWidth - intChippedOffToleranceRight - (int)m_fChipStartPixelExtendFromRight_Dark - 1;
            //            //intEndY2 = objImage.ref_intImageHeight - intChippedOffToleranceBottom - (int)m_fChipStartPixelExtendFromBottom_Dark - 1;

            //            int intInnerWidth = objImage.ref_intImageWidth - (intChippedOffToleranceLeft + (int)m_fChipStartPixelExtendFromLeft_Dark + intChippedOffToleranceRight + (int)m_fChipStartPixelExtendFromRight_Dark);
            //            int intInnerHeight = objImage.ref_intImageHeight - (intChippedOffToleranceTop + (int)m_fChipStartPixelExtendFromEdge_Dark + intChippedOffToleranceBottom + (int)m_fChipStartPixelExtendFromBottom_Dark);
            //            float fAngle = m_objRectGauge4L.GetGaugeTiltAngle();

            //            int intSmallInnerWidth = (int)Math.Round(intInnerHeight * Math.Tan(fAngle / 180 * Math.PI));

            //            pCornerTL = new Point(intChippedOffToleranceLeft + (int)m_fChipStartPixelExtendFromLeft_Dark, intChippedOffToleranceTop + (int)m_fChipStartPixelExtendFromEdge_Dark);
            //            pCornerTR = new Point(objImage.ref_intImageWidth - intChippedOffToleranceRight - (int)m_fChipStartPixelExtendFromRight_Dark - 1, intChippedOffToleranceTop + (int)m_fChipStartPixelExtendFromEdge_Dark);
            //            pCornerBL = new Point(intChippedOffToleranceLeft + (int)m_fChipStartPixelExtendFromLeft_Dark + intSmallInnerWidth, objImage.ref_intImageHeight - intChippedOffToleranceBottom - (int)m_fChipStartPixelExtendFromBottom_Dark - 1);
            //            pCornerBR = new Point(objImage.ref_intImageWidth - intChippedOffToleranceRight - (int)m_fChipStartPixelExtendFromRight_Dark - 1 - intSmallInnerWidth, objImage.ref_intImageHeight - intChippedOffToleranceBottom - (int)m_fChipStartPixelExtendFromBottom_Dark - 1);
            //        }
            //        break;
            //    case 2:
            //        if (intChipLineLimitPixelValue == 0)
            //        {
            //            //intStartX2 = intChippedOffToleranceLeft + (int)m_fChipStartPixelExtendFromLeft;
            //            //intStartY2 = intChippedOffToleranceTop + (int)m_fChipStartPixelExtendFromEdge;
            //            //intEndX2 = objImage.ref_intImageWidth - intChippedOffToleranceRight - (int)m_fChipStartPixelExtendFromRight - 1;
            //            //intEndY2 = objImage.ref_intImageHeight - intChippedOffToleranceBottom - (int)m_fChipStartPixelExtendFromBottom - 1;

            //            int intInnerWidth = objImage.ref_intImageWidth - (intChippedOffToleranceLeft + (int)m_fChipStartPixelExtendFromLeft + intChippedOffToleranceRight + (int)m_fChipStartPixelExtendFromRight);
            //            int intInnerHeight = objImage.ref_intImageHeight - (intChippedOffToleranceTop + (int)m_fChipStartPixelExtendFromEdge + intChippedOffToleranceBottom + (int)m_fChipStartPixelExtendFromBottom);
            //            float fAngle = m_objRectGauge4L.GetGaugeTiltAngle();

            //            int intSmallInnerHeight = (int)Math.Round(intInnerWidth * Math.Tan(fAngle / 180 * Math.PI));

            //            pCornerTL = new Point(intChippedOffToleranceLeft + (int)m_fChipStartPixelExtendFromLeft, intChippedOffToleranceTop + (int)m_fChipStartPixelExtendFromEdge + intSmallInnerHeight);
            //            pCornerTR = new Point(objImage.ref_intImageWidth - intChippedOffToleranceRight - (int)m_fChipStartPixelExtendFromRight - 1, intChippedOffToleranceTop + (int)m_fChipStartPixelExtendFromEdge);
            //            pCornerBL = new Point(intChippedOffToleranceLeft + (int)m_fChipStartPixelExtendFromLeft, objImage.ref_intImageHeight - intChippedOffToleranceBottom - (int)m_fChipStartPixelExtendFromBottom - 1 - intSmallInnerHeight);
            //            pCornerBR = new Point(objImage.ref_intImageWidth - intChippedOffToleranceRight - (int)m_fChipStartPixelExtendFromRight - 1, objImage.ref_intImageHeight - intChippedOffToleranceBottom - (int)m_fChipStartPixelExtendFromBottom - 1);
            //        }
            //        else
            //        {
            //            //intStartX2 = intChippedOffToleranceLeft + (int)m_fChipStartPixelExtendFromLeft_Dark;
            //            //intStartY2 = intChippedOffToleranceTop + (int)m_fChipStartPixelExtendFromEdge_Dark;
            //            //intEndX2 = objImage.ref_intImageWidth - intChippedOffToleranceRight - (int)m_fChipStartPixelExtendFromRight_Dark - 1;
            //            //intEndY2 = objImage.ref_intImageHeight - intChippedOffToleranceBottom - (int)m_fChipStartPixelExtendFromBottom_Dark - 1;

            //            int intInnerWidth = objImage.ref_intImageWidth - (intChippedOffToleranceLeft + (int)m_fChipStartPixelExtendFromLeft_Dark + intChippedOffToleranceRight + (int)m_fChipStartPixelExtendFromRight_Dark);
            //            int intInnerHeight = objImage.ref_intImageHeight - (intChippedOffToleranceTop + (int)m_fChipStartPixelExtendFromEdge_Dark + intChippedOffToleranceBottom + (int)m_fChipStartPixelExtendFromBottom_Dark);
            //            float fAngle = m_objRectGauge4L.GetGaugeTiltAngle();

            //            int intSmallInnerHeight = (int)Math.Round(intInnerWidth * Math.Tan(fAngle / 180 * Math.PI));

            //            pCornerTL = new Point(intChippedOffToleranceLeft + (int)m_fChipStartPixelExtendFromLeft_Dark, intChippedOffToleranceTop + (int)m_fChipStartPixelExtendFromEdge_Dark + intSmallInnerHeight);
            //            pCornerTR = new Point(objImage.ref_intImageWidth - intChippedOffToleranceRight - (int)m_fChipStartPixelExtendFromRight_Dark - 1, intChippedOffToleranceTop + (int)m_fChipStartPixelExtendFromEdge_Dark);
            //            pCornerBL = new Point(intChippedOffToleranceLeft + (int)m_fChipStartPixelExtendFromLeft_Dark, objImage.ref_intImageHeight - intChippedOffToleranceBottom - (int)m_fChipStartPixelExtendFromBottom_Dark - 1 - intSmallInnerHeight);
            //            pCornerBR = new Point(objImage.ref_intImageWidth - intChippedOffToleranceRight - (int)m_fChipStartPixelExtendFromRight_Dark - 1, objImage.ref_intImageHeight - intChippedOffToleranceBottom - (int)m_fChipStartPixelExtendFromBottom_Dark - 1);
            //        }

            //        break;
            //    case 3:
            //        if (intChipLineLimitPixelValue == 0)
            //        {
            //            //intStartX2 = intChippedOffToleranceLeft + (int)m_fChipStartPixelExtendFromLeft;
            //            //intStartY2 = intChippedOffToleranceTop + (int)m_fChipStartPixelExtendFromEdge;
            //            //intEndX2 = objImage.ref_intImageWidth - intChippedOffToleranceRight - (int)m_fChipStartPixelExtendFromRight - 1;
            //            //intEndY2 = objImage.ref_intImageHeight - intChippedOffToleranceBottom - (int)m_fChipStartPixelExtendFromBottom - 1;

            //            int intInnerWidth = objImage.ref_intImageWidth - (intChippedOffToleranceLeft + (int)m_fChipStartPixelExtendFromLeft + intChippedOffToleranceRight + (int)m_fChipStartPixelExtendFromRight);
            //            int intInnerHeight = objImage.ref_intImageHeight - (intChippedOffToleranceTop + (int)m_fChipStartPixelExtendFromEdge + intChippedOffToleranceBottom + (int)m_fChipStartPixelExtendFromBottom);
            //            float fAngle = m_objRectGauge4L.GetGaugeTiltAngle();

            //            int intSmallInnerWidth = (int)Math.Round(intInnerHeight * Math.Tan(fAngle / 180 * Math.PI));

            //            pCornerTL = new Point(intChippedOffToleranceLeft + (int)m_fChipStartPixelExtendFromLeft + intSmallInnerWidth, intChippedOffToleranceTop + (int)m_fChipStartPixelExtendFromEdge);
            //            pCornerTR = new Point(objImage.ref_intImageWidth - intChippedOffToleranceRight - (int)m_fChipStartPixelExtendFromRight - 1 - intSmallInnerWidth, intChippedOffToleranceTop + (int)m_fChipStartPixelExtendFromEdge);
            //            pCornerBL = new Point(intChippedOffToleranceLeft + (int)m_fChipStartPixelExtendFromLeft, objImage.ref_intImageHeight - intChippedOffToleranceBottom - (int)m_fChipStartPixelExtendFromBottom - 1);
            //            pCornerBR = new Point(objImage.ref_intImageWidth - intChippedOffToleranceRight - (int)m_fChipStartPixelExtendFromRight - 1, objImage.ref_intImageHeight - intChippedOffToleranceBottom - (int)m_fChipStartPixelExtendFromBottom - 1);
            //        }
            //        else
            //        {
            //            //intStartX2 = intChippedOffToleranceLeft + (int)m_fChipStartPixelExtendFromLeft_Dark;
            //            //intStartY2 = intChippedOffToleranceTop + (int)m_fChipStartPixelExtendFromEdge_Dark;
            //            //intEndX2 = objImage.ref_intImageWidth - intChippedOffToleranceRight - (int)m_fChipStartPixelExtendFromRight_Dark - 1;
            //            //intEndY2 = objImage.ref_intImageHeight - intChippedOffToleranceBottom - (int)m_fChipStartPixelExtendFromBottom_Dark - 1;

            //            int intInnerWidth = objImage.ref_intImageWidth - (intChippedOffToleranceLeft + (int)m_fChipStartPixelExtendFromLeft_Dark + intChippedOffToleranceRight + (int)m_fChipStartPixelExtendFromRight_Dark);
            //            int intInnerHeight = objImage.ref_intImageHeight - (intChippedOffToleranceTop + (int)m_fChipStartPixelExtendFromEdge_Dark + intChippedOffToleranceBottom + (int)m_fChipStartPixelExtendFromBottom_Dark);
            //            float fAngle = m_objRectGauge4L.GetGaugeTiltAngle();

            //            int intSmallInnerWidth = (int)Math.Round(intInnerHeight * Math.Tan(fAngle / 180 * Math.PI));

            //            pCornerTL = new Point(intChippedOffToleranceLeft + (int)m_fChipStartPixelExtendFromLeft_Dark + intSmallInnerWidth, intChippedOffToleranceTop + (int)m_fChipStartPixelExtendFromEdge_Dark);
            //            pCornerTR = new Point(objImage.ref_intImageWidth - intChippedOffToleranceRight - (int)m_fChipStartPixelExtendFromRight_Dark - 1 - intSmallInnerWidth, intChippedOffToleranceTop + (int)m_fChipStartPixelExtendFromEdge_Dark);
            //            pCornerBL = new Point(intChippedOffToleranceLeft + (int)m_fChipStartPixelExtendFromLeft_Dark, objImage.ref_intImageHeight - intChippedOffToleranceBottom - (int)m_fChipStartPixelExtendFromBottom_Dark - 1);
            //            pCornerBR = new Point(objImage.ref_intImageWidth - intChippedOffToleranceRight - (int)m_fChipStartPixelExtendFromRight_Dark - 1, objImage.ref_intImageHeight - intChippedOffToleranceBottom - (int)m_fChipStartPixelExtendFromBottom_Dark - 1);
            //        }
            //        break;
            //    case 4:
            //        if (intChipLineLimitPixelValue == 0)
            //        {
            //            //intStartX2 = intChippedOffToleranceLeft + (int)m_fChipStartPixelExtendFromLeft;
            //            //intStartY2 = intChippedOffToleranceTop + (int)m_fChipStartPixelExtendFromEdge;
            //            //intEndX2 = objImage.ref_intImageWidth - intChippedOffToleranceRight - (int)m_fChipStartPixelExtendFromRight - 1;
            //            //intEndY2 = objImage.ref_intImageHeight - intChippedOffToleranceBottom - (int)m_fChipStartPixelExtendFromBottom - 1;

            //            int intInnerWidth = objImage.ref_intImageWidth - (intChippedOffToleranceLeft + (int)m_fChipStartPixelExtendFromLeft + intChippedOffToleranceRight + (int)m_fChipStartPixelExtendFromRight);
            //            int intInnerHeight = objImage.ref_intImageHeight - (intChippedOffToleranceTop + (int)m_fChipStartPixelExtendFromEdge + intChippedOffToleranceBottom + (int)m_fChipStartPixelExtendFromBottom);
            //            float fAngle = m_objRectGauge4L.GetGaugeTiltAngle();

            //            int intSmallInnerHeight = (int)Math.Round(intInnerWidth * Math.Tan(fAngle / 180 * Math.PI));

            //            pCornerTL = new Point(intChippedOffToleranceLeft + (int)m_fChipStartPixelExtendFromLeft, intChippedOffToleranceTop + (int)m_fChipStartPixelExtendFromEdge);
            //            pCornerTR = new Point(objImage.ref_intImageWidth - intChippedOffToleranceRight - (int)m_fChipStartPixelExtendFromRight - 1, intChippedOffToleranceTop + (int)m_fChipStartPixelExtendFromEdge + intSmallInnerHeight);
            //            pCornerBL = new Point(intChippedOffToleranceLeft + (int)m_fChipStartPixelExtendFromLeft, objImage.ref_intImageHeight - intChippedOffToleranceBottom - (int)m_fChipStartPixelExtendFromBottom - 1);
            //            pCornerBR = new Point(objImage.ref_intImageWidth - intChippedOffToleranceRight - (int)m_fChipStartPixelExtendFromRight - 1, objImage.ref_intImageHeight - intChippedOffToleranceBottom - (int)m_fChipStartPixelExtendFromBottom - 1 - intSmallInnerHeight);
            //        }
            //        else
            //        {
            //            //intStartX2 = intChippedOffToleranceLeft + (int)m_fChipStartPixelExtendFromLeft_Dark;
            //            //intStartY2 = intChippedOffToleranceTop + (int)m_fChipStartPixelExtendFromEdge_Dark;
            //            //intEndX2 = objImage.ref_intImageWidth - intChippedOffToleranceRight - (int)m_fChipStartPixelExtendFromRight_Dark - 1;
            //            //intEndY2 = objImage.ref_intImageHeight - intChippedOffToleranceBottom - (int)m_fChipStartPixelExtendFromBottom_Dark - 1;

            //            int intInnerWidth = objImage.ref_intImageWidth - (intChippedOffToleranceLeft + (int)m_fChipStartPixelExtendFromLeft_Dark + intChippedOffToleranceRight + (int)m_fChipStartPixelExtendFromRight_Dark);
            //            int intInnerHeight = objImage.ref_intImageHeight - (intChippedOffToleranceTop + (int)m_fChipStartPixelExtendFromEdge_Dark + intChippedOffToleranceBottom + (int)m_fChipStartPixelExtendFromBottom_Dark);
            //            float fAngle = m_objRectGauge4L.GetGaugeTiltAngle();

            //            int intSmallInnerHeight = (int)Math.Round(intInnerWidth * Math.Tan(fAngle / 180 * Math.PI));

            //            pCornerTL = new Point(intChippedOffToleranceLeft + (int)m_fChipStartPixelExtendFromLeft_Dark, intChippedOffToleranceTop + (int)m_fChipStartPixelExtendFromEdge_Dark);
            //            pCornerTR = new Point(objImage.ref_intImageWidth - intChippedOffToleranceRight - (int)m_fChipStartPixelExtendFromRight_Dark - 1, intChippedOffToleranceTop + (int)m_fChipStartPixelExtendFromEdge_Dark + intSmallInnerHeight);
            //            pCornerBL = new Point(intChippedOffToleranceLeft + (int)m_fChipStartPixelExtendFromLeft_Dark, objImage.ref_intImageHeight - intChippedOffToleranceBottom - (int)m_fChipStartPixelExtendFromBottom_Dark - 1);
            //            pCornerBR = new Point(objImage.ref_intImageWidth - intChippedOffToleranceRight - (int)m_fChipStartPixelExtendFromRight_Dark - 1, objImage.ref_intImageHeight - intChippedOffToleranceBottom - (int)m_fChipStartPixelExtendFromBottom_Dark - 1 - intSmallInnerHeight);
            //        }

            //        break;
            //}

            objLine1.CalculateStraightLine(new PointF(intStartX1, intStartY1), pCornerTL);
            objLine2.CalculateStraightLine(new PointF(intEndX1, intStartY1), pCornerTR);
            objLine3.CalculateStraightLine(new PointF(intStartX1, intEndY1), pCornerBL);
            objLine4.CalculateStraightLine(new PointF(intEndX1, intEndY1), pCornerBR);

            // -------- separate corner with dark line -------------------------------------------
            if ((pCornerTL.X - intStartX1) >= (pCornerTL.Y - intStartY1))
            {
                for (x = intStartX1; x <= pCornerTL.X; x++)
                {
                    y = (int)Math.Round(objLine1.GetPointY(x), 0, MidpointRounding.AwayFromZero);

                    if (!(y >= 0 && y < objImage.ref_objMainImage.Height &&
                         x >= 0 && x < objImage.ref_objMainImage.Width))
                    {
                        continue;
                    }

                    if (y < objImage.ref_objMainImage.Height)
                        objImage.ref_objMainImage.SetPixel(darkPixel, x, y);
                }
            }
            else
            {
                for (y = intStartY1; y <= pCornerTL.Y; y++)
                {
                    x = (int)Math.Round(objLine1.GetPointX(y), 0, MidpointRounding.AwayFromZero);

                    if (!(y >= 0 && y < objImage.ref_objMainImage.Height &&
                         x >= 0 && x < objImage.ref_objMainImage.Width))
                    {
                        continue;
                    }

                    if (x < objImage.ref_objMainImage.Width)
                        objImage.ref_objMainImage.SetPixel(darkPixel, x, y);
                }
            }

            if ((intEndX1 - pCornerTR.X) >= (pCornerTR.Y - intStartY1))
            {
                for (x = pCornerTR.X; x <= intEndX1; x++)
                {
                    y = (int)Math.Round(objLine2.GetPointY(x), 0, MidpointRounding.AwayFromZero);

                    if (!(y >= 0 && y < objImage.ref_objMainImage.Height &&
                         x >= 0 && x < objImage.ref_objMainImage.Width))
                    {
                        continue;
                    }

                    if (y < objImage.ref_objMainImage.Height)
                        objImage.ref_objMainImage.SetPixel(darkPixel, x, y);
                }
            }
            else
            {
                for (y = intStartY1; y <= pCornerTR.Y; y++)
                {
                    x = (int)Math.Round(objLine2.GetPointX(y), 0, MidpointRounding.AwayFromZero);

                    if (!(y >= 0 && y < objImage.ref_objMainImage.Height &&
                         x >= 0 && x < objImage.ref_objMainImage.Width))
                    {
                        continue;
                    }

                    if (x < objImage.ref_objMainImage.Width)
                        objImage.ref_objMainImage.SetPixel(darkPixel, x, y);
                }
            }

            if ((pCornerBL.X - intStartX1) >= (intEndY1 - pCornerBL.Y))
            {
                for (x = intStartX1; x <= pCornerBL.X; x++)
                {
                    y = (int)Math.Round(objLine3.GetPointY(x), 0, MidpointRounding.AwayFromZero);

                    if (!(y >= 0 && y < objImage.ref_objMainImage.Height &&
                         x >= 0 && x < objImage.ref_objMainImage.Width))
                    {
                        continue;
                    }

                    if (y < objImage.ref_objMainImage.Height)
                        objImage.ref_objMainImage.SetPixel(darkPixel, x, y);
                }
            }
            else
            {
                for (y = pCornerBL.Y; y <= intEndY1; y++)
                {
                    x = (int)Math.Round(objLine3.GetPointX(y), 0, MidpointRounding.AwayFromZero);

                    if (!(y >= 0 && y < objImage.ref_objMainImage.Height &&
                         x >= 0 && x < objImage.ref_objMainImage.Width))
                    {
                        continue;
                    }

                    if (x < objImage.ref_objMainImage.Width)
                        objImage.ref_objMainImage.SetPixel(darkPixel, x, y);
                }
            }

            if ((intEndX1 - pCornerBR.X) >= (intEndY1 - pCornerBR.Y))
            {
                for (x = pCornerBR.X; x <= intEndX1; x++)
                {
                    y = (int)Math.Round(objLine4.GetPointY(x), 0, MidpointRounding.AwayFromZero);

                    if (!(y >= 0 && y < objImage.ref_objMainImage.Height &&
                         x >= 0 && x < objImage.ref_objMainImage.Width))
                    {
                        continue;
                    }

                    if (y < objImage.ref_objMainImage.Height)
                        objImage.ref_objMainImage.SetPixel(darkPixel, x, y);
                }
            }
            else
            {
                for (y = pCornerBR.Y; y <= intEndY1; y++)
                {
                    x = (int)Math.Round(objLine4.GetPointX(y), 0, MidpointRounding.AwayFromZero);

                    if (!(y >= 0 && y < objImage.ref_objMainImage.Height &&
                         x >= 0 && x < objImage.ref_objMainImage.Width))
                    {
                        continue;
                    }

                    if (x < objImage.ref_objMainImage.Width)
                        objImage.ref_objMainImage.SetPixel(darkPixel, x, y);
                }
            }
            //// -------- separate corner with dark line -------------------------------------------
            //for (x = intStartX1; x <= intStartX2; x++)
            //{
            //    y = (int)Math.Round(objLine1.GetPointY(x), 0, MidpointRounding.AwayFromZero);

            //    if (!(y >= 0 && y < objImage.ref_objMainImage.Height &&
            //         x >= 0 && x < objImage.ref_objMainImage.Width))
            //    {
            //        continue;
            //    }

            //    if (y < objImage.ref_objMainImage.Height)
            //        objImage.ref_objMainImage.SetPixel(darkPixel, x, y);
            //}
            //for (x = intEndX2; x <= intEndX1; x++)
            //{
            //    y = (int)Math.Round(objLine2.GetPointY(x), 0, MidpointRounding.AwayFromZero);

            //    if (!(y >= 0 && y < objImage.ref_objMainImage.Height &&
            //         x >= 0 && x < objImage.ref_objMainImage.Width))
            //    {
            //        continue;
            //    }

            //    if (y < objImage.ref_objMainImage.Height)
            //        objImage.ref_objMainImage.SetPixel(darkPixel, x, y);
            //}
            //for (x = intStartX1; x <= intStartX2; x++)
            //{
            //    y = (int)Math.Round(objLine3.GetPointY(x), 0, MidpointRounding.AwayFromZero);

            //    if (!(y >= 0 && y < objImage.ref_objMainImage.Height &&
            //         x >= 0 && x < objImage.ref_objMainImage.Width))
            //    {
            //        continue;
            //    }

            //    if (y < objImage.ref_objMainImage.Height)
            //        objImage.ref_objMainImage.SetPixel(darkPixel, x, y);
            //}
            //for (x = intEndX2; x <= intEndX1; x++)
            //{
            //    y = (int)Math.Round(objLine4.GetPointY(x), 0, MidpointRounding.AwayFromZero);

            //    if (!(y >= 0 && y < objImage.ref_objMainImage.Height &&
            //         x >= 0 && x < objImage.ref_objMainImage.Width))
            //    {
            //        continue;
            //    }

            //    if (y < objImage.ref_objMainImage.Height)
            //        objImage.ref_objMainImage.SetPixel(darkPixel, x, y);
            //}

            //// ------------------- Set limit with dark pixel --------------------------------------------------
            //for (x = intStartX2; x < intEndX2; x++)
            //{
            //    objImage.ref_objMainImage.SetPixel(darkPixel, x, intStartY2);
            //}
            //int intEnd = intEndY2;
            //for (x = intStartX2; x < intEndX2; x++)
            //{
            //    objImage.ref_objMainImage.SetPixel(darkPixel, x, intEnd);
            //}
            //for (y = intStartY2; y < intEndY2; y++)
            //{
            //    objImage.ref_objMainImage.SetPixel(darkPixel, intStartX2, y);
            //}
            //intEnd = intEndX2;
            //for (y = intStartY2; y < intEndY2; y++)
            //{
            //    objImage.ref_objMainImage.SetPixel(darkPixel, intEnd, y);
            //}
        }
        private bool CheckVoidDefect(ROI objImage1UnitROI, int intROIStartX, int intROIStartY, int intImageIndex, int intVoidLineLimitPixelValue)
        {
            if ((m_intFailPkgOptionMask & 0x100) == 0 && (m_intFailPkgOptionMask & 0x200) == 0)
                return true;
            bool blnDebugImage = false;
            float fPkgOffsetX = (objImage1UnitROI.ref_ROIWidth - Math.Max(GetResultUpWidth_RectGauge4L(0), GetResultDownWidth_RectGauge4L(0))) / 2;
            float fPkgOffsetY = (objImage1UnitROI.ref_ROIHeight - Math.Max(GetResultLeftHeight_RectGauge4L(0), GetResultRightHeight_RectGauge4L(0))) / 2;

            float fROIToleranceLeft = 0, fROIToleranceTop = 0, fROIToleranceRight = 0, fROIToleranceBottom = 0;
            if (m_blnSeperateBrightDarkROITolerance)
            {
                fROIToleranceLeft = m_fPkgStartPixelFromLeft_Dark;
                fROIToleranceTop = m_fPkgStartPixelFromEdge_Dark;
                fROIToleranceRight = m_fPkgStartPixelFromRight_Dark;
                fROIToleranceBottom = m_fPkgStartPixelFromBottom_Dark;
            }
            else
            {
                fROIToleranceLeft = m_fPkgStartPixelFromLeft;
                fROIToleranceTop = m_fPkgStartPixelFromEdge;
                fROIToleranceRight = m_fPkgStartPixelFromRight;
                fROIToleranceBottom = m_fPkgStartPixelFromBottom;
            }

            int intStartPixelFromEdgeX = (int)Math.Round(fPkgOffsetX + fROIToleranceLeft, 0, MidpointRounding.AwayFromZero);
            int intStartPixelFromEdgeY = (int)Math.Round(fPkgOffsetY + fROIToleranceTop, 0, MidpointRounding.AwayFromZero);
            int intStartPixelFromEdgeX2 = (int)Math.Round(fPkgOffsetX + fROIToleranceRight, 0, MidpointRounding.AwayFromZero);
            int intStartPixelFromEdgeY2 = (int)Math.Round(fPkgOffsetY + fROIToleranceBottom, 0, MidpointRounding.AwayFromZero);

            ROI objVoidROI = new ROI();
            objVoidROI.AttachImage(objImage1UnitROI);
            objVoidROI.LoadROISetting(intStartPixelFromEdgeX, intStartPixelFromEdgeY,
                objImage1UnitROI.ref_ROIWidth - intStartPixelFromEdgeX - intStartPixelFromEdgeX2,
                objImage1UnitROI.ref_ROIHeight - intStartPixelFromEdgeY - intStartPixelFromEdgeY2);

            bool bWhiteOnBlack;
            if (intVoidLineLimitPixelValue == 0)
                bWhiteOnBlack = true;    // detect white on black - white is the chip
            else
                bWhiteOnBlack = false;   // detect black on white - black is the chip

            int intSelectedObject = m_objEBlobs.BuildObjects_Filter_GetElement(objVoidROI, !bWhiteOnBlack, true, 0, m_intPkgImage2VoidThreshold,
                (int)m_fVoidMinArea, 15000, true, 0x0F);// 0x0D);


            bool blnOverallResult = true;
            if (intSelectedObject > 0)
            {

                float fCenterX = 0, fCenterY = 0, fWidth = 0, fHeight = 0;
                int intArea = 0;
                int intFailCount = 0;
                for (int i = 0; i < intSelectedObject; i++)
                {
                    fCenterX = m_objEBlobs.ref_arrLimitCenterX[i];
                    fCenterY = m_objEBlobs.ref_arrLimitCenterY[i];
                    fWidth = m_objEBlobs.ref_arrWidth[i];
                    fHeight = m_objEBlobs.ref_arrHeight[i];
                    intArea = m_objEBlobs.ref_arrArea[i];

                    fCenterX += intStartPixelFromEdgeX;
                    fCenterY += intStartPixelFromEdgeY;
                    float fStartX = (float)Math.Floor(fCenterX - (fWidth / 2));
                    float fStartY = (float)Math.Floor(fCenterY - (fHeight / 2));
                    float fEndX = (float)Math.Ceiling(fCenterX + (fWidth / 2));
                    float fEndY = (float)Math.Ceiling(fCenterY + (fHeight / 2));
                    float Max = Math.Max(fHeight, fWidth);
                    float Min = Math.Min(fHeight, fWidth);

                    if (Max / Min > 1.5)
                    {

                        continue;
                    }

                    if (Max / Min <= 1.5)
                    {
                        if ((intArea / (fHeight * fWidth)) < 0.5)
                        {

                            continue;
                        }
                    }

                    float fWidthMM = fWidth / m_fMMToPixelXValue;
                    float fHeightMM = fHeight / m_fMMToPixelYValue;
                    float fAreaMM = intArea / m_fMMToPixelYValue / m_fMMToPixelXValue;


                    //if ((fWidthMM > m_fVoidLength) || (fHeightMM > m_fVoidLength) || (fAreaMM > m_fVoidArea))
                    {
                        bool blnFail = false;
                        intFailCount++;
                        //0x04
                        m_intFailPkgResultMask |= 0x100;

                        Defect objDefect = new Defect();
                        objDefect.ref_strName = "Void";
                        objDefect.ref_intFailMask = 0x100;
                        objDefect.ref_fCenterX = intROIStartX + fCenterX;
                        objDefect.ref_fCenterY = intROIStartY + fCenterY;
                        objDefect.ref_fStartX = intROIStartX + fStartX;
                        objDefect.ref_fStartY = intROIStartY + fStartY;
                        objDefect.ref_fEndX = intROIStartX + fEndX;
                        objDefect.ref_fEndY = intROIStartY + fEndY;
                        objDefect.ref_fWidth = fWidth;
                        objDefect.ref_fHeight = fHeight;
                        objDefect.ref_fArea = intArea;
                        objDefect.ref_fWidthInMM = fWidthMM;
                        objDefect.ref_fHeightInMM = fHeightMM;
                        objDefect.ref_fAreaInMM2 = fAreaMM;
                        objDefect.ref_intImageNo = 2;

                        if ((m_intFailPkgOptionMask & 0x100) > 0)
                        {
                            if (fWidthMM > m_fVoidLength)
                            {
                                blnOverallResult = false;
                                objDefect.ref_fWidthFailValue = fWidthMM;
                                objDefect.ref_intFailCriteria |= 0x01;
                            }
                            if (fHeightMM > m_fVoidLength)
                            {
                                blnOverallResult = false;
                                objDefect.ref_fHeightFailValue = fHeightMM;
                                objDefect.ref_intFailCriteria |= 0x02;
                            }
                        }

                        if ((m_intFailPkgOptionMask & 0x200) > 0)
                        {
                            if (fAreaMM > m_fVoidArea)
                            {
                                blnOverallResult = false;
                                objDefect.ref_fAreaFailValue = fAreaMM;
                                objDefect.ref_intFailCriteria |= 0x04;
                            }
                        }

                        m_arrPkgDefectList.Add(objDefect);
                    }

                }
            }
            objVoidROI.Dispose();

            return blnOverallResult;
        }
        private bool CheckVoidDefect_TiltAngle(ROI objImage1UnitROI, int intROIStartX, int intROIStartY, int intImageIndex, int intVoidLineLimitPixelValue, int intPadIndex)
        {
            if ((m_intFailPkgOptionMask & 0x100) == 0 && (m_intFailPkgOptionMask & 0x200) == 0)
                return true;
            bool blnDebugImage = false;
            float fPkgOffsetX = (objImage1UnitROI.ref_ROIWidth - Math.Max(GetResultUpWidth_RectGauge4L(0), GetResultDownWidth_RectGauge4L(0))) / 2;
            float fPkgOffsetY = (objImage1UnitROI.ref_ROIHeight - Math.Max(GetResultLeftHeight_RectGauge4L(0), GetResultRightHeight_RectGauge4L(0))) / 2;

            float fROIToleranceLeft = 0, fROIToleranceTop = 0, fROIToleranceRight = 0, fROIToleranceBottom = 0;
            if (m_blnSeperateBrightDarkROITolerance)
            {
                fROIToleranceLeft = m_fPkgStartPixelFromLeft_Dark;
                fROIToleranceTop = m_fPkgStartPixelFromEdge_Dark;
                fROIToleranceRight = m_fPkgStartPixelFromRight_Dark;
                fROIToleranceBottom = m_fPkgStartPixelFromBottom_Dark;
            }
            else
            {
                fROIToleranceLeft = m_fPkgStartPixelFromLeft;
                fROIToleranceTop = m_fPkgStartPixelFromEdge;
                fROIToleranceRight = m_fPkgStartPixelFromRight;
                fROIToleranceBottom = m_fPkgStartPixelFromBottom;
            }

            int intStartPixelFromEdgeX = (int)Math.Round(fPkgOffsetX + fROIToleranceLeft, 0, MidpointRounding.AwayFromZero);
            int intStartPixelFromEdgeY = (int)Math.Round(fPkgOffsetY + fROIToleranceTop, 0, MidpointRounding.AwayFromZero);
            int intStartPixelFromEdgeX2 = (int)Math.Round(fPkgOffsetX + fROIToleranceRight, 0, MidpointRounding.AwayFromZero);
            int intStartPixelFromEdgeY2 = (int)Math.Round(fPkgOffsetY + fROIToleranceBottom, 0, MidpointRounding.AwayFromZero);

            ROI objVoidROI = new ROI();
            ImageDrawing ImgVoid = new ImageDrawing();
            ImgVoid.SetImageSize(objImage1UnitROI.ref_ROIWidth, objImage1UnitROI.ref_ROIHeight);
            objImage1UnitROI.CopyToImage(ref ImgVoid);
            objVoidROI.AttachImage(ImgVoid);
            objVoidROI.LoadROISetting(intStartPixelFromEdgeX, intStartPixelFromEdgeY,
                objImage1UnitROI.ref_ROIWidth - intStartPixelFromEdgeX - intStartPixelFromEdgeX2,
                objImage1UnitROI.ref_ROIHeight - intStartPixelFromEdgeY - intStartPixelFromEdgeY2);
            //2019-09-23 ZJYEOH : Subtract tilt dont care area 
            if (intPadIndex == 1) // Top
            {
                ROI DontCareTop = new ROI();

                DontCareTop.LoadROISetting(0, 0, objVoidROI.ref_ROIWidth, objVoidROI.ref_ROIHeight);
                DontCareTop.AttachImage(m_ImgTilt_Top_L);
                EasyImage.Oper(EArithmeticLogicOperation.Add, objVoidROI.ref_ROI, DontCareTop.ref_ROI, objVoidROI.ref_ROI);
                DontCareTop.LoadROISetting(m_ImgTilt_Top_R.ref_intImageWidth - objVoidROI.ref_ROIWidth, 0, objVoidROI.ref_ROIWidth, objVoidROI.ref_ROIHeight);
                DontCareTop.AttachImage(m_ImgTilt_Top_R);
                EasyImage.Oper(EArithmeticLogicOperation.Add, objVoidROI.ref_ROI, DontCareTop.ref_ROI, objVoidROI.ref_ROI);
                if (blnDebugImage)
                    objVoidROI.SaveImage("D:\\CheckVoidDefect_objVoidROITop.bmp");
                DontCareTop.Dispose();
            }
            if (intPadIndex == 2) // Right
            {
                ROI DontCareRight = new ROI();
                DontCareRight.LoadROISetting(m_ImgTilt_Top_R.ref_intImageWidth - objVoidROI.ref_ROIWidth, 0, objVoidROI.ref_ROIWidth, objVoidROI.ref_ROIHeight);
                DontCareRight.AttachImage(m_ImgTilt_Right_T);
                EasyImage.Oper(EArithmeticLogicOperation.Add, objVoidROI.ref_ROI, DontCareRight.ref_ROI, objVoidROI.ref_ROI);
                DontCareRight.LoadROISetting(m_ImgTilt_Top_R.ref_intImageWidth - objVoidROI.ref_ROIWidth, m_ImgTilt_Top_R.ref_intImageHeight - objVoidROI.ref_ROIHeight, objVoidROI.ref_ROIWidth, objVoidROI.ref_ROIHeight);
                DontCareRight.AttachImage(m_ImgTilt_Right_B);
                EasyImage.Oper(EArithmeticLogicOperation.Add, objVoidROI.ref_ROI, DontCareRight.ref_ROI, objVoidROI.ref_ROI);
                if (blnDebugImage)
                    objVoidROI.SaveImage("D:\\CheckVoidDefect_objVoidROIRight.bmp");
                DontCareRight.Dispose();
            }
            if (intPadIndex == 3) // Bottom
            {
                ROI DontCareBottom = new ROI();

                DontCareBottom.LoadROISetting(0, m_ImgTilt_Top_R.ref_intImageHeight - objVoidROI.ref_ROIHeight, objVoidROI.ref_ROIWidth, objVoidROI.ref_ROIHeight);
                DontCareBottom.AttachImage(m_ImgTilt_Bottom_L);
                EasyImage.Oper(EArithmeticLogicOperation.Add, objVoidROI.ref_ROI, DontCareBottom.ref_ROI, objVoidROI.ref_ROI);
                DontCareBottom.LoadROISetting(m_ImgTilt_Top_R.ref_intImageWidth - objVoidROI.ref_ROIWidth, m_ImgTilt_Top_R.ref_intImageHeight - objVoidROI.ref_ROIHeight, objVoidROI.ref_ROIWidth, objVoidROI.ref_ROIHeight);
                DontCareBottom.AttachImage(m_ImgTilt_Bottom_R);
                EasyImage.Oper(EArithmeticLogicOperation.Add, objVoidROI.ref_ROI, DontCareBottom.ref_ROI, objVoidROI.ref_ROI);
                if (blnDebugImage)
                    objVoidROI.SaveImage("D:\\CheckVoidDefect_objVoidROIBottom.bmp");
                DontCareBottom.Dispose();
            }
            if (intPadIndex == 4) // Left
            {
                ROI DontCareLeft = new ROI();

                DontCareLeft.LoadROISetting(0, 0, objVoidROI.ref_ROIWidth, objVoidROI.ref_ROIHeight);
                DontCareLeft.AttachImage(m_ImgTilt_Left_T);
                EasyImage.Oper(EArithmeticLogicOperation.Add, objVoidROI.ref_ROI, DontCareLeft.ref_ROI, objVoidROI.ref_ROI);
                DontCareLeft.LoadROISetting(0, m_ImgTilt_Top_R.ref_intImageHeight - objVoidROI.ref_ROIHeight, objVoidROI.ref_ROIWidth, objVoidROI.ref_ROIHeight);
                DontCareLeft.AttachImage(m_ImgTilt_Left_B);
                EasyImage.Oper(EArithmeticLogicOperation.Add, objVoidROI.ref_ROI, DontCareLeft.ref_ROI, objVoidROI.ref_ROI);
                if (blnDebugImage)
                    objVoidROI.SaveImage("D:\\CheckVoidDefect_objVoidROILeft.bmp");
                DontCareLeft.Dispose();
            }
            bool bWhiteOnBlack;
            if (intVoidLineLimitPixelValue == 0)
                bWhiteOnBlack = true;    // detect white on black - white is the chip
            else
                bWhiteOnBlack = false;   // detect black on white - black is the chip

            int intSelectedObject = m_objEBlobs.BuildObjects_Filter_GetElement(objVoidROI, !bWhiteOnBlack, true, 0, m_intPkgImage2VoidThreshold,
                (int)m_fVoidMinArea, 15000, true, 0x0F);// 0x0D);


            bool blnOverallResult = true;
            if (intSelectedObject > 0)
            {

                float fCenterX = 0, fCenterY = 0, fWidth = 0, fHeight = 0;
                int intArea = 0;
                int intFailCount = 0;
                for (int i = 0; i < intSelectedObject; i++)
                {
                    fCenterX = m_objEBlobs.ref_arrLimitCenterX[i];
                    fCenterY = m_objEBlobs.ref_arrLimitCenterY[i];
                    fWidth = m_objEBlobs.ref_arrWidth[i];
                    fHeight = m_objEBlobs.ref_arrHeight[i];
                    intArea = m_objEBlobs.ref_arrArea[i];

                    fCenterX += intStartPixelFromEdgeX;
                    fCenterY += intStartPixelFromEdgeY;
                    float fStartX = (float)Math.Floor(fCenterX - (fWidth / 2));
                    float fStartY = (float)Math.Floor(fCenterY - (fHeight / 2));
                    float fEndX = (float)Math.Ceiling(fCenterX + (fWidth / 2));
                    float fEndY = (float)Math.Ceiling(fCenterY + (fHeight / 2));
                    float Max = Math.Max(fHeight, fWidth);
                    float Min = Math.Min(fHeight, fWidth);

                    if (Max / Min > 1.5)
                    {

                        continue;
                    }

                    if (Max / Min <= 1.5)
                    {
                        if ((intArea / (fHeight * fWidth)) < 0.5)
                        {

                            continue;
                        }
                    }

                    float fWidthMM = fWidth / m_fMMToPixelXValue;
                    float fHeightMM = fHeight / m_fMMToPixelYValue;
                    float fAreaMM = intArea / m_fMMToPixelYValue / m_fMMToPixelXValue;


                    //if ((fWidthMM > m_fVoidLength) || (fHeightMM > m_fVoidLength) || (fAreaMM > m_fVoidArea))
                    {
                        bool blnFail = false;
                        intFailCount++;
                        //0x04
                        m_intFailPkgResultMask |= 0x100;

                        Defect objDefect = new Defect();
                        objDefect.ref_strName = "Void";
                        objDefect.ref_intFailMask = 0x100;
                        objDefect.ref_fCenterX = intROIStartX + fCenterX;
                        objDefect.ref_fCenterY = intROIStartY + fCenterY;
                        objDefect.ref_fStartX = intROIStartX + fStartX;
                        objDefect.ref_fStartY = intROIStartY + fStartY;
                        objDefect.ref_fEndX = intROIStartX + fEndX;
                        objDefect.ref_fEndY = intROIStartY + fEndY;
                        objDefect.ref_fWidth = fWidth;
                        objDefect.ref_fHeight = fHeight;
                        objDefect.ref_fArea = intArea;
                        objDefect.ref_fWidthInMM = fWidthMM;
                        objDefect.ref_fHeightInMM = fHeightMM;
                        objDefect.ref_fAreaInMM2 = fAreaMM;
                        objDefect.ref_intImageNo = 2;

                        if ((m_intFailPkgOptionMask & 0x100) > 0)
                        {
                            if (fWidthMM > m_fVoidLength)
                            {
                                blnOverallResult = false;
                                objDefect.ref_fWidthFailValue = fWidthMM;
                                objDefect.ref_intFailCriteria |= 0x01;
                            }
                            if (fHeightMM > m_fVoidLength)
                            {
                                blnOverallResult = false;
                                objDefect.ref_fHeightFailValue = fHeightMM;
                                objDefect.ref_intFailCriteria |= 0x02;
                            }
                        }

                        if ((m_intFailPkgOptionMask & 0x200) > 0)
                        {
                            if (fAreaMM > m_fVoidArea)
                            {
                                blnOverallResult = false;
                                objDefect.ref_fAreaFailValue = fAreaMM;
                                objDefect.ref_intFailCriteria |= 0x04;
                            }
                        }

                        m_arrPkgDefectList.Add(objDefect);
                    }

                }
            }
            objVoidROI.Dispose();
            ImgVoid.Dispose();
            return blnOverallResult;
        }
        public bool CheckCrackDefect_SimpleMode(ROI objImage1UnitROI, int intROIStartX, int intROIStartY, int intImageIndex)
        {
            // 0x400 = Crack Length, 0x800 = Crack Area
            if ((m_intFailPkgOptionMask & 0x800) == 0 && (m_intFailPkgOptionMask & 0x400) == 0)
                return true;
            bool blnDebugImage = false;
            float fPkgOffsetX = (objImage1UnitROI.ref_ROIWidth - Math.Max(GetResultUpWidth_RectGauge4L(0), GetResultDownWidth_RectGauge4L(0))) / 2;
            float fPkgOffsetY = (objImage1UnitROI.ref_ROIHeight - Math.Max(GetResultLeftHeight_RectGauge4L(0), GetResultRightHeight_RectGauge4L(0))) / 2;

            float fROIToleranceLeft = 0, fROIToleranceTop = 0, fROIToleranceRight = 0, fROIToleranceBottom = 0;
            if (m_blnSeperateBrightDarkROITolerance)
            {
                fROIToleranceLeft = m_fPkgStartPixelFromLeft_Dark;
                fROIToleranceTop = m_fPkgStartPixelFromEdge_Dark;
                fROIToleranceRight = m_fPkgStartPixelFromRight_Dark;
                fROIToleranceBottom = m_fPkgStartPixelFromBottom_Dark;
            }
            else
            {
                fROIToleranceLeft = m_fPkgStartPixelFromLeft;
                fROIToleranceTop = m_fPkgStartPixelFromEdge;
                fROIToleranceRight = m_fPkgStartPixelFromRight;
                fROIToleranceBottom = m_fPkgStartPixelFromBottom;
            }

            int intStartPixelFromEdgeX = (int)Math.Round(fPkgOffsetX + fROIToleranceLeft, 0, MidpointRounding.AwayFromZero);
            int intStartPixelFromEdgeY = (int)Math.Round(fPkgOffsetY + fROIToleranceTop, 0, MidpointRounding.AwayFromZero);
            int intStartPixelFromEdgeX2 = (int)Math.Round(fPkgOffsetX + fROIToleranceRight, 0, MidpointRounding.AwayFromZero);
            int intStartPixelFromEdgeY2 = (int)Math.Round(fPkgOffsetY + fROIToleranceBottom, 0, MidpointRounding.AwayFromZero);

            ROI objCrackROI = new ROI();
            objCrackROI.AttachImage(objImage1UnitROI);
            objCrackROI.LoadROISetting(intStartPixelFromEdgeX, intStartPixelFromEdgeY,
                objImage1UnitROI.ref_ROIWidth - intStartPixelFromEdgeX - intStartPixelFromEdgeX2,
                objImage1UnitROI.ref_ROIHeight - intStartPixelFromEdgeY - intStartPixelFromEdgeY2);

            int intSelectedObjectNum = m_objEBlobs.BuildObjects_Filter_GetElement_DoubleThreshold(
               objCrackROI, true, false, false, false, m_intPkgImage2LowCrackThreshold, m_intPkgImage2HighCrackThreshold,
               (int)m_fCrackMinArea, 15000, false, 0xED);


            bool blnOverallResult = true;
            if (intSelectedObjectNum > 0)
            {
                int intObjectArea = 0;
                float fObjectHeight = 0, fObjectWidth = 0, fObjectCenterX = 0, fObjectCenterY = 0, fObjectAngle = 0;

                int intFailCount = 0;
                for (int i = 0; i < intSelectedObjectNum; i++)
                {
                    intObjectArea = m_objEBlobs.ref_arrArea[i];
                    if (m_objEBlobs.ref_arrRectHeight[i] < m_objEBlobs.ref_arrRectWidth[i])
                    {
                        fObjectWidth = m_objEBlobs.ref_arrRectHeight[i];
                        fObjectHeight = m_objEBlobs.ref_arrRectWidth[i];
                        
                        fObjectAngle = m_objEBlobs.ref_arrRectAngle[i];

                        if (fObjectAngle >= 10)//&& fAngle <= 80)
                            fObjectAngle = m_objEBlobs.ref_arrRectAngle[i] - 90;
                        else
                            fObjectAngle = 90 + m_objEBlobs.ref_arrRectAngle[i];

                    }
                    else
                    {
                        fObjectHeight = m_objEBlobs.ref_arrRectHeight[i];
                        fObjectWidth = m_objEBlobs.ref_arrRectWidth[i];
                        
                        fObjectAngle = m_objEBlobs.ref_arrRectAngle[i];

                    }
                    //fObjectHeight = m_objEBlobs.ref_arrRectHeight[i];
                    //fObjectWidth = m_objEBlobs.ref_arrRectWidth[i];
                    fObjectCenterX = m_objEBlobs.ref_arrRectLimitCenterX[i];
                    fObjectCenterY = m_objEBlobs.ref_arrRectLimitCenterY[i];
                    //fObjectAngle = m_objEBlobs.ref_arrRectAngle[i];

                    fObjectCenterX += intStartPixelFromEdgeX;
                    fObjectCenterY += intStartPixelFromEdgeY;
                    //if (fObjectAngle < 0)
                    //    fObjectAngle = Math.Abs(fObjectAngle);
                    //else
                    //    fObjectAngle = 0 - (fObjectAngle);

                    //float Max = Math.Max(fObjectHeight, fObjectWidth);
                    //float Min = Math.Min(fObjectHeight, fObjectWidth);

                    //if (Max / Min <= 1.5)
                    //{
                    //    if ((intObjectArea / (fObjectHeight * fObjectWidth)) >= 0.5)
                    //    {
                    //        continue;
                    //    }
                    //}

                    float fWidthMM = fObjectWidth / m_fMMToPixelXValue;
                    float fHeightMM = fObjectHeight / m_fMMToPixelYValue;
                    float fAreaMM = intObjectArea / m_fMMToPixelYValue / m_fMMToPixelXValue;

                    //if ((fWidthMM > m_fCrackLength) || (fHeightMM > m_fCrackLength) || (fAreaMM > m_fCrackArea) && ((m_intFailPkgOptionMask & 0x400) > 0 || (m_intFailPkgOptionMask & 0x800) > 0))
                    {
                        intFailCount++;
                        //0x04
                        m_intFailPkgResultMask |= 0x400;

                        Defect objDefect = new Defect();
                        objDefect.ref_fWidth = fObjectWidth;
                        objDefect.ref_fHeight = fObjectHeight;
                        objDefect.ref_fArea = intObjectArea;
                        objDefect.ref_fWidthInMM = fWidthMM;
                        objDefect.ref_fHeightInMM = fHeightMM;
                        objDefect.ref_fAreaInMM2 = fAreaMM;
                        objDefect.ref_strName = "Crack";
                        objDefect.ref_fCenterX = intROIStartX + fObjectCenterX;
                        objDefect.ref_fCenterY = intROIStartY + fObjectCenterY;
                        objDefect.ref_fAngle = fObjectAngle;
                        objDefect.ref_intFailMask = 0x400;
                        objDefect.ref_intImageNo = intImageIndex;

                        if ((m_intFailPkgOptionMask & 0x400) > 0)
                        {
                            if (m_intCrackDarkDefectDimensionFailCondition == 0)
                            {
                                if (fWidthMM > m_fDarkHorizontalCrack)
                                {
                                    blnOverallResult = false;
                                    objDefect.ref_fWidthFailValue = fWidthMM;
                                    objDefect.ref_intFailCriteria |= 0x01;
                                }
                                if (fHeightMM > m_fDarkVerticalCrack)
                                {
                                    blnOverallResult = false;
                                    objDefect.ref_fHeightFailValue = fHeightMM;
                                    objDefect.ref_intFailCriteria |= 0x02;
                                }
                            }
                            else
                            {
                                if ((fWidthMM > m_fDarkHorizontalCrack) && (fHeightMM > m_fDarkVerticalCrack))
                                {
                                    blnOverallResult = false;
                                    objDefect.ref_fWidthFailValue = fWidthMM;
                                    objDefect.ref_intFailCriteria |= 0x01;
                                    objDefect.ref_fHeightFailValue = fHeightMM;
                                    objDefect.ref_intFailCriteria |= 0x02;
                                }
                            }
                        }

                        if ((m_intFailPkgOptionMask & 0x800) > 0)
                        {
                            if (fAreaMM > m_fCrackArea)
                            {
                                blnOverallResult = false;
                                objDefect.ref_fAreaFailValue = fAreaMM;
                                objDefect.ref_intFailCriteria |= 0x04;
                            }
                        }

                        m_arrPkgDefectList.Add(objDefect);
                    }

                }
            }

            objCrackROI.Dispose();

            return blnOverallResult;
        }
        public bool CheckCrackDefect_SimpleMode_WithLinkFunction(ROI objImage1UnitROI, int intROIStartX, int intROIStartY, int intImageIndex)
        {
            // 0x400 = Crack Length, 0x800 = Crack Area
            if ((m_intFailPkgOptionMask & 0x800) == 0 && (m_intFailPkgOptionMask & 0x400) == 0)
                return true;
            bool blnDebugImage = false;
            float fPkgOffsetX = (objImage1UnitROI.ref_ROIWidth - Math.Max(GetResultUpWidth_RectGauge4L(0), GetResultDownWidth_RectGauge4L(0))) / 2;
            float fPkgOffsetY = (objImage1UnitROI.ref_ROIHeight - Math.Max(GetResultLeftHeight_RectGauge4L(0), GetResultRightHeight_RectGauge4L(0))) / 2;

            float fROIToleranceLeft = 0, fROIToleranceTop = 0, fROIToleranceRight = 0, fROIToleranceBottom = 0;
            if (m_blnSeperateBrightDarkROITolerance)
            {
                fROIToleranceLeft = m_fPkgStartPixelFromLeft_Dark;
                fROIToleranceTop = m_fPkgStartPixelFromEdge_Dark;
                fROIToleranceRight = m_fPkgStartPixelFromRight_Dark;
                fROIToleranceBottom = m_fPkgStartPixelFromBottom_Dark;
            }
            else
            {
                fROIToleranceLeft = m_fPkgStartPixelFromLeft;
                fROIToleranceTop = m_fPkgStartPixelFromEdge;
                fROIToleranceRight = m_fPkgStartPixelFromRight;
                fROIToleranceBottom = m_fPkgStartPixelFromBottom;
            }

            int intStartPixelFromEdgeX = (int)Math.Round(fPkgOffsetX + fROIToleranceLeft, 0, MidpointRounding.AwayFromZero);
            int intStartPixelFromEdgeY = (int)Math.Round(fPkgOffsetY + fROIToleranceTop, 0, MidpointRounding.AwayFromZero);
            int intStartPixelFromEdgeX2 = (int)Math.Round(fPkgOffsetX + fROIToleranceRight, 0, MidpointRounding.AwayFromZero);
            int intStartPixelFromEdgeY2 = (int)Math.Round(fPkgOffsetY + fROIToleranceBottom, 0, MidpointRounding.AwayFromZero);

            ROI objCrackROI = new ROI();
            objCrackROI.AttachImage(objImage1UnitROI);
            objCrackROI.LoadROISetting(intStartPixelFromEdgeX, intStartPixelFromEdgeY,
                objImage1UnitROI.ref_ROIWidth - intStartPixelFromEdgeX - intStartPixelFromEdgeX2,
                objImage1UnitROI.ref_ROIHeight - intStartPixelFromEdgeY - intStartPixelFromEdgeY2);

            int intSelectedObjectNum = m_objEBlobs.BuildObjects_Filter_GetElement_DoubleThreshold(
               objCrackROI, true, false, false, false, m_intPkgImage2LowCrackThreshold, m_intPkgImage2HighCrackThreshold,
               (int)m_fCrackMinArea, 15000, false, 0xED);


            bool blnOverallResult = true;
            if (intSelectedObjectNum > 0)
            {
                List<List<System.Windows.Point>> arr2DPoints = new List<List<System.Windows.Point>>();
                List<List<PointF>> arrRotatedPoints = new List<List<PointF>>();
                List<float> fObjectHeightList = new List<float>(), fObjectWidthList = new List<float>(), fObjectCenterXList = new List<float>(), fObjectCenterYList = new List<float>(), fObjectAngleList = new List<float>();
                List<float> fObjectLimitHeightList = new List<float>(), fObjectLimitWidthList = new List<float>(), fObjectLimitCenterXList = new List<float>(), fObjectLimitCenterYList = new List<float>();
                List<int> fObjectAreaList = new List<int>(), fObjectAreaList2 = new List<int>();
                int intObjectArea = 0;
                float fObjectHeight = 0, fObjectWidth = 0, fObjectCenterX = 0, fObjectCenterY = 0, fObjectAngle = 0;
                int intTolerance = m_intCrackDefectLinkTolerance;
                int intFailCount = 0;
                for (int i = 0; i < intSelectedObjectNum; i++)
                {
                    arrRotatedPoints.Add(new List<PointF>());
                    arr2DPoints.Add(new List<System.Windows.Point>());
                    intObjectArea = m_objEBlobs.ref_arrArea[i];
                    if (m_objEBlobs.ref_arrRectHeight[i] < m_objEBlobs.ref_arrRectWidth[i])
                    {
                        fObjectWidth = m_objEBlobs.ref_arrRectHeight[i];
                        fObjectHeight = m_objEBlobs.ref_arrRectWidth[i];

                        fObjectAngle = m_objEBlobs.ref_arrRectAngle[i];

                        if (fObjectAngle >= 10)//&& fAngle <= 80)
                            fObjectAngle = m_objEBlobs.ref_arrRectAngle[i] - 90;
                        else
                            fObjectAngle = 90 + m_objEBlobs.ref_arrRectAngle[i];

                    }
                    else
                    {
                        fObjectHeight = m_objEBlobs.ref_arrRectHeight[i];
                        fObjectWidth = m_objEBlobs.ref_arrRectWidth[i];

                        fObjectAngle = m_objEBlobs.ref_arrRectAngle[i];

                    }
                    //fObjectHeight = m_objEBlobs.ref_arrRectHeight[i];
                    //fObjectWidth = m_objEBlobs.ref_arrRectWidth[i];
                    fObjectCenterX = m_objEBlobs.ref_arrRectLimitCenterX[i];
                    fObjectCenterY = m_objEBlobs.ref_arrRectLimitCenterY[i];
                    //fObjectAngle = m_objEBlobs.ref_arrRectAngle[i];

                    fObjectCenterX += intStartPixelFromEdgeX;
                    fObjectCenterY += intStartPixelFromEdgeY;
                    //if (fObjectAngle < 0)
                    //    fObjectAngle = Math.Abs(fObjectAngle);
                    //else
                    //    fObjectAngle = 0 - (fObjectAngle);

                    //float Max = Math.Max(fObjectHeight, fObjectWidth);
                    //float Min = Math.Min(fObjectHeight, fObjectWidth);

                    //if (Max / Min <= 1.5)
                    //{
                    //    if ((intObjectArea / (fObjectHeight * fObjectWidth)) >= 0.5)
                    //    {
                    //        continue;
                    //    }
                    //}

                    float newX1 = 0, newY1 = 0;  // new point 1
                    float newX2 = 0, newY2 = 0; // new point 2
                    float newX3 = 0, newY3 = 0; // new point 3
                    float newX4 = 0, newY4 = 0; // new point 4

                    //2020-12-18 ZJYEOH : Change to this format
                    //  Point 1 *-------------* Point 2
                    //          |             |
                    //          |             |
                    //          |             |
                    //  Point 4 *-------------* Point 3

                    Math2.RotateWithAngleAccordingToReferencePoint(fObjectCenterX, fObjectCenterY, (fObjectCenterX - (fObjectWidth / 2)), (fObjectCenterY - (fObjectHeight / 2)), fObjectAngle, ref newX1, ref newY1);
                    Math2.RotateWithAngleAccordingToReferencePoint(fObjectCenterX, fObjectCenterY, (fObjectCenterX + (fObjectWidth / 2)), (fObjectCenterY - (fObjectHeight / 2)), fObjectAngle, ref newX2, ref newY2);
                    Math2.RotateWithAngleAccordingToReferencePoint(fObjectCenterX, fObjectCenterY, (fObjectCenterX + (fObjectWidth / 2)), (fObjectCenterY + (fObjectHeight / 2)), fObjectAngle, ref newX3, ref newY3);
                    Math2.RotateWithAngleAccordingToReferencePoint(fObjectCenterX, fObjectCenterY, (fObjectCenterX - (fObjectWidth / 2)), (fObjectCenterY + (fObjectHeight / 2)), fObjectAngle, ref newX4, ref newY4);


                    arrRotatedPoints[i].Add(new PointF(newX1, newY1));
                    arrRotatedPoints[i].Add(new PointF(newX2, newY2));
                    arrRotatedPoints[i].Add(new PointF(newX3, newY3));
                    arrRotatedPoints[i].Add(new PointF(newX4, newY4));

                    Math2.RotateWithAngleAccordingToReferencePoint(fObjectCenterX, fObjectCenterY, (fObjectCenterX - (fObjectWidth / 2)) - intTolerance, (fObjectCenterY - (fObjectHeight / 2)) - intTolerance, fObjectAngle, ref newX1, ref newY1);
                    Math2.RotateWithAngleAccordingToReferencePoint(fObjectCenterX, fObjectCenterY, (fObjectCenterX + (fObjectWidth / 2)) + intTolerance, (fObjectCenterY - (fObjectHeight / 2)) - intTolerance, fObjectAngle, ref newX2, ref newY2);
                    Math2.RotateWithAngleAccordingToReferencePoint(fObjectCenterX, fObjectCenterY, (fObjectCenterX + (fObjectWidth / 2)) + intTolerance, (fObjectCenterY + (fObjectHeight / 2)) + intTolerance, fObjectAngle, ref newX3, ref newY3);
                    Math2.RotateWithAngleAccordingToReferencePoint(fObjectCenterX, fObjectCenterY, (fObjectCenterX - (fObjectWidth / 2)) - intTolerance, (fObjectCenterY + (fObjectHeight / 2)) + intTolerance, fObjectAngle, ref newX4, ref newY4);

                    arr2DPoints[i].Add(new System.Windows.Point(newX1, newY1));
                    arr2DPoints[i].Add(new System.Windows.Point(newX2, newY2));
                    arr2DPoints[i].Add(new System.Windows.Point(newX3, newY3));
                    arr2DPoints[i].Add(new System.Windows.Point(newX4, newY4));

                    fObjectHeightList.Add(fObjectHeight);
                    fObjectWidthList.Add(fObjectWidth);
                    fObjectCenterXList.Add(fObjectCenterX);
                    fObjectCenterYList.Add(fObjectCenterY);
                    fObjectAngleList.Add(fObjectAngle);
                    fObjectAreaList.Add(intObjectArea);
                    fObjectAreaList2.Add(intObjectArea);

                }
                int intAngleTolerance = 10;
                bool blnDecrement = false;
                if (intTolerance >= 0)
                {
                    for (int i = 0; i < fObjectHeightList.Count; i++)
                    {
                        if (blnDecrement)
                        {
                            blnDecrement = false;
                            if (i > 0)
                                i--;
                        }
                        for (int j = 0; j < fObjectHeightList.Count; j++)
                        {
                            if (i != j && i < fObjectHeightList.Count && j < fObjectHeightList.Count)
                            {
                                if (Intersection.CheckRectRectIntersection(arr2DPoints[i].ToArray(), arr2DPoints[j].ToArray(), intTolerance))
                                {

                                    PointF[] arrPoints = new PointF[8];

                                    arrPoints[0] = arrRotatedPoints[i][0];
                                    arrPoints[1] = arrRotatedPoints[i][1];
                                    arrPoints[2] = arrRotatedPoints[i][2];
                                    arrPoints[3] = arrRotatedPoints[i][3];
                                    arrPoints[4] = arrRotatedPoints[j][0];
                                    arrPoints[5] = arrRotatedPoints[j][1];
                                    arrPoints[6] = arrRotatedPoints[j][2];
                                    arrPoints[7] = arrRotatedPoints[j][3];

                                    float fMinAngle = 0;
                                    List<PointF> arrMinRect = new List<PointF>();
                                    arrMinRect = MinimumBoundingBox.CalculateMinimumBoundingBox(arrPoints, ref fMinAngle);
                                    //fObjectAngleList[i] = fMinAngle;
                                    if (fMinAngle < 0)
                                        fObjectAngleList[i] = -(90 + fMinAngle);
                                    else
                                        fObjectAngleList[i] = 90 - fMinAngle;

                                    //if (fMinAngle < 0)
                                    //    fObjectAngleList[i] = -(90 + fMinAngle);
                                    //else
                                    //    fObjectAngleList[i] = 90 - fMinAngle;

                                    Line onjLine1 = new Line();
                                    Line onjLine2 = new Line();
                                    onjLine1.CalculateStraightLine(arrMinRect[0], arrMinRect[2]);
                                    onjLine2.CalculateStraightLine(arrMinRect[1], arrMinRect[3]);
                                    PointF pCenter = Line.GetCrossPoint(onjLine1, onjLine2);
                                    float p1X = 0, p1Y = 0;
                                    float p2X = 0, p2Y = 0;
                                    float p3X = 0, p3Y = 0;
                                    float p4X = 0, p4Y = 0;
                                    Math2.RotateWithAngleAccordingToReferencePoint(pCenter.X, pCenter.Y, arrMinRect[0].X, arrMinRect[0].Y, -fObjectAngleList[i], ref p1X, ref p1Y);
                                    Math2.RotateWithAngleAccordingToReferencePoint(pCenter.X, pCenter.Y, arrMinRect[1].X, arrMinRect[1].Y, -fObjectAngleList[i], ref p2X, ref p2Y);
                                    Math2.RotateWithAngleAccordingToReferencePoint(pCenter.X, pCenter.Y, arrMinRect[2].X, arrMinRect[2].Y, -fObjectAngleList[i], ref p3X, ref p3Y);
                                    Math2.RotateWithAngleAccordingToReferencePoint(pCenter.X, pCenter.Y, arrMinRect[3].X, arrMinRect[3].Y, -fObjectAngleList[i], ref p4X, ref p4Y);

                                    float pR1X = 0, pR1Y = 0;
                                    float pR2X = 0, pR2Y = 0;
                                    float pR3X = 0, pR3Y = 0;
                                    float pR4X = 0, pR4Y = 0;
                                    Math2.RotateWithAngleAccordingToReferencePoint(pCenter.X, pCenter.Y, Math.Min(Math.Min(p1X, p2X), Math.Min(p3X, p4X)), Math.Min(Math.Min(p1Y, p2Y), Math.Min(p3Y, p4Y)), fObjectAngleList[i], ref pR1X, ref pR1Y); // Top Left
                                    Math2.RotateWithAngleAccordingToReferencePoint(pCenter.X, pCenter.Y, Math.Max(Math.Max(p1X, p2X), Math.Max(p3X, p4X)), Math.Min(Math.Min(p1Y, p2Y), Math.Min(p3Y, p4Y)), fObjectAngleList[i], ref pR2X, ref pR2Y); // Top Right
                                    Math2.RotateWithAngleAccordingToReferencePoint(pCenter.X, pCenter.Y, Math.Max(Math.Max(p1X, p2X), Math.Max(p3X, p4X)), Math.Max(Math.Max(p1Y, p2Y), Math.Max(p3Y, p4Y)), fObjectAngleList[i], ref pR3X, ref pR3Y); // Bottom Right
                                    Math2.RotateWithAngleAccordingToReferencePoint(pCenter.X, pCenter.Y, Math.Min(Math.Min(p1X, p2X), Math.Min(p3X, p4X)), Math.Max(Math.Max(p1Y, p2Y), Math.Max(p3Y, p4Y)), fObjectAngleList[i], ref pR4X, ref pR4Y); // Bottom Left
                                    arrMinRect[0] = new PointF(pR1X, pR1Y);
                                    arrMinRect[1] = new PointF(pR2X, pR2Y);
                                    arrMinRect[2] = new PointF(pR3X, pR3Y);
                                    arrMinRect[3] = new PointF(pR4X, pR4Y);

                                    arrRotatedPoints[i][0] = arrMinRect[0];
                                    arrRotatedPoints[i][1] = arrMinRect[1];
                                    arrRotatedPoints[i][2] = arrMinRect[2];
                                    arrRotatedPoints[i][3] = arrMinRect[3];

                                    Math2.RotateWithAngleAccordingToReferencePoint(pCenter.X, pCenter.Y, Math.Min(Math.Min(p1X, p2X), Math.Min(p3X, p4X)) - intTolerance, Math.Min(Math.Min(p1Y, p2Y), Math.Min(p3Y, p4Y)) - intTolerance, fObjectAngleList[i], ref pR1X, ref pR1Y); // Top Left
                                    Math2.RotateWithAngleAccordingToReferencePoint(pCenter.X, pCenter.Y, Math.Max(Math.Max(p1X, p2X), Math.Max(p3X, p4X)) + intTolerance, Math.Min(Math.Min(p1Y, p2Y), Math.Min(p3Y, p4Y)) - intTolerance, fObjectAngleList[i], ref pR2X, ref pR2Y); // Top Right
                                    Math2.RotateWithAngleAccordingToReferencePoint(pCenter.X, pCenter.Y, Math.Max(Math.Max(p1X, p2X), Math.Max(p3X, p4X)) + intTolerance, Math.Max(Math.Max(p1Y, p2Y), Math.Max(p3Y, p4Y)) + intTolerance, fObjectAngleList[i], ref pR3X, ref pR3Y); // Bottom Right
                                    Math2.RotateWithAngleAccordingToReferencePoint(pCenter.X, pCenter.Y, Math.Min(Math.Min(p1X, p2X), Math.Min(p3X, p4X)) - intTolerance, Math.Max(Math.Max(p1Y, p2Y), Math.Max(p3Y, p4Y)) + intTolerance, fObjectAngleList[i], ref pR4X, ref pR4Y); // Bottom Left

                                    arr2DPoints[i][0] = new System.Windows.Point(pR1X, pR1Y);
                                    arr2DPoints[i][1] = new System.Windows.Point(pR2X, pR2Y);
                                    arr2DPoints[i][2] = new System.Windows.Point(pR3X, pR3Y);
                                    arr2DPoints[i][3] = new System.Windows.Point(pR4X, pR4Y);

                                    arrRotatedPoints.RemoveAt(j);
                                    arr2DPoints.RemoveAt(j);

                                    float fDiffX = Math.Max(Math.Abs(p1X - p4X), Math.Abs(p2X - p3X));
                                    float fDiffY = Math.Max(Math.Abs(p3Y - p4Y), Math.Abs(p2Y - p1Y));

                                    fObjectWidthList[i] = fDiffX;
                                    fObjectHeightList[i] = fDiffY;

                                    fObjectCenterXList[i] = pCenter.X;
                                    fObjectCenterYList[i] = pCenter.Y;

                                    fObjectAreaList2.RemoveAt(j);
                                    fObjectAreaList[i] = fObjectAreaList[i] + fObjectAreaList[j];

                                    fObjectHeightList.RemoveAt(j);
                                    fObjectWidthList.RemoveAt(j);
                                    fObjectCenterXList.RemoveAt(j);
                                    fObjectCenterYList.RemoveAt(j);
                                    fObjectAngleList.RemoveAt(j);
                                    fObjectAreaList.RemoveAt(j);

                                    if (j > 0)
                                        j = -1;
                                    if (i > 0)
                                    {
                                        i = 0;
                                    }
                                    else
                                        blnDecrement = true;

                                }

                            }
                        }
                    }
                }
                for (int i = 0; i < fObjectHeightList.Count; i++)
                {
                    if (fObjectHeightList[i] < fObjectWidthList[i])
                    {
                        fObjectWidth = fObjectHeightList[i];
                        fObjectHeight = fObjectWidthList[i];

                        fObjectAngle = fObjectAngleList[i];

                        if (fObjectAngle >= 10)//&& fAngle <= 80)
                            fObjectAngle = fObjectAngleList[i] - 90;
                        else
                            fObjectAngle = 90 + fObjectAngleList[i];

                        fObjectWidthList[i] = fObjectWidth;
                        fObjectHeightList[i] = fObjectHeight;
                        fObjectAngleList[i] = fObjectAngle;
                    }
                    else
                    {
                        fObjectHeight = fObjectHeightList[i];
                        fObjectWidth = fObjectWidthList[i];

                        fObjectAngle = fObjectAngleList[i];

                        fObjectWidthList[i] = fObjectWidth;
                        fObjectHeightList[i] = fObjectHeight;
                        fObjectAngleList[i] = fObjectAngle;
                    }

                    //    float fWidthMM = fObjectWidth / m_fMMToPixelXValue;
                    //float fHeightMM = fObjectHeight / m_fMMToPixelYValue;
                    //float fAreaMM = intObjectArea / m_fMMToPixelYValue / m_fMMToPixelXValue;
                    float fWidthMM = fObjectWidthList[i] / m_fMMToPixelXValue;
                    float fHeightMM = fObjectHeightList[i] / m_fMMToPixelYValue;
                    float fAreaMM = fObjectAreaList[i] / (m_fMMToPixelXValue * m_fMMToPixelYValue);

                    //if ((fWidthMM > m_fCrackLength) || (fHeightMM > m_fCrackLength) || (fAreaMM > m_fCrackArea) && ((m_intFailPkgOptionMask & 0x400) > 0 || (m_intFailPkgOptionMask & 0x800) > 0))
                    {
                        intFailCount++;
                        //0x04
                        m_intFailPkgResultMask |= 0x400;

                        Defect objDefect = new Defect();
                        objDefect.ref_fWidth = fObjectWidthList[i];
                        objDefect.ref_fHeight = fObjectHeightList[i];
                        objDefect.ref_fArea = fObjectAreaList[i];
                        objDefect.ref_fWidthInMM = fWidthMM;
                        objDefect.ref_fHeightInMM = fHeightMM;
                        objDefect.ref_fAreaInMM2 = fAreaMM;
                        objDefect.ref_strName = "Crack";
                        objDefect.ref_fCenterX = intROIStartX + fObjectCenterXList[i];
                        objDefect.ref_fCenterY = intROIStartY + fObjectCenterYList[i];
                        objDefect.ref_fAngle = fObjectAngleList[i];
                        objDefect.ref_intFailMask = 0x400;
                        objDefect.ref_intImageNo = intImageIndex;

                        if ((m_intFailPkgOptionMask & 0x400) > 0)
                        {
                            if (m_intCrackDarkDefectDimensionFailCondition == 0)
                            {
                                if (fWidthMM > m_fDarkHorizontalCrack)
                                {
                                    blnOverallResult = false;
                                    objDefect.ref_fWidthFailValue = fWidthMM;
                                    objDefect.ref_intFailCriteria |= 0x01;
                                }
                                if (fHeightMM > m_fDarkVerticalCrack)
                                {
                                    blnOverallResult = false;
                                    objDefect.ref_fHeightFailValue = fHeightMM;
                                    objDefect.ref_intFailCriteria |= 0x02;
                                }
                            }
                            else
                            {
                                if ((fWidthMM > m_fDarkHorizontalCrack) && (fHeightMM > m_fDarkVerticalCrack))
                                {
                                    blnOverallResult = false;
                                    objDefect.ref_fWidthFailValue = fWidthMM;
                                    objDefect.ref_intFailCriteria |= 0x01;
                                    objDefect.ref_fHeightFailValue = fHeightMM;
                                    objDefect.ref_intFailCriteria |= 0x02;
                                }
                            }
                        }

                        if ((m_intFailPkgOptionMask & 0x800) > 0)
                        {
                            if (fAreaMM > m_fCrackArea)
                            {
                                blnOverallResult = false;
                                objDefect.ref_fAreaFailValue = fAreaMM;
                                objDefect.ref_intFailCriteria |= 0x04;
                            }
                        }

                        m_arrPkgDefectList.Add(objDefect);
                    }

                }
            }

            objCrackROI.Dispose();

            return blnOverallResult;
        }
        public bool CheckCrackDefect_SimpleMode_TiltAngle(ROI objImage1UnitROI, int intROIStartX, int intROIStartY, int intImageIndex, int intPadIndex)
        {
            // 0x400 = Crack Length, 0x800 = Crack Area
            if ((m_intFailPkgOptionMask & 0x800) == 0 && (m_intFailPkgOptionMask & 0x400) == 0)
                return true;
            bool blnDebugImage = false;
            float fPkgOffsetX = (objImage1UnitROI.ref_ROIWidth - Math.Max(GetResultUpWidth_RectGauge4L(0), GetResultDownWidth_RectGauge4L(0))) / 2;
            float fPkgOffsetY = (objImage1UnitROI.ref_ROIHeight - Math.Max(GetResultLeftHeight_RectGauge4L(0), GetResultRightHeight_RectGauge4L(0))) / 2;

            float fROIToleranceLeft = 0, fROIToleranceTop = 0, fROIToleranceRight = 0, fROIToleranceBottom = 0;
            if (m_blnSeperateBrightDarkROITolerance)
            {
                fROIToleranceLeft = m_fPkgStartPixelFromLeft_Dark;
                fROIToleranceTop = m_fPkgStartPixelFromEdge_Dark;
                fROIToleranceRight = m_fPkgStartPixelFromRight_Dark;
                fROIToleranceBottom = m_fPkgStartPixelFromBottom_Dark;
            }
            else
            {
                fROIToleranceLeft = m_fPkgStartPixelFromLeft;
                fROIToleranceTop = m_fPkgStartPixelFromEdge;
                fROIToleranceRight = m_fPkgStartPixelFromRight;
                fROIToleranceBottom = m_fPkgStartPixelFromBottom;
            }

            int intStartPixelFromEdgeX = (int)Math.Round(fPkgOffsetX + fROIToleranceLeft, 0, MidpointRounding.AwayFromZero);
            int intStartPixelFromEdgeY = (int)Math.Round(fPkgOffsetY + fROIToleranceTop, 0, MidpointRounding.AwayFromZero);
            int intStartPixelFromEdgeX2 = (int)Math.Round(fPkgOffsetX + fROIToleranceRight, 0, MidpointRounding.AwayFromZero);
            int intStartPixelFromEdgeY2 = (int)Math.Round(fPkgOffsetY + fROIToleranceBottom, 0, MidpointRounding.AwayFromZero);
            ImageDrawing ImgCrack = new ImageDrawing();
            ROI objCrackROI = new ROI();
            ImgCrack.SetImageSize(objImage1UnitROI.ref_ROIWidth, objImage1UnitROI.ref_ROIHeight);
            objImage1UnitROI.CopyToImage(ref ImgCrack);
            objCrackROI.AttachImage(ImgCrack);
            objCrackROI.LoadROISetting(intStartPixelFromEdgeX, intStartPixelFromEdgeY,
                objImage1UnitROI.ref_ROIWidth - intStartPixelFromEdgeX - intStartPixelFromEdgeX2,
                objImage1UnitROI.ref_ROIHeight - intStartPixelFromEdgeY - intStartPixelFromEdgeY2);
            //2019-09-23 ZJYEOH : Subtract tilt dont care area 
            if (intPadIndex == 1) // Top
            {
                ROI DontCareTop = new ROI();

                DontCareTop.LoadROISetting(0, 0, objCrackROI.ref_ROIWidth, objCrackROI.ref_ROIHeight);
                DontCareTop.AttachImage(m_ImgTilt_Top_L);
                EasyImage.Oper(EArithmeticLogicOperation.Add, objCrackROI.ref_ROI, DontCareTop.ref_ROI, objCrackROI.ref_ROI);
                DontCareTop.LoadROISetting(m_ImgTilt_Top_R.ref_intImageWidth - objCrackROI.ref_ROIWidth, 0, objCrackROI.ref_ROIWidth, objCrackROI.ref_ROIHeight);
                DontCareTop.AttachImage(m_ImgTilt_Top_R);
                EasyImage.Oper(EArithmeticLogicOperation.Add, objCrackROI.ref_ROI, DontCareTop.ref_ROI, objCrackROI.ref_ROI);
                if (blnDebugImage)
                    objCrackROI.SaveImage("D:\\CheckCrackDefect_SimpleMode_objCrackROITop.bmp");
                DontCareTop.Dispose();
            }
            if (intPadIndex == 2) // Right
            {
                ROI DontCareRight = new ROI();
                DontCareRight.LoadROISetting(m_ImgTilt_Top_R.ref_intImageWidth - objCrackROI.ref_ROIWidth, 0, objCrackROI.ref_ROIWidth, objCrackROI.ref_ROIHeight);
                DontCareRight.AttachImage(m_ImgTilt_Right_T);
                EasyImage.Oper(EArithmeticLogicOperation.Add, objCrackROI.ref_ROI, DontCareRight.ref_ROI, objCrackROI.ref_ROI);
                DontCareRight.LoadROISetting(m_ImgTilt_Top_R.ref_intImageWidth - objCrackROI.ref_ROIWidth, m_ImgTilt_Top_R.ref_intImageHeight - objCrackROI.ref_ROIHeight, objCrackROI.ref_ROIWidth, objCrackROI.ref_ROIHeight);
                DontCareRight.AttachImage(m_ImgTilt_Right_B);
                EasyImage.Oper(EArithmeticLogicOperation.Add, objCrackROI.ref_ROI, DontCareRight.ref_ROI, objCrackROI.ref_ROI);
                if (blnDebugImage)
                    objCrackROI.SaveImage("D:\\CheckCrackDefect_SimpleMode_objCrackROIRight.bmp");
                DontCareRight.Dispose();
            }
            if (intPadIndex == 3) // Bottom
            {
                ROI DontCareBottom = new ROI();

                DontCareBottom.LoadROISetting(0, m_ImgTilt_Top_R.ref_intImageHeight - objCrackROI.ref_ROIHeight, objCrackROI.ref_ROIWidth, objCrackROI.ref_ROIHeight);
                DontCareBottom.AttachImage(m_ImgTilt_Bottom_L);
                EasyImage.Oper(EArithmeticLogicOperation.Add, objCrackROI.ref_ROI, DontCareBottom.ref_ROI, objCrackROI.ref_ROI);
                DontCareBottom.LoadROISetting(m_ImgTilt_Top_R.ref_intImageWidth - objCrackROI.ref_ROIWidth, m_ImgTilt_Top_R.ref_intImageHeight - objCrackROI.ref_ROIHeight, objCrackROI.ref_ROIWidth, objCrackROI.ref_ROIHeight);
                DontCareBottom.AttachImage(m_ImgTilt_Bottom_R);
                EasyImage.Oper(EArithmeticLogicOperation.Add, objCrackROI.ref_ROI, DontCareBottom.ref_ROI, objCrackROI.ref_ROI);
                if (blnDebugImage)
                    objCrackROI.SaveImage("D:\\CheckCrackDefect_SimpleMode_objCrackROIBottom.bmp");
                DontCareBottom.Dispose();
            }
            if (intPadIndex == 4) // Left
            {
                ROI DontCareLeft = new ROI();

                DontCareLeft.LoadROISetting(0, 0, objCrackROI.ref_ROIWidth, objCrackROI.ref_ROIHeight);
                DontCareLeft.AttachImage(m_ImgTilt_Left_T);
                EasyImage.Oper(EArithmeticLogicOperation.Add, objCrackROI.ref_ROI, DontCareLeft.ref_ROI, objCrackROI.ref_ROI);
                DontCareLeft.LoadROISetting(0, m_ImgTilt_Top_R.ref_intImageHeight - objCrackROI.ref_ROIHeight, objCrackROI.ref_ROIWidth, objCrackROI.ref_ROIHeight);
                DontCareLeft.AttachImage(m_ImgTilt_Left_B);
                EasyImage.Oper(EArithmeticLogicOperation.Add, objCrackROI.ref_ROI, DontCareLeft.ref_ROI, objCrackROI.ref_ROI);
                if (blnDebugImage)
                    objCrackROI.SaveImage("D:\\CheckCrackDefect_SimpleMode_objCrackROILeft.bmp");
                DontCareLeft.Dispose();
            }
            int intSelectedObjectNum = m_objEBlobs.BuildObjects_Filter_GetElement_DoubleThreshold(
               objCrackROI, true, false, false, false, m_intPkgImage2LowCrackThreshold, m_intPkgImage2HighCrackThreshold,
               (int)m_fCrackMinArea, 15000, false, 0xED);


            bool blnOverallResult = true;
            if (intSelectedObjectNum > 0)
            {
                int intObjectArea = 0;
                float fObjectHeight = 0, fObjectWidth = 0, fObjectCenterX = 0, fObjectCenterY = 0, fObjectAngle = 0;

                int intFailCount = 0;
                for (int i = 0; i < intSelectedObjectNum; i++)
                {
                    intObjectArea = m_objEBlobs.ref_arrArea[i];
                    if (m_objEBlobs.ref_arrRectHeight[i] < m_objEBlobs.ref_arrRectWidth[i])
                    {
                        fObjectWidth = m_objEBlobs.ref_arrRectHeight[i];
                        fObjectHeight = m_objEBlobs.ref_arrRectWidth[i];

                        fObjectAngle = m_objEBlobs.ref_arrRectAngle[i];

                        if (fObjectAngle >= 10)//&& fAngle <= 80)
                            fObjectAngle = m_objEBlobs.ref_arrRectAngle[i] - 90;
                        else
                            fObjectAngle = 90 + m_objEBlobs.ref_arrRectAngle[i];

                    }
                    else
                    {
                        fObjectHeight = m_objEBlobs.ref_arrRectHeight[i];
                        fObjectWidth = m_objEBlobs.ref_arrRectWidth[i];

                        fObjectAngle = m_objEBlobs.ref_arrRectAngle[i];

                    }
                    //fObjectHeight = m_objEBlobs.ref_arrRectHeight[i];
                    //fObjectWidth = m_objEBlobs.ref_arrRectWidth[i];
                    fObjectCenterX = m_objEBlobs.ref_arrRectLimitCenterX[i];
                    fObjectCenterY = m_objEBlobs.ref_arrRectLimitCenterY[i];
                    //fObjectAngle = m_objEBlobs.ref_arrRectAngle[i];

                    fObjectCenterX += intStartPixelFromEdgeX;
                    fObjectCenterY += intStartPixelFromEdgeY;
                    //if (fObjectAngle < 0)
                    //    fObjectAngle = Math.Abs(fObjectAngle);
                    //else
                    //    fObjectAngle = 0 - (fObjectAngle);

                    //float Max = Math.Max(fObjectHeight, fObjectWidth);
                    //float Min = Math.Min(fObjectHeight, fObjectWidth);

                    //if (Max / Min <= 1.5)
                    //{
                    //    if ((intObjectArea / (fObjectHeight * fObjectWidth)) >= 0.5)
                    //    {
                    //        continue;
                    //    }
                    //}

                    float fWidthMM = fObjectWidth / m_fMMToPixelXValue;
                    float fHeightMM = fObjectHeight / m_fMMToPixelYValue;
                    float fAreaMM = intObjectArea / m_fMMToPixelYValue / m_fMMToPixelXValue;

                    //if ((fWidthMM > m_fCrackLength) || (fHeightMM > m_fCrackLength) || (fAreaMM > m_fCrackArea) && ((m_intFailPkgOptionMask & 0x400) > 0 || (m_intFailPkgOptionMask & 0x800) > 0))
                    {
                        intFailCount++;
                        //0x04
                        m_intFailPkgResultMask |= 0x400;

                        Defect objDefect = new Defect();
                        objDefect.ref_fWidth = fObjectWidth;
                        objDefect.ref_fHeight = fObjectHeight;
                        objDefect.ref_fArea = intObjectArea;
                        objDefect.ref_fWidthInMM = fWidthMM;
                        objDefect.ref_fHeightInMM = fHeightMM;
                        objDefect.ref_fAreaInMM2 = fAreaMM;
                        objDefect.ref_strName = "Crack";
                        objDefect.ref_fCenterX = intROIStartX + fObjectCenterX;
                        objDefect.ref_fCenterY = intROIStartY + fObjectCenterY;
                        objDefect.ref_fAngle = fObjectAngle;
                        objDefect.ref_intFailMask = 0x400;
                        objDefect.ref_intImageNo = intImageIndex;

                        if ((m_intFailPkgOptionMask & 0x400) > 0)
                        {
                            if (m_intCrackDarkDefectDimensionFailCondition == 0)
                            {
                                if (fWidthMM > m_fDarkHorizontalCrack)
                                {
                                    blnOverallResult = false;
                                    objDefect.ref_fWidthFailValue = fWidthMM;
                                    objDefect.ref_intFailCriteria |= 0x01;
                                }
                                if (fHeightMM > m_fDarkVerticalCrack)
                                {
                                    blnOverallResult = false;
                                    objDefect.ref_fHeightFailValue = fHeightMM;
                                    objDefect.ref_intFailCriteria |= 0x02;
                                }
                            }
                            else
                            {
                                if ((fWidthMM > m_fDarkHorizontalCrack) && (fHeightMM > m_fDarkVerticalCrack))
                                {
                                    blnOverallResult = false;
                                    objDefect.ref_fWidthFailValue = fWidthMM;
                                    objDefect.ref_intFailCriteria |= 0x01;
                                    objDefect.ref_fHeightFailValue = fHeightMM;
                                    objDefect.ref_intFailCriteria |= 0x02;
                                }
                            }
                        }

                        if ((m_intFailPkgOptionMask & 0x800) > 0)
                        {
                            if (fAreaMM > m_fCrackArea)
                            {
                                blnOverallResult = false;
                                objDefect.ref_fAreaFailValue = fAreaMM;
                                objDefect.ref_intFailCriteria |= 0x04;
                            }
                        }

                        m_arrPkgDefectList.Add(objDefect);
                    }

                }
            }

            objCrackROI.Dispose();
            ImgCrack.Dispose();
            return blnOverallResult;
        }
        public bool CheckCrackDefect_SimpleMode_TiltAngle_WithLinkFunction(ROI objImage1UnitROI, int intROIStartX, int intROIStartY, int intImageIndex, int intPadIndex)
        {
            // 0x400 = Crack Length, 0x800 = Crack Area
            if ((m_intFailPkgOptionMask & 0x800) == 0 && (m_intFailPkgOptionMask & 0x400) == 0)
                return true;
            bool blnDebugImage = false;
            float fPkgOffsetX = (objImage1UnitROI.ref_ROIWidth - Math.Max(GetResultUpWidth_RectGauge4L(0), GetResultDownWidth_RectGauge4L(0))) / 2;
            float fPkgOffsetY = (objImage1UnitROI.ref_ROIHeight - Math.Max(GetResultLeftHeight_RectGauge4L(0), GetResultRightHeight_RectGauge4L(0))) / 2;

            float fROIToleranceLeft = 0, fROIToleranceTop = 0, fROIToleranceRight = 0, fROIToleranceBottom = 0;
            if (m_blnSeperateBrightDarkROITolerance)
            {
                fROIToleranceLeft = m_fPkgStartPixelFromLeft_Dark;
                fROIToleranceTop = m_fPkgStartPixelFromEdge_Dark;
                fROIToleranceRight = m_fPkgStartPixelFromRight_Dark;
                fROIToleranceBottom = m_fPkgStartPixelFromBottom_Dark;
            }
            else
            {
                fROIToleranceLeft = m_fPkgStartPixelFromLeft;
                fROIToleranceTop = m_fPkgStartPixelFromEdge;
                fROIToleranceRight = m_fPkgStartPixelFromRight;
                fROIToleranceBottom = m_fPkgStartPixelFromBottom;
            }

            int intStartPixelFromEdgeX = (int)Math.Round(fPkgOffsetX + fROIToleranceLeft, 0, MidpointRounding.AwayFromZero);
            int intStartPixelFromEdgeY = (int)Math.Round(fPkgOffsetY + fROIToleranceTop, 0, MidpointRounding.AwayFromZero);
            int intStartPixelFromEdgeX2 = (int)Math.Round(fPkgOffsetX + fROIToleranceRight, 0, MidpointRounding.AwayFromZero);
            int intStartPixelFromEdgeY2 = (int)Math.Round(fPkgOffsetY + m_fPkgStartPixelFromBottom_Dark, 0, MidpointRounding.AwayFromZero);
            ImageDrawing ImgCrack = new ImageDrawing();
            ROI objCrackROI = new ROI();
            ImgCrack.SetImageSize(objImage1UnitROI.ref_ROIWidth, objImage1UnitROI.ref_ROIHeight);
            objImage1UnitROI.CopyToImage(ref ImgCrack);
            objCrackROI.AttachImage(ImgCrack);
            objCrackROI.LoadROISetting(intStartPixelFromEdgeX, intStartPixelFromEdgeY,
                objImage1UnitROI.ref_ROIWidth - intStartPixelFromEdgeX - intStartPixelFromEdgeX2,
                objImage1UnitROI.ref_ROIHeight - intStartPixelFromEdgeY - intStartPixelFromEdgeY2);
            //2019-09-23 ZJYEOH : Subtract tilt dont care area 
            if (intPadIndex == 1) // Top
            {
                ROI DontCareTop = new ROI();

                DontCareTop.LoadROISetting(0, 0, objCrackROI.ref_ROIWidth, objCrackROI.ref_ROIHeight);
                DontCareTop.AttachImage(m_ImgTilt_Top_L);
                EasyImage.Oper(EArithmeticLogicOperation.Add, objCrackROI.ref_ROI, DontCareTop.ref_ROI, objCrackROI.ref_ROI);
                DontCareTop.LoadROISetting(m_ImgTilt_Top_R.ref_intImageWidth - objCrackROI.ref_ROIWidth, 0, objCrackROI.ref_ROIWidth, objCrackROI.ref_ROIHeight);
                DontCareTop.AttachImage(m_ImgTilt_Top_R);
                EasyImage.Oper(EArithmeticLogicOperation.Add, objCrackROI.ref_ROI, DontCareTop.ref_ROI, objCrackROI.ref_ROI);
                if (blnDebugImage)
                    objCrackROI.SaveImage("D:\\CheckCrackDefect_SimpleMode_objCrackROITop.bmp");
                DontCareTop.Dispose();
            }
            if (intPadIndex == 2) // Right
            {
                ROI DontCareRight = new ROI();
                DontCareRight.LoadROISetting(m_ImgTilt_Top_R.ref_intImageWidth - objCrackROI.ref_ROIWidth, 0, objCrackROI.ref_ROIWidth, objCrackROI.ref_ROIHeight);
                DontCareRight.AttachImage(m_ImgTilt_Right_T);
                EasyImage.Oper(EArithmeticLogicOperation.Add, objCrackROI.ref_ROI, DontCareRight.ref_ROI, objCrackROI.ref_ROI);
                DontCareRight.LoadROISetting(m_ImgTilt_Top_R.ref_intImageWidth - objCrackROI.ref_ROIWidth, m_ImgTilt_Top_R.ref_intImageHeight - objCrackROI.ref_ROIHeight, objCrackROI.ref_ROIWidth, objCrackROI.ref_ROIHeight);
                DontCareRight.AttachImage(m_ImgTilt_Right_B);
                EasyImage.Oper(EArithmeticLogicOperation.Add, objCrackROI.ref_ROI, DontCareRight.ref_ROI, objCrackROI.ref_ROI);
                if (blnDebugImage)
                    objCrackROI.SaveImage("D:\\CheckCrackDefect_SimpleMode_objCrackROIRight.bmp");
                DontCareRight.Dispose();
            }
            if (intPadIndex == 3) // Bottom
            {
                ROI DontCareBottom = new ROI();

                DontCareBottom.LoadROISetting(0, m_ImgTilt_Top_R.ref_intImageHeight - objCrackROI.ref_ROIHeight, objCrackROI.ref_ROIWidth, objCrackROI.ref_ROIHeight);
                DontCareBottom.AttachImage(m_ImgTilt_Bottom_L);
                EasyImage.Oper(EArithmeticLogicOperation.Add, objCrackROI.ref_ROI, DontCareBottom.ref_ROI, objCrackROI.ref_ROI);
                DontCareBottom.LoadROISetting(m_ImgTilt_Top_R.ref_intImageWidth - objCrackROI.ref_ROIWidth, m_ImgTilt_Top_R.ref_intImageHeight - objCrackROI.ref_ROIHeight, objCrackROI.ref_ROIWidth, objCrackROI.ref_ROIHeight);
                DontCareBottom.AttachImage(m_ImgTilt_Bottom_R);
                EasyImage.Oper(EArithmeticLogicOperation.Add, objCrackROI.ref_ROI, DontCareBottom.ref_ROI, objCrackROI.ref_ROI);
                if (blnDebugImage)
                    objCrackROI.SaveImage("D:\\CheckCrackDefect_SimpleMode_objCrackROIBottom.bmp");
                DontCareBottom.Dispose();
            }
            if (intPadIndex == 4) // Left
            {
                ROI DontCareLeft = new ROI();

                DontCareLeft.LoadROISetting(0, 0, objCrackROI.ref_ROIWidth, objCrackROI.ref_ROIHeight);
                DontCareLeft.AttachImage(m_ImgTilt_Left_T);
                EasyImage.Oper(EArithmeticLogicOperation.Add, objCrackROI.ref_ROI, DontCareLeft.ref_ROI, objCrackROI.ref_ROI);
                DontCareLeft.LoadROISetting(0, m_ImgTilt_Top_R.ref_intImageHeight - objCrackROI.ref_ROIHeight, objCrackROI.ref_ROIWidth, objCrackROI.ref_ROIHeight);
                DontCareLeft.AttachImage(m_ImgTilt_Left_B);
                EasyImage.Oper(EArithmeticLogicOperation.Add, objCrackROI.ref_ROI, DontCareLeft.ref_ROI, objCrackROI.ref_ROI);
                if (blnDebugImage)
                    objCrackROI.SaveImage("D:\\CheckCrackDefect_SimpleMode_objCrackROILeft.bmp");
                DontCareLeft.Dispose();
            }
            int intSelectedObjectNum = m_objEBlobs.BuildObjects_Filter_GetElement_DoubleThreshold(
               objCrackROI, true, false, false, false, m_intPkgImage2LowCrackThreshold, m_intPkgImage2HighCrackThreshold,
               (int)m_fCrackMinArea, 15000, false, 0xED);


            bool blnOverallResult = true;
            if (intSelectedObjectNum > 0)
            {
                List<List<System.Windows.Point>> arr2DPoints = new List<List<System.Windows.Point>>();
                List<List<PointF>> arrRotatedPoints = new List<List<PointF>>();
                List<float> fObjectHeightList = new List<float>(), fObjectWidthList = new List<float>(), fObjectCenterXList = new List<float>(), fObjectCenterYList = new List<float>(), fObjectAngleList = new List<float>();
                List<float> fObjectLimitHeightList = new List<float>(), fObjectLimitWidthList = new List<float>(), fObjectLimitCenterXList = new List<float>(), fObjectLimitCenterYList = new List<float>();
                List<int> fObjectAreaList = new List<int>(), fObjectAreaList2 = new List<int>();
                int intObjectArea = 0;
                float fObjectHeight = 0, fObjectWidth = 0, fObjectCenterX = 0, fObjectCenterY = 0, fObjectAngle = 0;
                int intTolerance = m_intCrackDefectLinkTolerance;
                int intFailCount = 0;
                for (int i = 0; i < intSelectedObjectNum; i++)
                {
                    arrRotatedPoints.Add(new List<PointF>());
                    arr2DPoints.Add(new List<System.Windows.Point>());
                    intObjectArea = m_objEBlobs.ref_arrArea[i];
                    if (m_objEBlobs.ref_arrRectHeight[i] < m_objEBlobs.ref_arrRectWidth[i])
                    {
                        fObjectWidth = m_objEBlobs.ref_arrRectHeight[i];
                        fObjectHeight = m_objEBlobs.ref_arrRectWidth[i];

                        fObjectAngle = m_objEBlobs.ref_arrRectAngle[i];

                        if (fObjectAngle >= 10)//&& fAngle <= 80)
                            fObjectAngle = m_objEBlobs.ref_arrRectAngle[i] - 90;
                        else
                            fObjectAngle = 90 + m_objEBlobs.ref_arrRectAngle[i];

                    }
                    else
                    {
                        fObjectHeight = m_objEBlobs.ref_arrRectHeight[i];
                        fObjectWidth = m_objEBlobs.ref_arrRectWidth[i];

                        fObjectAngle = m_objEBlobs.ref_arrRectAngle[i];

                    }
                    //fObjectHeight = m_objEBlobs.ref_arrRectHeight[i];
                    //fObjectWidth = m_objEBlobs.ref_arrRectWidth[i];
                    fObjectCenterX = m_objEBlobs.ref_arrRectLimitCenterX[i];
                    fObjectCenterY = m_objEBlobs.ref_arrRectLimitCenterY[i];
                    //fObjectAngle = m_objEBlobs.ref_arrRectAngle[i];

                    fObjectCenterX += intStartPixelFromEdgeX;
                    fObjectCenterY += intStartPixelFromEdgeY;
                    //if (fObjectAngle < 0)
                    //    fObjectAngle = Math.Abs(fObjectAngle);
                    //else
                    //    fObjectAngle = 0 - (fObjectAngle);

                    //float Max = Math.Max(fObjectHeight, fObjectWidth);
                    //float Min = Math.Min(fObjectHeight, fObjectWidth);

                    //if (Max / Min <= 1.5)
                    //{
                    //    if ((intObjectArea / (fObjectHeight * fObjectWidth)) >= 0.5)
                    //    {
                    //        continue;
                    //    }
                    //}

                    float newX1 = 0, newY1 = 0;  // new point 1
                    float newX2 = 0, newY2 = 0; // new point 2
                    float newX3 = 0, newY3 = 0; // new point 3
                    float newX4 = 0, newY4 = 0; // new point 4

                    //2020-12-18 ZJYEOH : Change to this format
                    //  Point 1 *-------------* Point 2
                    //          |             |
                    //          |             |
                    //          |             |
                    //  Point 4 *-------------* Point 3

                    Math2.RotateWithAngleAccordingToReferencePoint(fObjectCenterX, fObjectCenterY, (fObjectCenterX - (fObjectWidth / 2)), (fObjectCenterY - (fObjectHeight / 2)), fObjectAngle, ref newX1, ref newY1);
                    Math2.RotateWithAngleAccordingToReferencePoint(fObjectCenterX, fObjectCenterY, (fObjectCenterX + (fObjectWidth / 2)), (fObjectCenterY - (fObjectHeight / 2)), fObjectAngle, ref newX2, ref newY2);
                    Math2.RotateWithAngleAccordingToReferencePoint(fObjectCenterX, fObjectCenterY, (fObjectCenterX + (fObjectWidth / 2)), (fObjectCenterY + (fObjectHeight / 2)), fObjectAngle, ref newX3, ref newY3);
                    Math2.RotateWithAngleAccordingToReferencePoint(fObjectCenterX, fObjectCenterY, (fObjectCenterX - (fObjectWidth / 2)), (fObjectCenterY + (fObjectHeight / 2)), fObjectAngle, ref newX4, ref newY4);


                    arrRotatedPoints[i].Add(new PointF(newX1, newY1));
                    arrRotatedPoints[i].Add(new PointF(newX2, newY2));
                    arrRotatedPoints[i].Add(new PointF(newX3, newY3));
                    arrRotatedPoints[i].Add(new PointF(newX4, newY4));

                    Math2.RotateWithAngleAccordingToReferencePoint(fObjectCenterX, fObjectCenterY, (fObjectCenterX - (fObjectWidth / 2)) - intTolerance, (fObjectCenterY - (fObjectHeight / 2)) - intTolerance, fObjectAngle, ref newX1, ref newY1);
                    Math2.RotateWithAngleAccordingToReferencePoint(fObjectCenterX, fObjectCenterY, (fObjectCenterX + (fObjectWidth / 2)) + intTolerance, (fObjectCenterY - (fObjectHeight / 2)) - intTolerance, fObjectAngle, ref newX2, ref newY2);
                    Math2.RotateWithAngleAccordingToReferencePoint(fObjectCenterX, fObjectCenterY, (fObjectCenterX + (fObjectWidth / 2)) + intTolerance, (fObjectCenterY + (fObjectHeight / 2)) + intTolerance, fObjectAngle, ref newX3, ref newY3);
                    Math2.RotateWithAngleAccordingToReferencePoint(fObjectCenterX, fObjectCenterY, (fObjectCenterX - (fObjectWidth / 2)) - intTolerance, (fObjectCenterY + (fObjectHeight / 2)) + intTolerance, fObjectAngle, ref newX4, ref newY4);

                    arr2DPoints[i].Add(new System.Windows.Point(newX1, newY1));
                    arr2DPoints[i].Add(new System.Windows.Point(newX2, newY2));
                    arr2DPoints[i].Add(new System.Windows.Point(newX3, newY3));
                    arr2DPoints[i].Add(new System.Windows.Point(newX4, newY4));

                    fObjectHeightList.Add(fObjectHeight);
                    fObjectWidthList.Add(fObjectWidth);
                    fObjectCenterXList.Add(fObjectCenterX);
                    fObjectCenterYList.Add(fObjectCenterY);
                    fObjectAngleList.Add(fObjectAngle);
                    fObjectAreaList.Add(intObjectArea);
                    fObjectAreaList2.Add(intObjectArea);
                }
                int intAngleTolerance = 10;
                bool blnDecrement = false;
                if (intTolerance >= 0)
                {
                    for (int i = 0; i < fObjectHeightList.Count; i++)
                    {
                        if (blnDecrement)
                        {
                            blnDecrement = false;
                            if (i > 0)
                                i--;
                        }
                        for (int j = 0; j < fObjectHeightList.Count; j++)
                        {
                            if (i != j && i < fObjectHeightList.Count && j < fObjectHeightList.Count)
                            {
                                if (Intersection.CheckRectRectIntersection(arr2DPoints[i].ToArray(), arr2DPoints[j].ToArray(), intTolerance))
                                {

                                    PointF[] arrPoints = new PointF[8];

                                    arrPoints[0] = arrRotatedPoints[i][0];
                                    arrPoints[1] = arrRotatedPoints[i][1];
                                    arrPoints[2] = arrRotatedPoints[i][2];
                                    arrPoints[3] = arrRotatedPoints[i][3];
                                    arrPoints[4] = arrRotatedPoints[j][0];
                                    arrPoints[5] = arrRotatedPoints[j][1];
                                    arrPoints[6] = arrRotatedPoints[j][2];
                                    arrPoints[7] = arrRotatedPoints[j][3];

                                    float fMinAngle = 0;
                                    List<PointF> arrMinRect = new List<PointF>();
                                    arrMinRect = MinimumBoundingBox.CalculateMinimumBoundingBox(arrPoints, ref fMinAngle);
                                    //fObjectAngleList[i] = fMinAngle;
                                    if (fMinAngle < 0)
                                        fObjectAngleList[i] = -(90 + fMinAngle);
                                    else
                                        fObjectAngleList[i] = 90 - fMinAngle;

                                    //if (fMinAngle < 0)
                                    //    fObjectAngleList[i] = -(90 + fMinAngle);
                                    //else
                                    //    fObjectAngleList[i] = 90 - fMinAngle;

                                    Line onjLine1 = new Line();
                                    Line onjLine2 = new Line();
                                    onjLine1.CalculateStraightLine(arrMinRect[0], arrMinRect[2]);
                                    onjLine2.CalculateStraightLine(arrMinRect[1], arrMinRect[3]);
                                    PointF pCenter = Line.GetCrossPoint(onjLine1, onjLine2);
                                    float p1X = 0, p1Y = 0;
                                    float p2X = 0, p2Y = 0;
                                    float p3X = 0, p3Y = 0;
                                    float p4X = 0, p4Y = 0;
                                    Math2.RotateWithAngleAccordingToReferencePoint(pCenter.X, pCenter.Y, arrMinRect[0].X, arrMinRect[0].Y, -fObjectAngleList[i], ref p1X, ref p1Y);
                                    Math2.RotateWithAngleAccordingToReferencePoint(pCenter.X, pCenter.Y, arrMinRect[1].X, arrMinRect[1].Y, -fObjectAngleList[i], ref p2X, ref p2Y);
                                    Math2.RotateWithAngleAccordingToReferencePoint(pCenter.X, pCenter.Y, arrMinRect[2].X, arrMinRect[2].Y, -fObjectAngleList[i], ref p3X, ref p3Y);
                                    Math2.RotateWithAngleAccordingToReferencePoint(pCenter.X, pCenter.Y, arrMinRect[3].X, arrMinRect[3].Y, -fObjectAngleList[i], ref p4X, ref p4Y);

                                    float pR1X = 0, pR1Y = 0;
                                    float pR2X = 0, pR2Y = 0;
                                    float pR3X = 0, pR3Y = 0;
                                    float pR4X = 0, pR4Y = 0;
                                    Math2.RotateWithAngleAccordingToReferencePoint(pCenter.X, pCenter.Y, Math.Min(Math.Min(p1X, p2X), Math.Min(p3X, p4X)), Math.Min(Math.Min(p1Y, p2Y), Math.Min(p3Y, p4Y)), fObjectAngleList[i], ref pR1X, ref pR1Y); // Top Left
                                    Math2.RotateWithAngleAccordingToReferencePoint(pCenter.X, pCenter.Y, Math.Max(Math.Max(p1X, p2X), Math.Max(p3X, p4X)), Math.Min(Math.Min(p1Y, p2Y), Math.Min(p3Y, p4Y)), fObjectAngleList[i], ref pR2X, ref pR2Y); // Top Right
                                    Math2.RotateWithAngleAccordingToReferencePoint(pCenter.X, pCenter.Y, Math.Max(Math.Max(p1X, p2X), Math.Max(p3X, p4X)), Math.Max(Math.Max(p1Y, p2Y), Math.Max(p3Y, p4Y)), fObjectAngleList[i], ref pR3X, ref pR3Y); // Bottom Right
                                    Math2.RotateWithAngleAccordingToReferencePoint(pCenter.X, pCenter.Y, Math.Min(Math.Min(p1X, p2X), Math.Min(p3X, p4X)), Math.Max(Math.Max(p1Y, p2Y), Math.Max(p3Y, p4Y)), fObjectAngleList[i], ref pR4X, ref pR4Y); // Bottom Left
                                    arrMinRect[0] = new PointF(pR1X, pR1Y);
                                    arrMinRect[1] = new PointF(pR2X, pR2Y);
                                    arrMinRect[2] = new PointF(pR3X, pR3Y);
                                    arrMinRect[3] = new PointF(pR4X, pR4Y);

                                    arrRotatedPoints[i][0] = arrMinRect[0];
                                    arrRotatedPoints[i][1] = arrMinRect[1];
                                    arrRotatedPoints[i][2] = arrMinRect[2];
                                    arrRotatedPoints[i][3] = arrMinRect[3];

                                    Math2.RotateWithAngleAccordingToReferencePoint(pCenter.X, pCenter.Y, Math.Min(Math.Min(p1X, p2X), Math.Min(p3X, p4X)) - intTolerance, Math.Min(Math.Min(p1Y, p2Y), Math.Min(p3Y, p4Y)) - intTolerance, fObjectAngleList[i], ref pR1X, ref pR1Y); // Top Left
                                    Math2.RotateWithAngleAccordingToReferencePoint(pCenter.X, pCenter.Y, Math.Max(Math.Max(p1X, p2X), Math.Max(p3X, p4X)) + intTolerance, Math.Min(Math.Min(p1Y, p2Y), Math.Min(p3Y, p4Y)) - intTolerance, fObjectAngleList[i], ref pR2X, ref pR2Y); // Top Right
                                    Math2.RotateWithAngleAccordingToReferencePoint(pCenter.X, pCenter.Y, Math.Max(Math.Max(p1X, p2X), Math.Max(p3X, p4X)) + intTolerance, Math.Max(Math.Max(p1Y, p2Y), Math.Max(p3Y, p4Y)) + intTolerance, fObjectAngleList[i], ref pR3X, ref pR3Y); // Bottom Right
                                    Math2.RotateWithAngleAccordingToReferencePoint(pCenter.X, pCenter.Y, Math.Min(Math.Min(p1X, p2X), Math.Min(p3X, p4X)) - intTolerance, Math.Max(Math.Max(p1Y, p2Y), Math.Max(p3Y, p4Y)) + intTolerance, fObjectAngleList[i], ref pR4X, ref pR4Y); // Bottom Left

                                    arr2DPoints[i][0] = new System.Windows.Point(pR1X, pR1Y);
                                    arr2DPoints[i][1] = new System.Windows.Point(pR2X, pR2Y);
                                    arr2DPoints[i][2] = new System.Windows.Point(pR3X, pR3Y);
                                    arr2DPoints[i][3] = new System.Windows.Point(pR4X, pR4Y);

                                    arrRotatedPoints.RemoveAt(j);
                                    arr2DPoints.RemoveAt(j);

                                    float fDiffX = Math.Max(Math.Abs(p1X - p4X), Math.Abs(p2X - p3X));
                                    float fDiffY = Math.Max(Math.Abs(p3Y - p4Y), Math.Abs(p2Y - p1Y));

                                    fObjectWidthList[i] = fDiffX;
                                    fObjectHeightList[i] = fDiffY;

                                    fObjectCenterXList[i] = pCenter.X;
                                    fObjectCenterYList[i] = pCenter.Y;

                                    fObjectAreaList2.RemoveAt(j);
                                    fObjectAreaList[i] = fObjectAreaList[i] + fObjectAreaList[j];

                                    fObjectHeightList.RemoveAt(j);
                                    fObjectWidthList.RemoveAt(j);
                                    fObjectCenterXList.RemoveAt(j);
                                    fObjectCenterYList.RemoveAt(j);
                                    fObjectAngleList.RemoveAt(j);
                                    fObjectAreaList.RemoveAt(j);

                                    if (j > 0)
                                        j = -1;
                                    if (i > 0)
                                    {
                                        i = 0;
                                    }
                                    else
                                        blnDecrement = true;

                                }

                            }
                        }
                    }
                }
                for (int i = 0; i < fObjectHeightList.Count; i++)
                {
                    if (fObjectHeightList[i] < fObjectWidthList[i])
                    {
                        fObjectWidth = fObjectHeightList[i];
                        fObjectHeight = fObjectWidthList[i];

                        fObjectAngle = fObjectAngleList[i];

                        if (fObjectAngle >= 10)//&& fAngle <= 80)
                            fObjectAngle = fObjectAngleList[i] - 90;
                        else
                            fObjectAngle = 90 + fObjectAngleList[i];

                        fObjectWidthList[i] = fObjectWidth;
                        fObjectHeightList[i] = fObjectHeight;
                        fObjectAngleList[i] = fObjectAngle;
                    }
                    else
                    {
                        fObjectHeight = fObjectHeightList[i];
                        fObjectWidth = fObjectWidthList[i];

                        fObjectAngle = fObjectAngleList[i];

                        fObjectWidthList[i] = fObjectWidth;
                        fObjectHeightList[i] = fObjectHeight;
                        fObjectAngleList[i] = fObjectAngle;
                    }

                    //    float fWidthMM = fObjectWidth / m_fMMToPixelXValue;
                    //float fHeightMM = fObjectHeight / m_fMMToPixelYValue;
                    //float fAreaMM = intObjectArea / m_fMMToPixelYValue / m_fMMToPixelXValue;
                    float fWidthMM = fObjectWidthList[i] / m_fMMToPixelXValue;
                    float fHeightMM = fObjectHeightList[i] / m_fMMToPixelYValue;
                    float fAreaMM = fObjectAreaList[i] / (m_fMMToPixelXValue * m_fMMToPixelYValue);
                    //if ((fWidthMM > m_fCrackLength) || (fHeightMM > m_fCrackLength) || (fAreaMM > m_fCrackArea) && ((m_intFailPkgOptionMask & 0x400) > 0 || (m_intFailPkgOptionMask & 0x800) > 0))
                    {
                        intFailCount++;
                        //0x04
                        m_intFailPkgResultMask |= 0x400;

                        Defect objDefect = new Defect();
                        objDefect.ref_fWidth = fObjectWidthList[i];
                        objDefect.ref_fHeight = fObjectHeightList[i];
                        objDefect.ref_fArea = fObjectAreaList[i];
                        objDefect.ref_fWidthInMM = fWidthMM;
                        objDefect.ref_fHeightInMM = fHeightMM;
                        objDefect.ref_fAreaInMM2 = fAreaMM;
                        objDefect.ref_strName = "Crack";
                        objDefect.ref_fCenterX = intROIStartX + fObjectCenterXList[i];
                        objDefect.ref_fCenterY = intROIStartY + fObjectCenterYList[i];
                        objDefect.ref_fAngle = fObjectAngleList[i];
                        objDefect.ref_intFailMask = 0x400;
                        objDefect.ref_intImageNo = intImageIndex;

                        if ((m_intFailPkgOptionMask & 0x400) > 0)
                        {
                            if (m_intCrackDarkDefectDimensionFailCondition == 0)
                            {
                                if (fWidthMM > m_fDarkHorizontalCrack)
                                {
                                    blnOverallResult = false;
                                    objDefect.ref_fWidthFailValue = fWidthMM;
                                    objDefect.ref_intFailCriteria |= 0x01;
                                }
                                if (fHeightMM > m_fDarkVerticalCrack)
                                {
                                    blnOverallResult = false;
                                    objDefect.ref_fHeightFailValue = fHeightMM;
                                    objDefect.ref_intFailCriteria |= 0x02;
                                }
                            }
                            else
                            {
                                if ((fWidthMM > m_fDarkHorizontalCrack) && (fHeightMM > m_fDarkVerticalCrack))
                                {
                                    blnOverallResult = false;
                                    objDefect.ref_fWidthFailValue = fWidthMM;
                                    objDefect.ref_intFailCriteria |= 0x01;
                                    objDefect.ref_fHeightFailValue = fHeightMM;
                                    objDefect.ref_intFailCriteria |= 0x02;
                                }
                            }
                        }

                        if ((m_intFailPkgOptionMask & 0x800) > 0)
                        {
                            if (fAreaMM > m_fCrackArea)
                            {
                                blnOverallResult = false;
                                objDefect.ref_fAreaFailValue = fAreaMM;
                                objDefect.ref_intFailCriteria |= 0x04;
                            }
                        }

                        m_arrPkgDefectList.Add(objDefect);
                    }

                }
            }

            objCrackROI.Dispose();
            ImgCrack.Dispose();
            return blnOverallResult;
        }
        public bool CheckCrackDefect(ROI objImage1UnitROI, int intROIStartX, int intROIStartY, int intImageIndex)
        {
            // 0x400 = Crack Length, 0x800 = Crack Area
            if ((m_intFailPkgOptionMask & 0x800) == 0 && (m_intFailPkgOptionMask & 0x400) == 0)
                return true;
            bool blnDebugImage = false;
            float fPkgOffsetX = (objImage1UnitROI.ref_ROIWidth - Math.Max(GetResultUpWidth_RectGauge4L(0), GetResultDownWidth_RectGauge4L(0))) / 2;
            float fPkgOffsetY = (objImage1UnitROI.ref_ROIHeight - Math.Max(GetResultLeftHeight_RectGauge4L(0), GetResultRightHeight_RectGauge4L(0))) / 2;

            float fROIToleranceLeft = 0, fROIToleranceTop = 0, fROIToleranceRight = 0, fROIToleranceBottom = 0;
            if (m_blnSeperateBrightDarkROITolerance)
            {
                fROIToleranceLeft = m_fPkgStartPixelFromLeft_Dark;
                fROIToleranceTop = m_fPkgStartPixelFromEdge_Dark;
                fROIToleranceRight = m_fPkgStartPixelFromRight_Dark;
                fROIToleranceBottom = m_fPkgStartPixelFromBottom_Dark;
            }
            else
            {
                fROIToleranceLeft = m_fPkgStartPixelFromLeft;
                fROIToleranceTop = m_fPkgStartPixelFromEdge;
                fROIToleranceRight = m_fPkgStartPixelFromRight;
                fROIToleranceBottom = m_fPkgStartPixelFromBottom;
            }

            int intStartPixelFromEdgeX = (int)Math.Round(fPkgOffsetX + fROIToleranceLeft, 0, MidpointRounding.AwayFromZero);
            int intStartPixelFromEdgeY = (int)Math.Round(fPkgOffsetY + fROIToleranceTop, 0, MidpointRounding.AwayFromZero);
            int intStartPixelFromEdgeX2 = (int)Math.Round(fPkgOffsetX + fROIToleranceRight, 0, MidpointRounding.AwayFromZero);
            int intStartPixelFromEdgeY2 = (int)Math.Round(fPkgOffsetY + fROIToleranceBottom, 0, MidpointRounding.AwayFromZero);

            ROI objCrackROI = new ROI();
            objCrackROI.AttachImage(objImage1UnitROI);
            objCrackROI.LoadROISetting(intStartPixelFromEdgeX, intStartPixelFromEdgeY,
                objImage1UnitROI.ref_ROIWidth - intStartPixelFromEdgeX - intStartPixelFromEdgeX2,
                objImage1UnitROI.ref_ROIHeight - intStartPixelFromEdgeY - intStartPixelFromEdgeY2);

            int intSelectedObjectNum = m_objEBlobs.BuildObjects_Filter_GetElement_DoubleThreshold(
               objCrackROI, true, false, false, false, m_intPkgImage2LowCrackThreshold, m_intPkgImage2HighCrackThreshold,
               (int)m_fCrackMinArea, 15000, false, 0xED);

            bool blnOverallResult = true;
            if (intSelectedObjectNum > 0)
            {
                int intObjectArea = 0;
                float fObjectHeight = 0, fObjectWidth = 0, fObjectCenterX = 0, fObjectCenterY = 0, fObjectAngle = 0;

                int intFailCount = 0;
                for (int i = 0; i < intSelectedObjectNum; i++)
                {
                    intObjectArea = m_objEBlobs.ref_arrArea[i];
                    fObjectHeight = m_objEBlobs.ref_arrRectHeight[i];
                    fObjectWidth = m_objEBlobs.ref_arrRectWidth[i];
                    fObjectCenterX = m_objEBlobs.ref_arrRectLimitCenterX[i];
                    fObjectCenterY = m_objEBlobs.ref_arrRectLimitCenterY[i];
                    fObjectAngle = m_objEBlobs.ref_arrRectAngle[i];

                    fObjectCenterX += intStartPixelFromEdgeX;
                    fObjectCenterY += intStartPixelFromEdgeY;
                    if (fObjectAngle < 0)
                        fObjectAngle = Math.Abs(fObjectAngle);
                    else
                        fObjectAngle = 0 - (fObjectAngle);

                    float Max = Math.Max(fObjectHeight, fObjectWidth);
                    float Min = Math.Min(fObjectHeight, fObjectWidth);

                    if (Max / Min <= 1.5)
                    {
                        if ((intObjectArea / (fObjectHeight * fObjectWidth)) >= 0.5)
                        {
                            continue;
                        }
                    }

                    float fWidthMM = fObjectWidth / m_fMMToPixelXValue;
                    float fHeightMM = fObjectHeight / m_fMMToPixelYValue;
                    float fAreaMM = intObjectArea / m_fMMToPixelYValue / m_fMMToPixelXValue;

                    //if ((fWidthMM > m_fCrackLength) || (fHeightMM > m_fCrackLength) || (fAreaMM > m_fCrackArea) && ((m_intFailPkgOptionMask & 0x400) > 0 || (m_intFailPkgOptionMask & 0x800) > 0))
                    {
                        intFailCount++;
                        //0x04
                        m_intFailPkgResultMask |= 0x400;

                        Defect objDefect = new Defect();
                        objDefect.ref_fWidth = fObjectWidth;
                        objDefect.ref_fHeight = fObjectHeight;
                        objDefect.ref_fArea = intObjectArea;
                        objDefect.ref_fWidthInMM = fWidthMM;
                        objDefect.ref_fHeightInMM = fHeightMM;
                        objDefect.ref_fAreaInMM2 = fAreaMM;
                        objDefect.ref_strName = "Crack";
                        objDefect.ref_fCenterX = intROIStartX + fObjectCenterX;
                        objDefect.ref_fCenterY = intROIStartY + fObjectCenterY;
                        objDefect.ref_fAngle = fObjectAngle;
                        objDefect.ref_intFailMask = 0x400;
                        objDefect.ref_intImageNo = 2;

                        if ((m_intFailPkgOptionMask & 0x400) > 0)
                        {
                            if (fWidthMM > m_fCrackLength)
                            {
                                blnOverallResult = false;
                                objDefect.ref_fWidthFailValue = fWidthMM;
                                objDefect.ref_intFailCriteria |= 0x01;
                            }
                            if (fHeightMM > m_fCrackLength)
                            {
                                blnOverallResult = false;
                                objDefect.ref_fHeightFailValue = fHeightMM;
                                objDefect.ref_intFailCriteria |= 0x02;
                            }
                        }

                        if ((m_intFailPkgOptionMask & 0x800) > 0)
                        {
                            if (fAreaMM > m_fCrackArea)
                            {
                                blnOverallResult = false;
                                objDefect.ref_fAreaFailValue = fAreaMM;
                                objDefect.ref_intFailCriteria |= 0x04;
                            }
                        }

                        m_arrPkgDefectList.Add(objDefect);
                    }

                }
            }

            objCrackROI.Dispose();

            return blnOverallResult;
        }
        public bool CheckCrackDefect_TiltAngle(ROI objImage1UnitROI, int intROIStartX, int intROIStartY, int intImageIndex, int intPadIndex)
        {
            // 0x400 = Crack Length, 0x800 = Crack Area
            if ((m_intFailPkgOptionMask & 0x800) == 0 && (m_intFailPkgOptionMask & 0x400) == 0)
                return true;
            bool blnDebugImage = false;
            float fPkgOffsetX = (objImage1UnitROI.ref_ROIWidth - Math.Max(GetResultUpWidth_RectGauge4L(0), GetResultDownWidth_RectGauge4L(0))) / 2;
            float fPkgOffsetY = (objImage1UnitROI.ref_ROIHeight - Math.Max(GetResultLeftHeight_RectGauge4L(0), GetResultRightHeight_RectGauge4L(0))) / 2;

            float fROIToleranceLeft = 0, fROIToleranceTop = 0, fROIToleranceRight = 0, fROIToleranceBottom = 0;
            if (m_blnSeperateBrightDarkROITolerance)
            {
                fROIToleranceLeft = m_fPkgStartPixelFromLeft_Dark;
                fROIToleranceTop = m_fPkgStartPixelFromEdge_Dark;
                fROIToleranceRight = m_fPkgStartPixelFromRight_Dark;
                fROIToleranceBottom = m_fPkgStartPixelFromBottom_Dark;
            }
            else
            {
                fROIToleranceLeft = m_fPkgStartPixelFromLeft;
                fROIToleranceTop = m_fPkgStartPixelFromEdge;
                fROIToleranceRight = m_fPkgStartPixelFromRight;
                fROIToleranceBottom = m_fPkgStartPixelFromBottom;
            }

            int intStartPixelFromEdgeX = (int)Math.Round(fPkgOffsetX + fROIToleranceLeft, 0, MidpointRounding.AwayFromZero);
            int intStartPixelFromEdgeY = (int)Math.Round(fPkgOffsetY + fROIToleranceTop, 0, MidpointRounding.AwayFromZero);
            int intStartPixelFromEdgeX2 = (int)Math.Round(fPkgOffsetX + fROIToleranceRight, 0, MidpointRounding.AwayFromZero);
            int intStartPixelFromEdgeY2 = (int)Math.Round(fPkgOffsetY + fROIToleranceBottom, 0, MidpointRounding.AwayFromZero);

            ImageDrawing ImgCrack = new ImageDrawing();
            ROI objCrackROI = new ROI();
            ImgCrack.SetImageSize(objImage1UnitROI.ref_ROIWidth, objImage1UnitROI.ref_ROIHeight);
            objImage1UnitROI.CopyToImage(ref ImgCrack);
            objCrackROI.AttachImage(ImgCrack);
            objCrackROI.LoadROISetting(intStartPixelFromEdgeX, intStartPixelFromEdgeY,
                objImage1UnitROI.ref_ROIWidth - intStartPixelFromEdgeX - intStartPixelFromEdgeX2,
                objImage1UnitROI.ref_ROIHeight - intStartPixelFromEdgeY - intStartPixelFromEdgeY2);
            //2019-09-23 ZJYEOH : Subtract tilt dont care area 
            if (intPadIndex == 1) // Top
            {
                ROI DontCareTop = new ROI();

                DontCareTop.LoadROISetting(0, 0, objCrackROI.ref_ROIWidth, objCrackROI.ref_ROIHeight);
                DontCareTop.AttachImage(m_ImgTilt_Top_L);
                EasyImage.Oper(EArithmeticLogicOperation.Add, objCrackROI.ref_ROI, DontCareTop.ref_ROI, objCrackROI.ref_ROI);
                DontCareTop.LoadROISetting(m_ImgTilt_Top_R.ref_intImageWidth - objCrackROI.ref_ROIWidth, 0, objCrackROI.ref_ROIWidth, objCrackROI.ref_ROIHeight);
                DontCareTop.AttachImage(m_ImgTilt_Top_R);
                EasyImage.Oper(EArithmeticLogicOperation.Add, objCrackROI.ref_ROI, DontCareTop.ref_ROI, objCrackROI.ref_ROI);
                if (blnDebugImage)
                    objCrackROI.SaveImage("D:\\CheckCrackDefect_objCrackROITop.bmp");
                DontCareTop.Dispose();
            }
            if (intPadIndex == 2) // Right
            {
                ROI DontCareRight = new ROI();
                DontCareRight.LoadROISetting(m_ImgTilt_Top_R.ref_intImageWidth - objCrackROI.ref_ROIWidth, 0, objCrackROI.ref_ROIWidth, objCrackROI.ref_ROIHeight);
                DontCareRight.AttachImage(m_ImgTilt_Right_T);
                EasyImage.Oper(EArithmeticLogicOperation.Add, objCrackROI.ref_ROI, DontCareRight.ref_ROI, objCrackROI.ref_ROI);
                DontCareRight.LoadROISetting(m_ImgTilt_Top_R.ref_intImageWidth - objCrackROI.ref_ROIWidth, m_ImgTilt_Top_R.ref_intImageHeight - objCrackROI.ref_ROIHeight, objCrackROI.ref_ROIWidth, objCrackROI.ref_ROIHeight);
                DontCareRight.AttachImage(m_ImgTilt_Right_B);
                EasyImage.Oper(EArithmeticLogicOperation.Add, objCrackROI.ref_ROI, DontCareRight.ref_ROI, objCrackROI.ref_ROI);
                if (blnDebugImage)
                    objCrackROI.SaveImage("D:\\CheckCrackDefect_objCrackROIRight.bmp");
                DontCareRight.Dispose();
            }
            if (intPadIndex == 3) // Bottom
            {
                ROI DontCareBottom = new ROI();

                DontCareBottom.LoadROISetting(0, m_ImgTilt_Top_R.ref_intImageHeight - objCrackROI.ref_ROIHeight, objCrackROI.ref_ROIWidth, objCrackROI.ref_ROIHeight);
                DontCareBottom.AttachImage(m_ImgTilt_Bottom_L);
                EasyImage.Oper(EArithmeticLogicOperation.Add, objCrackROI.ref_ROI, DontCareBottom.ref_ROI, objCrackROI.ref_ROI);
                DontCareBottom.LoadROISetting(m_ImgTilt_Top_R.ref_intImageWidth - objCrackROI.ref_ROIWidth, m_ImgTilt_Top_R.ref_intImageHeight - objCrackROI.ref_ROIHeight, objCrackROI.ref_ROIWidth, objCrackROI.ref_ROIHeight);
                DontCareBottom.AttachImage(m_ImgTilt_Bottom_R);
                EasyImage.Oper(EArithmeticLogicOperation.Add, objCrackROI.ref_ROI, DontCareBottom.ref_ROI, objCrackROI.ref_ROI);
                if (blnDebugImage)
                    objCrackROI.SaveImage("D:\\CheckCrackDefect_objCrackROIBottom.bmp");
                DontCareBottom.Dispose();
            }
            if (intPadIndex == 4) // Left
            {
                ROI DontCareLeft = new ROI();

                DontCareLeft.LoadROISetting(0, 0, objCrackROI.ref_ROIWidth, objCrackROI.ref_ROIHeight);
                DontCareLeft.AttachImage(m_ImgTilt_Left_T);
                EasyImage.Oper(EArithmeticLogicOperation.Add, objCrackROI.ref_ROI, DontCareLeft.ref_ROI, objCrackROI.ref_ROI);
                DontCareLeft.LoadROISetting(0, m_ImgTilt_Top_R.ref_intImageHeight - objCrackROI.ref_ROIHeight, objCrackROI.ref_ROIWidth, objCrackROI.ref_ROIHeight);
                DontCareLeft.AttachImage(m_ImgTilt_Left_B);
                EasyImage.Oper(EArithmeticLogicOperation.Add, objCrackROI.ref_ROI, DontCareLeft.ref_ROI, objCrackROI.ref_ROI);
                if (blnDebugImage)
                    objCrackROI.SaveImage("D:\\CheckCrackDefect_objCrackROILeft.bmp");
                DontCareLeft.Dispose();
            }
            int intSelectedObjectNum = m_objEBlobs.BuildObjects_Filter_GetElement_DoubleThreshold(
               objCrackROI, true, false, false, false, m_intPkgImage2LowCrackThreshold, m_intPkgImage2HighCrackThreshold,
               (int)m_fCrackMinArea, 15000, false, 0xED);


            bool blnOverallResult = true;
            if (intSelectedObjectNum > 0)
            {
                int intObjectArea = 0;
                float fObjectHeight = 0, fObjectWidth = 0, fObjectCenterX = 0, fObjectCenterY = 0, fObjectAngle = 0;

                int intFailCount = 0;
                for (int i = 0; i < intSelectedObjectNum; i++)
                {
                    intObjectArea = m_objEBlobs.ref_arrArea[i];
                    fObjectHeight = m_objEBlobs.ref_arrRectHeight[i];
                    fObjectWidth = m_objEBlobs.ref_arrRectWidth[i];
                    fObjectCenterX = m_objEBlobs.ref_arrRectLimitCenterX[i];
                    fObjectCenterY = m_objEBlobs.ref_arrRectLimitCenterY[i];
                    fObjectAngle = m_objEBlobs.ref_arrRectAngle[i];

                    fObjectCenterX += intStartPixelFromEdgeX;
                    fObjectCenterY += intStartPixelFromEdgeY;
                    if (fObjectAngle < 0)
                        fObjectAngle = Math.Abs(fObjectAngle);
                    else
                        fObjectAngle = 0 - (fObjectAngle);

                    float Max = Math.Max(fObjectHeight, fObjectWidth);
                    float Min = Math.Min(fObjectHeight, fObjectWidth);

                    if (Max / Min <= 1.5)
                    {
                        if ((intObjectArea / (fObjectHeight * fObjectWidth)) >= 0.5)
                        {
                            continue;
                        }
                    }

                    float fWidthMM = fObjectWidth / m_fMMToPixelXValue;
                    float fHeightMM = fObjectHeight / m_fMMToPixelYValue;
                    float fAreaMM = intObjectArea / m_fMMToPixelYValue / m_fMMToPixelXValue;

                    //if ((fWidthMM > m_fCrackLength) || (fHeightMM > m_fCrackLength) || (fAreaMM > m_fCrackArea) && ((m_intFailPkgOptionMask & 0x400) > 0 || (m_intFailPkgOptionMask & 0x800) > 0))
                    {
                        intFailCount++;
                        //0x04
                        m_intFailPkgResultMask |= 0x400;

                        Defect objDefect = new Defect();
                        objDefect.ref_fWidth = fObjectWidth;
                        objDefect.ref_fHeight = fObjectHeight;
                        objDefect.ref_fArea = intObjectArea;
                        objDefect.ref_fWidthInMM = fWidthMM;
                        objDefect.ref_fHeightInMM = fHeightMM;
                        objDefect.ref_fAreaInMM2 = fAreaMM;
                        objDefect.ref_strName = "Crack";
                        objDefect.ref_fCenterX = intROIStartX + fObjectCenterX;
                        objDefect.ref_fCenterY = intROIStartY + fObjectCenterY;
                        objDefect.ref_fAngle = fObjectAngle;
                        objDefect.ref_intFailMask = 0x400;
                        objDefect.ref_intImageNo = 2;

                        if ((m_intFailPkgOptionMask & 0x400) > 0)
                        {
                            if (fWidthMM > m_fCrackLength)
                            {
                                blnOverallResult = false;
                                objDefect.ref_fWidthFailValue = fWidthMM;
                                objDefect.ref_intFailCriteria |= 0x01;
                            }
                            if (fHeightMM > m_fCrackLength)
                            {
                                blnOverallResult = false;
                                objDefect.ref_fHeightFailValue = fHeightMM; 
                                objDefect.ref_intFailCriteria |= 0x02;
                            }
                        }

                        if ((m_intFailPkgOptionMask & 0x800) > 0)
                        {
                            if (fAreaMM > m_fCrackArea)
                            {
                                blnOverallResult = false;
                                objDefect.ref_fAreaFailValue = fAreaMM;
                                objDefect.ref_intFailCriteria |= 0x04;
                            }
                        }

                        m_arrPkgDefectList.Add(objDefect);
                    }

                }
            }

            objCrackROI.Dispose();
            ImgCrack.Dispose();
            return blnOverallResult;
        }

        public bool GetWantInspectPackage()
        {
            return m_blnInspectPackage;
        }
        public void SetWantInspectPackage(bool bWantDefect)
        {
            m_blnInspectPackage = bWantDefect;
        }

        private bool CheckImageChipDefect_SimpleMode(ROI objImageUnitToleranceROI, ROI objImageUnitROI, int intImageIndex)//, bool blnPadPkg)
        {
            /* This function is to do image processing for Chipped off and surface scratches test.
             * Skip this function if Chipped off and scratches test is disabled.
             * 
             * Image Processing:
             * 
             * 1. Double threshold sample image 
             *    using image 1 surface double threshold value 
             *    with class 255, 0 255.
             *    Mean defect area on surface will be while color. Good surface area will be black color.
             * 2. Single threshold template image 
             *    using Pad Threshold value 
             *    with class 0, 255
             * 3. Get ready a blank black image
             * 4. Scan each template pads, 
             *     based on different size between sample and template pad,
             *     Erode/dilate the template pads
             *     add the Erode/dilate template pads into the blank black image.
             *     Mean you will get a erode/dilate template with pad while color, surface area black color.
             * 5. Substract the Sample image - Erode/dilate template image.
             *     After substract, you will get defect surface area with white color, 
             *     good surface area will be black color, 
             *     pad area will be totally dark color. 
             * 6  Send final substract image for chipped off test and surface scratches test.
             *
             * 
             *
             */

            // Return if Contamination, Chipped off, Scratches Length and Area is OFF
            if ((m_intFailPkgOptionMask & 0x04) == 0)
                return true;

            int intInpectMode = 0; //0=Flexi template size, 1= use sample size, 2: Fix template size
            bool blnResult = true;
            bool blnDebugImage = false;

            if (blnDebugImage)
            {
                objImageUnitToleranceROI.SaveImage("D:\\TS\\1.objImageUnitToleranceROI.bmp");
                objImageUnitROI.SaveImage("D:\\TS\\2.objImageUnitROI.bmp");
            }

            // Get ready sample ROI
            ROI objSampleROI = new ROI();
            m_objInsSurfacePkgImage1.SetImageToBlack(); // 2021 07 27 - CCENG: make sure temporary use image is black so that no affecting inspection result.
            objSampleROI.AttachImage(m_objInsSurfacePkgImage1);  // m_objInsSurfacePkgImage1 is temporary image use to hold objSampleROI double threshold
            objSampleROI.LoadROISetting(objImageUnitToleranceROI.ref_ROITotalX, objImageUnitToleranceROI.ref_ROITotalY, objImageUnitToleranceROI.ref_ROIWidth, objImageUnitToleranceROI.ref_ROIHeight);
#if (Debug_2_12 || Release_2_12)
            // Gain and Double threshold
            switch (intImageIndex)
            {
                case 1: // Image 1 (Grab 1 & Grab 2 Merged)
                    {
                        if (m_fPkgImage1Gain != 1f)
                        {
                            EasyImage.GainOffset(objImageUnitToleranceROI.ref_ROI, objSampleROI.ref_ROI, m_fPkgImage1Gain);
                            EasyImage.DoubleThreshold(objSampleROI.ref_ROI, objSampleROI.ref_ROI, (uint)m_intPkgImage1LowSurfaceThreshold, (uint)m_intPkgImage1HighSurfaceThreshold, 0, 255, 0); // WinXP (255,0,255) , Win7 (0,255,0)
                        }
                        else
                        {
                            EasyImage.DoubleThreshold(objImageUnitToleranceROI.ref_ROI, objSampleROI.ref_ROI, (uint)m_intPkgImage1LowSurfaceThreshold, (uint)m_intPkgImage1HighSurfaceThreshold, 0, 255, 0);// WinXP (255,0,255) , Win7 (0,255,0)
                        }
                    }
                    break;
                case 2: // Image 2 (Grab 3)
                    {
                        EasyImage.DoubleThreshold(objImageUnitToleranceROI.ref_ROI, objSampleROI.ref_ROI, (uint)m_intPkgImage2LowThreshold, (uint)m_intPkgImage2HighThreshold, 0, 255, 0);// WinXP (255,0,255) , Win7 (0,255,0)
                    }
                    break;
            }

#elif (DEBUG || RELEASE || RTXRelease || RTXDebug)
            // Gain and Double threshold
            switch (intImageIndex)
            {
                case 1: // Image 1 (Grab 1 & Grab 2 Merged)
                    {
                        if (m_fPkgImage1Gain != 1f)
                        {
                            EasyImage.GainOffset(objImageUnitToleranceROI.ref_ROI, objSampleROI.ref_ROI, m_fPkgImage1Gain);
                            EasyImage.DoubleThreshold(objSampleROI.ref_ROI, objSampleROI.ref_ROI, m_intPkgImage1LowSurfaceThreshold, m_intPkgImage1HighSurfaceThreshold, 0, 255, 0); // WinXP (255,0,255) , Win7 (0,255,0)
                        }
                        else
                        {
                            EasyImage.DoubleThreshold(objImageUnitToleranceROI.ref_ROI, objSampleROI.ref_ROI, m_intPkgImage1LowSurfaceThreshold, m_intPkgImage1HighSurfaceThreshold, 0, 255, 0);// WinXP (255,0,255) , Win7 (0,255,0)
                        }
                    }
                    break;
                case 2: // Image 2 (Grab 3)
                    {
                        EasyImage.DoubleThreshold(objImageUnitToleranceROI.ref_ROI, objSampleROI.ref_ROI, m_intPkgImage2LowThreshold, m_intPkgImage2HighThreshold, 0, 255, 0);// WinXP (255,0,255) , Win7 (0,255,0)
                    }
                    break;
            }

#endif

            if (blnDebugImage)
            {
                objImageUnitToleranceROI.SaveImage("D:\\TS\\objImageUnitToleranceROI.bmp");
                m_objInsSurfacePkgImage1.SaveImage("D:\\TS\\3.m_objInsSurfacePkgImage1.bmp");
                objSampleROI.SaveImage("D:\\TS\\4.objSampleROI.bmp");
            }

            // Get ready template ROI
            ROI objTemplateROI = new ROI();
            if (intInpectMode == 0)
            {
                // Get threshold value
                int intThresholdValue;
                if (m_intThresholdValue < 0)
                {
                    EBW8 objBW8;
                    if (intImageIndex == 1)
                        objBW8 = EasyImage.AutoThreshold(m_ImgUnitTemplateImage, EThresholdMode.MinResidue);
                    else
                        objBW8 = EasyImage.AutoThreshold(m_ImgUnitTemplateImagePkg, EThresholdMode.MinResidue);
                    intThresholdValue = objBW8.Value;
                }
                else
                    intThresholdValue = m_intThresholdValue;

                if (blnDebugImage)
                {
                    m_ImgUnitTemplateImage.Save("D:\\TS\\5.m_ImgUnitTemplateImage.bmp");// debug
                    m_ImgTUnitErodeThresImage.Save("D:\\TS\\6.m_ImgTUnitErodeThresImage.bmp");// debug
                    m_ImgUnitTemplateImagePkg.Save("D:\\TS\\7.m_ImgUnitTemplateImagePkg.bmp");// debug
                    m_ImgTUnitErodeThresImagePkg.Save("D:\\TS\\8.m_ImgTUnitErodeThresImagePkg.bmp");// debug
                }
#if (Debug_2_12 || Release_2_12)
                if (intImageIndex == 1)
                {
                    EasyImage.Copy(m_ImgUnitTemplateImage, m_ImgTUnitErodeThresImage);
                    // single threshold template image
                    if (m_fPadImageGain != 1f)
                    {
                        EasyImage.GainOffset(m_ImgTUnitErodeThresImage, m_ImgTUnitErodeThresImage, m_fPadImageGain);
                        EasyImage.Threshold(m_ImgTUnitErodeThresImage, m_ImgTUnitErodeThresImage, (uint)intThresholdValue);
                    }
                    else
                    {
                        EasyImage.Threshold(m_ImgTUnitErodeThresImage, m_ImgTUnitErodeThresImage, (uint)intThresholdValue);
                    }

                    objTemplateROI.ref_ROI.Detach();
                    objTemplateROI.ref_ROI.Attach(m_ImgTUnitErodeThresImage);
                    objTemplateROI.LoadROISetting(m_ImgTUnitErodeThresImage.Width / 2 - objImageUnitToleranceROI.ref_ROIWidth / 2,
                                                  m_ImgTUnitErodeThresImage.Height / 2 - objImageUnitToleranceROI.ref_ROIHeight / 2,
                                                  objImageUnitToleranceROI.ref_ROIWidth,
                                                  objImageUnitToleranceROI.ref_ROIHeight);
                }
                else
                {

                    //EasyImage.Copy(m_ImgUnitTemplateImagePkg, m_ImgTUnitErodeThresImagePkg);

                    //// single threshold template image
                    //EasyImage.Threshold(m_ImgTUnitErodeThresImagePkg, m_ImgTUnitErodeThresImagePkg, intThresholdValue);

                    //objTemplateROI.ref_ROI.Detach();
                    //objTemplateROI.ref_ROI.Attach(m_ImgTUnitErodeThresImagePkg);
                    //objTemplateROI.LoadROISetting(0, 0, objImageUnitROI.ref_ROIWidth, objImageUnitROI.ref_ROIHeight);

                    // 2019-10-09 ZJYEOH : Previous version Image Offset to 0,0
                    EasyImage.Copy(m_ImgUnitTemplateImage, m_ImgTUnitErodeThresImage);
                    // single threshold template image
                    if (m_fPadImageGain != 1f)
                    {
                        EasyImage.GainOffset(m_ImgTUnitErodeThresImage, m_ImgTUnitErodeThresImage, m_fPadImageGain);
                        EasyImage.Threshold(m_ImgTUnitErodeThresImage, m_ImgTUnitErodeThresImage, (uint)intThresholdValue);
                    }
                    else
                    {
                        EasyImage.Threshold(m_ImgTUnitErodeThresImage, m_ImgTUnitErodeThresImage, (uint)intThresholdValue);
                    }

                    objTemplateROI.ref_ROI.Detach();
                    objTemplateROI.ref_ROI.Attach(m_ImgTUnitErodeThresImage);
                    objTemplateROI.LoadROISetting(m_ImgTUnitErodeThresImage.Width / 2 - objImageUnitToleranceROI.ref_ROIWidth / 2,
                                                  m_ImgTUnitErodeThresImage.Height / 2 - objImageUnitToleranceROI.ref_ROIHeight / 2,
                                                  objImageUnitToleranceROI.ref_ROIWidth,
                                                  objImageUnitToleranceROI.ref_ROIHeight);
                }

#elif (DEBUG || RELEASE || RTXRelease || RTXDebug)
                if (intImageIndex == 1)
                {
                    EasyImage.Copy(m_ImgUnitTemplateImage, m_ImgTUnitErodeThresImage);
                    // single threshold template image
                    if (m_fPadImageGain != 1f)
                    {
                        EasyImage.GainOffset(m_ImgTUnitErodeThresImage, m_ImgTUnitErodeThresImage, m_fPadImageGain);
                        EasyImage.Threshold(m_ImgTUnitErodeThresImage, m_ImgTUnitErodeThresImage, intThresholdValue);
                    }
                    else
                    {
                        EasyImage.Threshold(m_ImgTUnitErodeThresImage, m_ImgTUnitErodeThresImage, intThresholdValue);
                    }

                    objTemplateROI.ref_ROI.Detach();
                    objTemplateROI.ref_ROI.Attach(m_ImgTUnitErodeThresImage);
                    objTemplateROI.LoadROISetting(m_ImgTUnitErodeThresImage.Width / 2 - objImageUnitToleranceROI.ref_ROIWidth / 2,
                                                  m_ImgTUnitErodeThresImage.Height / 2 - objImageUnitToleranceROI.ref_ROIHeight / 2,
                                                  objImageUnitToleranceROI.ref_ROIWidth,
                                                  objImageUnitToleranceROI.ref_ROIHeight);
                }
                else
                {

                    //EasyImage.Copy(m_ImgUnitTemplateImagePkg, m_ImgTUnitErodeThresImagePkg);

                    //// single threshold template image
                    //EasyImage.Threshold(m_ImgTUnitErodeThresImagePkg, m_ImgTUnitErodeThresImagePkg, intThresholdValue);

                    //objTemplateROI.ref_ROI.Detach();
                    //objTemplateROI.ref_ROI.Attach(m_ImgTUnitErodeThresImagePkg);
                    //objTemplateROI.LoadROISetting(0, 0, objImageUnitROI.ref_ROIWidth, objImageUnitROI.ref_ROIHeight);

                    // 2019-10-09 ZJYEOH : Previous version Image Offset to 0,0
                    EasyImage.Copy(m_ImgUnitTemplateImage, m_ImgTUnitErodeThresImage);
                    // single threshold template image
                    if (m_fPadImageGain != 1f)
                    {
                        EasyImage.GainOffset(m_ImgTUnitErodeThresImage, m_ImgTUnitErodeThresImage, m_fPadImageGain);
                        EasyImage.Threshold(m_ImgTUnitErodeThresImage, m_ImgTUnitErodeThresImage, intThresholdValue);
                    }
                    else
                    {
                        EasyImage.Threshold(m_ImgTUnitErodeThresImage, m_ImgTUnitErodeThresImage, intThresholdValue);
                    }

                    objTemplateROI.ref_ROI.Detach();
                    objTemplateROI.ref_ROI.Attach(m_ImgTUnitErodeThresImage);
                    objTemplateROI.LoadROISetting(m_ImgTUnitErodeThresImage.Width / 2 - objImageUnitToleranceROI.ref_ROIWidth / 2,
                                                  m_ImgTUnitErodeThresImage.Height / 2 - objImageUnitToleranceROI.ref_ROIHeight / 2,
                                                  objImageUnitToleranceROI.ref_ROIWidth,
                                                  objImageUnitToleranceROI.ref_ROIHeight);
                }

#endif

                if (blnDebugImage)
                {
                    objImageUnitROI.SaveImage("D:\\TS\\9.B_OriSampleROI.bmp");// debug
                    m_ImgUnitTemplateImage.Save("D:\\TS\\10.B_OriTemplateImage.bmp");// debug
                    m_ImgTUnitErodeThresImage.Save("D:\\TS\\11.B_m_ImgTUnitErodeThresImage.bmp");// debug
                    objTemplateROI.SaveImage("D:\\TS\\12.B_objTemplateROI.bmp");// debug
                    objSampleROI.SaveImage("D:\\TS\\13.B_objSampleROI.bmp");// debug
                }
            }

            int intBWImageWidth = 0, intBWImageHeight = 0;

            // 2019-10-09 ZJYEOH : For Image 2 Inspection, Use Blank Black Image, will use Addition operation to get image with black defect only
            //if (intImageIndex == 1)
            {
                // Get ready blank black image
                m_ImgBlackUnitTemplateImage.CopyTo(m_ImgBlackUnitTemplateImage2);
                intBWImageWidth = m_ImgBlackUnitTemplateImage2.Width;
                intBWImageHeight = m_ImgBlackUnitTemplateImage2.Height;
            }
            //else
            //{
            // Get ready blank white image
            //m_ImgWhiteUnitTemplateImage.CopyTo(m_ImgWhiteUnitTemplateImage2);
            //    intBWImageWidth = m_ImgWhiteUnitTemplateImage2.Width;
            //    intBWImageHeight = m_ImgWhiteUnitTemplateImage2.Height;
            //}

            ROI objTemplateROI2 = new ROI();
            objTemplateROI2.ref_ROI.Detach();
            //if (intImageIndex == 1)
            {
                objTemplateROI2.ref_ROI.Attach(m_ImgBlackUnitTemplateImage2);
            }
            //else
            //{
            //    objTemplateROI2.ref_ROI.Attach(m_ImgWhiteUnitTemplateImage2);
            //}

            objTemplateROI2.LoadROISetting(0, 0, objImageUnitToleranceROI.ref_ROIWidth, objImageUnitToleranceROI.ref_ROIHeight);


            if (blnDebugImage)
                objTemplateROI2.SaveImage("D:\\TS\\14.BlankTemplateROI2.bmp");// debug

            int intStartX, intStartY, intEndX, intEndY, intAdjustX, intAdjustY, intStartX2, intStartY2, intWidth, intHeight;

            if (intInpectMode == 0)
            {
                #region Inspect Mode == 0
                int intToleSize = m_intMPDilateHalfWidth;

                int[] arrTemplateStartX = new int[m_arrTemplateBlobPads.Count];
                int[] arrTemplateStartY = new int[m_arrTemplateBlobPads.Count];
                int[] arrTemplateEndX = new int[m_arrTemplateBlobPads.Count];
                int[] arrTemplateEndY = new int[m_arrTemplateBlobPads.Count];
                int[] arrSampleStartX = new int[m_arrTemplateBlobPads.Count];
                int[] arrSampleStartY = new int[m_arrTemplateBlobPads.Count];
                int[] arrSampleEndX = new int[m_arrTemplateBlobPads.Count];
                int[] arrSampleEndY = new int[m_arrTemplateBlobPads.Count];
                int[] arrTemplateSampleWidth = new int[m_arrTemplateBlobPads.Count];
                int[] arrTemplateSampleHeight = new int[m_arrTemplateBlobPads.Count];
                int[] arrDifferentSizeX = new int[m_arrTemplateBlobPads.Count]; // Template and sample different size
                int[] arrDifferentSizeY = new int[m_arrTemplateBlobPads.Count]; // Template and sample different size
                int[] arrOffsetStartX = new int[m_arrTemplateBlobPads.Count];
                int[] arrOffsetStartY = new int[m_arrTemplateBlobPads.Count];

                DefinePadSubtractOffset(objTemplateROI, intToleSize, m_ImgBlackUnitTemplateImage2.Width - 1, m_ImgBlackUnitTemplateImage2.Height - 1,
                    ref arrTemplateStartX, ref arrTemplateStartY, ref arrTemplateEndX, ref arrTemplateEndY,
                    ref arrSampleStartX, ref arrSampleStartY, ref arrSampleEndX, ref arrSampleEndY,
                    ref arrTemplateSampleWidth, ref arrTemplateSampleHeight, 
                    ref arrDifferentSizeX, ref arrDifferentSizeY,
                    ref arrOffsetStartX, ref arrOffsetStartY, false);

                //2021-03-12 ZJYEOH : Need Offset back when pad no use gauge but package got use gauge
                if (!GetOverallWantGaugeMeasurePkgSize(false))
                {
                    for (int i = 0; i < arrOffsetStartX.Length; i++)
                    {
                        arrOffsetStartX[i] += (int)Math.Round(GetResultCenterPoint_UnitMatcher().X - GetResultCenterPoint_RectGauge4L().X);
                        arrOffsetStartY[i] += (int)Math.Round(GetResultCenterPoint_UnitMatcher().Y - GetResultCenterPoint_RectGauge4L().Y);
                    }
                }

                for (int i = 0; i < m_arrTemplateBlobPads.Count; i++)
                {
                    if (m_arrSampleBlobPads[i].intFailMask != 0)
                        continue;


                    // Get template pad roi
                    ROI objTemplatePadROI = new ROI();
                    objTemplatePadROI.AttachImage(objTemplateROI);
                    objTemplatePadROI.LoadROISetting(arrTemplateStartX[i], arrTemplateStartY[i], arrTemplateSampleWidth[i], arrTemplateSampleHeight[i]);

                    if (blnDebugImage)
                    {
                        objTemplatePadROI.SaveImage("D:\\TS\\objTemplatePadROI.bmp");// debug
                    }

                    m_ImgMPUnitTemplateImage.SetSize(objTemplatePadROI.ref_ROIWidth, objTemplatePadROI.ref_ROIHeight);
                    EasyImage.Copy(objTemplatePadROI.ref_ROI, m_ImgMPUnitTemplateImage);

                    if (arrDifferentSizeX[i]  < -intToleSize)
                        arrDifferentSizeX[i] = -intToleSize;
                    else if (arrDifferentSizeX[i] > intToleSize)
                        arrDifferentSizeX[i] = intToleSize;

                    if (arrDifferentSizeY[i] < -intToleSize)
                        arrDifferentSizeY[i] = -intToleSize;
                    else if (arrDifferentSizeY[i] > intToleSize)
                        arrDifferentSizeY[i] = intToleSize;
#if (Debug_2_12 || Release_2_12)
                    if ((arrDifferentSizeX[i] < 0) || (arrDifferentSizeY[i] < 0))
                    {
                        int intDiffSizeWidth2 = arrDifferentSizeX[i] + m_intMPErodeHalfWidth;
                        int intDiffSizeHeight2 = arrDifferentSizeY[i] + m_intMPErodeHalfWidth;
                        if ((intDiffSizeWidth2 > 0 && intDiffSizeHeight2 < 0) || (intDiffSizeHeight2 > 0 && intDiffSizeWidth2 < 0))
                        {
                            if (Math.Abs(intDiffSizeWidth2) > Math.Abs(intDiffSizeHeight2))
                                intDiffSizeHeight2 = 0;
                            else
                                intDiffSizeWidth2 = 0;
                        }

                        if ((intDiffSizeWidth2 < 0) || (intDiffSizeHeight2 < 0))
                        {
                            EasyImage.ErodeBox(m_ImgMPUnitTemplateImage, objTemplatePadROI.ref_ROI, (uint)Math.Abs(intDiffSizeWidth2), (uint)Math.Abs(intDiffSizeHeight2));
                        }
                        else
                        {

                            intDiffSizeWidth2 = arrDifferentSizeY[i] + m_intMPDilateHalfWidth;
                            intDiffSizeHeight2 = intDiffSizeHeight2 + m_intMPDilateHalfWidth;
                            if ((intDiffSizeWidth2 > 0 && intDiffSizeHeight2 < 0) || (intDiffSizeHeight2 > 0 && intDiffSizeWidth2 < 0))
                            {
                                if (Math.Abs(intDiffSizeWidth2) > Math.Abs(intDiffSizeHeight2))
                                    intDiffSizeHeight2 = 0;
                                else
                                    intDiffSizeWidth2 = 0;
                            }

                            if ((intDiffSizeWidth2 < 0) || (intDiffSizeHeight2 < 0))
                            {
                            }
                            else
                            {
                                EasyImage.DilateBox(m_ImgMPUnitTemplateImage, objTemplatePadROI.ref_ROI, (uint)Math.Abs(intDiffSizeWidth2), (uint)Math.Abs(intDiffSizeHeight2));
                            }
                        }
                    }
                    else
                    {
                        if ((Math.Abs(arrDifferentSizeX[i]) + m_intMPDilateHalfWidth) > 0 || (Math.Abs(arrDifferentSizeY[i]) + m_intMPDilateHalfWidth) > 0)
                            EasyImage.DilateBox(m_ImgMPUnitTemplateImage, objTemplatePadROI.ref_ROI, (uint)(Math.Abs(arrDifferentSizeX[i]) + m_intMPDilateHalfWidth), (uint)(Math.Abs(arrDifferentSizeY[i]) + m_intMPDilateHalfWidth));
                    }

#elif (DEBUG || RELEASE || RTXRelease || RTXDebug)
                      if ((arrDifferentSizeX[i] < 0) || (arrDifferentSizeY[i] < 0))
                    {
                        int intDiffSizeWidth2 = arrDifferentSizeX[i] + m_intMPErodeHalfWidth;
                        int intDiffSizeHeight2 = arrDifferentSizeY[i] + m_intMPErodeHalfWidth;
                        if ((intDiffSizeWidth2 > 0 && intDiffSizeHeight2 < 0) || (intDiffSizeHeight2 > 0 && intDiffSizeWidth2 < 0))
                        {
                            if (Math.Abs(intDiffSizeWidth2) > Math.Abs(intDiffSizeHeight2))
                                intDiffSizeHeight2 = 0;
                            else
                                intDiffSizeWidth2 = 0;
                        }

                        if ((intDiffSizeWidth2 < 0) || (intDiffSizeHeight2 < 0))
                        {
                            EasyImage.ErodeBox(m_ImgMPUnitTemplateImage, objTemplatePadROI.ref_ROI, Math.Abs(intDiffSizeWidth2), Math.Abs(intDiffSizeHeight2));
                        }
                        else
                        {

                            intDiffSizeWidth2 = arrDifferentSizeY[i] + m_intMPDilateHalfWidth;
                            intDiffSizeHeight2 = intDiffSizeHeight2 + m_intMPDilateHalfWidth;
                            if ((intDiffSizeWidth2 > 0 && intDiffSizeHeight2 < 0) || (intDiffSizeHeight2 > 0 && intDiffSizeWidth2 < 0))
                            {
                                if (Math.Abs(intDiffSizeWidth2) > Math.Abs(intDiffSizeHeight2))
                                    intDiffSizeHeight2 = 0;
                                else
                                    intDiffSizeWidth2 = 0;
                            }

                            if ((intDiffSizeWidth2 < 0) || (intDiffSizeHeight2 < 0))
                            {
                            }
                            else
                            {
                                EasyImage.DilateBox(m_ImgMPUnitTemplateImage, objTemplatePadROI.ref_ROI, Math.Abs(intDiffSizeWidth2), Math.Abs(intDiffSizeHeight2));
                            }
                        }
                    }
                    else
                    {
                        if ((Math.Abs(arrDifferentSizeX[i]) + m_intMPDilateHalfWidth) > 0 || (Math.Abs(arrDifferentSizeY[i]) + m_intMPDilateHalfWidth) > 0)
                            EasyImage.DilateBox(m_ImgMPUnitTemplateImage, objTemplatePadROI.ref_ROI, Math.Abs(arrDifferentSizeX[i]) + m_intMPDilateHalfWidth, Math.Abs(arrDifferentSizeY[i]) + m_intMPDilateHalfWidth);
                    }

#endif

                    // Get template2 pad ROI
                    ROI objTemplate2PadROI = new ROI();

                    objTemplate2PadROI.ref_ROI.Detach();
                    objTemplate2PadROI.ref_ROI.Attach(m_ImgBlackUnitTemplateImage2);
                    objTemplate2PadROI.LoadROISetting(arrSampleStartX[i] + arrOffsetStartX[i], arrSampleStartY[i] + arrOffsetStartY[i], arrTemplateSampleWidth[i], arrTemplateSampleHeight[i]);

                    if (blnDebugImage)
                    {
                        m_ImgMPUnitTemplateImage.Save("D:\\TS\\B_BfMPTemplateImage.bmp");// debug
                        objTemplatePadROI.SaveImage("D:\\TS\\B_AfMPTemplateImage.bmp");// debug
                        objTemplate2PadROI.SaveImage("D:\\TS\\B_BfSBTemplate2PadImage.bmp");// debug
                    }


                    // Add sample pad roi - template pad roi
                    EasyImage.Oper(EArithmeticLogicOperation.Add, objTemplate2PadROI.ref_ROI, objTemplatePadROI.ref_ROI, objTemplate2PadROI.ref_ROI);

                    if (blnDebugImage)
                    {
                        objTemplate2PadROI.SaveImage("D:\\TS\\B_AfSBTemplate2PadImage.bmp");// debug
                        objTemplateROI2.SaveImage("D:\\TS\\B_objTemplate2ROI.bmp");// debug
                    }

                    objTemplatePadROI.Dispose();
                    objTemplate2PadROI.Dispose();
                }

                #endregion
            }
            else if (intInpectMode == 1)
            {
                #region Inspect Mode == 1
                for (int i = 0; i < m_arrSampleBlobPads.Length; i++)
                {
                    if (m_arrSampleBlobPads[i].intFailMask != 0)
                        continue;

                    intStartX = (int)Math.Floor(m_arrSampleBlobPads[i].fStartX);
                    intStartY = (int)Math.Floor(m_arrSampleBlobPads[i].fStartY);

                    intStartX2 = (int)Math.Floor(m_arrSampleBlobPads[i].fCenterX - m_arrSampleBlobPads[i].fWidth / 2);
                    intStartY2 = (int)Math.Floor(m_arrSampleBlobPads[i].fCenterY - m_arrSampleBlobPads[i].fHeight / 2);

                    intWidth = (int)Math.Ceiling(m_arrSampleBlobPads[i].fWidth) + 1;
                    intHeight = (int)Math.Ceiling(m_arrSampleBlobPads[i].fHeight) + 1;

                    // Get template pad roi
                    ROI objTemplatePadROI = new ROI();
                    objTemplatePadROI.AttachImage(objTemplateROI);
                    objTemplatePadROI.LoadROISetting(intStartX, intStartY, intWidth, intHeight);

                    // Get Sample pad ROI
                    ROI objTemplate2PadROI = new ROI();
                    objTemplate2PadROI.ref_ROI.Detach();
                    objTemplate2PadROI.ref_ROI.Attach(m_ImgBlackUnitTemplateImage2);
                    objTemplate2PadROI.LoadROISetting(intStartX2, intStartY2, intWidth, intHeight);

                    // subtract sample pad roi - template pad roi
                    EasyImage.Oper(EArithmeticLogicOperation.Add, objTemplate2PadROI.ref_ROI, objTemplatePadROI.ref_ROI, objTemplate2PadROI.ref_ROI);

                    objTemplatePadROI.Dispose();
                    objTemplate2PadROI.Dispose();
                }
                #endregion
            }
            else
            {
                #region Inspect mode == 2
                for (int i = 0; i < m_arrTemplateBlobPads.Count; i++)
                {
                    if (m_arrSampleBlobPads[i].intFailMask != 0)
                        continue;

                    intAdjustX = 0;
                    intAdjustY = 0;
                    intStartX = ((BlobsFeatures)m_arrTemplateBlobPads[i]).intStartX - 3;
                    if (intStartX < 0)
                    {
                        intAdjustX = intStartX;
                        intStartX = 0;
                    }
                    intStartY = ((BlobsFeatures)m_arrTemplateBlobPads[i]).intStartY - 3;
                    if (intStartY < 0)
                    {
                        intAdjustY = intStartY;
                        intStartY = 0;
                    }

                    intStartX2 = (int)Math.Round(m_arrSampleBlobPads[i].fCenterX - ((BlobsFeatures)m_arrTemplateBlobPads[i]).fWidth / 2, 0, MidpointRounding.AwayFromZero);
                    intStartX2 -= 3;
                    if (intStartX2 < 0)
                    {
                        if (intStartX2 > intAdjustX)
                            intAdjustX = intStartX2;
                        intStartX2 = 0;
                    }
                    intStartY2 = (int)Math.Round(m_arrSampleBlobPads[i].fCenterY - ((BlobsFeatures)m_arrTemplateBlobPads[i]).fHeight / 2, 0, MidpointRounding.AwayFromZero);
                    intStartY2 -= 3;
                    if (intStartY2 < 0)
                    {
                        if (intStartY2 > intAdjustY)
                            intAdjustY = intStartY2;
                        intStartY2 = 0;
                    }

                    intWidth = (int)Math.Round(((BlobsFeatures)m_arrTemplateBlobPads[i]).fWidth, 0, MidpointRounding.AwayFromZero) + 6;
                    intEndX = intStartX + intWidth + intAdjustX;
                    int intEndAdjustX = 0;
                    if (intEndX > objTemplateROI.ref_ROIWidth - 1)
                    {
                        intEndAdjustX = (intEndX - (objTemplateROI.ref_ROIWidth - 1));
                    }
                    intHeight = (int)Math.Round(((BlobsFeatures)m_arrTemplateBlobPads[i]).fHeight, 0, MidpointRounding.AwayFromZero) + 6;
                    intEndY = intStartY + intHeight + intAdjustY;
                    int intEndAdjustY = 0;
                    if (intEndY > objTemplateROI.ref_ROIHeight - 1)
                    {
                        intEndAdjustY = (intEndY - (objTemplateROI.ref_ROIHeight - 1));
                    }

                    intEndX = intStartX2 + intWidth + 6 + intAdjustX;
                    if (intEndX > m_ImgBlackUnitTemplateImage2.Width - 1)
                    {
                        if (intEndAdjustX < (intEndX - (m_ImgBlackUnitTemplateImage2.Width - 1)))
                            intEndAdjustX = (intEndX - (m_ImgBlackUnitTemplateImage2.Width - 1));
                    }
                    intEndY = intStartY2 + intHeight + 6 + intAdjustY;
                    if (intEndY > m_ImgBlackUnitTemplateImage2.Height - 1)
                    {
                        if (intEndAdjustY < (intEndY - (m_ImgBlackUnitTemplateImage2.Height - 1)))
                            intEndAdjustY = (intEndY - (m_ImgBlackUnitTemplateImage2.Height - 1));
                    }

                    intWidth -= intEndAdjustX;
                    intHeight -= intEndAdjustY;

                    // Get template pad roi
                    ROI objTemplatePadROI = new ROI();
                    objTemplatePadROI.AttachImage(objTemplateROI);
                    objTemplatePadROI.LoadROISetting(intStartX, intStartY, intWidth, intHeight);

                    // Get Sample pad ROI
                    ROI objTemplate2PadROI = new ROI();
                    objTemplate2PadROI.ref_ROI.Detach();
                    objTemplate2PadROI.ref_ROI.Attach(m_ImgBlackUnitTemplateImage2);
                    objTemplate2PadROI.LoadROISetting(intStartX2, intStartY2, intWidth, intHeight);

                    // subtract sample pad roi - template pad roi
                    EasyImage.Oper(EArithmeticLogicOperation.Add, objTemplate2PadROI.ref_ROI, objTemplatePadROI.ref_ROI, objTemplate2PadROI.ref_ROI);

                    objTemplatePadROI.Dispose();
                    objTemplate2PadROI.Dispose();
                }

                #endregion
            }

            if (blnDebugImage)
            {
                objSampleROI.SaveImage("D:\\TS\\20.B_BfSBSampleROI.bmp");// debug
                objTemplateROI2.SaveImage("D:\\TS\\21.B_objTemplate2ROI.bmp");// debug
            }

            // Subtract sample ROI - template ROI
            if (objSampleROI.ref_ROIWidth > objTemplateROI2.ref_ROIWidth)
                objSampleROI.ref_ROIWidth = objTemplateROI2.ref_ROIWidth;
            else
                objTemplateROI2.ref_ROIWidth = objSampleROI.ref_ROIWidth;

            if (objSampleROI.ref_ROIHeight > objTemplateROI2.ref_ROIHeight)
                objSampleROI.ref_ROIHeight = objTemplateROI2.ref_ROIHeight;
            else
                objTemplateROI2.ref_ROIHeight = objSampleROI.ref_ROIHeight;

            if (blnDebugImage)
            {
                objSampleROI.SaveImage("D:\\TS\\22.B_BfSBSampleROI.bmp");// debug
                objTemplateROI2.SaveImage("D:\\TS\\23.B_objTemplate2ROI.bmp");// debug
                objTemplateROI.SaveImage("D:\\TS\\24.objTemplateROI.bmp");
            }


            if (intImageIndex == 1)
                EasyImage.Oper(EArithmeticLogicOperation.Subtract, objSampleROI.ref_ROI, objTemplateROI2.ref_ROI, objSampleROI.ref_ROI);    // 2019 05 14 - CCENG: Use templateROI2 because the pad location is according to sample ROI.
                                                                                                                                            //EasyImage.Oper(EArithmeticLogicOperation.Subtract, objSampleROI.ref_ROI, objTemplateROI.ref_ROI, objSampleROI.ref_ROI);
            else
                EasyImage.Oper(EArithmeticLogicOperation.Add, objSampleROI.ref_ROI, objTemplateROI2.ref_ROI, objSampleROI.ref_ROI);  // 2019-10-09 ZJYEOH : use Addition operation to get image with black defect only

            //objSampleROI.SaveImage("D:\\objSampleROI.bmp");
            //objTemplateROI.SaveImage("D:\\objTemplateROI.bmp");
            if (blnDebugImage)
                objSampleROI.SaveImage("D:\\TS\\B_AfSBSampleROI.bmp");// debug


            // Check Unit Chipped off
            if ((m_intFailPkgOptionMask & 0x04) > 0)
            {
                objSampleROI.LoadROISetting(objImageUnitROI.ref_ROITotalX,
                                            objImageUnitROI.ref_ROITotalY,
                                            objImageUnitROI.ref_ROIWidth, objImageUnitROI.ref_ROIHeight);

                if (blnDebugImage)
                    objSampleROI.SaveImage("D:\\TS\\B_FinalSampleROI.bmp");// debug

                if (m_objRectGauge4L.GetGaugeTiltAngle() == 0)
                {
                    if (!IsImage1UnitChippedOff2_Area_SimpleMode(objSampleROI, objSampleROI.ref_ROITotalX, objSampleROI.ref_ROITotalY, intImageIndex)) // IsImage1UnitChippedOff2
                    {
                        //objImageUnitROI.SaveImage("D:\\objImageUnitROI_"+intImageIndex.ToString()+".bmp");
                        //objSampleROI.SaveImage("D:\\objSampleROI_" + intImageIndex.ToString() + ".bmp");
                        //objTemplateROI.SaveImage("D:\\objTemplateROI_" + intImageIndex.ToString() + ".bmp");
                        //objTemplateROI2.SaveImage("D:\\objTemplateROI2_" + intImageIndex.ToString() + ".bmp");

                        objSampleROI.Dispose();
                        objTemplateROI.Dispose();
                        objTemplateROI2.Dispose();

                        return false;
                    }
                }
                else
                {
                    if (!IsImage1UnitChippedOff2_Area_SimpleMode_TiltAngle(objSampleROI, objSampleROI.ref_ROITotalX, objSampleROI.ref_ROITotalY, intImageIndex)) // IsImage1UnitChippedOff2
                    {
                        //objImageUnitROI.SaveImage("D:\\objImageUnitROI_"+intImageIndex.ToString()+".bmp");
                        //objSampleROI.SaveImage("D:\\objSampleROI_" + intImageIndex.ToString() + ".bmp");
                        //objTemplateROI.SaveImage("D:\\objTemplateROI_" + intImageIndex.ToString() + ".bmp");
                        //objTemplateROI2.SaveImage("D:\\objTemplateROI2_" + intImageIndex.ToString() + ".bmp");

                        objSampleROI.Dispose();
                        objTemplateROI.Dispose();
                        objTemplateROI2.Dispose();

                        return false;
                    }
                }
            }

            objSampleROI.Dispose();
            objTemplateROI.Dispose();
            objTemplateROI2.Dispose();

            return blnResult;
        }

        private bool CheckImageChipDefect_SimpleMode_2020_11_26(ROI objImageUnitToleranceROI, ROI objImageUnitROI, int intImageIndex)//, bool blnPadPkg)
        {
            /* This function is to do image processing for Chipped off and surface scratches test.
             * Skip this function if Chipped off and scratches test is disabled.
             * 
             * Image Processing:
             * 
             * 1. Double threshold sample image 
             *    using image 1 surface double threshold value 
             *    with class 255, 0 255.
             *    Mean defect area on surface will be while color. Good surface area will be black color.
             * 2. Single threshold template image 
             *    using Pad Threshold value 
             *    with class 0, 255
             * 3. Get ready a blank black image
             * 4. Scan each template pads, 
             *     based on different size between sample and template pad,
             *     Erode/dilate the template pads
             *     add the Erode/dilate template pads into the blank black image.
             *     Mean you will get a erode/dilate template with pad while color, surface area black color.
             * 5. Substract the Sample image - Erode/dilate template image.
             *     After substract, you will get defect surface area with white color, 
             *     good surface area will be black color, 
             *     pad area will be totally dark color. 
             * 6  Send final substract image for chipped off test and surface scratches test.
             *
             * 
             *
             */

            // Return if Contamination, Chipped off, Scratches Length and Area is OFF
            if ((m_intFailPkgOptionMask & 0x04) == 0)
                return true;

            int intInpectMode = 0; //0=Flexi template size, 1= use sample size, 2: Fix template size
            bool blnResult = true;
            bool blnDebugImage = false;

            if (blnDebugImage)
            {
                objImageUnitToleranceROI.SaveImage("D:\\TS\\1.objImageUnitToleranceROI.bmp");
                objImageUnitROI.SaveImage("D:\\TS\\2.objImageUnitROI.bmp");
            }

            // Get ready sample ROI
            ROI objSampleROI = new ROI();
            objSampleROI.AttachImage(m_objInsSurfacePkgImage1);  // m_objInsSurfacePkgImage1 is temporary image use to hold objSampleROI double threshold
            objSampleROI.LoadROISetting(objImageUnitToleranceROI.ref_ROITotalX, objImageUnitToleranceROI.ref_ROITotalY, objImageUnitToleranceROI.ref_ROIWidth, objImageUnitToleranceROI.ref_ROIHeight);
#if (Debug_2_12 || Release_2_12)
            // Gain and Double threshold
            switch (intImageIndex)
            {
                case 1: // Image 1 (Grab 1 & Grab 2 Merged)
                    {
                        if (m_fPkgImage1Gain != 1f)
                        {
                            EasyImage.GainOffset(objImageUnitToleranceROI.ref_ROI, objSampleROI.ref_ROI, m_fPkgImage1Gain);
                            EasyImage.DoubleThreshold(objSampleROI.ref_ROI, objSampleROI.ref_ROI, (uint)m_intPkgImage1LowSurfaceThreshold, (uint)m_intPkgImage1HighSurfaceThreshold, 0, 255, 0); // WinXP (255,0,255) , Win7 (0,255,0)
                        }
                        else
                        {
                            EasyImage.DoubleThreshold(objImageUnitToleranceROI.ref_ROI, objSampleROI.ref_ROI, (uint)m_intPkgImage1LowSurfaceThreshold, (uint)m_intPkgImage1HighSurfaceThreshold, 0, 255, 0);// WinXP (255,0,255) , Win7 (0,255,0)
                        }
                    }
                    break;
                case 2: // Image 2 (Grab 3)
                    {
                        EasyImage.DoubleThreshold(objImageUnitToleranceROI.ref_ROI, objSampleROI.ref_ROI, (uint)m_intPkgImage2LowThreshold, (uint)m_intPkgImage2HighThreshold, 0, 255, 0);// WinXP (255,0,255) , Win7 (0,255,0)
                    }
                    break;
            }

#elif (DEBUG || RELEASE || RTXRelease || RTXDebug)
            // Gain and Double threshold
            switch (intImageIndex)
            {
                case 1: // Image 1 (Grab 1 & Grab 2 Merged)
                    {
                        if (m_fPkgImage1Gain != 1f)
                        {
                            EasyImage.GainOffset(objImageUnitToleranceROI.ref_ROI, objSampleROI.ref_ROI, m_fPkgImage1Gain);
                            EasyImage.DoubleThreshold(objSampleROI.ref_ROI, objSampleROI.ref_ROI, m_intPkgImage1LowSurfaceThreshold, m_intPkgImage1HighSurfaceThreshold, 0, 255, 0); // WinXP (255,0,255) , Win7 (0,255,0)
                        }
                        else
                        {
                            EasyImage.DoubleThreshold(objImageUnitToleranceROI.ref_ROI, objSampleROI.ref_ROI, m_intPkgImage1LowSurfaceThreshold, m_intPkgImage1HighSurfaceThreshold, 0, 255, 0);// WinXP (255,0,255) , Win7 (0,255,0)
                        }
                    }
                    break;
                case 2: // Image 2 (Grab 3)
                    {
                        EasyImage.DoubleThreshold(objImageUnitToleranceROI.ref_ROI, objSampleROI.ref_ROI, m_intPkgImage2LowThreshold, m_intPkgImage2HighThreshold, 0, 255, 0);// WinXP (255,0,255) , Win7 (0,255,0)
                    }
                    break;
            }

#endif

            if (blnDebugImage)
            {
                objImageUnitToleranceROI.SaveImage("D:\\TS\\objImageUnitToleranceROI.bmp");
                m_objInsSurfacePkgImage1.SaveImage("D:\\TS\\3.m_objInsSurfacePkgImage1.bmp");
                objSampleROI.SaveImage("D:\\TS\\4.objSampleROI.bmp");
            }

            // Get ready template ROI
            ROI objTemplateROI = new ROI();
            if (intInpectMode == 0)
            {
                // Get threshold value
                int intThresholdValue;
                if (m_intThresholdValue < 0)
                {
                    EBW8 objBW8;
                    if (intImageIndex == 1)
                        objBW8 = EasyImage.AutoThreshold(m_ImgUnitTemplateImage, EThresholdMode.MinResidue);
                    else
                        objBW8 = EasyImage.AutoThreshold(m_ImgUnitTemplateImagePkg, EThresholdMode.MinResidue);
                    intThresholdValue = objBW8.Value;
                }
                else
                    intThresholdValue = m_intThresholdValue;

                if (blnDebugImage)
                {
                    m_ImgUnitTemplateImage.Save("D:\\TS\\5.m_ImgUnitTemplateImage.bmp");// debug
                    m_ImgTUnitErodeThresImage.Save("D:\\TS\\6.m_ImgTUnitErodeThresImage.bmp");// debug
                    m_ImgUnitTemplateImagePkg.Save("D:\\TS\\7.m_ImgUnitTemplateImagePkg.bmp");// debug
                    m_ImgTUnitErodeThresImagePkg.Save("D:\\TS\\8.m_ImgTUnitErodeThresImagePkg.bmp");// debug
                }
#if (Debug_2_12 || Release_2_12)
                if (intImageIndex == 1)
                {
                    EasyImage.Copy(m_ImgUnitTemplateImage, m_ImgTUnitErodeThresImage);
                    // single threshold template image
                    if (m_fPadImageGain != 1f)
                    {
                        EasyImage.GainOffset(m_ImgTUnitErodeThresImage, m_ImgTUnitErodeThresImage, m_fPadImageGain);
                        EasyImage.Threshold(m_ImgTUnitErodeThresImage, m_ImgTUnitErodeThresImage, (uint)intThresholdValue);
                    }
                    else
                    {
                        EasyImage.Threshold(m_ImgTUnitErodeThresImage, m_ImgTUnitErodeThresImage, (uint)intThresholdValue);
                    }

                    objTemplateROI.ref_ROI.Detach();
                    objTemplateROI.ref_ROI.Attach(m_ImgTUnitErodeThresImage);
                    objTemplateROI.LoadROISetting(m_ImgTUnitErodeThresImage.Width / 2 - objImageUnitToleranceROI.ref_ROIWidth / 2,
                                                  m_ImgTUnitErodeThresImage.Height / 2 - objImageUnitToleranceROI.ref_ROIHeight / 2,
                                                  objImageUnitToleranceROI.ref_ROIWidth,
                                                  objImageUnitToleranceROI.ref_ROIHeight);
                }
                else
                {

                    //EasyImage.Copy(m_ImgUnitTemplateImagePkg, m_ImgTUnitErodeThresImagePkg);

                    //// single threshold template image
                    //EasyImage.Threshold(m_ImgTUnitErodeThresImagePkg, m_ImgTUnitErodeThresImagePkg, intThresholdValue);

                    //objTemplateROI.ref_ROI.Detach();
                    //objTemplateROI.ref_ROI.Attach(m_ImgTUnitErodeThresImagePkg);
                    //objTemplateROI.LoadROISetting(0, 0, objImageUnitROI.ref_ROIWidth, objImageUnitROI.ref_ROIHeight);

                    // 2019-10-09 ZJYEOH : Previous version Image Offset to 0,0
                    EasyImage.Copy(m_ImgUnitTemplateImage, m_ImgTUnitErodeThresImage);
                    // single threshold template image
                    if (m_fPadImageGain != 1f)
                    {
                        EasyImage.GainOffset(m_ImgTUnitErodeThresImage, m_ImgTUnitErodeThresImage, m_fPadImageGain);
                        EasyImage.Threshold(m_ImgTUnitErodeThresImage, m_ImgTUnitErodeThresImage, (uint)intThresholdValue);
                    }
                    else
                    {
                        EasyImage.Threshold(m_ImgTUnitErodeThresImage, m_ImgTUnitErodeThresImage, (uint)intThresholdValue);
                    }

                    objTemplateROI.ref_ROI.Detach();
                    objTemplateROI.ref_ROI.Attach(m_ImgTUnitErodeThresImage);
                    objTemplateROI.LoadROISetting(m_ImgTUnitErodeThresImage.Width / 2 - objImageUnitToleranceROI.ref_ROIWidth / 2,
                                                  m_ImgTUnitErodeThresImage.Height / 2 - objImageUnitToleranceROI.ref_ROIHeight / 2,
                                                  objImageUnitToleranceROI.ref_ROIWidth,
                                                  objImageUnitToleranceROI.ref_ROIHeight);
                }

#elif (DEBUG || RELEASE || RTXRelease || RTXDebug)
                if (intImageIndex == 1)
                {
                    EasyImage.Copy(m_ImgUnitTemplateImage, m_ImgTUnitErodeThresImage);
                    // single threshold template image
                    if (m_fPadImageGain != 1f)
                    {
                        EasyImage.GainOffset(m_ImgTUnitErodeThresImage, m_ImgTUnitErodeThresImage, m_fPadImageGain);
                        EasyImage.Threshold(m_ImgTUnitErodeThresImage, m_ImgTUnitErodeThresImage, intThresholdValue);
                    }
                    else
                    {
                        EasyImage.Threshold(m_ImgTUnitErodeThresImage, m_ImgTUnitErodeThresImage, intThresholdValue);
                    }

                    objTemplateROI.ref_ROI.Detach();
                    objTemplateROI.ref_ROI.Attach(m_ImgTUnitErodeThresImage);
                    objTemplateROI.LoadROISetting(m_ImgTUnitErodeThresImage.Width / 2 - objImageUnitToleranceROI.ref_ROIWidth / 2,
                                                  m_ImgTUnitErodeThresImage.Height / 2 - objImageUnitToleranceROI.ref_ROIHeight / 2,
                                                  objImageUnitToleranceROI.ref_ROIWidth,
                                                  objImageUnitToleranceROI.ref_ROIHeight);
                }
                else
                {

                    //EasyImage.Copy(m_ImgUnitTemplateImagePkg, m_ImgTUnitErodeThresImagePkg);

                    //// single threshold template image
                    //EasyImage.Threshold(m_ImgTUnitErodeThresImagePkg, m_ImgTUnitErodeThresImagePkg, intThresholdValue);

                    //objTemplateROI.ref_ROI.Detach();
                    //objTemplateROI.ref_ROI.Attach(m_ImgTUnitErodeThresImagePkg);
                    //objTemplateROI.LoadROISetting(0, 0, objImageUnitROI.ref_ROIWidth, objImageUnitROI.ref_ROIHeight);

                    // 2019-10-09 ZJYEOH : Previous version Image Offset to 0,0
                    EasyImage.Copy(m_ImgUnitTemplateImage, m_ImgTUnitErodeThresImage);
                    // single threshold template image
                    if (m_fPadImageGain != 1f)
                    {
                        EasyImage.GainOffset(m_ImgTUnitErodeThresImage, m_ImgTUnitErodeThresImage, m_fPadImageGain);
                        EasyImage.Threshold(m_ImgTUnitErodeThresImage, m_ImgTUnitErodeThresImage, intThresholdValue);
                    }
                    else
                    {
                        EasyImage.Threshold(m_ImgTUnitErodeThresImage, m_ImgTUnitErodeThresImage, intThresholdValue);
                    }

                    objTemplateROI.ref_ROI.Detach();
                    objTemplateROI.ref_ROI.Attach(m_ImgTUnitErodeThresImage);
                    objTemplateROI.LoadROISetting(m_ImgTUnitErodeThresImage.Width / 2 - objImageUnitToleranceROI.ref_ROIWidth / 2,
                                                  m_ImgTUnitErodeThresImage.Height / 2 - objImageUnitToleranceROI.ref_ROIHeight / 2,
                                                  objImageUnitToleranceROI.ref_ROIWidth,
                                                  objImageUnitToleranceROI.ref_ROIHeight);
                }

#endif

                if (blnDebugImage)
                {
                    objImageUnitROI.SaveImage("D:\\TS\\9.B_OriSampleROI.bmp");// debug
                    m_ImgUnitTemplateImage.Save("D:\\TS\\10.B_OriTemplateImage.bmp");// debug
                    m_ImgTUnitErodeThresImage.Save("D:\\TS\\11.B_m_ImgTUnitErodeThresImage.bmp");// debug
                    objTemplateROI.SaveImage("D:\\TS\\12.B_objTemplateROI.bmp");// debug
                    objSampleROI.SaveImage("D:\\TS\\13.B_objSampleROI.bmp");// debug
                }
            }

            int intBWImageWidth = 0, intBWImageHeight = 0;

            // 2019-10-09 ZJYEOH : For Image 2 Inspection, Use Blank Black Image, will use Addition operation to get image with black defect only
            //if (intImageIndex == 1)
            {
                // Get ready blank black image
                m_ImgBlackUnitTemplateImage.CopyTo(m_ImgBlackUnitTemplateImage2);
                intBWImageWidth = m_ImgBlackUnitTemplateImage2.Width;
                intBWImageHeight = m_ImgBlackUnitTemplateImage2.Height;
            }
            //else
            //{
            // Get ready blank white image
            //m_ImgWhiteUnitTemplateImage.CopyTo(m_ImgWhiteUnitTemplateImage2);
            //    intBWImageWidth = m_ImgWhiteUnitTemplateImage2.Width;
            //    intBWImageHeight = m_ImgWhiteUnitTemplateImage2.Height;
            //}

            ROI objTemplateROI2 = new ROI();
            objTemplateROI2.ref_ROI.Detach();
            //if (intImageIndex == 1)
            {
                objTemplateROI2.ref_ROI.Attach(m_ImgBlackUnitTemplateImage2);
            }
            //else
            //{
            //    objTemplateROI2.ref_ROI.Attach(m_ImgWhiteUnitTemplateImage2);
            //}

            objTemplateROI2.LoadROISetting(0, 0, objImageUnitToleranceROI.ref_ROIWidth, objImageUnitToleranceROI.ref_ROIHeight);


            if (blnDebugImage)
                objTemplateROI2.SaveImage("D:\\TS\\14.BlankTemplateROI2.bmp");// debug

            int intStartX, intStartY, intEndX, intEndY, intAdjustX, intAdjustY, intStartX2, intStartY2, intWidth, intHeight;

            if (intInpectMode == 0)
            {
                #region Inspect Mode == 0
                int intToleSize = m_intMPDilateHalfWidth;

                for (int i = 0; i < m_arrTemplateBlobPads.Count; i++)
                {
                    if (m_arrSampleBlobPads[i].intFailMask != 0)
                        continue;

                    // check the different size between sample pad and template pad
                    int intDiffSizeWidth = (int)Math.Round((m_arrSampleBlobPads[i].fWidth - ((BlobsFeatures)m_arrTemplateBlobPads[i]).fWidth) / 2, 0, MidpointRounding.AwayFromZero);
                    int intDiffSizeHeight = (int)Math.Round((m_arrSampleBlobPads[i].fHeight - ((BlobsFeatures)m_arrTemplateBlobPads[i]).fHeight) / 2, 0, MidpointRounding.AwayFromZero);

                    // set one of the size (width or height) to zero if one side is bigger and another side is smaller
                    if ((intDiffSizeWidth > 0 && intDiffSizeHeight < 0) || (intDiffSizeHeight > 0 && intDiffSizeWidth < 0))
                    {
                        if (Math.Abs(intDiffSizeWidth) > Math.Abs(intDiffSizeHeight))    // the bigger value will set to 0
                            intDiffSizeHeight = 0;
                        else
                            intDiffSizeWidth = 0;
                    }

                    float fWidth, fHeight;
                    // get bigger size from sample pad or template pad
                    if ((intDiffSizeWidth > 0) || (intDiffSizeHeight > 0))
                    {
                        // Use sample size
                        fWidth = m_arrSampleBlobPads[i].fWidth;
                        fHeight = m_arrSampleBlobPads[i].fHeight;
                    }
                    else
                    {
                        // Use template size
                        fWidth = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fWidth;
                        fHeight = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fHeight;
                    }

                    // Get "template" pad start and end corner point with tolerance size added.
                    intAdjustX = 0;
                    intAdjustY = 0;
                    intStartX = (int)Math.Round(((BlobsFeatures)m_arrTemplateBlobPads[i]).fLimitCenterX - fWidth / 2 - intToleSize, 0, MidpointRounding.AwayFromZero);
                    if (intStartX < 0)  // Set to zero if value smaller than zero
                    {
                        intAdjustX = intStartX; // add adjust value when intStartX change from negative to 0
                        intStartX = 0;
                    }
                    intStartY = (int)Math.Round(((BlobsFeatures)m_arrTemplateBlobPads[i]).fLimitCenterY - fHeight / 2 - intToleSize, 0, MidpointRounding.AwayFromZero);
                    if (intStartY < 0)  // Set to zero if value smaller than zero
                    {
                        intAdjustY = intStartY; // add adjust value when intStartY change from negative to 0
                        intStartY = 0;
                    }

                    // Get "sample" pad start and end corner point with tolerance size added.
                    intStartX2 = (int)Math.Round(m_arrSampleBlobPads[i].fCenterX - fWidth / 2 - intToleSize, 0, MidpointRounding.AwayFromZero);
                    if (intStartX2 < 0) // Set to zero if value smaller than zero
                    {
                        if (intStartX2 > intAdjustX)    // set bigger value in adjust value // Why is bigger, not smaller?
                            intAdjustX = intStartX2;
                        intStartX2 = 0;
                    }
                    intStartY2 = (int)Math.Round(m_arrSampleBlobPads[i].fCenterY - fHeight / 2 - intToleSize, 0, MidpointRounding.AwayFromZero);
                    if (intStartY2 < 0) // Set to zero if value smaller than zero
                    {
                        if (intStartY2 > intAdjustY)    // set bigger value in adjust value // Why is bigger, not smaller?
                            intAdjustY = intStartY2;
                        intStartY2 = 0;
                    }

                    // Set "template" pad width with tolerance size and adjust value added
                    intWidth = (int)Math.Round(fWidth + intToleSize * 2, 0, MidpointRounding.AwayFromZero);
                    intEndX = intStartX + intWidth + intAdjustX;
                    int intEndAdjustX = 0;
                    if (intEndX > objTemplateROI.ref_ROIWidth - 1)
                    {
                        intEndAdjustX = (intEndX - (objTemplateROI.ref_ROIWidth - 1));  // Set end adjust value if endx bigger than roi area
                    }
                    intHeight = (int)Math.Round(fHeight + intToleSize * 2, 0, MidpointRounding.AwayFromZero);
                    intEndY = intStartY + intHeight + intAdjustY;
                    int intEndAdjustY = 0;
                    if (intEndY > objTemplateROI.ref_ROIHeight - 1)
                    {
                        intEndAdjustY = (intEndY - (objTemplateROI.ref_ROIHeight)); // Set end adjust value if endx bigger than roi area
                    }

                    // set pad corner end point value
                    //intEndX = intStartX2 + intWidth + intToleSize * 2 + intAdjustX;
                    intEndX = intStartX2 + intWidth + intAdjustX;
                    if (intEndX > intBWImageWidth - 1)
                    {
                        if (intEndAdjustX < (intEndX - (intBWImageWidth - 1)))
                            intEndAdjustX = (intEndX - (intBWImageWidth - 1));
                    }
                    //intEndY = intStartY2 + intHeight + intToleSize * 2 + intAdjustY;
                    intEndY = intStartY2 + intHeight + intAdjustY;
                    if (intEndY > intBWImageHeight - 1)
                    {
                        if (intEndAdjustY < (intEndY - (intBWImageHeight - 1)))
                            intEndAdjustY = (intEndY - (intBWImageHeight - 1));
                    }

                    intWidth -= intEndAdjustX;
                    intHeight -= intEndAdjustY;

                    // Get template pad roi
                    ROI objTemplatePadROI = new ROI();
                    objTemplatePadROI.AttachImage(objTemplateROI);
                    objTemplatePadROI.LoadROISetting(intStartX, intStartY, intWidth, intHeight);

                    if (blnDebugImage)
                    {
                        objTemplatePadROI.SaveImage("D:\\TS\\objTemplatePadROI.bmp");// debug
                    }

                    m_ImgMPUnitTemplateImage.SetSize(objTemplatePadROI.ref_ROIWidth, objTemplatePadROI.ref_ROIHeight);
                    EasyImage.Copy(objTemplatePadROI.ref_ROI, m_ImgMPUnitTemplateImage);

                    if (intDiffSizeWidth < -intToleSize)
                        intDiffSizeWidth = -intToleSize;
                    else if (intDiffSizeWidth > intToleSize)
                        intDiffSizeWidth = intToleSize;

                    if (intDiffSizeHeight < -intToleSize)
                        intDiffSizeHeight = -intToleSize;
                    else if (intDiffSizeHeight > intToleSize)
                        intDiffSizeHeight = intToleSize;
#if (Debug_2_12 || Release_2_12)
                    if ((intDiffSizeWidth < 0) || (intDiffSizeHeight < 0))
                    {
                        int intDiffSizeWidth2 = intDiffSizeWidth + m_intMPErodeHalfWidth;
                        int intDiffSizeHeight2 = intDiffSizeHeight + m_intMPErodeHalfWidth;
                        if ((intDiffSizeWidth2 > 0 && intDiffSizeHeight2 < 0) || (intDiffSizeHeight2 > 0 && intDiffSizeWidth2 < 0))
                        {
                            if (Math.Abs(intDiffSizeWidth2) > Math.Abs(intDiffSizeHeight2))
                                intDiffSizeHeight2 = 0;
                            else
                                intDiffSizeWidth2 = 0;
                        }

                        if ((intDiffSizeWidth2 < 0) || (intDiffSizeHeight2 < 0))
                        {
                            EasyImage.ErodeBox(m_ImgMPUnitTemplateImage, objTemplatePadROI.ref_ROI, (uint)Math.Abs(intDiffSizeWidth2), (uint)Math.Abs(intDiffSizeHeight2));
                        }
                        else
                        {

                            intDiffSizeWidth2 = intDiffSizeWidth + m_intMPDilateHalfWidth;
                            intDiffSizeHeight2 = intDiffSizeHeight2 + m_intMPDilateHalfWidth;
                            if ((intDiffSizeWidth2 > 0 && intDiffSizeHeight2 < 0) || (intDiffSizeHeight2 > 0 && intDiffSizeWidth2 < 0))
                            {
                                if (Math.Abs(intDiffSizeWidth2) > Math.Abs(intDiffSizeHeight2))
                                    intDiffSizeHeight2 = 0;
                                else
                                    intDiffSizeWidth2 = 0;
                            }

                            if ((intDiffSizeWidth2 < 0) || (intDiffSizeHeight2 < 0))
                            {
                            }
                            else
                            {
                                EasyImage.DilateBox(m_ImgMPUnitTemplateImage, objTemplatePadROI.ref_ROI, (uint)Math.Abs(intDiffSizeWidth2), (uint)Math.Abs(intDiffSizeHeight2));
                            }
                        }
                    }
                    else
                    {
                        if ((Math.Abs(intDiffSizeWidth) + m_intMPDilateHalfWidth) > 0 || (Math.Abs(intDiffSizeHeight) + m_intMPDilateHalfWidth) > 0)
                            EasyImage.DilateBox(m_ImgMPUnitTemplateImage, objTemplatePadROI.ref_ROI, (uint)(Math.Abs(intDiffSizeWidth) + m_intMPDilateHalfWidth), (uint)(Math.Abs(intDiffSizeHeight) + m_intMPDilateHalfWidth));
                    }

#elif (DEBUG || RELEASE || RTXRelease || RTXDebug)
                    if ((intDiffSizeWidth < 0) || (intDiffSizeHeight < 0))
                    {
                        int intDiffSizeWidth2 = intDiffSizeWidth + m_intMPErodeHalfWidth;
                        int intDiffSizeHeight2 = intDiffSizeHeight + m_intMPErodeHalfWidth;
                        if ((intDiffSizeWidth2 > 0 && intDiffSizeHeight2 < 0) || (intDiffSizeHeight2 > 0 && intDiffSizeWidth2 < 0))
                        {
                            if (Math.Abs(intDiffSizeWidth2) > Math.Abs(intDiffSizeHeight2))
                                intDiffSizeHeight2 = 0;
                            else
                                intDiffSizeWidth2 = 0;
                        }

                        if ((intDiffSizeWidth2 < 0) || (intDiffSizeHeight2 < 0))
                        {
                            EasyImage.ErodeBox(m_ImgMPUnitTemplateImage, objTemplatePadROI.ref_ROI, Math.Abs(intDiffSizeWidth2), Math.Abs(intDiffSizeHeight2));
                        }
                        else
                        {

                            intDiffSizeWidth2 = intDiffSizeWidth + m_intMPDilateHalfWidth;
                            intDiffSizeHeight2 = intDiffSizeHeight2 + m_intMPDilateHalfWidth;
                            if ((intDiffSizeWidth2 > 0 && intDiffSizeHeight2 < 0) || (intDiffSizeHeight2 > 0 && intDiffSizeWidth2 < 0))
                            {
                                if (Math.Abs(intDiffSizeWidth2) > Math.Abs(intDiffSizeHeight2))
                                    intDiffSizeHeight2 = 0;
                                else
                                    intDiffSizeWidth2 = 0;
                            }

                            if ((intDiffSizeWidth2 < 0) || (intDiffSizeHeight2 < 0))
                            {
                            }
                            else
                            {
                                EasyImage.DilateBox(m_ImgMPUnitTemplateImage, objTemplatePadROI.ref_ROI, Math.Abs(intDiffSizeWidth2), Math.Abs(intDiffSizeHeight2));
                            }
                        }
                    }
                    else
                    {
                        if ((Math.Abs(intDiffSizeWidth) + m_intMPDilateHalfWidth) > 0 || (Math.Abs(intDiffSizeHeight) + m_intMPDilateHalfWidth) > 0)
                            EasyImage.DilateBox(m_ImgMPUnitTemplateImage, objTemplatePadROI.ref_ROI, Math.Abs(intDiffSizeWidth) + m_intMPDilateHalfWidth, Math.Abs(intDiffSizeHeight) + m_intMPDilateHalfWidth);
                    }

#endif

                    if (!GetOverallWantGaugeMeasurePkgSize(false))
                    {
                        intStartX2 += (int)Math.Round(GetResultCenterPoint_UnitMatcher().X - GetResultCenterPoint_RectGauge4L().X);
                        intStartY2 += (int)Math.Round(GetResultCenterPoint_UnitMatcher().Y - GetResultCenterPoint_RectGauge4L().Y);
                    }

                    // Get template2 pad ROI
                    ROI objTemplate2PadROI = new ROI();

                    objTemplate2PadROI.ref_ROI.Detach();
                    //if (intImageIndex == 1)
                    objTemplate2PadROI.ref_ROI.Attach(m_ImgBlackUnitTemplateImage2);
                    //else
                    //    objTemplate2PadROI.ref_ROI.Attach(m_ImgWhiteUnitTemplateImage2);
                    objTemplate2PadROI.LoadROISetting(intStartX2, intStartY2, intWidth, intHeight);

                    if (blnDebugImage)
                    {
                        m_ImgMPUnitTemplateImage.Save("D:\\TS\\B_BfMPTemplateImage.bmp");// debug
                        objTemplatePadROI.SaveImage("D:\\TS\\B_AfMPTemplateImage.bmp");// debug
                        objTemplate2PadROI.SaveImage("D:\\TS\\B_BfSBTemplate2PadImage.bmp");// debug
                    }


                    // Add sample pad roi - template pad roi
                    EasyImage.Oper(EArithmeticLogicOperation.Add, objTemplate2PadROI.ref_ROI, objTemplatePadROI.ref_ROI, objTemplate2PadROI.ref_ROI);

                    if (blnDebugImage)
                    {
                        objTemplate2PadROI.SaveImage("D:\\TS\\B_AfSBTemplate2PadImage.bmp");// debug
                        objTemplateROI2.SaveImage("D:\\TS\\B_objTemplate2ROI.bmp");// debug
                    }

                    objTemplatePadROI.Dispose();
                    objTemplate2PadROI.Dispose();
                }

                #endregion
            }
            else if (intInpectMode == 1)
            {
                #region Inspect Mode == 1
                for (int i = 0; i < m_arrSampleBlobPads.Length; i++)
                {
                    if (m_arrSampleBlobPads[i].intFailMask != 0)
                        continue;

                    intStartX = (int)Math.Floor(m_arrSampleBlobPads[i].fStartX);
                    intStartY = (int)Math.Floor(m_arrSampleBlobPads[i].fStartY);

                    intStartX2 = (int)Math.Floor(m_arrSampleBlobPads[i].fCenterX - m_arrSampleBlobPads[i].fWidth / 2);
                    intStartY2 = (int)Math.Floor(m_arrSampleBlobPads[i].fCenterY - m_arrSampleBlobPads[i].fHeight / 2);

                    intWidth = (int)Math.Ceiling(m_arrSampleBlobPads[i].fWidth) + 1;
                    intHeight = (int)Math.Ceiling(m_arrSampleBlobPads[i].fHeight) + 1;

                    // Get template pad roi
                    ROI objTemplatePadROI = new ROI();
                    objTemplatePadROI.AttachImage(objTemplateROI);
                    objTemplatePadROI.LoadROISetting(intStartX, intStartY, intWidth, intHeight);

                    // Get Sample pad ROI
                    ROI objTemplate2PadROI = new ROI();
                    objTemplate2PadROI.ref_ROI.Detach();
                    objTemplate2PadROI.ref_ROI.Attach(m_ImgBlackUnitTemplateImage2);
                    objTemplate2PadROI.LoadROISetting(intStartX2, intStartY2, intWidth, intHeight);

                    // subtract sample pad roi - template pad roi
                    EasyImage.Oper(EArithmeticLogicOperation.Add, objTemplate2PadROI.ref_ROI, objTemplatePadROI.ref_ROI, objTemplate2PadROI.ref_ROI);

                    objTemplatePadROI.Dispose();
                    objTemplate2PadROI.Dispose();
                }
                #endregion
            }
            else
            {
                #region Inspect mode == 2
                for (int i = 0; i < m_arrTemplateBlobPads.Count; i++)
                {
                    if (m_arrSampleBlobPads[i].intFailMask != 0)
                        continue;

                    intAdjustX = 0;
                    intAdjustY = 0;
                    intStartX = ((BlobsFeatures)m_arrTemplateBlobPads[i]).intStartX - 3;
                    if (intStartX < 0)
                    {
                        intAdjustX = intStartX;
                        intStartX = 0;
                    }
                    intStartY = ((BlobsFeatures)m_arrTemplateBlobPads[i]).intStartY - 3;
                    if (intStartY < 0)
                    {
                        intAdjustY = intStartY;
                        intStartY = 0;
                    }

                    intStartX2 = (int)Math.Round(m_arrSampleBlobPads[i].fCenterX - ((BlobsFeatures)m_arrTemplateBlobPads[i]).fWidth / 2, 0, MidpointRounding.AwayFromZero);
                    intStartX2 -= 3;
                    if (intStartX2 < 0)
                    {
                        if (intStartX2 > intAdjustX)
                            intAdjustX = intStartX2;
                        intStartX2 = 0;
                    }
                    intStartY2 = (int)Math.Round(m_arrSampleBlobPads[i].fCenterY - ((BlobsFeatures)m_arrTemplateBlobPads[i]).fHeight / 2, 0, MidpointRounding.AwayFromZero);
                    intStartY2 -= 3;
                    if (intStartY2 < 0)
                    {
                        if (intStartY2 > intAdjustY)
                            intAdjustY = intStartY2;
                        intStartY2 = 0;
                    }

                    intWidth = (int)Math.Round(((BlobsFeatures)m_arrTemplateBlobPads[i]).fWidth, 0, MidpointRounding.AwayFromZero) + 6;
                    intEndX = intStartX + intWidth + intAdjustX;
                    int intEndAdjustX = 0;
                    if (intEndX > objTemplateROI.ref_ROIWidth - 1)
                    {
                        intEndAdjustX = (intEndX - (objTemplateROI.ref_ROIWidth - 1));
                    }
                    intHeight = (int)Math.Round(((BlobsFeatures)m_arrTemplateBlobPads[i]).fHeight, 0, MidpointRounding.AwayFromZero) + 6;
                    intEndY = intStartY + intHeight + intAdjustY;
                    int intEndAdjustY = 0;
                    if (intEndY > objTemplateROI.ref_ROIHeight - 1)
                    {
                        intEndAdjustY = (intEndY - (objTemplateROI.ref_ROIHeight - 1));
                    }

                    intEndX = intStartX2 + intWidth + 6 + intAdjustX;
                    if (intEndX > m_ImgBlackUnitTemplateImage2.Width - 1)
                    {
                        if (intEndAdjustX < (intEndX - (m_ImgBlackUnitTemplateImage2.Width - 1)))
                            intEndAdjustX = (intEndX - (m_ImgBlackUnitTemplateImage2.Width - 1));
                    }
                    intEndY = intStartY2 + intHeight + 6 + intAdjustY;
                    if (intEndY > m_ImgBlackUnitTemplateImage2.Height - 1)
                    {
                        if (intEndAdjustY < (intEndY - (m_ImgBlackUnitTemplateImage2.Height - 1)))
                            intEndAdjustY = (intEndY - (m_ImgBlackUnitTemplateImage2.Height - 1));
                    }

                    intWidth -= intEndAdjustX;
                    intHeight -= intEndAdjustY;

                    // Get template pad roi
                    ROI objTemplatePadROI = new ROI();
                    objTemplatePadROI.AttachImage(objTemplateROI);
                    objTemplatePadROI.LoadROISetting(intStartX, intStartY, intWidth, intHeight);

                    // Get Sample pad ROI
                    ROI objTemplate2PadROI = new ROI();
                    objTemplate2PadROI.ref_ROI.Detach();
                    objTemplate2PadROI.ref_ROI.Attach(m_ImgBlackUnitTemplateImage2);
                    objTemplate2PadROI.LoadROISetting(intStartX2, intStartY2, intWidth, intHeight);

                    // subtract sample pad roi - template pad roi
                    EasyImage.Oper(EArithmeticLogicOperation.Add, objTemplate2PadROI.ref_ROI, objTemplatePadROI.ref_ROI, objTemplate2PadROI.ref_ROI);

                    objTemplatePadROI.Dispose();
                    objTemplate2PadROI.Dispose();
                }

                #endregion
            }

            if (blnDebugImage)
            {
                objSampleROI.SaveImage("D:\\TS\\20.B_BfSBSampleROI.bmp");// debug
                objTemplateROI2.SaveImage("D:\\TS\\21.B_objTemplate2ROI.bmp");// debug
            }

            // Subtract sample ROI - template ROI
            if (objSampleROI.ref_ROIWidth > objTemplateROI2.ref_ROIWidth)
                objSampleROI.ref_ROIWidth = objTemplateROI2.ref_ROIWidth;
            else
                objTemplateROI2.ref_ROIWidth = objSampleROI.ref_ROIWidth;

            if (objSampleROI.ref_ROIHeight > objTemplateROI2.ref_ROIHeight)
                objSampleROI.ref_ROIHeight = objTemplateROI2.ref_ROIHeight;
            else
                objTemplateROI2.ref_ROIHeight = objSampleROI.ref_ROIHeight;

            if (blnDebugImage)
            {
                objSampleROI.SaveImage("D:\\TS\\22.B_BfSBSampleROI.bmp");// debug
                objTemplateROI2.SaveImage("D:\\TS\\23.B_objTemplate2ROI.bmp");// debug
                objTemplateROI.SaveImage("D:\\TS\\24.objTemplateROI.bmp");
            }


            if (intImageIndex == 1)
                EasyImage.Oper(EArithmeticLogicOperation.Subtract, objSampleROI.ref_ROI, objTemplateROI2.ref_ROI, objSampleROI.ref_ROI);    // 2019 05 14 - CCENG: Use templateROI2 because the pad location is according to sample ROI.
                                                                                                                                            //EasyImage.Oper(EArithmeticLogicOperation.Subtract, objSampleROI.ref_ROI, objTemplateROI.ref_ROI, objSampleROI.ref_ROI);
            else
                EasyImage.Oper(EArithmeticLogicOperation.Add, objSampleROI.ref_ROI, objTemplateROI2.ref_ROI, objSampleROI.ref_ROI);  // 2019-10-09 ZJYEOH : use Addition operation to get image with black defect only

            //objSampleROI.SaveImage("D:\\objSampleROI.bmp");
            //objTemplateROI.SaveImage("D:\\objTemplateROI.bmp");
            if (blnDebugImage)
                objSampleROI.SaveImage("D:\\TS\\B_AfSBSampleROI.bmp");// debug


            // Check Unit Chipped off
            if ((m_intFailPkgOptionMask & 0x04) > 0)
            {
                objSampleROI.LoadROISetting(objImageUnitROI.ref_ROITotalX,
                                            objImageUnitROI.ref_ROITotalY,
                                            objImageUnitROI.ref_ROIWidth, objImageUnitROI.ref_ROIHeight);

                if (blnDebugImage)
                    objSampleROI.SaveImage("D:\\TS\\B_FinalSampleROI.bmp");// debug

                if (m_objRectGauge4L.GetGaugeTiltAngle() == 0)
                {
                    if (!IsImage1UnitChippedOff2_Area_SimpleMode(objSampleROI, objSampleROI.ref_ROITotalX, objSampleROI.ref_ROITotalY, intImageIndex)) // IsImage1UnitChippedOff2
                    {
                        //objImageUnitROI.SaveImage("D:\\objImageUnitROI_"+intImageIndex.ToString()+".bmp");
                        //objSampleROI.SaveImage("D:\\objSampleROI_" + intImageIndex.ToString() + ".bmp");
                        //objTemplateROI.SaveImage("D:\\objTemplateROI_" + intImageIndex.ToString() + ".bmp");
                        //objTemplateROI2.SaveImage("D:\\objTemplateROI2_" + intImageIndex.ToString() + ".bmp");

                        objSampleROI.Dispose();
                        objTemplateROI.Dispose();
                        objTemplateROI2.Dispose();

                        return false;
                    }
                }
                else
                {
                    if (!IsImage1UnitChippedOff2_Area_SimpleMode_TiltAngle(objSampleROI, objSampleROI.ref_ROITotalX, objSampleROI.ref_ROITotalY, intImageIndex)) // IsImage1UnitChippedOff2
                    {
                        //objImageUnitROI.SaveImage("D:\\objImageUnitROI_"+intImageIndex.ToString()+".bmp");
                        //objSampleROI.SaveImage("D:\\objSampleROI_" + intImageIndex.ToString() + ".bmp");
                        //objTemplateROI.SaveImage("D:\\objTemplateROI_" + intImageIndex.ToString() + ".bmp");
                        //objTemplateROI2.SaveImage("D:\\objTemplateROI2_" + intImageIndex.ToString() + ".bmp");

                        objSampleROI.Dispose();
                        objTemplateROI.Dispose();
                        objTemplateROI2.Dispose();

                        return false;
                    }
                }
            }

            objSampleROI.Dispose();
            objTemplateROI.Dispose();
            objTemplateROI2.Dispose();

            return blnResult;
        }
        private bool CheckImageBrightForeignMateriaDefect(ROI objImageUnitToleranceROI, ROI objImageUnitROI, int intImageIndex, int intPadIndex)//, bool blnPadPkg)
        {
            // Return if Bright Field Area and Length are OFF
            if (((m_intFailPkgOptionMask & 0x400000) == 0) && ((m_intFailPkgOptionMask & 0x800000) == 0))
                return true;

            int intInpectMode = 0; //0=Flexi template size, 1= use sample size, 2: Fix template size
            bool blnResult = true;
            bool blnDebugImage = false;

            if (blnDebugImage)
            {
                objImageUnitToleranceROI.SaveImage("D:\\TS\\1.objImageUnitToleranceROI.bmp");
                objImageUnitROI.SaveImage("D:\\TS\\2.objImageUnitROI.bmp");
            }

            // Get ready sample ROI
            ROI objSampleROI = new ROI();
            objSampleROI.AttachImage(m_objInsSurfacePkgImage1);  // m_objInsSurfacePkgImage1 is temporary image use to hold objSampleROI double threshold
            objSampleROI.LoadROISetting(objImageUnitToleranceROI.ref_ROITotalX, objImageUnitToleranceROI.ref_ROITotalY, objImageUnitToleranceROI.ref_ROIWidth, objImageUnitToleranceROI.ref_ROIHeight);

            //// Gain and Double threshold
#if (Debug_2_12 || Release_2_12)
            if (m_fPkgImage1Gain != 1f)
            {
                EasyImage.GainOffset(objImageUnitToleranceROI.ref_ROI, objSampleROI.ref_ROI, m_fPkgImage1Gain);
                EasyImage.Threshold(objImageUnitToleranceROI.ref_ROI, objSampleROI.ref_ROI, (uint)m_intForeignMaterialBrightFieldThreshold);
            }
            else
            {
                EasyImage.Threshold(objImageUnitToleranceROI.ref_ROI, objSampleROI.ref_ROI, (uint)m_intForeignMaterialBrightFieldThreshold);
            }
#elif (DEBUG || RELEASE)

            if (m_fPkgImage1Gain != 1f)
            {
                EasyImage.GainOffset(objImageUnitToleranceROI.ref_ROI, objSampleROI.ref_ROI, m_fPkgImage1Gain);
                EasyImage.Threshold(objImageUnitToleranceROI.ref_ROI, objSampleROI.ref_ROI, m_intForeignMaterialBrightFieldThreshold);
            }
            else
            {
                EasyImage.Threshold(objImageUnitToleranceROI.ref_ROI, objSampleROI.ref_ROI, m_intForeignMaterialBrightFieldThreshold);
            }
#endif
            if (blnDebugImage)
            {
                objImageUnitToleranceROI.SaveImage("D:\\TS\\objImageUnitToleranceROI.bmp");
                m_objInsSurfacePkgImage1.SaveImage("D:\\TS\\3.m_objInsSurfacePkgImage1.bmp");
                objSampleROI.SaveImage("D:\\TS\\4.objSampleROI.bmp");
            }

            // Get ready template ROI
            ROI objTemplateROI = new ROI();
            if (intInpectMode == 0) // Current use Inspect Mode
            {
                // Get threshold value
                int intThresholdValue;
                if (m_intThresholdValue < 0)
                {
                    EBW8 objBW8;
                    if (intImageIndex == 1)
                        objBW8 = EasyImage.AutoThreshold(m_ImgUnitTemplateImage, EThresholdMode.MinResidue);
                    else
                        objBW8 = EasyImage.AutoThreshold(m_ImgUnitTemplateImagePkg, EThresholdMode.MinResidue);
                    intThresholdValue = objBW8.Value;
                }
                else
                    intThresholdValue = m_intThresholdValue;

                if (blnDebugImage)
                {
                    m_ImgUnitTemplateImage.Save("D:\\TS\\5.m_ImgUnitTemplateImage.bmp");// debug
                    m_ImgTUnitErodeThresImage.Save("D:\\TS\\6.m_ImgTUnitErodeThresImage.bmp");// debug
                    m_ImgUnitTemplateImagePkg.Save("D:\\TS\\7.m_ImgUnitTemplateImagePkg.bmp");// debug
                    m_ImgTUnitErodeThresImagePkg.Save("D:\\TS\\8.m_ImgTUnitErodeThresImagePkg.bmp");// debug
                }
#if (Debug_2_12 || Release_2_12)
                if (intImageIndex == 1)
                {
                    if (m_ImgTUnitErodeThresImage.Width != m_ImgUnitTemplateImage.Width ||
                        m_ImgTUnitErodeThresImage.Height != m_ImgUnitTemplateImage.Height)
                    {
                        m_ImgTUnitErodeThresImage.SetSize(m_ImgUnitTemplateImage.Width, m_ImgUnitTemplateImage.Height);
                    }

                    EasyImage.Copy(m_ImgUnitTemplateImage, m_ImgTUnitErodeThresImage);
                    // single threshold template image
                    if (m_fPadImageGain != 1f)
                    {
                        EasyImage.GainOffset(m_ImgTUnitErodeThresImage, m_ImgTUnitErodeThresImage, m_fPadImageGain);
                        EasyImage.Threshold(m_ImgTUnitErodeThresImage, m_ImgTUnitErodeThresImage, (uint)intThresholdValue);
                    }
                    else
                    {
                        EasyImage.Threshold(m_ImgTUnitErodeThresImage, m_ImgTUnitErodeThresImage, (uint)intThresholdValue);
                    }

                    objTemplateROI.ref_ROI.Detach();
                    objTemplateROI.ref_ROI.Attach(m_ImgTUnitErodeThresImage);
                    objTemplateROI.LoadROISetting(m_ImgTUnitErodeThresImage.Width / 2 - objImageUnitToleranceROI.ref_ROIWidth / 2,
                                                  m_ImgTUnitErodeThresImage.Height / 2 - objImageUnitToleranceROI.ref_ROIHeight / 2,
                                                  objImageUnitToleranceROI.ref_ROIWidth,
                                                  objImageUnitToleranceROI.ref_ROIHeight);
                }
                else
                {
                    EasyImage.Copy(m_ImgUnitTemplateImagePkg, m_ImgTUnitErodeThresImagePkg);
                    // single threshold template image
                    if (m_fPadImageGain != 1f)
                    {
                        EasyImage.GainOffset(m_ImgTUnitErodeThresImagePkg, m_ImgTUnitErodeThresImagePkg, m_fPadImageGain);
                        EasyImage.Threshold(m_ImgTUnitErodeThresImagePkg, m_ImgTUnitErodeThresImagePkg, (uint)intThresholdValue);
                    }
                    else
                    {
                        EasyImage.Threshold(m_ImgTUnitErodeThresImagePkg, m_ImgTUnitErodeThresImagePkg, (uint)intThresholdValue);
                    }
                    objTemplateROI.ref_ROI.Detach();
                    objTemplateROI.ref_ROI.Attach(m_ImgTUnitErodeThresImagePkg);
                    objTemplateROI.LoadROISetting(0, 0, objImageUnitROI.ref_ROIWidth, objImageUnitROI.ref_ROIHeight);
                }

#elif (DEBUG || RELEASE || RTXRelease || RTXDebug)
                if (intImageIndex == 1)
                {
                    if (m_ImgTUnitErodeThresImage.Width != m_ImgUnitTemplateImage.Width ||
                        m_ImgTUnitErodeThresImage.Height != m_ImgUnitTemplateImage.Height)
                    {
                        m_ImgTUnitErodeThresImage.SetSize(m_ImgUnitTemplateImage.Width, m_ImgUnitTemplateImage.Height);
                    }

                    EasyImage.Copy(m_ImgUnitTemplateImage, m_ImgTUnitErodeThresImage);
                    // single threshold template image
                    if (m_fPadImageGain != 1f)
                    {
                        EasyImage.GainOffset(m_ImgTUnitErodeThresImage, m_ImgTUnitErodeThresImage, m_fPadImageGain);
                        EasyImage.Threshold(m_ImgTUnitErodeThresImage, m_ImgTUnitErodeThresImage, intThresholdValue);
                    }
                    else
                    {
                        EasyImage.Threshold(m_ImgTUnitErodeThresImage, m_ImgTUnitErodeThresImage, intThresholdValue);
                    }
                    objTemplateROI.ref_ROI.Detach();
                    objTemplateROI.ref_ROI.Attach(m_ImgTUnitErodeThresImage);
                    objTemplateROI.LoadROISetting(m_ImgTUnitErodeThresImage.Width / 2 - objImageUnitToleranceROI.ref_ROIWidth / 2,
                                                  m_ImgTUnitErodeThresImage.Height / 2 - objImageUnitToleranceROI.ref_ROIHeight / 2,
                                                  objImageUnitToleranceROI.ref_ROIWidth,
                                                  objImageUnitToleranceROI.ref_ROIHeight);
                }
                else
                {
                    EasyImage.Copy(m_ImgUnitTemplateImagePkg, m_ImgTUnitErodeThresImagePkg);
                    // single threshold template image
                    if (m_fPadImageGain != 1f)
                    {
                        EasyImage.GainOffset(m_ImgTUnitErodeThresImagePkg, m_ImgTUnitErodeThresImagePkg, m_fPadImageGain);
                        EasyImage.Threshold(m_ImgTUnitErodeThresImagePkg, m_ImgTUnitErodeThresImagePkg, (uint)intThresholdValue);
                    }
                    else
                    {
                        EasyImage.Threshold(m_ImgTUnitErodeThresImagePkg, m_ImgTUnitErodeThresImagePkg, intThresholdValue);
                    }
                    objTemplateROI.ref_ROI.Detach();
                    objTemplateROI.ref_ROI.Attach(m_ImgTUnitErodeThresImagePkg);
                    objTemplateROI.LoadROISetting(0, 0, objImageUnitROI.ref_ROIWidth, objImageUnitROI.ref_ROIHeight);
                }

#endif

                if (blnDebugImage)
                {
                    objImageUnitROI.SaveImage("D:\\TS\\9.B_OriSampleROI.bmp");// debug
                    m_ImgUnitTemplateImage.Save("D:\\TS\\10.B_OriTemplateImage.bmp");// debug
                    m_ImgTUnitErodeThresImage.Save("D:\\TS\\11.B_m_ImgTUnitErodeThresImage.bmp");// debug
                    objTemplateROI.SaveImage("D:\\TS\\12.B_objTemplateROI.bmp");// debug
                    objSampleROI.SaveImage("D:\\TS\\13.B_objSampleROI.bmp");// debug
                }
            }

            if (intImageIndex == 1)
            {
                // Get ready blank black image
                m_ImgBlackUnitTemplateImage.CopyTo(m_ImgBlackUnitTemplateImage2);
            }
            else
            {
                // Get ready blank white image
                m_ImgWhiteUnitTemplateImagePkg.CopyTo(m_ImgWhiteUnitTemplateImage2);
            }

            ROI objTemplateROI2 = new ROI();
            objTemplateROI2.ref_ROI.Detach();
            if (intImageIndex == 1)
            {
                objTemplateROI2.ref_ROI.Attach(m_ImgBlackUnitTemplateImage2);
            }
            else
            {
                objTemplateROI2.ref_ROI.Attach(m_ImgWhiteUnitTemplateImage2);
            }

            objTemplateROI2.LoadROISetting(0, 0, objImageUnitToleranceROI.ref_ROIWidth, objImageUnitToleranceROI.ref_ROIHeight);


            if (blnDebugImage)
                objTemplateROI2.SaveImage("D:\\TS\\14.BlankTemplateROI2.bmp");// debug

            if (intInpectMode == 0)
            {
                #region Inspect Mode == 0
                int[] arrTemplateStartX = new int[m_arrTemplateBlobPads.Count];
                int[] arrTemplateStartY = new int[m_arrTemplateBlobPads.Count];
                int[] arrTemplateEndX = new int[m_arrTemplateBlobPads.Count];
                int[] arrTemplateEndY = new int[m_arrTemplateBlobPads.Count];
                int[] arrSampleStartX = new int[m_arrTemplateBlobPads.Count];
                int[] arrSampleStartY = new int[m_arrTemplateBlobPads.Count];
                int[] arrSampleEndX = new int[m_arrTemplateBlobPads.Count];
                int[] arrSampleEndY = new int[m_arrTemplateBlobPads.Count];
                int[] arrTemplateSampleWidth = new int[m_arrTemplateBlobPads.Count];
                int[] arrTemplateSampleHeight = new int[m_arrTemplateBlobPads.Count];
                int[] arrDifferentSizeX = new int[m_arrTemplateBlobPads.Count]; // Template and sample different size
                int[] arrDifferentSizeY = new int[m_arrTemplateBlobPads.Count]; // Template and sample different size
                int[] arrOffsetStartX = new int[m_arrTemplateBlobPads.Count];
                int[] arrOffsetStartY = new int[m_arrTemplateBlobPads.Count];

                DefinePadSubtractOffset(objTemplateROI, m_intMPDilateHalfWidth, m_ImgBlackUnitTemplateImage2.Width - 1, m_ImgBlackUnitTemplateImage2.Height - 1,
                    ref arrTemplateStartX, ref arrTemplateStartY, ref arrTemplateEndX, ref arrTemplateEndY,
                    ref arrSampleStartX, ref arrSampleStartY, ref arrSampleEndX, ref arrSampleEndY,
                    ref arrTemplateSampleWidth, ref arrTemplateSampleHeight,
                    ref arrDifferentSizeX, ref arrDifferentSizeY,
                    ref arrOffsetStartX, ref arrOffsetStartY, false);

                //2021-03-12 ZJYEOH : Need Offset back when pad no use gauge but package got use gauge
                if (!GetOverallWantGaugeMeasurePkgSize(false))
                {
                    for (int i = 0; i < arrOffsetStartX.Length; i++)
                    {
                        arrOffsetStartX[i] += (int)(Math.Round(GetResultCenterPoint_UnitMatcher().X - GetResultCenterPoint_RectGauge4L().X));
                        arrOffsetStartY[i] += (int)(Math.Round(GetResultCenterPoint_UnitMatcher().Y - GetResultCenterPoint_RectGauge4L().Y));
                    }
                }

                for (int i = 0; i < m_arrTemplateBlobPads.Count; i++)
                {
                    if (m_arrSampleBlobPads[i].intFailMask != 0)
                        continue;

                    // Get template pad roi
                    ROI objTemplatePadROI = new ROI();
                    objTemplatePadROI.AttachImage(objTemplateROI);
                    objTemplatePadROI.LoadROISetting(arrTemplateStartX[i], arrTemplateStartY[i], arrTemplateSampleWidth[i], arrTemplateSampleHeight[i]);

                    if (blnDebugImage)
                    {
                        objTemplatePadROI.SaveImage("D:\\TS\\objTemplatePadROI.bmp");// debug
                    }

                    m_ImgMPUnitTemplateImage.SetSize(objTemplatePadROI.ref_ROIWidth, objTemplatePadROI.ref_ROIHeight);
                    EasyImage.Copy(objTemplatePadROI.ref_ROI, m_ImgMPUnitTemplateImage);

#if (Debug_2_12 || Release_2_12)
                    // 2019-09-27 ZJYEOH : Straight dilate according to setting
                    EasyImage.DilateBox(m_ImgMPUnitTemplateImage, objTemplatePadROI.ref_ROI, (uint)Math.Abs(m_intMPDilateHalfWidth), (uint)Math.Abs(m_intMPDilateHalfWidth));

#elif (DEBUG || RELEASE || RTXRelease || RTXDebug)
                    // 2019-09-27 ZJYEOH : Straight dilate according to setting
                    EasyImage.DilateBox(m_ImgMPUnitTemplateImage, objTemplatePadROI.ref_ROI, Math.Abs(m_intMPDilateHalfWidth), Math.Abs(m_intMPDilateHalfWidth));

#endif

                    // Get template2 pad ROI
                    ROI objTemplate2PadROI = new ROI();
                    objTemplate2PadROI.ref_ROI.Detach();
                    objTemplate2PadROI.ref_ROI.Attach(m_ImgBlackUnitTemplateImage2);
                    objTemplate2PadROI.LoadROISetting(arrSampleStartX[i] + arrOffsetStartX[i], arrSampleStartY[i] + arrOffsetStartY[i], arrTemplateSampleWidth[i], arrTemplateSampleHeight[i]);

                    if (blnDebugImage)
                    {
                        m_ImgBlackUnitTemplateImage2.Save("D:\\TS\\1_B_m_ImgBlackUnitTemplateImage2.bmp");
                        m_ImgMPUnitTemplateImage.Save("D:\\TS\\2_B_BfMPTemplateImage.bmp");// debug
                        objTemplatePadROI.SaveImage("D:\\TS\\3_B_AfMPTemplateImage.bmp");// debug
                        objTemplate2PadROI.SaveImage("D:\\TS\\4_B_BfSBTemplate2PadImage.bmp");// debug
                    }


                    if (objTemplatePadROI.ref_ROIWidth != objTemplate2PadROI.ref_ROIWidth)
                    {
                        int intSmallWidth = Math.Min(objTemplatePadROI.ref_ROIWidth, objTemplate2PadROI.ref_ROIWidth);
                        objTemplatePadROI.LoadROISetting(objTemplatePadROI.ref_ROIPositionX, objTemplatePadROI.ref_ROIPositionY, intSmallWidth, objTemplatePadROI.ref_ROIHeight);
                        objTemplate2PadROI.LoadROISetting(objTemplate2PadROI.ref_ROIPositionX, objTemplate2PadROI.ref_ROIPositionY, intSmallWidth, objTemplate2PadROI.ref_ROIHeight);
                    }

                    if (objTemplatePadROI.ref_ROIHeight != objTemplate2PadROI.ref_ROIHeight)
                    {
                        int intSmallHeight = Math.Min(objTemplatePadROI.ref_ROIHeight, objTemplate2PadROI.ref_ROIHeight);
                        objTemplatePadROI.LoadROISetting(objTemplatePadROI.ref_ROIPositionX, objTemplatePadROI.ref_ROIPositionY, objTemplatePadROI.ref_ROIWidth, intSmallHeight);
                        objTemplate2PadROI.LoadROISetting(objTemplate2PadROI.ref_ROIPositionX, objTemplate2PadROI.ref_ROIPositionY, objTemplate2PadROI.ref_ROIWidth, intSmallHeight);
                    }

                    // Add sample pad roi - template pad roi
                    EasyImage.Oper(EArithmeticLogicOperation.Add, objTemplate2PadROI.ref_ROI, objTemplatePadROI.ref_ROI, objTemplate2PadROI.ref_ROI);

                    if (blnDebugImage)
                    {
                        objTemplate2PadROI.SaveImage("D:\\TS\\B_AfSBTemplate2PadImage.bmp");// debug
                        objTemplateROI2.SaveImage("D:\\TS\\B_objTemplate2ROI.bmp");// debug
                    }

                    objTemplatePadROI.Dispose();
                    objTemplate2PadROI.Dispose();
                }

                #endregion
            }

            if (blnDebugImage)
            {
                objSampleROI.SaveImage("D:\\TS\\20.B_BfSBSampleROI.bmp");// debug
                objTemplateROI2.SaveImage("D:\\TS\\21.B_objTemplate2ROI.bmp");// debug
            }

            // Subtract sample ROI - template ROI
            if (objSampleROI.ref_ROIWidth != objTemplateROI2.ref_ROIWidth)
            {
                if (objSampleROI.ref_ROIWidth > objTemplateROI2.ref_ROIWidth)
                    objSampleROI.ref_ROIWidth = objTemplateROI2.ref_ROIWidth;
                else
                    objTemplateROI2.ref_ROIWidth = objSampleROI.ref_ROIWidth;
            }

            if (objSampleROI.ref_ROIHeight != objTemplateROI2.ref_ROIHeight)
            {
                if (objSampleROI.ref_ROIHeight > objTemplateROI2.ref_ROIHeight)
                    objSampleROI.ref_ROIHeight = objTemplateROI2.ref_ROIHeight;
                else
                    objTemplateROI2.ref_ROIHeight = objSampleROI.ref_ROIHeight;
            }

            if (blnDebugImage)
            {
                objSampleROI.SaveImage("D:\\TS\\22.B_BfSBSampleROI.bmp");// debug
                objTemplateROI2.SaveImage("D:\\TS\\23.B_objTemplate2ROI.bmp");// debug
                objTemplateROI.SaveImage("D:\\TS\\24.objTemplateROI.bmp");
            }


            if (intImageIndex == 1)
                EasyImage.Oper(EArithmeticLogicOperation.Subtract, objSampleROI.ref_ROI, objTemplateROI2.ref_ROI, objSampleROI.ref_ROI);    // 2019 05 14 - CCENG: Use templateROI2 because the pad location is according to sample ROI.
                                                                                                                                            //EasyImage.Oper(EArithmeticLogicOperation.Subtract, objSampleROI.ref_ROI, objTemplateROI.ref_ROI, objSampleROI.ref_ROI);

            //objSampleROI.SaveImage("D:\\objSampleROI.bmp");
            //objTemplateROI.SaveImage("D:\\objTemplateROI.bmp");
            if (blnDebugImage)
                objSampleROI.SaveImage("D:\\TS\\B_AfSBSampleROI.bmp");// debug

            if ((m_intFailPkgOptionMask & 0xC00000) > 0)
            {
                objSampleROI.LoadROISetting(objImageUnitROI.ref_ROITotalX,
                                            objImageUnitROI.ref_ROITotalY,
                                            objImageUnitROI.ref_ROIWidth, objImageUnitROI.ref_ROIHeight);

                if (m_objRectGauge4L.GetGaugeTiltAngle() == 0)
                {
                    if (!IsImage1UnitBrightFieldForeignMaterialFailed(objSampleROI, objSampleROI.ref_ROITotalX, objSampleROI.ref_ROITotalY, intImageIndex))
                    {
                        objSampleROI.Dispose();
                        //objTemplateROI.Dispose();
                        //objTemplateROI2.Dispose();
                        return false;
                    }
                }
                else
                {
                    if (!IsImage1UnitBrightFieldForeignMaterialFailed_TiltAngle(objSampleROI, objSampleROI.ref_ROITotalX, objSampleROI.ref_ROITotalY, intImageIndex, intPadIndex))
                    {
                        objSampleROI.Dispose();
                        //objTemplateROI.Dispose();
                        //objTemplateROI2.Dispose();
                        return false;
                    }
                }
            }

            objSampleROI.Dispose();
            //objTemplateROI.Dispose();
            //objTemplateROI2.Dispose();

            return blnResult;
        }
        private bool CheckImageScratchAndChipDefect(ROI objImageUnitToleranceROI, ROI objImageUnitROI, int intImageIndex, int intPadIndex)//, bool blnPadPkg)
        {
            /* This function is to do image processing for Chipped off and surface scratches test.
             * Skip this function if Chipped off and scratches test is disabled.
             * 
             * Image Processing:
             * 
             * 1. Double threshold sample image 
             *    using image 1 surface double threshold value 
             *    with class 255, 0 255.
             *    Mean defect area on surface will be while color. Good surface area will be black color.
             * 2. Single threshold template image 
             *    using Pad Threshold value 
             *    with class 0, 255
             * 3. Get ready a blank black image
             * 4. Scan each template pads, 
             *     based on different size between sample and template pad,
             *     Erode/dilate the template pads
             *     add the Erode/dilate template pads into the blank black image.
             *     Mean you will get a erode/dilate template with pad while color, surface area black color.
             * 5. Substract the Sample image - Erode/dilate template image.
             *     After substract, you will get defect surface area with white color, 
             *     good surface area will be black color, 
             *     pad area will be totally dark color. 
             * 6  Send final substract image for chipped off test and surface scratches test.
             *
             * 
             *
             */

            // Return if Contamination, Chipped off, Scratches Length and Area is OFF
            if (((m_intFailPkgOptionMask & 0x04) == 0) && ((m_intFailPkgOptionMask & 0x08) == 0) && ((m_intFailPkgOptionMask & 0x1000) == 0) && ((m_intFailPkgOptionMask & 0x70) == 0))
                return true;

            int intInpectMode = 0; //0=Flexi template size, 1= use sample size, 2: Fix template size
            bool blnResult = true;
            bool blnDebugImage = false;

            if (blnDebugImage)
            {
                objImageUnitToleranceROI.SaveImage("D:\\TS\\1.objImageUnitToleranceROI.bmp");
                objImageUnitROI.SaveImage("D:\\TS\\2.objImageUnitROI.bmp");
            }

            // Get ready sample ROI
            ROI objSampleROI = new ROI();
            objSampleROI.AttachImage(m_objInsSurfacePkgImage1);  // m_objInsSurfacePkgImage1 is temporary image use to hold objSampleROI double threshold
            objSampleROI.LoadROISetting(objImageUnitToleranceROI.ref_ROITotalX, objImageUnitToleranceROI.ref_ROITotalY, objImageUnitToleranceROI.ref_ROIWidth, objImageUnitToleranceROI.ref_ROIHeight);
#if (Debug_2_12 || Release_2_12)
            // Gain and Double threshold
            switch (intImageIndex)
            {
                case 1: // Image 1 (Grab 1 & Grab 2 Merged)
                    {
                        if (m_fPkgImage1Gain != 1f)
                        {
                            EasyImage.GainOffset(objImageUnitToleranceROI.ref_ROI, objSampleROI.ref_ROI, m_fPkgImage1Gain);
                            EasyImage.DoubleThreshold(objSampleROI.ref_ROI, objSampleROI.ref_ROI, (uint)m_intPkgImage1LowSurfaceThreshold, (uint)m_intPkgImage1HighSurfaceThreshold, 0, 255, 0); // WinXP (255,0,255) , Win7 (0,255,0)
                        }
                        else
                        {
                            EasyImage.DoubleThreshold(objImageUnitToleranceROI.ref_ROI, objSampleROI.ref_ROI, (uint)m_intPkgImage1LowSurfaceThreshold, (uint)m_intPkgImage1HighSurfaceThreshold, 0, 255, 0);// WinXP (255,0,255) , Win7 (0,255,0)
                        }
                    }
                    break;
                case 2: // Image 2 (Grab 3)
                    {
                        EasyImage.DoubleThreshold(objImageUnitToleranceROI.ref_ROI, objSampleROI.ref_ROI, (uint)m_intPkgImage2LowThreshold, (uint)m_intPkgImage2HighThreshold, 0, 255, 0);// WinXP (255,0,255) , Win7 (0,255,0)
                    }
                    break;
            }

#elif (DEBUG || RELEASE || RTXRelease || RTXDebug)
            // Gain and Double threshold
            switch (intImageIndex)
            {
                case 1: // Image 1 (Grab 1 & Grab 2 Merged)
                    {
                        if (m_fPkgImage1Gain != 1f)
                        {
                            EasyImage.GainOffset(objImageUnitToleranceROI.ref_ROI, objSampleROI.ref_ROI, m_fPkgImage1Gain);
                            EasyImage.DoubleThreshold(objSampleROI.ref_ROI, objSampleROI.ref_ROI, m_intPkgImage1LowSurfaceThreshold, m_intPkgImage1HighSurfaceThreshold, 0, 255, 0); // WinXP (255,0,255) , Win7 (0,255,0)
                        }
                        else
                        {
                            EasyImage.DoubleThreshold(objImageUnitToleranceROI.ref_ROI, objSampleROI.ref_ROI, m_intPkgImage1LowSurfaceThreshold, m_intPkgImage1HighSurfaceThreshold, 0, 255, 0);// WinXP (255,0,255) , Win7 (0,255,0)
                        }
                    }
                    break;
                case 2: // Image 2 (Grab 3)
                    {
                        EasyImage.DoubleThreshold(objImageUnitToleranceROI.ref_ROI, objSampleROI.ref_ROI, m_intPkgImage2LowThreshold, m_intPkgImage2HighThreshold, 0, 255, 0);// WinXP (255,0,255) , Win7 (0,255,0)
                    }
                    break;
            }

#endif

            if (blnDebugImage)
            {
                objImageUnitToleranceROI.SaveImage("D:\\TS\\objImageUnitToleranceROI.bmp");
                m_objInsSurfacePkgImage1.SaveImage("D:\\TS\\3.m_objInsSurfacePkgImage1.bmp");
                objSampleROI.SaveImage("D:\\TS\\4.objSampleROI.bmp");
            }

            // Get ready template ROI
            ROI objTemplateROI = new ROI();
            if (intInpectMode == 0)
            {
                // Get threshold value
                int intThresholdValue;
                if (m_intThresholdValue < 0)
                {
                    EBW8 objBW8;
                    if (intImageIndex == 1)
                        objBW8 = EasyImage.AutoThreshold(m_ImgUnitTemplateImage, EThresholdMode.MinResidue);
                    else
                        objBW8 = EasyImage.AutoThreshold(m_ImgUnitTemplateImagePkg, EThresholdMode.MinResidue);
                    intThresholdValue = objBW8.Value;
                }
                else
                    intThresholdValue = m_intThresholdValue;

                if (blnDebugImage)
                {
                    m_ImgUnitTemplateImage.Save("D:\\TS\\5.m_ImgUnitTemplateImage.bmp");// debug
                    m_ImgTUnitErodeThresImage.Save("D:\\TS\\6.m_ImgTUnitErodeThresImage.bmp");// debug
                    m_ImgUnitTemplateImagePkg.Save("D:\\TS\\7.m_ImgUnitTemplateImagePkg.bmp");// debug
                    m_ImgTUnitErodeThresImagePkg.Save("D:\\TS\\8.m_ImgTUnitErodeThresImagePkg.bmp");// debug
                }
#if (Debug_2_12 || Release_2_12)
                if (intImageIndex == 1)
                {
                    EasyImage.Copy(m_ImgUnitTemplateImage, m_ImgTUnitErodeThresImage);
                    // single threshold template image
                    if (m_fPadImageGain != 1f)
                    {
                        EasyImage.GainOffset(m_ImgTUnitErodeThresImage, m_ImgTUnitErodeThresImage, m_fPadImageGain);
                        EasyImage.Threshold(m_ImgTUnitErodeThresImage, m_ImgTUnitErodeThresImage, (uint)intThresholdValue);
                    }
                    else
                    {
                        EasyImage.Threshold(m_ImgTUnitErodeThresImage, m_ImgTUnitErodeThresImage, (uint)intThresholdValue);
                    }

                    objTemplateROI.ref_ROI.Detach();
                    objTemplateROI.ref_ROI.Attach(m_ImgTUnitErodeThresImage);
                    objTemplateROI.LoadROISetting(m_ImgTUnitErodeThresImage.Width / 2 - objImageUnitToleranceROI.ref_ROIWidth / 2,
                                                  m_ImgTUnitErodeThresImage.Height / 2 - objImageUnitToleranceROI.ref_ROIHeight / 2,
                                                  objImageUnitToleranceROI.ref_ROIWidth,
                                                  objImageUnitToleranceROI.ref_ROIHeight);
                }
                else
                {
                    EasyImage.Copy(m_ImgUnitTemplateImagePkg, m_ImgTUnitErodeThresImagePkg);
                    // single threshold template image
                    if (m_fPadImageGain != 1f)
                    {
                        EasyImage.GainOffset(m_ImgTUnitErodeThresImagePkg, m_ImgTUnitErodeThresImagePkg, m_fPadImageGain);
                        EasyImage.Threshold(m_ImgTUnitErodeThresImagePkg, m_ImgTUnitErodeThresImagePkg, (uint)intThresholdValue);
                    }
                    else
                    {
                        EasyImage.Threshold(m_ImgTUnitErodeThresImagePkg, m_ImgTUnitErodeThresImagePkg, (uint)intThresholdValue);
                    }

                    objTemplateROI.ref_ROI.Detach();
                    objTemplateROI.ref_ROI.Attach(m_ImgTUnitErodeThresImagePkg);
                    objTemplateROI.LoadROISetting(0, 0, objImageUnitROI.ref_ROIWidth, objImageUnitROI.ref_ROIHeight);
                }

#elif (DEBUG || RELEASE || RTXRelease || RTXDebug)
                if (intImageIndex == 1)
                {
                    EasyImage.Copy(m_ImgUnitTemplateImage, m_ImgTUnitErodeThresImage);
                    // single threshold template image
                    if (m_fPadImageGain != 1f)
                    {
                        EasyImage.GainOffset(m_ImgTUnitErodeThresImage, m_ImgTUnitErodeThresImage, m_fPadImageGain);
                        EasyImage.Threshold(m_ImgTUnitErodeThresImage, m_ImgTUnitErodeThresImage, intThresholdValue);
                    }
                    else
                    {
                        EasyImage.Threshold(m_ImgTUnitErodeThresImage, m_ImgTUnitErodeThresImage, intThresholdValue);
                    }
                    objTemplateROI.ref_ROI.Detach();
                    objTemplateROI.ref_ROI.Attach(m_ImgTUnitErodeThresImage);
                    objTemplateROI.LoadROISetting(m_ImgTUnitErodeThresImage.Width / 2 - objImageUnitToleranceROI.ref_ROIWidth / 2,
                                                  m_ImgTUnitErodeThresImage.Height / 2 - objImageUnitToleranceROI.ref_ROIHeight / 2,
                                                  objImageUnitToleranceROI.ref_ROIWidth,
                                                  objImageUnitToleranceROI.ref_ROIHeight);
                }
                else
                {
                    EasyImage.Copy(m_ImgUnitTemplateImagePkg, m_ImgTUnitErodeThresImagePkg);
                    // single threshold template image
                    if (m_fPadImageGain != 1f)
                    {
                        EasyImage.GainOffset(m_ImgTUnitErodeThresImagePkg, m_ImgTUnitErodeThresImagePkg, m_fPadImageGain);
                        EasyImage.Threshold(m_ImgTUnitErodeThresImagePkg, m_ImgTUnitErodeThresImagePkg, intThresholdValue);
                    }
                    else
                    {
                        EasyImage.Threshold(m_ImgTUnitErodeThresImagePkg, m_ImgTUnitErodeThresImagePkg, intThresholdValue);
                    }
                    objTemplateROI.ref_ROI.Detach();
                    objTemplateROI.ref_ROI.Attach(m_ImgTUnitErodeThresImagePkg);
                    objTemplateROI.LoadROISetting(0, 0, objImageUnitROI.ref_ROIWidth, objImageUnitROI.ref_ROIHeight);
                }

#endif

                if (blnDebugImage)
                {
                    objImageUnitROI.SaveImage("D:\\TS\\9.B_OriSampleROI.bmp");// debug
                    m_ImgUnitTemplateImage.Save("D:\\TS\\10.B_OriTemplateImage.bmp");// debug
                    m_ImgTUnitErodeThresImage.Save("D:\\TS\\11.B_m_ImgTUnitErodeThresImage.bmp");// debug
                    objTemplateROI.SaveImage("D:\\TS\\12.B_objTemplateROI.bmp");// debug
                    objSampleROI.SaveImage("D:\\TS\\13.B_objSampleROI.bmp");// debug
                }
            }

            if (intImageIndex == 1)
            {
                // Get ready blank black image
                m_ImgBlackUnitTemplateImage.CopyTo(m_ImgBlackUnitTemplateImage2);
            }
            else
            {
                // Get ready blank white image
                m_ImgWhiteUnitTemplateImagePkg.CopyTo(m_ImgWhiteUnitTemplateImage2);
            }

            ROI objTemplateROI2 = new ROI();
            objTemplateROI2.ref_ROI.Detach();
            if (intImageIndex == 1)
            {
                objTemplateROI2.ref_ROI.Attach(m_ImgBlackUnitTemplateImage2);
            }
            else
            {
                objTemplateROI2.ref_ROI.Attach(m_ImgWhiteUnitTemplateImage2);
            }

            objTemplateROI2.LoadROISetting(0, 0, objImageUnitToleranceROI.ref_ROIWidth, objImageUnitToleranceROI.ref_ROIHeight);


            if (blnDebugImage)
                objTemplateROI2.SaveImage("D:\\TS\\14.BlankTemplateROI2.bmp");// debug

            int intStartX, intStartY, intEndX, intEndY, intAdjustX, intAdjustY, intStartX2, intStartY2, intWidth, intHeight;

            if (intInpectMode == 0)
            {
                #region Inspect Mode == 0
                int intToleSize = m_intMPDilateHalfWidth;

                for (int i = 0; i < m_arrTemplateBlobPads.Count; i++)
                {
                    if (m_arrSampleBlobPads[i].intFailMask != 0)
                        continue;

                    // check the different size between sample pad and template pad
                    int intDiffSizeWidth = (int)Math.Round((m_arrSampleBlobPads[i].fWidth - ((BlobsFeatures)m_arrTemplateBlobPads[i]).fWidth) / 2, 0, MidpointRounding.AwayFromZero);
                    int intDiffSizeHeight = (int)Math.Round((m_arrSampleBlobPads[i].fHeight - ((BlobsFeatures)m_arrTemplateBlobPads[i]).fHeight) / 2, 0, MidpointRounding.AwayFromZero);

                    // set one of the size (width or height) to zero if one side is bigger and another side is smaller
                    if ((intDiffSizeWidth > 0 && intDiffSizeHeight < 0) || (intDiffSizeHeight > 0 && intDiffSizeWidth < 0))
                    {
                        if (Math.Abs(intDiffSizeWidth) > Math.Abs(intDiffSizeHeight))    // the bigger value will set to 0
                            intDiffSizeHeight = 0;
                        else
                            intDiffSizeWidth = 0;
                    }

                    float fWidth, fHeight;
                    // get bigger size from sample pad or template pad
                    if ((intDiffSizeWidth > 0) || (intDiffSizeHeight > 0))
                    {
                        // Use sample size
                        fWidth = m_arrSampleBlobPads[i].fWidth;
                        fHeight = m_arrSampleBlobPads[i].fHeight;
                    }
                    else
                    {
                        // Use template size
                        fWidth = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fWidth;
                        fHeight = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fHeight;
                    }

                    // Get "template" pad start and end corner point with tolerance size added.
                    intAdjustX = 0;
                    intAdjustY = 0;
                    intStartX = (int)Math.Round(((BlobsFeatures)m_arrTemplateBlobPads[i]).fLimitCenterX - fWidth / 2 - intToleSize, 0, MidpointRounding.AwayFromZero);
                    if (intStartX < 0)  // Set to zero if value smaller than zero
                    {
                        intAdjustX = intStartX; // add adjust value when intStartX change from negative to 0
                        intStartX = 0;
                    }
                    intStartY = (int)Math.Round(((BlobsFeatures)m_arrTemplateBlobPads[i]).fLimitCenterY - fHeight / 2 - intToleSize, 0, MidpointRounding.AwayFromZero);
                    if (intStartY < 0)  // Set to zero if value smaller than zero
                    {
                        intAdjustY = intStartY; // add adjust value when intStartY change from negative to 0
                        intStartY = 0;
                    }

                    // Get "sample" pad start and end corner point with tolerance size added.
                    intStartX2 = (int)Math.Round(m_arrSampleBlobPads[i].fCenterX - fWidth / 2 - intToleSize, 0, MidpointRounding.AwayFromZero);
                    if (intStartX2 < 0) // Set to zero if value smaller than zero
                    {
                        if (intStartX2 > intAdjustX)    // set bigger value in adjust value // Why is bigger, not smaller?
                            intAdjustX = intStartX2;
                        intStartX2 = 0;
                    }
                    intStartY2 = (int)Math.Round(m_arrSampleBlobPads[i].fCenterY - fHeight / 2 - intToleSize, 0, MidpointRounding.AwayFromZero);
                    if (intStartY2 < 0) // Set to zero if value smaller than zero
                    {
                        if (intStartY2 > intAdjustY)    // set bigger value in adjust value // Why is bigger, not smaller?
                            intAdjustY = intStartY2;
                        intStartY2 = 0;
                    }

                    // Set "template" pad width with tolerance size and adjust value added
                    intWidth = (int)Math.Round(fWidth + intToleSize * 2, 0, MidpointRounding.AwayFromZero);
                    intEndX = intStartX + intWidth + intAdjustX;
                    int intEndAdjustX = 0;
                    if (intEndX > objTemplateROI.ref_ROIWidth - 1)
                    {
                        intEndAdjustX = (intEndX - (objTemplateROI.ref_ROIWidth - 1));  // Set end adjust value if endx bigger than roi area
                    }
                    intHeight = (int)Math.Round(fHeight + intToleSize * 2, 0, MidpointRounding.AwayFromZero);
                    intEndY = intStartY + intHeight + intAdjustY;
                    int intEndAdjustY = 0;
                    if (intEndY > objTemplateROI.ref_ROIHeight - 1)
                    {
                        intEndAdjustY = (intEndY - (objTemplateROI.ref_ROIHeight)); // Set end adjust value if endx bigger than roi area
                    }

                    // set pad corner end point value
                    //intEndX = intStartX2 + intWidth + intToleSize * 2 + intAdjustX;
                    intEndX = intStartX2 + intWidth + intAdjustX;
                    if (intEndX > m_ImgBlackUnitTemplateImage2.Width - 1)
                    {
                        if (intEndAdjustX < (intEndX - (m_ImgBlackUnitTemplateImage2.Width - 1)))
                            intEndAdjustX = (intEndX - (m_ImgBlackUnitTemplateImage2.Width - 1));
                    }
                    //intEndY = intStartY2 + intHeight + intToleSize * 2 + intAdjustY;
                    intEndY = intStartY2 + intHeight + intAdjustY;
                    if (intEndY > m_ImgBlackUnitTemplateImage2.Height - 1)
                    {
                        if (intEndAdjustY < (intEndY - (m_ImgBlackUnitTemplateImage2.Height - 1)))
                            intEndAdjustY = (intEndY - (m_ImgBlackUnitTemplateImage2.Height - 1));
                    }

                    intWidth -= intEndAdjustX;
                    intHeight -= intEndAdjustY;

                    // Get template pad roi
                    ROI objTemplatePadROI = new ROI();
                    objTemplatePadROI.AttachImage(objTemplateROI);
                    objTemplatePadROI.LoadROISetting(intStartX, intStartY, intWidth, intHeight);

                    if (blnDebugImage)
                    {
                        objTemplatePadROI.SaveImage("D:\\TS\\objTemplatePadROI.bmp");// debug
                    }

                    m_ImgMPUnitTemplateImage.SetSize(objTemplatePadROI.ref_ROIWidth, objTemplatePadROI.ref_ROIHeight);
                    EasyImage.Copy(objTemplatePadROI.ref_ROI, m_ImgMPUnitTemplateImage);

                    if (intDiffSizeWidth < -intToleSize)
                        intDiffSizeWidth = -intToleSize;
                    else if (intDiffSizeWidth > intToleSize)
                        intDiffSizeWidth = intToleSize;

                    if (intDiffSizeHeight < -intToleSize)
                        intDiffSizeHeight = -intToleSize;
                    else if (intDiffSizeHeight > intToleSize)
                        intDiffSizeHeight = intToleSize;
#if (Debug_2_12 || Release_2_12)
                    if ((intDiffSizeWidth < 0) || (intDiffSizeHeight < 0))
                    {
                        int intDiffSizeWidth2 = intDiffSizeWidth + m_intMPErodeHalfWidth;
                        int intDiffSizeHeight2 = intDiffSizeHeight + m_intMPErodeHalfWidth;
                        if ((intDiffSizeWidth2 > 0 && intDiffSizeHeight2 < 0) || (intDiffSizeHeight2 > 0 && intDiffSizeWidth2 < 0))
                        {
                            if (Math.Abs(intDiffSizeWidth2) > Math.Abs(intDiffSizeHeight2))
                                intDiffSizeHeight2 = 0;
                            else
                                intDiffSizeWidth2 = 0;
                        }

                        if ((intDiffSizeWidth2 < 0) || (intDiffSizeHeight2 < 0))
                        {
                            EasyImage.ErodeBox(m_ImgMPUnitTemplateImage, objTemplatePadROI.ref_ROI, (uint)Math.Abs(intDiffSizeWidth2), (uint)Math.Abs(intDiffSizeHeight2));
                        }
                        else
                        {

                            intDiffSizeWidth2 = intDiffSizeWidth + m_intMPDilateHalfWidth;
                            intDiffSizeHeight2 = intDiffSizeHeight2 + m_intMPDilateHalfWidth;
                            if ((intDiffSizeWidth2 > 0 && intDiffSizeHeight2 < 0) || (intDiffSizeHeight2 > 0 && intDiffSizeWidth2 < 0))
                            {
                                if (Math.Abs(intDiffSizeWidth2) > Math.Abs(intDiffSizeHeight2))
                                    intDiffSizeHeight2 = 0;
                                else
                                    intDiffSizeWidth2 = 0;
                            }

                            if ((intDiffSizeWidth2 < 0) || (intDiffSizeHeight2 < 0))
                            {
                            }
                            else
                            {
                                EasyImage.DilateBox(m_ImgMPUnitTemplateImage, objTemplatePadROI.ref_ROI, (uint)Math.Abs(intDiffSizeWidth2), (uint)Math.Abs(intDiffSizeHeight2));
                            }
                        }
                    }
                    else
                    {
                        if ((Math.Abs(intDiffSizeWidth) + m_intMPDilateHalfWidth) > 0 || (Math.Abs(intDiffSizeHeight) + m_intMPDilateHalfWidth) > 0)
                            EasyImage.DilateBox(m_ImgMPUnitTemplateImage, objTemplatePadROI.ref_ROI, (uint)(Math.Abs(intDiffSizeWidth) + m_intMPDilateHalfWidth), (uint)(Math.Abs(intDiffSizeHeight) + m_intMPDilateHalfWidth));
                    }

#elif (DEBUG || RELEASE || RTXRelease || RTXDebug)
                    if ((intDiffSizeWidth < 0) || (intDiffSizeHeight < 0))
                    {
                        int intDiffSizeWidth2 = intDiffSizeWidth + m_intMPErodeHalfWidth;
                        int intDiffSizeHeight2 = intDiffSizeHeight + m_intMPErodeHalfWidth;
                        if ((intDiffSizeWidth2 > 0 && intDiffSizeHeight2 < 0) || (intDiffSizeHeight2 > 0 && intDiffSizeWidth2 < 0))
                        {
                            if (Math.Abs(intDiffSizeWidth2) > Math.Abs(intDiffSizeHeight2))
                                intDiffSizeHeight2 = 0;
                            else
                                intDiffSizeWidth2 = 0;
                        }

                        if ((intDiffSizeWidth2 < 0) || (intDiffSizeHeight2 < 0))
                        {
                            EasyImage.ErodeBox(m_ImgMPUnitTemplateImage, objTemplatePadROI.ref_ROI, Math.Abs(intDiffSizeWidth2), Math.Abs(intDiffSizeHeight2));
                        }
                        else
                        {

                            intDiffSizeWidth2 = intDiffSizeWidth + m_intMPDilateHalfWidth;
                            intDiffSizeHeight2 = intDiffSizeHeight2 + m_intMPDilateHalfWidth;
                            if ((intDiffSizeWidth2 > 0 && intDiffSizeHeight2 < 0) || (intDiffSizeHeight2 > 0 && intDiffSizeWidth2 < 0))
                            {
                                if (Math.Abs(intDiffSizeWidth2) > Math.Abs(intDiffSizeHeight2))
                                    intDiffSizeHeight2 = 0;
                                else
                                    intDiffSizeWidth2 = 0;
                            }

                            if ((intDiffSizeWidth2 < 0) || (intDiffSizeHeight2 < 0))
                            {
                            }
                            else
                            {
                                EasyImage.DilateBox(m_ImgMPUnitTemplateImage, objTemplatePadROI.ref_ROI, Math.Abs(intDiffSizeWidth2), Math.Abs(intDiffSizeHeight2));
                            }
                        }
                    }
                    else
                    {
                        if ((Math.Abs(intDiffSizeWidth) + m_intMPDilateHalfWidth) > 0 || (Math.Abs(intDiffSizeHeight) + m_intMPDilateHalfWidth) > 0)
                            EasyImage.DilateBox(m_ImgMPUnitTemplateImage, objTemplatePadROI.ref_ROI, Math.Abs(intDiffSizeWidth) + m_intMPDilateHalfWidth, Math.Abs(intDiffSizeHeight) + m_intMPDilateHalfWidth);
                    }

#endif

                    if (!GetOverallWantGaugeMeasurePkgSize(false))
                    {
                        intStartX2 += (int)Math.Round(GetResultCenterPoint_UnitMatcher().X - GetResultCenterPoint_RectGauge4L().X);
                        intStartY2 += (int)Math.Round(GetResultCenterPoint_UnitMatcher().Y - GetResultCenterPoint_RectGauge4L().Y);
                    }

                    // Get template2 pad ROI
                    ROI objTemplate2PadROI = new ROI();
                    objTemplate2PadROI.ref_ROI.Detach();
                    objTemplate2PadROI.ref_ROI.Attach(m_ImgBlackUnitTemplateImage2);
                    objTemplate2PadROI.LoadROISetting(intStartX2, intStartY2, intWidth, intHeight);

                    if (blnDebugImage)
                    {
                        m_ImgMPUnitTemplateImage.Save("D:\\TS\\B_BfMPTemplateImage.bmp");// debug
                        objTemplatePadROI.SaveImage("D:\\TS\\B_AfMPTemplateImage.bmp");// debug
                        objTemplate2PadROI.SaveImage("D:\\TS\\B_BfSBTemplate2PadImage.bmp");// debug
                    }

                    // Add sample pad roi - template pad roi
                    EasyImage.Oper(EArithmeticLogicOperation.Add, objTemplate2PadROI.ref_ROI, objTemplatePadROI.ref_ROI, objTemplate2PadROI.ref_ROI);

                    if (blnDebugImage)
                    {
                        objTemplate2PadROI.SaveImage("D:\\TS\\B_AfSBTemplate2PadImage.bmp");// debug
                        objTemplateROI2.SaveImage("D:\\TS\\B_objTemplate2ROI.bmp");// debug
                    }

                    objTemplatePadROI.Dispose();
                    objTemplate2PadROI.Dispose();
                }

                #endregion
            }
            else if (intInpectMode == 1)
            {
                #region Inspect Mode == 1
                for (int i = 0; i < m_arrSampleBlobPads.Length; i++)
                {
                    if (m_arrSampleBlobPads[i].intFailMask != 0)
                        continue;

                    intStartX = (int)Math.Floor(m_arrSampleBlobPads[i].fStartX);
                    intStartY = (int)Math.Floor(m_arrSampleBlobPads[i].fStartY);

                    intStartX2 = (int)Math.Floor(m_arrSampleBlobPads[i].fCenterX - m_arrSampleBlobPads[i].fWidth / 2);
                    intStartY2 = (int)Math.Floor(m_arrSampleBlobPads[i].fCenterY - m_arrSampleBlobPads[i].fHeight / 2);

                    intWidth = (int)Math.Ceiling(m_arrSampleBlobPads[i].fWidth) + 1;
                    intHeight = (int)Math.Ceiling(m_arrSampleBlobPads[i].fHeight) + 1;

                    // Get template pad roi
                    ROI objTemplatePadROI = new ROI();
                    objTemplatePadROI.AttachImage(objTemplateROI);
                    objTemplatePadROI.LoadROISetting(intStartX, intStartY, intWidth, intHeight);

                    // Get Sample pad ROI
                    ROI objTemplate2PadROI = new ROI();
                    objTemplate2PadROI.ref_ROI.Detach();
                    objTemplate2PadROI.ref_ROI.Attach(m_ImgBlackUnitTemplateImage2);
                    objTemplate2PadROI.LoadROISetting(intStartX2, intStartY2, intWidth, intHeight);

                    // subtract sample pad roi - template pad roi
                    EasyImage.Oper(EArithmeticLogicOperation.Add, objTemplate2PadROI.ref_ROI, objTemplatePadROI.ref_ROI, objTemplate2PadROI.ref_ROI);

                    objTemplatePadROI.Dispose();
                    objTemplate2PadROI.Dispose();
                }
                #endregion 
            }
            else
            {
                #region Inspect mode == 2
                for (int i = 0; i < m_arrTemplateBlobPads.Count; i++)
                {
                    if (m_arrSampleBlobPads[i].intFailMask != 0)
                        continue;

                    intAdjustX = 0;
                    intAdjustY = 0;
                    intStartX = ((BlobsFeatures)m_arrTemplateBlobPads[i]).intStartX - 3;
                    if (intStartX < 0)
                    {
                        intAdjustX = intStartX;
                        intStartX = 0;
                    }
                    intStartY = ((BlobsFeatures)m_arrTemplateBlobPads[i]).intStartY - 3;
                    if (intStartY < 0)
                    {
                        intAdjustY = intStartY;
                        intStartY = 0;
                    }

                    intStartX2 = (int)Math.Round(m_arrSampleBlobPads[i].fCenterX - ((BlobsFeatures)m_arrTemplateBlobPads[i]).fWidth / 2, 0, MidpointRounding.AwayFromZero);
                    intStartX2 -= 3;
                    if (intStartX2 < 0)
                    {
                        if (intStartX2 > intAdjustX)
                            intAdjustX = intStartX2;
                        intStartX2 = 0;
                    }
                    intStartY2 = (int)Math.Round(m_arrSampleBlobPads[i].fCenterY - ((BlobsFeatures)m_arrTemplateBlobPads[i]).fHeight / 2, 0, MidpointRounding.AwayFromZero);
                    intStartY2 -= 3;
                    if (intStartY2 < 0)
                    {
                        if (intStartY2 > intAdjustY)
                            intAdjustY = intStartY2;
                        intStartY2 = 0;
                    }

                    intWidth = (int)Math.Round(((BlobsFeatures)m_arrTemplateBlobPads[i]).fWidth, 0, MidpointRounding.AwayFromZero) + 6;
                    intEndX = intStartX + intWidth + intAdjustX;
                    int intEndAdjustX = 0;
                    if (intEndX > objTemplateROI.ref_ROIWidth - 1)
                    {
                        intEndAdjustX = (intEndX - (objTemplateROI.ref_ROIWidth - 1));
                    }
                    intHeight = (int)Math.Round(((BlobsFeatures)m_arrTemplateBlobPads[i]).fHeight, 0, MidpointRounding.AwayFromZero) + 6;
                    intEndY = intStartY + intHeight + intAdjustY;
                    int intEndAdjustY = 0;
                    if (intEndY > objTemplateROI.ref_ROIHeight - 1)
                    {
                        intEndAdjustY = (intEndY - (objTemplateROI.ref_ROIHeight - 1));
                    }

                    intEndX = intStartX2 + intWidth + 6 + intAdjustX;
                    if (intEndX > m_ImgBlackUnitTemplateImage2.Width - 1)
                    {
                        if (intEndAdjustX < (intEndX - (m_ImgBlackUnitTemplateImage2.Width - 1)))
                            intEndAdjustX = (intEndX - (m_ImgBlackUnitTemplateImage2.Width - 1));
                    }
                    intEndY = intStartY2 + intHeight + 6 + intAdjustY;
                    if (intEndY > m_ImgBlackUnitTemplateImage2.Height - 1)
                    {
                        if (intEndAdjustY < (intEndY - (m_ImgBlackUnitTemplateImage2.Height - 1)))
                            intEndAdjustY = (intEndY - (m_ImgBlackUnitTemplateImage2.Height - 1));
                    }

                    intWidth -= intEndAdjustX;
                    intHeight -= intEndAdjustY;

                    // Get template pad roi
                    ROI objTemplatePadROI = new ROI();
                    objTemplatePadROI.AttachImage(objTemplateROI);
                    objTemplatePadROI.LoadROISetting(intStartX, intStartY, intWidth, intHeight);

                    // Get Sample pad ROI
                    ROI objTemplate2PadROI = new ROI();
                    objTemplate2PadROI.ref_ROI.Detach();
                    objTemplate2PadROI.ref_ROI.Attach(m_ImgBlackUnitTemplateImage2);
                    objTemplate2PadROI.LoadROISetting(intStartX2, intStartY2, intWidth, intHeight);

                    // subtract sample pad roi - template pad roi
                    EasyImage.Oper(EArithmeticLogicOperation.Add, objTemplate2PadROI.ref_ROI, objTemplatePadROI.ref_ROI, objTemplate2PadROI.ref_ROI);

                    objTemplatePadROI.Dispose();
                    objTemplate2PadROI.Dispose();
                }

                #endregion
            }

            if (blnDebugImage)
            {
                objSampleROI.SaveImage("D:\\TS\\20.B_BfSBSampleROI.bmp");// debug
                objTemplateROI2.SaveImage("D:\\TS\\21.B_objTemplate2ROI.bmp");// debug
            }

            // Subtract sample ROI - template ROI
            if (objSampleROI.ref_ROIWidth > objTemplateROI2.ref_ROIWidth)
                objSampleROI.ref_ROIWidth = objTemplateROI2.ref_ROIWidth;
            else
                objTemplateROI2.ref_ROIWidth = objSampleROI.ref_ROIWidth;

            if (objSampleROI.ref_ROIHeight > objTemplateROI2.ref_ROIHeight)
                objSampleROI.ref_ROIHeight = objTemplateROI2.ref_ROIHeight;
            else
                objTemplateROI2.ref_ROIHeight = objSampleROI.ref_ROIHeight;

            if (blnDebugImage)
            {
                objSampleROI.SaveImage("D:\\TS\\22.B_BfSBSampleROI.bmp");// debug
                objTemplateROI2.SaveImage("D:\\TS\\23.B_objTemplate2ROI.bmp");// debug
                objTemplateROI.SaveImage("D:\\TS\\24.objTemplateROI.bmp");
            }


            if (intImageIndex == 1)
                EasyImage.Oper(EArithmeticLogicOperation.Subtract, objSampleROI.ref_ROI, objTemplateROI2.ref_ROI, objSampleROI.ref_ROI);    // 2019 05 14 - CCENG: Use templateROI2 because the pad location is according to sample ROI.
                                                                                                                                            //EasyImage.Oper(EArithmeticLogicOperation.Subtract, objSampleROI.ref_ROI, objTemplateROI.ref_ROI, objSampleROI.ref_ROI);

            //objSampleROI.SaveImage("D:\\objSampleROI.bmp");
            //objTemplateROI.SaveImage("D:\\objTemplateROI.bmp");
            if (blnDebugImage)
                objSampleROI.SaveImage("D:\\TS\\B_AfSBSampleROI.bmp");// debug

            // Check Unit Surface Contamination (m_intFailPkgOptionMask 0x10=Contamination Length, 0x20=Contamiation Area, 0x40=Contamination Total Area
            if (((m_intFailPkgOptionMask & 0x70) > 0) && intImageIndex == 1)
            {
                objSampleROI.LoadROISetting(objImageUnitROI.ref_ROITotalX,
                                            objImageUnitROI.ref_ROITotalY,
                                            objImageUnitROI.ref_ROIWidth, objImageUnitROI.ref_ROIHeight);

                if (m_objRectGauge4L.GetGaugeTiltAngle() == 0)
                {
                    if (!IsImage1UnitContaminated(objSampleROI, objSampleROI.ref_ROITotalX, objSampleROI.ref_ROITotalY, intImageIndex))//,  blnPadPkg))
                    {
                        objSampleROI.Dispose();
                        objTemplateROI.Dispose();
                        objTemplateROI2.Dispose();
                        return false;
                    }
                }
                else
                {
                    if (!IsImage1UnitContaminated_TiltAngle(objSampleROI, objSampleROI.ref_ROITotalX, objSampleROI.ref_ROITotalY, intImageIndex, intPadIndex))//,  blnPadPkg))
                    {
                        objSampleROI.Dispose();
                        objTemplateROI.Dispose();
                        objTemplateROI2.Dispose();
                        return false;
                    }
                }
            }

            // Check Unit Surface Scratch
            if (((m_intFailPkgOptionMask & 0x08) > 0 || (m_intFailPkgOptionMask & 0x1000) > 0) && intImageIndex == 1)
            {
                objSampleROI.LoadROISetting(objImageUnitROI.ref_ROITotalX,
                                            objImageUnitROI.ref_ROITotalY,
                                            objImageUnitROI.ref_ROIWidth, objImageUnitROI.ref_ROIHeight);
                if (m_objRectGauge4L.GetGaugeTiltAngle() == 0)
                {
                    if (!IsImage1UnitScratch(objSampleROI, objSampleROI.ref_ROITotalX, objSampleROI.ref_ROITotalY, intImageIndex))//,  blnPadPkg))
                    {
                        objSampleROI.Dispose();
                        objTemplateROI.Dispose();
                        objTemplateROI2.Dispose();
                        return false;
                    }
                }
                else
                {
                    if (!IsImage1UnitScratch_TiltAngle(objSampleROI, objSampleROI.ref_ROITotalX, objSampleROI.ref_ROITotalY, intImageIndex, intPadIndex))//,  blnPadPkg))
                    {
                        objSampleROI.Dispose();
                        objTemplateROI.Dispose();
                        objTemplateROI2.Dispose();
                        return false;
                    }
                }
            }

            // Check Unit Chipped off
            if ((m_intFailPkgOptionMask & 0x04) > 0)
            {
                objSampleROI.LoadROISetting(objImageUnitROI.ref_ROITotalX,
                                            objImageUnitROI.ref_ROITotalY,
                                            objImageUnitROI.ref_ROIWidth, objImageUnitROI.ref_ROIHeight);

                if (!IsImage1UnitChippedOff2_Area(objSampleROI, objSampleROI.ref_ROITotalX, objSampleROI.ref_ROITotalY, intImageIndex)) // IsImage1UnitChippedOff2
                {
                    //objImageUnitROI.SaveImage("D:\\objImageUnitROI_"+intImageIndex.ToString()+".bmp");
                    //objSampleROI.SaveImage("D:\\objSampleROI_" + intImageIndex.ToString() + ".bmp");
                    //objTemplateROI.SaveImage("D:\\objTemplateROI_" + intImageIndex.ToString() + ".bmp");
                    //objTemplateROI2.SaveImage("D:\\objTemplateROI2_" + intImageIndex.ToString() + ".bmp");

                    objSampleROI.Dispose();
                    objTemplateROI.Dispose();
                    objTemplateROI2.Dispose();

                    return false;
                }
            }

            objSampleROI.Dispose();
            objTemplateROI.Dispose();
            objTemplateROI2.Dispose();

            return blnResult;
        }

        private bool CheckImageBrightDefect_Simple(ROI objImageUnitToleranceROI, ROI objImageUnitROI, int intImageIndex, int intPadIndex)//, bool blnPadPkg)
        {
            // Return if Bright Field Area and Length are OFF
            if (((m_intFailPkgOptionMask & 0x10000) == 0) && ((m_intFailPkgOptionMask & 0x20000) == 0))
                return true;

            int intInpectMode = 0; //0=Flexi template size, 1= use sample size, 2: Fix template size
            bool blnResult = true;
            bool blnDebugImage = false;

            if (blnDebugImage)
            {
                objImageUnitToleranceROI.SaveImage("D:\\TS\\1.objImageUnitToleranceROI.bmp");
                objImageUnitROI.SaveImage("D:\\TS\\2.objImageUnitROI.bmp");
            }

            // Get ready sample ROI
            ROI objSampleROI = new ROI();
            objSampleROI.AttachImage(m_objInsSurfacePkgImage1);  // m_objInsSurfacePkgImage1 is temporary image use to hold objSampleROI double threshold
            objSampleROI.LoadROISetting(objImageUnitToleranceROI.ref_ROITotalX, objImageUnitToleranceROI.ref_ROITotalY, objImageUnitToleranceROI.ref_ROIWidth, objImageUnitToleranceROI.ref_ROIHeight);
#if (Debug_2_12 || Release_2_12)
            // Gain and Double threshold

            if (m_fPkgImage1Gain != 1f)
            {
                EasyImage.GainOffset(objImageUnitToleranceROI.ref_ROI, objSampleROI.ref_ROI, m_fPkgImage1Gain);
                EasyImage.DoubleThreshold(objSampleROI.ref_ROI, objSampleROI.ref_ROI, (uint)m_intBrightFieldLowThreshold, (uint)m_intBrightFieldHighThreshold, 0, 255, 0); // WinXP (255,0,255) , Win7 (0,255,0)
            }
            else
            {
                EasyImage.DoubleThreshold(objImageUnitToleranceROI.ref_ROI, objSampleROI.ref_ROI, (uint)m_intBrightFieldLowThreshold, (uint)m_intBrightFieldHighThreshold, 0, 255, 0);// WinXP (255,0,255) , Win7 (0,255,0)
            }

#elif (DEBUG || RELEASE || RTXRelease || RTXDebug)
            // Gain and Double threshold

            if (m_fPkgImage1Gain != 1f)
            {
                EasyImage.GainOffset(objImageUnitToleranceROI.ref_ROI, objSampleROI.ref_ROI, m_fPkgImage1Gain);
                EasyImage.DoubleThreshold(objSampleROI.ref_ROI, objSampleROI.ref_ROI, m_intBrightFieldLowThreshold, m_intBrightFieldHighThreshold, 0, 255, 0); // WinXP (255,0,255) , Win7 (0,255,0)
            }
            else
            {
                EasyImage.DoubleThreshold(objImageUnitToleranceROI.ref_ROI, objSampleROI.ref_ROI, m_intBrightFieldLowThreshold, m_intBrightFieldHighThreshold, 0, 255, 0);// WinXP (255,0,255) , Win7 (0,255,0)
            }

#endif

            if (blnDebugImage)
            {
                objImageUnitToleranceROI.SaveImage("D:\\TS\\objImageUnitToleranceROI.bmp");
                m_objInsSurfacePkgImage1.SaveImage("D:\\TS\\3.m_objInsSurfacePkgImage1.bmp");
                objSampleROI.SaveImage("D:\\TS\\4.objSampleROI.bmp");
            }

            // Get ready template ROI
            ROI objTemplateROI = new ROI();
            if (intInpectMode == 0) // Current use Inspect Mode
            {
                // Get threshold value
                int intThresholdValue;
                if (m_intThresholdValue < 0)
                {
                    EBW8 objBW8;
                    if (intImageIndex == 1)
                        objBW8 = EasyImage.AutoThreshold(m_ImgUnitTemplateImage, EThresholdMode.MinResidue);
                    else
                        objBW8 = EasyImage.AutoThreshold(m_ImgUnitTemplateImagePkg, EThresholdMode.MinResidue);
                    intThresholdValue = objBW8.Value;
                }
                else
                    intThresholdValue = m_intThresholdValue;

                if (blnDebugImage)
                {
                    m_ImgUnitTemplateImage.Save("D:\\TS\\5.m_ImgUnitTemplateImage.bmp");// debug
                    m_ImgTUnitErodeThresImage.Save("D:\\TS\\6.m_ImgTUnitErodeThresImage.bmp");// debug
                    m_ImgUnitTemplateImagePkg.Save("D:\\TS\\7.m_ImgUnitTemplateImagePkg.bmp");// debug
                    m_ImgTUnitErodeThresImagePkg.Save("D:\\TS\\8.m_ImgTUnitErodeThresImagePkg.bmp");// debug
                }
#if (Debug_2_12 || Release_2_12)
                if (intImageIndex == 1)
                {
                    if (m_ImgTUnitErodeThresImage.Width != m_ImgUnitTemplateImage.Width ||
                        m_ImgTUnitErodeThresImage.Height != m_ImgUnitTemplateImage.Height)
                    {
                        m_ImgTUnitErodeThresImage.SetSize(m_ImgUnitTemplateImage.Width, m_ImgUnitTemplateImage.Height);
                    }

                    EasyImage.Copy(m_ImgUnitTemplateImage, m_ImgTUnitErodeThresImage);
                    // single threshold template image
                    if (m_fPadImageGain != 1f)
                    {
                        EasyImage.GainOffset(m_ImgTUnitErodeThresImage, m_ImgTUnitErodeThresImage, m_fPadImageGain);
                        EasyImage.Threshold(m_ImgTUnitErodeThresImage, m_ImgTUnitErodeThresImage, (uint)intThresholdValue);
                    }
                    else
                    {
                        EasyImage.Threshold(m_ImgTUnitErodeThresImage, m_ImgTUnitErodeThresImage, (uint)intThresholdValue);
                    }

                    objTemplateROI.ref_ROI.Detach();
                    objTemplateROI.ref_ROI.Attach(m_ImgTUnitErodeThresImage);
                    objTemplateROI.LoadROISetting(m_ImgTUnitErodeThresImage.Width / 2 - objImageUnitToleranceROI.ref_ROIWidth / 2,
                                                  m_ImgTUnitErodeThresImage.Height / 2 - objImageUnitToleranceROI.ref_ROIHeight / 2,
                                                  objImageUnitToleranceROI.ref_ROIWidth,
                                                  objImageUnitToleranceROI.ref_ROIHeight);
                }
                else
                {
                    EasyImage.Copy(m_ImgUnitTemplateImagePkg, m_ImgTUnitErodeThresImagePkg);
                    // single threshold template image
                    if (m_fPadImageGain != 1f)
                    {
                        EasyImage.GainOffset(m_ImgTUnitErodeThresImagePkg, m_ImgTUnitErodeThresImagePkg, m_fPadImageGain);
                        EasyImage.Threshold(m_ImgTUnitErodeThresImagePkg, m_ImgTUnitErodeThresImagePkg, (uint)intThresholdValue);
                    }
                    else
                    {
                        EasyImage.Threshold(m_ImgTUnitErodeThresImagePkg, m_ImgTUnitErodeThresImagePkg, (uint)intThresholdValue);
                    }

                    objTemplateROI.ref_ROI.Detach();
                    objTemplateROI.ref_ROI.Attach(m_ImgTUnitErodeThresImagePkg);
                    objTemplateROI.LoadROISetting(0, 0, objImageUnitROI.ref_ROIWidth, objImageUnitROI.ref_ROIHeight);
                }

#elif (DEBUG || RELEASE || RTXRelease || RTXDebug)
                if (intImageIndex == 1)
                {
                    if (m_ImgTUnitErodeThresImage.Width != m_ImgUnitTemplateImage.Width ||
                        m_ImgTUnitErodeThresImage.Height != m_ImgUnitTemplateImage.Height)
                    {
                        m_ImgTUnitErodeThresImage.SetSize(m_ImgUnitTemplateImage.Width, m_ImgUnitTemplateImage.Height);
                    }

                    EasyImage.Copy(m_ImgUnitTemplateImage, m_ImgTUnitErodeThresImage);
                    // single threshold template image
                    if (m_fPadImageGain != 1f)
                    {
                        EasyImage.GainOffset(m_ImgTUnitErodeThresImage, m_ImgTUnitErodeThresImage, m_fPadImageGain);
                        EasyImage.Threshold(m_ImgTUnitErodeThresImage, m_ImgTUnitErodeThresImage, intThresholdValue);
                    }
                    else
                    {
                        EasyImage.Threshold(m_ImgTUnitErodeThresImage, m_ImgTUnitErodeThresImage, intThresholdValue);
                    }
                    objTemplateROI.ref_ROI.Detach();
                    objTemplateROI.ref_ROI.Attach(m_ImgTUnitErodeThresImage);
                    objTemplateROI.LoadROISetting(m_ImgTUnitErodeThresImage.Width / 2 - objImageUnitToleranceROI.ref_ROIWidth / 2,
                                                  m_ImgTUnitErodeThresImage.Height / 2 - objImageUnitToleranceROI.ref_ROIHeight / 2,
                                                  objImageUnitToleranceROI.ref_ROIWidth,
                                                  objImageUnitToleranceROI.ref_ROIHeight);
                }
                else
                {
                    EasyImage.Copy(m_ImgUnitTemplateImagePkg, m_ImgTUnitErodeThresImagePkg);
                    // single threshold template image
                    if (m_fPadImageGain != 1f)
                    {
                        EasyImage.GainOffset(m_ImgTUnitErodeThresImagePkg, m_ImgTUnitErodeThresImagePkg, m_fPadImageGain);
                        EasyImage.Threshold(m_ImgTUnitErodeThresImagePkg, m_ImgTUnitErodeThresImagePkg, intThresholdValue);
                    }
                    else
                    {
                        EasyImage.Threshold(m_ImgTUnitErodeThresImagePkg, m_ImgTUnitErodeThresImagePkg, intThresholdValue);
                    }
                    objTemplateROI.ref_ROI.Detach();
                    objTemplateROI.ref_ROI.Attach(m_ImgTUnitErodeThresImagePkg);
                    objTemplateROI.LoadROISetting(0, 0, objImageUnitROI.ref_ROIWidth, objImageUnitROI.ref_ROIHeight);
                }

#endif

                if (blnDebugImage)
                {
                    objImageUnitROI.SaveImage("D:\\TS\\9.B_OriSampleROI.bmp");// debug
                    m_ImgUnitTemplateImage.Save("D:\\TS\\10.B_OriTemplateImage.bmp");// debug
                    m_ImgTUnitErodeThresImage.Save("D:\\TS\\11.B_m_ImgTUnitErodeThresImage.bmp");// debug
                    objTemplateROI.SaveImage("D:\\TS\\12.B_objTemplateROI.bmp");// debug
                    objSampleROI.SaveImage("D:\\TS\\13.B_objSampleROI.bmp");// debug
                }
            }

            if (intImageIndex == 1)
            {
                // Get ready blank black image
                m_ImgBlackUnitTemplateImage.CopyTo(m_ImgBlackUnitTemplateImage2);
            }
            else
            {
                // Get ready blank white image
                m_ImgWhiteUnitTemplateImagePkg.CopyTo(m_ImgWhiteUnitTemplateImage2);
            }

            ROI objTemplateROI2 = new ROI();
            objTemplateROI2.ref_ROI.Detach();
            if (intImageIndex == 1)
            {
                objTemplateROI2.ref_ROI.Attach(m_ImgBlackUnitTemplateImage2);
            }
            else
            {
                objTemplateROI2.ref_ROI.Attach(m_ImgWhiteUnitTemplateImage2);
            }

            objTemplateROI2.LoadROISetting(0, 0, objImageUnitToleranceROI.ref_ROIWidth, objImageUnitToleranceROI.ref_ROIHeight);


            if (blnDebugImage)
                objTemplateROI2.SaveImage("D:\\TS\\14.BlankTemplateROI2.bmp");// debug

            if (intInpectMode == 0)
            {
                #region Inspect Mode == 0
                int[] arrTemplateStartX = new int[m_arrTemplateBlobPads.Count];
                int[] arrTemplateStartY = new int[m_arrTemplateBlobPads.Count];
                int[] arrTemplateEndX = new int[m_arrTemplateBlobPads.Count];
                int[] arrTemplateEndY = new int[m_arrTemplateBlobPads.Count];
                int[] arrSampleStartX = new int[m_arrTemplateBlobPads.Count];
                int[] arrSampleStartY = new int[m_arrTemplateBlobPads.Count];
                int[] arrSampleEndX = new int[m_arrTemplateBlobPads.Count];
                int[] arrSampleEndY = new int[m_arrTemplateBlobPads.Count];
                int[] arrTemplateSampleWidth = new int[m_arrTemplateBlobPads.Count];
                int[] arrTemplateSampleHeight = new int[m_arrTemplateBlobPads.Count];
                int[] arrDifferentSizeX = new int[m_arrTemplateBlobPads.Count]; // Template and sample different size
                int[] arrDifferentSizeY = new int[m_arrTemplateBlobPads.Count]; // Template and sample different size
                int[] arrOffsetStartX = new int[m_arrTemplateBlobPads.Count];
                int[] arrOffsetStartY = new int[m_arrTemplateBlobPads.Count];

                DefinePadSubtractOffset(objTemplateROI, m_intMPDilateHalfWidth, m_ImgBlackUnitTemplateImage2.Width - 1, m_ImgBlackUnitTemplateImage2.Height - 1,
                    ref arrTemplateStartX, ref arrTemplateStartY, ref arrTemplateEndX, ref arrTemplateEndY,
                    ref arrSampleStartX, ref arrSampleStartY, ref arrSampleEndX, ref arrSampleEndY,
                    ref arrTemplateSampleWidth, ref arrTemplateSampleHeight,
                    ref arrDifferentSizeX, ref arrDifferentSizeY,
                    ref arrOffsetStartX, ref arrOffsetStartY, false);

                //2021-03-12 ZJYEOH : Need Offset back when pad no use gauge but package got use gauge
                if (!GetOverallWantGaugeMeasurePkgSize(false))
                {
                    for (int i = 0; i < arrOffsetStartX.Length; i++)
                    {
                        arrOffsetStartX[i] += (int)(Math.Round(GetResultCenterPoint_UnitMatcher().X - GetResultCenterPoint_RectGauge4L().X));
                        arrOffsetStartY[i] += (int)(Math.Round(GetResultCenterPoint_UnitMatcher().Y - GetResultCenterPoint_RectGauge4L().Y));
                    }
                }

                for (int i = 0; i < m_arrTemplateBlobPads.Count; i++)
                {
                    if (m_arrSampleBlobPads[i].intFailMask != 0)
                        continue;

                    // Get template pad roi
                    ROI objTemplatePadROI = new ROI();
                    objTemplatePadROI.AttachImage(objTemplateROI);
                    objTemplatePadROI.LoadROISetting(arrTemplateStartX[i], arrTemplateStartY[i], arrTemplateSampleWidth[i], arrTemplateSampleHeight[i]);

                    if (blnDebugImage)
                    {
                        objTemplatePadROI.SaveImage("D:\\TS\\objTemplatePadROI.bmp");// debug
                    }

                    m_ImgMPUnitTemplateImage.SetSize(objTemplatePadROI.ref_ROIWidth, objTemplatePadROI.ref_ROIHeight);
                    EasyImage.Copy(objTemplatePadROI.ref_ROI, m_ImgMPUnitTemplateImage);

#if (Debug_2_12 || Release_2_12)
                    // 2019-09-27 ZJYEOH : Straight dilate according to setting
                    EasyImage.DilateBox(m_ImgMPUnitTemplateImage, objTemplatePadROI.ref_ROI, (uint)Math.Abs(m_intMPDilateHalfWidth), (uint)Math.Abs(m_intMPDilateHalfWidth));

#elif (DEBUG || RELEASE || RTXRelease || RTXDebug)
                    // 2019-09-27 ZJYEOH : Straight dilate according to setting
                    EasyImage.DilateBox(m_ImgMPUnitTemplateImage, objTemplatePadROI.ref_ROI, Math.Abs(m_intMPDilateHalfWidth), Math.Abs(m_intMPDilateHalfWidth));

#endif

                    // Get template2 pad ROI
                    ROI objTemplate2PadROI = new ROI();
                    objTemplate2PadROI.ref_ROI.Detach();
                    objTemplate2PadROI.ref_ROI.Attach(m_ImgBlackUnitTemplateImage2);
                    objTemplate2PadROI.LoadROISetting(arrSampleStartX[i] + arrOffsetStartX[i], arrSampleStartY[i] + arrOffsetStartY[i], arrTemplateSampleWidth[i], arrTemplateSampleHeight[i]);

                    if (blnDebugImage)
                    {
                        m_ImgBlackUnitTemplateImage2.Save("D:\\TS\\1_B_m_ImgBlackUnitTemplateImage2.bmp");
                        m_ImgMPUnitTemplateImage.Save("D:\\TS\\2_B_BfMPTemplateImage.bmp");// debug
                        objTemplatePadROI.SaveImage("D:\\TS\\3_B_AfMPTemplateImage.bmp");// debug
                        objTemplate2PadROI.SaveImage("D:\\TS\\4_B_BfSBTemplate2PadImage.bmp");// debug
                    }


                    if (objTemplatePadROI.ref_ROIWidth != objTemplate2PadROI.ref_ROIWidth)
                    {
                        int intSmallWidth = Math.Min(objTemplatePadROI.ref_ROIWidth, objTemplate2PadROI.ref_ROIWidth);
                        objTemplatePadROI.LoadROISetting(objTemplatePadROI.ref_ROIPositionX, objTemplatePadROI.ref_ROIPositionY, intSmallWidth, objTemplatePadROI.ref_ROIHeight);
                        objTemplate2PadROI.LoadROISetting(objTemplate2PadROI.ref_ROIPositionX, objTemplate2PadROI.ref_ROIPositionY, intSmallWidth, objTemplate2PadROI.ref_ROIHeight);
                    }

                    if (objTemplatePadROI.ref_ROIHeight != objTemplate2PadROI.ref_ROIHeight)
                    {
                        int intSmallHeight = Math.Min(objTemplatePadROI.ref_ROIHeight, objTemplate2PadROI.ref_ROIHeight);
                        objTemplatePadROI.LoadROISetting(objTemplatePadROI.ref_ROIPositionX, objTemplatePadROI.ref_ROIPositionY, objTemplatePadROI.ref_ROIWidth, intSmallHeight);
                        objTemplate2PadROI.LoadROISetting(objTemplate2PadROI.ref_ROIPositionX, objTemplate2PadROI.ref_ROIPositionY, objTemplate2PadROI.ref_ROIWidth, intSmallHeight);
                    }

                    // Add sample pad roi - template pad roi
                    if (objTemplate2PadROI.ref_ROIWidth > 0 && objTemplate2PadROI.ref_ROIHeight > 0 &&
                        objTemplatePadROI.ref_ROIWidth > 0 && objTemplatePadROI.ref_ROIHeight > 0)
                    {
                        EasyImage.Oper(EArithmeticLogicOperation.Add, objTemplate2PadROI.ref_ROI, objTemplatePadROI.ref_ROI, objTemplate2PadROI.ref_ROI);
                    }

                    if (blnDebugImage)
                    {
                        objTemplate2PadROI.SaveImage("D:\\TS\\B_AfSBTemplate2PadImage.bmp");// debug
                        objTemplateROI2.SaveImage("D:\\TS\\B_objTemplate2ROI.bmp");// debug
                    }

                    objTemplatePadROI.Dispose();
                    objTemplate2PadROI.Dispose();
                }

                #endregion
            }

            if (blnDebugImage)
            {
                objSampleROI.SaveImage("D:\\TS\\20.B_BfSBSampleROI.bmp");// debug
                objTemplateROI2.SaveImage("D:\\TS\\21.B_objTemplate2ROI.bmp");// debug
            }

            // Subtract sample ROI - template ROI
            if (objSampleROI.ref_ROIWidth != objTemplateROI2.ref_ROIWidth)
            {
                if (objSampleROI.ref_ROIWidth > objTemplateROI2.ref_ROIWidth)
                    objSampleROI.ref_ROIWidth = objTemplateROI2.ref_ROIWidth;
                else
                    objTemplateROI2.ref_ROIWidth = objSampleROI.ref_ROIWidth;
            }

            if (objSampleROI.ref_ROIHeight != objTemplateROI2.ref_ROIHeight)
            {
                if (objSampleROI.ref_ROIHeight > objTemplateROI2.ref_ROIHeight)
                    objSampleROI.ref_ROIHeight = objTemplateROI2.ref_ROIHeight;
                else
                    objTemplateROI2.ref_ROIHeight = objSampleROI.ref_ROIHeight;
            }

            if (blnDebugImage)
            {
                objSampleROI.SaveImage("D:\\TS\\22.B_BfSBSampleROI.bmp");// debug
                objTemplateROI2.SaveImage("D:\\TS\\23.B_objTemplate2ROI.bmp");// debug
                objTemplateROI.SaveImage("D:\\TS\\24.objTemplateROI.bmp");
            }


            if (intImageIndex == 1)
                EasyImage.Oper(EArithmeticLogicOperation.Subtract, objSampleROI.ref_ROI, objTemplateROI2.ref_ROI, objSampleROI.ref_ROI);    // 2019 05 14 - CCENG: Use templateROI2 because the pad location is according to sample ROI.
                                                                                                                                            //EasyImage.Oper(EArithmeticLogicOperation.Subtract, objSampleROI.ref_ROI, objTemplateROI.ref_ROI, objSampleROI.ref_ROI);

            //objSampleROI.SaveImage("D:\\objSampleROI.bmp");
            //objTemplateROI.SaveImage("D:\\objTemplateROI.bmp");
            if (blnDebugImage)
                objSampleROI.SaveImage("D:\\TS\\B_AfSBSampleROI.bmp");// debug

            // Check Unit Surface Contamination (m_intFailPkgOptionMask 0x10=Contamination Length, 0x20=Contamiation Area, 0x40=Contamination Total Area
            if ((m_intFailPkgOptionMask & 0x30000) > 0)
            {
                objSampleROI.LoadROISetting(objImageUnitROI.ref_ROITotalX,
                                            objImageUnitROI.ref_ROITotalY,
                                            objImageUnitROI.ref_ROIWidth, objImageUnitROI.ref_ROIHeight);

                if (m_blnWantLinkBrightDefect)
                {
                    if (m_objRectGauge4L.GetGaugeTiltAngle() == 0)
                    {
                        if (!IsImage1UnitBrightFieldPackageFailed_WithLinkFunction(objSampleROI, objSampleROI.ref_ROITotalX, objSampleROI.ref_ROITotalY, intImageIndex))
                        {
                            objSampleROI.Dispose();
                            objTemplateROI.Dispose();
                            objTemplateROI2.Dispose();
                            return false;
                        }
                    }
                    else
                    {
                        if (!IsImage1UnitBrightFieldPackageFailed_TiltAngle_WithLinkFunction(objSampleROI, objSampleROI.ref_ROITotalX, objSampleROI.ref_ROITotalY, intImageIndex, intPadIndex))
                        {
                            objSampleROI.Dispose();
                            objTemplateROI.Dispose();
                            objTemplateROI2.Dispose();
                            return false;
                        }
                    }
                }
                else
                {
                    if (m_objRectGauge4L.GetGaugeTiltAngle() == 0)
                    {
                        if (!IsImage1UnitBrightFieldPackageFailed(objSampleROI, objSampleROI.ref_ROITotalX, objSampleROI.ref_ROITotalY, intImageIndex))
                        {
                            objSampleROI.Dispose();
                            objTemplateROI.Dispose();
                            objTemplateROI2.Dispose();
                            return false;
                        }
                    }
                    else
                    {
                        if (!IsImage1UnitBrightFieldPackageFailed_TiltAngle(objSampleROI, objSampleROI.ref_ROITotalX, objSampleROI.ref_ROITotalY, intImageIndex, intPadIndex))
                        {
                            objSampleROI.Dispose();
                            objTemplateROI.Dispose();
                            objTemplateROI2.Dispose();
                            return false;
                        }
                    }
                }
            }

            //// Check Unit Chipped off
            //if ((m_intFailPkgOptionMask & 0x04) > 0)
            //{
            //    objSampleROI.LoadROISetting(objImageUnitROI.ref_ROITotalX,
            //                                objImageUnitROI.ref_ROITotalY,
            //                                objImageUnitROI.ref_ROIWidth, objImageUnitROI.ref_ROIHeight);

            //    if (!IsImage1UnitChippedOff2_Area(objSampleROI, objSampleROI.ref_ROITotalX, objSampleROI.ref_ROITotalY, intImageIndex)) // IsImage1UnitChippedOff2
            //    {
            //        //objImageUnitROI.SaveImage("D:\\objImageUnitROI_"+intImageIndex.ToString()+".bmp");
            //        //objSampleROI.SaveImage("D:\\objSampleROI_" + intImageIndex.ToString() + ".bmp");
            //        //objTemplateROI.SaveImage("D:\\objTemplateROI_" + intImageIndex.ToString() + ".bmp");
            //        //objTemplateROI2.SaveImage("D:\\objTemplateROI2_" + intImageIndex.ToString() + ".bmp");

            //        objSampleROI.Dispose();
            //        objTemplateROI.Dispose();
            //        objTemplateROI2.Dispose();

            //        return false;
            //    }
            //}

            objSampleROI.Dispose();
            objTemplateROI.Dispose();
            objTemplateROI2.Dispose();

            return blnResult;
        }

        // Replace by new function CheckImageBrightDefect_Simple due to add Pad Subtract Method
//        private bool CheckImageBrightDefect_Simple_2020_11_25(ROI objImageUnitToleranceROI, ROI objImageUnitROI, int intImageIndex, int intPadIndex)//, bool blnPadPkg)
//        {
//            // Return if Bright Field Area and Length are OFF
//            if (((m_intFailPkgOptionMask & 0x10000) == 0) && ((m_intFailPkgOptionMask & 0x20000) == 0))
//                return true;

//            int intInpectMode = 0; //0=Flexi template size, 1= use sample size, 2: Fix template size
//            bool blnResult = true;
//            bool blnDebugImage = false;

//            if (blnDebugImage)
//            {
//                objImageUnitToleranceROI.SaveImage("D:\\TS\\1.objImageUnitToleranceROI.bmp");
//                objImageUnitROI.SaveImage("D:\\TS\\2.objImageUnitROI.bmp");
//            }

//            // Get ready sample ROI
//            ROI objSampleROI = new ROI();
//            objSampleROI.AttachImage(m_objInsSurfacePkgImage1);  // m_objInsSurfacePkgImage1 is temporary image use to hold objSampleROI double threshold
//            objSampleROI.LoadROISetting(objImageUnitToleranceROI.ref_ROITotalX, objImageUnitToleranceROI.ref_ROITotalY, objImageUnitToleranceROI.ref_ROIWidth, objImageUnitToleranceROI.ref_ROIHeight);
//#if (Debug_2_12 || Release_2_12)
//            // Gain and Double threshold

//            if (m_fPkgImage1Gain != 1f)
//            {
//                EasyImage.GainOffset(objImageUnitToleranceROI.ref_ROI, objSampleROI.ref_ROI, m_fPkgImage1Gain);
//                EasyImage.DoubleThreshold(objSampleROI.ref_ROI, objSampleROI.ref_ROI, (uint)m_intBrightFieldLowThreshold, (uint)m_intBrightFieldHighThreshold, 0, 255, 0); // WinXP (255,0,255) , Win7 (0,255,0)
//            }
//            else
//            {
//                EasyImage.DoubleThreshold(objImageUnitToleranceROI.ref_ROI, objSampleROI.ref_ROI, (uint)m_intBrightFieldLowThreshold, (uint)m_intBrightFieldHighThreshold, 0, 255, 0);// WinXP (255,0,255) , Win7 (0,255,0)
//            }

//#elif (DEBUG || RELEASE || RTXRelease || RTXDebug)
//            // Gain and Double threshold

//            if (m_fPkgImage1Gain != 1f)
//            {
//                EasyImage.GainOffset(objImageUnitToleranceROI.ref_ROI, objSampleROI.ref_ROI, m_fPkgImage1Gain);
//                EasyImage.DoubleThreshold(objSampleROI.ref_ROI, objSampleROI.ref_ROI, m_intBrightFieldLowThreshold, m_intBrightFieldHighThreshold, 0, 255, 0); // WinXP (255,0,255) , Win7 (0,255,0)
//            }
//            else
//            {
//                EasyImage.DoubleThreshold(objImageUnitToleranceROI.ref_ROI, objSampleROI.ref_ROI, m_intBrightFieldLowThreshold, m_intBrightFieldHighThreshold, 0, 255, 0);// WinXP (255,0,255) , Win7 (0,255,0)
//            }

//#endif

//            if (blnDebugImage)
//            {
//                objImageUnitToleranceROI.SaveImage("D:\\TS\\objImageUnitToleranceROI.bmp");
//                m_objInsSurfacePkgImage1.SaveImage("D:\\TS\\3.m_objInsSurfacePkgImage1.bmp");
//                objSampleROI.SaveImage("D:\\TS\\4.objSampleROI.bmp");
//            }

//            // Get ready template ROI
//            ROI objTemplateROI = new ROI();
//            if (intInpectMode == 0) // Current use Inspect Mode
//            {
//                // Get threshold value
//                int intThresholdValue;
//                if (m_intThresholdValue < 0)
//                {
//                    EBW8 objBW8;
//                    if (intImageIndex == 1)
//                        objBW8 = EasyImage.AutoThreshold(m_ImgUnitTemplateImage, EThresholdMode.MinResidue);
//                    else
//                        objBW8 = EasyImage.AutoThreshold(m_ImgUnitTemplateImagePkg, EThresholdMode.MinResidue);
//                    intThresholdValue = objBW8.Value;
//                }
//                else
//                    intThresholdValue = m_intThresholdValue;

//                if (blnDebugImage)
//                {
//                    m_ImgUnitTemplateImage.Save("D:\\TS\\5.m_ImgUnitTemplateImage.bmp");// debug
//                    m_ImgTUnitErodeThresImage.Save("D:\\TS\\6.m_ImgTUnitErodeThresImage.bmp");// debug
//                    m_ImgUnitTemplateImagePkg.Save("D:\\TS\\7.m_ImgUnitTemplateImagePkg.bmp");// debug
//                    m_ImgTUnitErodeThresImagePkg.Save("D:\\TS\\8.m_ImgTUnitErodeThresImagePkg.bmp");// debug
//                }
//#if (Debug_2_12 || Release_2_12)
//                if (intImageIndex == 1)
//                {
//                    if (m_ImgTUnitErodeThresImage.Width != m_ImgUnitTemplateImage.Width ||
//                        m_ImgTUnitErodeThresImage.Height != m_ImgUnitTemplateImage.Height)
//                    {
//                        m_ImgTUnitErodeThresImage.SetSize(m_ImgUnitTemplateImage.Width, m_ImgUnitTemplateImage.Height);
//                    }

//                    EasyImage.Copy(m_ImgUnitTemplateImage, m_ImgTUnitErodeThresImage);
//                    // single threshold template image
//                    EasyImage.Threshold(m_ImgTUnitErodeThresImage, m_ImgTUnitErodeThresImage, (uint)intThresholdValue);

//                    objTemplateROI.ref_ROI.Detach();
//                    objTemplateROI.ref_ROI.Attach(m_ImgTUnitErodeThresImage);
//                    objTemplateROI.LoadROISetting(m_ImgTUnitErodeThresImage.Width / 2 - objImageUnitToleranceROI.ref_ROIWidth / 2,
//                                                  m_ImgTUnitErodeThresImage.Height / 2 - objImageUnitToleranceROI.ref_ROIHeight / 2,
//                                                  objImageUnitToleranceROI.ref_ROIWidth,
//                                                  objImageUnitToleranceROI.ref_ROIHeight);
//                }
//                else
//                {
//                    EasyImage.Copy(m_ImgUnitTemplateImagePkg, m_ImgTUnitErodeThresImagePkg);
//                    // single threshold template image
//                    EasyImage.Threshold(m_ImgTUnitErodeThresImagePkg, m_ImgTUnitErodeThresImagePkg, (uint)intThresholdValue);

//                    objTemplateROI.ref_ROI.Detach();
//                    objTemplateROI.ref_ROI.Attach(m_ImgTUnitErodeThresImagePkg);
//                    objTemplateROI.LoadROISetting(0, 0, objImageUnitROI.ref_ROIWidth, objImageUnitROI.ref_ROIHeight);
//                }

//#elif (DEBUG || RELEASE || RTXRelease || RTXDebug)
//                if (intImageIndex == 1)
//                {
//                    if (m_ImgTUnitErodeThresImage.Width != m_ImgUnitTemplateImage.Width ||
//                        m_ImgTUnitErodeThresImage.Height != m_ImgUnitTemplateImage.Height)
//                    {
//                        m_ImgTUnitErodeThresImage.SetSize(m_ImgUnitTemplateImage.Width, m_ImgUnitTemplateImage.Height);
//                    }

//                    EasyImage.Copy(m_ImgUnitTemplateImage, m_ImgTUnitErodeThresImage);
//                    // single threshold template image
//                    EasyImage.Threshold(m_ImgTUnitErodeThresImage, m_ImgTUnitErodeThresImage, intThresholdValue);

//                    objTemplateROI.ref_ROI.Detach();
//                    objTemplateROI.ref_ROI.Attach(m_ImgTUnitErodeThresImage);
//                    objTemplateROI.LoadROISetting(m_ImgTUnitErodeThresImage.Width / 2 - objImageUnitToleranceROI.ref_ROIWidth / 2,
//                                                  m_ImgTUnitErodeThresImage.Height / 2 - objImageUnitToleranceROI.ref_ROIHeight / 2,
//                                                  objImageUnitToleranceROI.ref_ROIWidth,
//                                                  objImageUnitToleranceROI.ref_ROIHeight);
//                }
//                else
//                {
//                    EasyImage.Copy(m_ImgUnitTemplateImagePkg, m_ImgTUnitErodeThresImagePkg);
//                    // single threshold template image
//                    EasyImage.Threshold(m_ImgTUnitErodeThresImagePkg, m_ImgTUnitErodeThresImagePkg, intThresholdValue);

//                    objTemplateROI.ref_ROI.Detach();
//                    objTemplateROI.ref_ROI.Attach(m_ImgTUnitErodeThresImagePkg);
//                    objTemplateROI.LoadROISetting(0, 0, objImageUnitROI.ref_ROIWidth, objImageUnitROI.ref_ROIHeight);
//                }

//#endif

//                if (blnDebugImage)
//                {
//                    objImageUnitROI.SaveImage("D:\\TS\\9.B_OriSampleROI.bmp");// debug
//                    m_ImgUnitTemplateImage.Save("D:\\TS\\10.B_OriTemplateImage.bmp");// debug
//                    m_ImgTUnitErodeThresImage.Save("D:\\TS\\11.B_m_ImgTUnitErodeThresImage.bmp");// debug
//                    objTemplateROI.SaveImage("D:\\TS\\12.B_objTemplateROI.bmp");// debug
//                    objSampleROI.SaveImage("D:\\TS\\13.B_objSampleROI.bmp");// debug
//                }
//            }

//            if (intImageIndex == 1)
//            {
//                // Get ready blank black image
//                m_ImgBlackUnitTemplateImage.CopyTo(m_ImgBlackUnitTemplateImage2);
//            }
//            else
//            {
//                // Get ready blank white image
//                m_ImgWhiteUnitTemplateImagePkg.CopyTo(m_ImgWhiteUnitTemplateImage2);
//            }

//            ROI objTemplateROI2 = new ROI();
//            objTemplateROI2.ref_ROI.Detach();
//            if (intImageIndex == 1)
//            {
//                objTemplateROI2.ref_ROI.Attach(m_ImgBlackUnitTemplateImage2);
//            }
//            else
//            {
//                objTemplateROI2.ref_ROI.Attach(m_ImgWhiteUnitTemplateImage2);
//            }

//            objTemplateROI2.LoadROISetting(0, 0, objImageUnitToleranceROI.ref_ROIWidth, objImageUnitToleranceROI.ref_ROIHeight);


//            if (blnDebugImage)
//                objTemplateROI2.SaveImage("D:\\TS\\14.BlankTemplateROI2.bmp");// debug

//            int intStartX, intStartY, intEndX, intEndY, intAdjustX, intAdjustY, intStartX2, intStartY2, intWidth, intHeight;

//            if (intInpectMode == 0)
//            {
//                #region Inspect Mode == 0
//                int intToleSize = m_intMPDilateHalfWidth;

//                for (int i = 0; i < m_arrTemplateBlobPads.Count; i++)
//                {
//                    if (m_arrSampleBlobPads[i].intFailMask != 0)
//                        continue;

//                    // check the different size between sample pad and template pad
//                    int intDiffSizeWidth = (int)Math.Round((m_arrSampleBlobPads[i].fWidth - ((BlobsFeatures)m_arrTemplateBlobPads[i]).fWidth) / 2, 0, MidpointRounding.AwayFromZero);
//                    int intDiffSizeHeight = (int)Math.Round((m_arrSampleBlobPads[i].fHeight - ((BlobsFeatures)m_arrTemplateBlobPads[i]).fHeight) / 2, 0, MidpointRounding.AwayFromZero);

//                    // set one of the size (width or height) to zero if one side is bigger and another side is smaller
//                    if ((intDiffSizeWidth > 0 && intDiffSizeHeight < 0) || (intDiffSizeHeight > 0 && intDiffSizeWidth < 0))
//                    {
//                        if (Math.Abs(intDiffSizeWidth) > Math.Abs(intDiffSizeHeight))    // the bigger value will set to 0
//                            intDiffSizeHeight = 0;
//                        else
//                            intDiffSizeWidth = 0;
//                    }

//                    float fWidth, fHeight;
//                    // get bigger size from sample pad or template pad
//                    if ((intDiffSizeWidth > 0) || (intDiffSizeHeight > 0))
//                    {
//                        // Use sample size
//                        fWidth = m_arrSampleBlobPads[i].fWidth;
//                        fHeight = m_arrSampleBlobPads[i].fHeight;
//                    }
//                    else
//                    {
//                        // Use template size
//                        fWidth = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fWidth;
//                        fHeight = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fHeight;
//                    }

//                    // Get "template" pad start and end corner point with tolerance size added.
//                    intAdjustX = 0;
//                    intAdjustY = 0;
//                    intStartX = (int)Math.Round(((BlobsFeatures)m_arrTemplateBlobPads[i]).fLimitCenterX - fWidth / 2 - intToleSize, 0, MidpointRounding.AwayFromZero);
//                    if (intStartX < 0)  // Set to zero if value smaller than zero
//                    {
//                        intAdjustX = intStartX; // add adjust value when intStartX change from negative to 0
//                        intStartX = 0;
//                    }
//                    intStartY = (int)Math.Round(((BlobsFeatures)m_arrTemplateBlobPads[i]).fLimitCenterY - fHeight / 2 - intToleSize, 0, MidpointRounding.AwayFromZero);
//                    if (intStartY < 0)  // Set to zero if value smaller than zero
//                    {
//                        intAdjustY = intStartY; // add adjust value when intStartY change from negative to 0
//                        intStartY = 0;
//                    }

//                    // Get "sample" pad start and end corner point with tolerance size added.
//                    intStartX2 = (int)Math.Round(m_arrSampleBlobPads[i].fCenterX - fWidth / 2 - intToleSize, 0, MidpointRounding.AwayFromZero);
//                    if (intStartX2 < 0) // Set to zero if value smaller than zero
//                    {
//                        if (intStartX2 > intAdjustX)    // set bigger value in adjust value // Why is bigger, not smaller?
//                            intAdjustX = intStartX2;
//                        intStartX2 = 0;
//                    }
//                    intStartY2 = (int)Math.Round(m_arrSampleBlobPads[i].fCenterY - fHeight / 2 - intToleSize, 0, MidpointRounding.AwayFromZero);
//                    if (intStartY2 < 0) // Set to zero if value smaller than zero
//                    {
//                        if (intStartY2 > intAdjustY)    // set bigger value in adjust value // Why is bigger, not smaller?
//                            intAdjustY = intStartY2;
//                        intStartY2 = 0;
//                    }

//                    // Set "template" pad width with tolerance size and adjust value added
//                    intWidth = (int)Math.Round(fWidth + intToleSize * 2, 0, MidpointRounding.AwayFromZero);
//                    intEndX = intStartX + intWidth + intAdjustX;
//                    int intEndAdjustX = 0;
//                    if (intEndX > objTemplateROI.ref_ROIWidth - 1)
//                    {
//                        intEndAdjustX = (intEndX - (objTemplateROI.ref_ROIWidth - 1));  // Set end adjust value if endx bigger than roi area
//                    }
//                    intHeight = (int)Math.Round(fHeight + intToleSize * 2, 0, MidpointRounding.AwayFromZero);
//                    intEndY = intStartY + intHeight + intAdjustY;
//                    int intEndAdjustY = 0;
//                    if (intEndY > objTemplateROI.ref_ROIHeight - 1)
//                    {
//                        intEndAdjustY = (intEndY - (objTemplateROI.ref_ROIHeight)); // Set end adjust value if endx bigger than roi area
//                    }

//                    // set pad corner end point value
//                    //intEndX = intStartX2 + intWidth + intToleSize * 2 + intAdjustX;
//                    intEndX = intStartX2 + intWidth + intAdjustX;
//                    if (intEndX > m_ImgBlackUnitTemplateImage2.Width - 1)
//                    {
//                        if (intEndAdjustX < (intEndX - (m_ImgBlackUnitTemplateImage2.Width - 1)))
//                            intEndAdjustX = (intEndX - (m_ImgBlackUnitTemplateImage2.Width - 1));
//                    }
//                    //intEndY = intStartY2 + intHeight + intToleSize * 2 + intAdjustY;
//                    intEndY = intStartY2 + intHeight + intAdjustY;
//                    if (intEndY > m_ImgBlackUnitTemplateImage2.Height - 1)
//                    {
//                        if (intEndAdjustY < (intEndY - (m_ImgBlackUnitTemplateImage2.Height - 1)))
//                            intEndAdjustY = (intEndY - (m_ImgBlackUnitTemplateImage2.Height - 1));
//                    }

//                    intWidth -= intEndAdjustX;
//                    intHeight -= intEndAdjustY;

//                    // Get template pad roi
//                    ROI objTemplatePadROI = new ROI();
//                    objTemplatePadROI.AttachImage(objTemplateROI);
//                    objTemplatePadROI.LoadROISetting(intStartX, intStartY, intWidth, intHeight);

//                    if (blnDebugImage)
//                    {
//                        objTemplatePadROI.SaveImage("D:\\TS\\objTemplatePadROI.bmp");// debug
//                    }

//                    m_ImgMPUnitTemplateImage.SetSize(objTemplatePadROI.ref_ROIWidth, objTemplatePadROI.ref_ROIHeight);
//                    EasyImage.Copy(objTemplatePadROI.ref_ROI, m_ImgMPUnitTemplateImage);

//                    if (intDiffSizeWidth < -intToleSize)
//                        intDiffSizeWidth = -intToleSize;
//                    else if (intDiffSizeWidth > intToleSize)
//                        intDiffSizeWidth = intToleSize;

//                    if (intDiffSizeHeight < -intToleSize)
//                        intDiffSizeHeight = -intToleSize;
//                    else if (intDiffSizeHeight > intToleSize)
//                        intDiffSizeHeight = intToleSize;

//                    //if ((intDiffSizeWidth < 0) || (intDiffSizeHeight < 0))
//                    //{
//                    //    int intDiffSizeWidth2 = intDiffSizeWidth + m_intMPErodeHalfWidth;
//                    //    int intDiffSizeHeight2 = intDiffSizeHeight + m_intMPErodeHalfWidth;
//                    //    if ((intDiffSizeWidth2 > 0 && intDiffSizeHeight2 < 0) || (intDiffSizeHeight2 > 0 && intDiffSizeWidth2 < 0))
//                    //    {
//                    //        if (Math.Abs(intDiffSizeWidth2) > Math.Abs(intDiffSizeHeight2))
//                    //            intDiffSizeHeight2 = 0;
//                    //        else
//                    //            intDiffSizeWidth2 = 0;
//                    //    }

//                    //    if ((intDiffSizeWidth2 < 0) || (intDiffSizeHeight2 < 0))
//                    //    {
//                    //        EasyImage.ErodeBox(m_ImgMPUnitTemplateImage, objTemplatePadROI.ref_ROI, Math.Abs(intDiffSizeWidth2), Math.Abs(intDiffSizeHeight2));
//                    //    }
//                    //    else
//                    //    {

//                    //        intDiffSizeWidth2 = intDiffSizeWidth + m_intMPDilateHalfWidth;
//                    //        intDiffSizeHeight2 = intDiffSizeHeight2 + m_intMPDilateHalfWidth;
//                    //        if ((intDiffSizeWidth2 > 0 && intDiffSizeHeight2 < 0) || (intDiffSizeHeight2 > 0 && intDiffSizeWidth2 < 0))
//                    //        {
//                    //            if (Math.Abs(intDiffSizeWidth2) > Math.Abs(intDiffSizeHeight2))
//                    //                intDiffSizeHeight2 = 0;
//                    //            else
//                    //                intDiffSizeWidth2 = 0;
//                    //        }

//                    //        if ((intDiffSizeWidth2 < 0) || (intDiffSizeHeight2 < 0))
//                    //        {
//                    //        }
//                    //        else
//                    //        {
//                    //            EasyImage.DilateBox(m_ImgMPUnitTemplateImage, objTemplatePadROI.ref_ROI, Math.Abs(intDiffSizeWidth2), Math.Abs(intDiffSizeHeight2));
//                    //        }
//                    //    }
//                    //}
//                    //else
//                    //{
//                    //    if ((Math.Abs(intDiffSizeWidth) + m_intMPDilateHalfWidth) > 0 || (Math.Abs(intDiffSizeHeight) + m_intMPDilateHalfWidth) > 0)
//                    //        EasyImage.DilateBox(m_ImgMPUnitTemplateImage, objTemplatePadROI.ref_ROI, Math.Abs(intDiffSizeWidth) + m_intMPDilateHalfWidth, Math.Abs(intDiffSizeHeight) + m_intMPDilateHalfWidth);
//                    //}

//#if (Debug_2_12 || Release_2_12)
//                    // 2019-09-27 ZJYEOH : Straight dilate according to setting
//                    EasyImage.DilateBox(m_ImgMPUnitTemplateImage, objTemplatePadROI.ref_ROI, (uint)Math.Abs(m_intMPDilateHalfWidth), (uint)Math.Abs(m_intMPDilateHalfWidth));

//#elif (DEBUG || RELEASE || RTXRelease || RTXDebug)
//                    // 2019-09-27 ZJYEOH : Straight dilate according to setting
//                    EasyImage.DilateBox(m_ImgMPUnitTemplateImage, objTemplatePadROI.ref_ROI, Math.Abs(m_intMPDilateHalfWidth), Math.Abs(m_intMPDilateHalfWidth));

//#endif

//                    // Get template2 pad ROI
//                    ROI objTemplate2PadROI = new ROI();
//                    objTemplate2PadROI.ref_ROI.Detach();
//                    objTemplate2PadROI.ref_ROI.Attach(m_ImgBlackUnitTemplateImage2);
//                    objTemplate2PadROI.LoadROISetting(intStartX2, intStartY2, intWidth, intHeight);

//                    if (blnDebugImage)
//                    {
//                        m_ImgBlackUnitTemplateImage2.Save("D:\\TS\\1_B_m_ImgBlackUnitTemplateImage2.bmp");
//                        m_ImgMPUnitTemplateImage.Save("D:\\TS\\2_B_BfMPTemplateImage.bmp");// debug
//                        objTemplatePadROI.SaveImage("D:\\TS\\3_B_AfMPTemplateImage.bmp");// debug
//                        objTemplate2PadROI.SaveImage("D:\\TS\\4_B_BfSBTemplate2PadImage.bmp");// debug
//                    }


//                    if (objTemplatePadROI.ref_ROIWidth != objTemplate2PadROI.ref_ROIWidth)
//                    {
//                        int intSmallWidth = Math.Min(objTemplatePadROI.ref_ROIWidth, objTemplate2PadROI.ref_ROIWidth);
//                        objTemplatePadROI.LoadROISetting(objTemplatePadROI.ref_ROIPositionX, objTemplatePadROI.ref_ROIPositionY, intSmallWidth, objTemplatePadROI.ref_ROIHeight);
//                        objTemplate2PadROI.LoadROISetting(objTemplate2PadROI.ref_ROIPositionX, objTemplate2PadROI.ref_ROIPositionY, intSmallWidth, objTemplate2PadROI.ref_ROIHeight);
//                    }

//                    if (objTemplatePadROI.ref_ROIHeight != objTemplate2PadROI.ref_ROIHeight)
//                    {
//                        int intSmallHeight = Math.Min(objTemplatePadROI.ref_ROIHeight, objTemplate2PadROI.ref_ROIHeight);
//                        objTemplatePadROI.LoadROISetting(objTemplatePadROI.ref_ROIPositionX, objTemplatePadROI.ref_ROIPositionY, objTemplatePadROI.ref_ROIWidth, intSmallHeight);
//                        objTemplate2PadROI.LoadROISetting(objTemplate2PadROI.ref_ROIPositionX, objTemplate2PadROI.ref_ROIPositionY, objTemplate2PadROI.ref_ROIWidth, intSmallHeight);
//                    }

//                    // Add sample pad roi - template pad roi
//                    EasyImage.Oper(EArithmeticLogicOperation.Add, objTemplate2PadROI.ref_ROI, objTemplatePadROI.ref_ROI, objTemplate2PadROI.ref_ROI);

//                    if (blnDebugImage)
//                    {
//                        objTemplate2PadROI.SaveImage("D:\\TS\\B_AfSBTemplate2PadImage.bmp");// debug
//                        objTemplateROI2.SaveImage("D:\\TS\\B_objTemplate2ROI.bmp");// debug
//                    }

//                    objTemplatePadROI.Dispose();
//                    objTemplate2PadROI.Dispose();
//                }

//#endregion
//            }
//            //else if (intInpectMode == 1)
//            //{
//            //    #region Inspect Mode == 1
//            //    for (int i = 0; i < m_arrSampleBlobPads.Length; i++)
//            //    {
//            //        if (m_arrSampleBlobPads[i].intFailMask != 0)
//            //            continue;

//            //        intStartX = (int)Math.Floor(m_arrSampleBlobPads[i].fStartX);
//            //        intStartY = (int)Math.Floor(m_arrSampleBlobPads[i].fStartY);

//            //        intStartX2 = (int)Math.Floor(m_arrSampleBlobPads[i].fCenterX - m_arrSampleBlobPads[i].fWidth / 2);
//            //        intStartY2 = (int)Math.Floor(m_arrSampleBlobPads[i].fCenterY - m_arrSampleBlobPads[i].fHeight / 2);

//            //        intWidth = (int)Math.Ceiling(m_arrSampleBlobPads[i].fWidth) + 1;
//            //        intHeight = (int)Math.Ceiling(m_arrSampleBlobPads[i].fHeight) + 1;

//            //        // Get template pad roi
//            //        ROI objTemplatePadROI = new ROI();
//            //        objTemplatePadROI.AttachImage(objTemplateROI);
//            //        objTemplatePadROI.LoadROISetting(intStartX, intStartY, intWidth, intHeight);

//            //        // Get Sample pad ROI
//            //        ROI objTemplate2PadROI = new ROI();
//            //        objTemplate2PadROI.ref_ROI.Detach();
//            //        objTemplate2PadROI.ref_ROI.Attach(m_ImgBlackUnitTemplateImage2);
//            //        objTemplate2PadROI.LoadROISetting(intStartX2, intStartY2, intWidth, intHeight);

//            //        // subtract sample pad roi - template pad roi
//            //        EasyImage.Oper(EArithmeticLogicOperation.Add, objTemplate2PadROI.ref_ROI, objTemplatePadROI.ref_ROI, objTemplate2PadROI.ref_ROI);

//            //        objTemplatePadROI.Dispose();
//            //        objTemplate2PadROI.Dispose();
//            //    }
//            //    #endregion 
//            //}
//            //else
//            //{
//            //    #region Inspect mode == 2
//            //    for (int i = 0; i < m_arrTemplateBlobPads.Count; i++)
//            //    {
//            //        if (m_arrSampleBlobPads[i].intFailMask != 0)
//            //            continue;

//            //        intAdjustX = 0;
//            //        intAdjustY = 0;
//            //        intStartX = ((BlobsFeatures)m_arrTemplateBlobPads[i]).intStartX - 3;
//            //        if (intStartX < 0)
//            //        {
//            //            intAdjustX = intStartX;
//            //            intStartX = 0;
//            //        }
//            //        intStartY = ((BlobsFeatures)m_arrTemplateBlobPads[i]).intStartY - 3;
//            //        if (intStartY < 0)
//            //        {
//            //            intAdjustY = intStartY;
//            //            intStartY = 0;
//            //        }

//            //        intStartX2 = (int)Math.Round(m_arrSampleBlobPads[i].fCenterX - ((BlobsFeatures)m_arrTemplateBlobPads[i]).fWidth / 2, 0, MidpointRounding.AwayFromZero);
//            //        intStartX2 -= 3;
//            //        if (intStartX2 < 0)
//            //        {
//            //            if (intStartX2 > intAdjustX)
//            //                intAdjustX = intStartX2;
//            //            intStartX2 = 0;
//            //        }
//            //        intStartY2 = (int)Math.Round(m_arrSampleBlobPads[i].fCenterY - ((BlobsFeatures)m_arrTemplateBlobPads[i]).fHeight / 2, 0, MidpointRounding.AwayFromZero);
//            //        intStartY2 -= 3;
//            //        if (intStartY2 < 0)
//            //        {
//            //            if (intStartY2 > intAdjustY)
//            //                intAdjustY = intStartY2;
//            //            intStartY2 = 0;
//            //        }

//            //        intWidth = (int)Math.Round(((BlobsFeatures)m_arrTemplateBlobPads[i]).fWidth, 0, MidpointRounding.AwayFromZero) + 6;
//            //        intEndX = intStartX + intWidth + intAdjustX;
//            //        int intEndAdjustX = 0;
//            //        if (intEndX > objTemplateROI.ref_ROIWidth - 1)
//            //        {
//            //            intEndAdjustX = (intEndX - (objTemplateROI.ref_ROIWidth - 1));
//            //        }
//            //        intHeight = (int)Math.Round(((BlobsFeatures)m_arrTemplateBlobPads[i]).fHeight, 0, MidpointRounding.AwayFromZero) + 6;
//            //        intEndY = intStartY + intHeight + intAdjustY;
//            //        int intEndAdjustY = 0;
//            //        if (intEndY > objTemplateROI.ref_ROIHeight - 1)
//            //        {
//            //            intEndAdjustY = (intEndY - (objTemplateROI.ref_ROIHeight - 1));
//            //        }

//            //        intEndX = intStartX2 + intWidth + 6 + intAdjustX;
//            //        if (intEndX > m_ImgBlackUnitTemplateImage2.Width - 1)
//            //        {
//            //            if (intEndAdjustX < (intEndX - (m_ImgBlackUnitTemplateImage2.Width - 1)))
//            //                intEndAdjustX = (intEndX - (m_ImgBlackUnitTemplateImage2.Width - 1));
//            //        }
//            //        intEndY = intStartY2 + intHeight + 6 + intAdjustY;
//            //        if (intEndY > m_ImgBlackUnitTemplateImage2.Height - 1)
//            //        {
//            //            if (intEndAdjustY < (intEndY - (m_ImgBlackUnitTemplateImage2.Height - 1)))
//            //                intEndAdjustY = (intEndY - (m_ImgBlackUnitTemplateImage2.Height - 1));
//            //        }

//            //        intWidth -= intEndAdjustX;
//            //        intHeight -= intEndAdjustY;

//            //        // Get template pad roi
//            //        ROI objTemplatePadROI = new ROI();
//            //        objTemplatePadROI.AttachImage(objTemplateROI);
//            //        objTemplatePadROI.LoadROISetting(intStartX, intStartY, intWidth, intHeight);

//            //        // Get Sample pad ROI
//            //        ROI objTemplate2PadROI = new ROI();
//            //        objTemplate2PadROI.ref_ROI.Detach();
//            //        objTemplate2PadROI.ref_ROI.Attach(m_ImgBlackUnitTemplateImage2);
//            //        objTemplate2PadROI.LoadROISetting(intStartX2, intStartY2, intWidth, intHeight);

//            //        // subtract sample pad roi - template pad roi
//            //        EasyImage.Oper(EArithmeticLogicOperation.Add, objTemplate2PadROI.ref_ROI, objTemplatePadROI.ref_ROI, objTemplate2PadROI.ref_ROI);

//            //        objTemplatePadROI.Dispose();
//            //        objTemplate2PadROI.Dispose();
//            //    }

//            //    #endregion
//            //}

//            if (blnDebugImage)
//            {
//                objSampleROI.SaveImage("D:\\TS\\20.B_BfSBSampleROI.bmp");// debug
//                objTemplateROI2.SaveImage("D:\\TS\\21.B_objTemplate2ROI.bmp");// debug
//            }

//            // Subtract sample ROI - template ROI
//            if (objSampleROI.ref_ROIWidth != objTemplateROI2.ref_ROIWidth)
//            {
//                if (objSampleROI.ref_ROIWidth > objTemplateROI2.ref_ROIWidth)
//                    objSampleROI.ref_ROIWidth = objTemplateROI2.ref_ROIWidth;
//                else
//                    objTemplateROI2.ref_ROIWidth = objSampleROI.ref_ROIWidth;
//            }

//            if (objSampleROI.ref_ROIHeight != objTemplateROI2.ref_ROIHeight)
//            {
//                if (objSampleROI.ref_ROIHeight > objTemplateROI2.ref_ROIHeight)
//                    objSampleROI.ref_ROIHeight = objTemplateROI2.ref_ROIHeight;
//                else
//                    objTemplateROI2.ref_ROIHeight = objSampleROI.ref_ROIHeight;
//            }

//            if (blnDebugImage)
//            {
//                objSampleROI.SaveImage("D:\\TS\\22.B_BfSBSampleROI.bmp");// debug
//                objTemplateROI2.SaveImage("D:\\TS\\23.B_objTemplate2ROI.bmp");// debug
//                objTemplateROI.SaveImage("D:\\TS\\24.objTemplateROI.bmp");
//            }


//            if (intImageIndex == 1)
//                EasyImage.Oper(EArithmeticLogicOperation.Subtract, objSampleROI.ref_ROI, objTemplateROI2.ref_ROI, objSampleROI.ref_ROI);    // 2019 05 14 - CCENG: Use templateROI2 because the pad location is according to sample ROI.
//                                                                                                                                            //EasyImage.Oper(EArithmeticLogicOperation.Subtract, objSampleROI.ref_ROI, objTemplateROI.ref_ROI, objSampleROI.ref_ROI);

//            //objSampleROI.SaveImage("D:\\objSampleROI.bmp");
//            //objTemplateROI.SaveImage("D:\\objTemplateROI.bmp");
//            if (blnDebugImage)
//                objSampleROI.SaveImage("D:\\TS\\B_AfSBSampleROI.bmp");// debug

//            // Check Unit Surface Contamination (m_intFailPkgOptionMask 0x10=Contamination Length, 0x20=Contamiation Area, 0x40=Contamination Total Area
//            if ((m_intFailPkgOptionMask & 0x30000) > 0)
//            {
//                objSampleROI.LoadROISetting(objImageUnitROI.ref_ROITotalX,
//                                            objImageUnitROI.ref_ROITotalY,
//                                            objImageUnitROI.ref_ROIWidth, objImageUnitROI.ref_ROIHeight);

//                if (m_objRectGauge4L.GetGaugeTiltAngle() == 0)
//                {
//                    if (!IsImage1UnitBrightFieldPackageFailed(objSampleROI, objSampleROI.ref_ROITotalX, objSampleROI.ref_ROITotalY, intImageIndex))
//                    {
//                        objSampleROI.Dispose();
//                        objTemplateROI.Dispose();
//                        objTemplateROI2.Dispose();
//                        return false;
//                    }
//                }
//                else
//                {
//                    if (!IsImage1UnitBrightFieldPackageFailed_TiltAngle(objSampleROI, objSampleROI.ref_ROITotalX, objSampleROI.ref_ROITotalY, intImageIndex, intPadIndex))
//                    {
//                        objSampleROI.Dispose();
//                        objTemplateROI.Dispose();
//                        objTemplateROI2.Dispose();
//                        return false;
//                    }
//                }
//            }

//            //// Check Unit Chipped off
//            //if ((m_intFailPkgOptionMask & 0x04) > 0)
//            //{
//            //    objSampleROI.LoadROISetting(objImageUnitROI.ref_ROITotalX,
//            //                                objImageUnitROI.ref_ROITotalY,
//            //                                objImageUnitROI.ref_ROIWidth, objImageUnitROI.ref_ROIHeight);

//            //    if (!IsImage1UnitChippedOff2_Area(objSampleROI, objSampleROI.ref_ROITotalX, objSampleROI.ref_ROITotalY, intImageIndex)) // IsImage1UnitChippedOff2
//            //    {
//            //        //objImageUnitROI.SaveImage("D:\\objImageUnitROI_"+intImageIndex.ToString()+".bmp");
//            //        //objSampleROI.SaveImage("D:\\objSampleROI_" + intImageIndex.ToString() + ".bmp");
//            //        //objTemplateROI.SaveImage("D:\\objTemplateROI_" + intImageIndex.ToString() + ".bmp");
//            //        //objTemplateROI2.SaveImage("D:\\objTemplateROI2_" + intImageIndex.ToString() + ".bmp");

//            //        objSampleROI.Dispose();
//            //        objTemplateROI.Dispose();
//            //        objTemplateROI2.Dispose();

//            //        return false;
//            //    }
//            //}

//            objSampleROI.Dispose();
//            objTemplateROI.Dispose();
//            objTemplateROI2.Dispose();

//            return blnResult;
//        }

        private bool CheckImageDarkDefect_Simple(ROI objImageUnitToleranceROI, ROI objImageUnitROI, int intImageIndex, int intPadIndex)//, bool blnPadPkg)
        {
            // Return if Bright Field Area and Length are OFF
            if (((m_intFailPkgOptionMask & 0x40000) == 0) && ((m_intFailPkgOptionMask & 0x80000) == 0))
                return true;

            int intInpectMode = 0; //0=Flexi template size, 1= use sample size, 2: Fix template size
            bool blnResult = true;
            bool blnDebugImage = false;

            if (blnDebugImage)
            {
                objImageUnitToleranceROI.SaveImage("D:\\TS\\1.objImageUnitToleranceROI.bmp");
                objImageUnitROI.SaveImage("D:\\TS\\2.objImageUnitROI.bmp");
            }

            // Get ready sample ROI
            ROI objSampleROI = new ROI();
            objSampleROI.AttachImage(m_objInsSurfacePkgImage1);  // m_objInsSurfacePkgImage1 is temporary image use to hold objSampleROI double threshold
            objSampleROI.LoadROISetting(objImageUnitToleranceROI.ref_ROITotalX, objImageUnitToleranceROI.ref_ROITotalY, objImageUnitToleranceROI.ref_ROIWidth, objImageUnitToleranceROI.ref_ROIHeight);

            //// Gain and Double threshold
            //EasyImage.DoubleThreshold(objImageUnitToleranceROI.ref_ROI, objSampleROI.ref_ROI, m_intDarkFieldLowThreshold, m_intDarkFieldHighThreshold, 255, 0, 255);// WinXP (255,0,255) , Win7 (0,255,0)

            // 2019-11-06 ZJYEOH : Add gain for Dark Field Inspection Image
            EasyImage.GainOffset(objImageUnitToleranceROI.ref_ROI, objSampleROI.ref_ROI, m_fDarkFieldImageGain);
#if (Debug_2_12 || Release_2_12)
            // Gain and Double threshold
            EasyImage.DoubleThreshold(objSampleROI.ref_ROI, objSampleROI.ref_ROI, (uint)m_intDarkFieldLowThreshold, (uint)m_intDarkFieldHighThreshold, 255, 0, 255);// WinXP (255,0,255) , Win7 (0,255,0)

#elif (DEBUG || RELEASE || RTXRelease || RTXDebug)
                  // Gain and Double threshold
            EasyImage.DoubleThreshold(objSampleROI.ref_ROI, objSampleROI.ref_ROI, m_intDarkFieldLowThreshold, m_intDarkFieldHighThreshold, 255, 0, 255);// WinXP (255,0,255) , Win7 (0,255,0)

#endif

            if (blnDebugImage)
            {
                objImageUnitToleranceROI.SaveImage("D:\\TS\\objImageUnitToleranceROI.bmp");
                m_objInsSurfacePkgImage1.SaveImage("D:\\TS\\3.m_objInsSurfacePkgImage1.bmp");
                objSampleROI.SaveImage("D:\\TS\\4.objSampleROI.bmp");
            }

            // Get ready template ROI
            ROI objTemplateROI = new ROI();
            if (intInpectMode == 0) // Current use Inspect Mode
            {
                // Get threshold value
                int intThresholdValue;
                if (m_intThresholdValue < 0)
                {
                    EBW8 objBW8;
                    if (intImageIndex == 1)
                        objBW8 = EasyImage.AutoThreshold(m_ImgUnitTemplateImage, EThresholdMode.MinResidue);
                    else
                        objBW8 = EasyImage.AutoThreshold(m_ImgUnitTemplateImagePkg, EThresholdMode.MinResidue);
                    intThresholdValue = objBW8.Value;
                }
                else
                    intThresholdValue = m_intThresholdValue;

                if (blnDebugImage)
                {
                    m_ImgUnitTemplateImage.Save("D:\\TS\\5.m_ImgUnitTemplateImage.bmp");// debug
                    m_ImgTUnitErodeThresImage.Save("D:\\TS\\6.m_ImgTUnitErodeThresImage.bmp");// debug
                    m_ImgUnitTemplateImagePkg.Save("D:\\TS\\7.m_ImgUnitTemplateImagePkg.bmp");// debug
                    m_ImgTUnitErodeThresImagePkg.Save("D:\\TS\\8.m_ImgTUnitErodeThresImagePkg.bmp");// debug
                }
#if (Debug_2_12 || Release_2_12)
                if (intImageIndex == 1)
                {
                    EasyImage.Copy(m_ImgUnitTemplateImage, m_ImgTUnitErodeThresImage);
                    // single threshold template image
                    if (m_fPadImageGain != 1f)
                    {
                        EasyImage.GainOffset(m_ImgTUnitErodeThresImage, m_ImgTUnitErodeThresImage, m_fPadImageGain);
                        EasyImage.Threshold(m_ImgTUnitErodeThresImage, m_ImgTUnitErodeThresImage, (uint)intThresholdValue);
                    }
                    else
                    {
                        EasyImage.Threshold(m_ImgTUnitErodeThresImage, m_ImgTUnitErodeThresImage, (uint)intThresholdValue);
                    }
                    objTemplateROI.ref_ROI.Detach();
                    objTemplateROI.ref_ROI.Attach(m_ImgTUnitErodeThresImage);
                    objTemplateROI.LoadROISetting(m_ImgTUnitErodeThresImage.Width / 2 - objImageUnitToleranceROI.ref_ROIWidth / 2,
                                                  m_ImgTUnitErodeThresImage.Height / 2 - objImageUnitToleranceROI.ref_ROIHeight / 2,
                                                  objImageUnitToleranceROI.ref_ROIWidth,
                                                  objImageUnitToleranceROI.ref_ROIHeight);
                }
                else
                {
                    EasyImage.Copy(m_ImgUnitTemplateImagePkg, m_ImgTUnitErodeThresImagePkg);
                    // single threshold template image
                    if (m_fPadImageGain != 1f)
                    {
                        EasyImage.GainOffset(m_ImgTUnitErodeThresImagePkg, m_ImgTUnitErodeThresImagePkg, m_fPadImageGain);
                        EasyImage.Threshold(m_ImgTUnitErodeThresImagePkg, m_ImgTUnitErodeThresImagePkg, (uint)intThresholdValue);
                    }
                    else
                    {
                        EasyImage.Threshold(m_ImgTUnitErodeThresImagePkg, m_ImgTUnitErodeThresImagePkg, (uint)intThresholdValue);
                    }
                    objTemplateROI.ref_ROI.Detach();
                    objTemplateROI.ref_ROI.Attach(m_ImgTUnitErodeThresImagePkg);
                    objTemplateROI.LoadROISetting(0, 0, objImageUnitROI.ref_ROIWidth, objImageUnitROI.ref_ROIHeight);
                }

#elif (DEBUG || RELEASE || RTXRelease || RTXDebug)
                if (intImageIndex == 1)
                {
                    EasyImage.Copy(m_ImgUnitTemplateImage, m_ImgTUnitErodeThresImage);
                    // single threshold template image
                    if (m_fPadImageGain != 1f)
                    {
                        EasyImage.GainOffset(m_ImgTUnitErodeThresImage, m_ImgTUnitErodeThresImage, m_fPadImageGain);
                        EasyImage.Threshold(m_ImgTUnitErodeThresImage, m_ImgTUnitErodeThresImage, intThresholdValue);
                    }
                    else
                    {
                        EasyImage.Threshold(m_ImgTUnitErodeThresImage, m_ImgTUnitErodeThresImage, intThresholdValue);
                    }
                    objTemplateROI.ref_ROI.Detach();
                    objTemplateROI.ref_ROI.Attach(m_ImgTUnitErodeThresImage);
                    objTemplateROI.LoadROISetting(m_ImgTUnitErodeThresImage.Width / 2 - objImageUnitToleranceROI.ref_ROIWidth / 2,
                                                  m_ImgTUnitErodeThresImage.Height / 2 - objImageUnitToleranceROI.ref_ROIHeight / 2,
                                                  objImageUnitToleranceROI.ref_ROIWidth,
                                                  objImageUnitToleranceROI.ref_ROIHeight);
                }
                else
                {
                    EasyImage.Copy(m_ImgUnitTemplateImagePkg, m_ImgTUnitErodeThresImagePkg);
                    // single threshold template image
                    if (m_fPadImageGain != 1f)
                    {
                        EasyImage.GainOffset(m_ImgTUnitErodeThresImagePkg, m_ImgTUnitErodeThresImagePkg, m_fPadImageGain);
                        EasyImage.Threshold(m_ImgTUnitErodeThresImagePkg, m_ImgTUnitErodeThresImagePkg, intThresholdValue);
                    }
                    else
                    {
                        EasyImage.Threshold(m_ImgTUnitErodeThresImagePkg, m_ImgTUnitErodeThresImagePkg, intThresholdValue);
                    }
                    objTemplateROI.ref_ROI.Detach();
                    objTemplateROI.ref_ROI.Attach(m_ImgTUnitErodeThresImagePkg);
                    objTemplateROI.LoadROISetting(0, 0, objImageUnitROI.ref_ROIWidth, objImageUnitROI.ref_ROIHeight);
                }

#endif

                if (blnDebugImage)
                {
                    objImageUnitROI.SaveImage("D:\\TS\\9.B_OriSampleROI.bmp");// debug
                    m_ImgUnitTemplateImage.Save("D:\\TS\\10.B_OriTemplateImage.bmp");// debug
                    m_ImgTUnitErodeThresImage.Save("D:\\TS\\11.B_m_ImgTUnitErodeThresImage.bmp");// debug
                    objTemplateROI.SaveImage("D:\\TS\\12.B_objTemplateROI.bmp");// debug
                    objSampleROI.SaveImage("D:\\TS\\13.B_objSampleROI.bmp");// debug
                }
            }

            if (intImageIndex == 1)
            {
                // Get ready blank black image
                m_ImgBlackUnitTemplateImage.CopyTo(m_ImgBlackUnitTemplateImage2);
            }
            else
            {
                // Get ready blank white image
                m_ImgWhiteUnitTemplateImagePkg.CopyTo(m_ImgWhiteUnitTemplateImage2);
            }

            ROI objTemplateROI2 = new ROI();
            objTemplateROI2.ref_ROI.Detach();
            if (intImageIndex == 1)
            {
                objTemplateROI2.ref_ROI.Attach(m_ImgBlackUnitTemplateImage2);
            }
            else
            {
                //objTemplateROI2.ref_ROI.Attach(m_ImgBlackUnitTemplateImage2);
                objTemplateROI2.ref_ROI.Attach(m_ImgWhiteUnitTemplateImage2);
            }

            objTemplateROI2.LoadROISetting(0, 0, objImageUnitToleranceROI.ref_ROIWidth, objImageUnitToleranceROI.ref_ROIHeight);


            if (blnDebugImage)
                objTemplateROI2.SaveImage("D:\\TS\\14.BlankTemplateROI2.bmp");// debug

            int intStartX, intStartY, intEndX, intEndY, intAdjustX, intAdjustY, intStartX2, intStartY2, intWidth, intHeight;

            if (intInpectMode == 10)
            {
#region Inspect Mode == 0
                int intToleSize = m_intMPDilateHalfWidth;

                for (int i = 0; i < m_arrTemplateBlobPads.Count; i++)
                {
                    if (m_arrSampleBlobPads[i].intFailMask != 0)
                        continue;

                    // check the different size between sample pad and template pad
                    int intDiffSizeWidth = (int)Math.Round((m_arrSampleBlobPads[i].fWidth - ((BlobsFeatures)m_arrTemplateBlobPads[i]).fWidth) / 2, 0, MidpointRounding.AwayFromZero);
                    int intDiffSizeHeight = (int)Math.Round((m_arrSampleBlobPads[i].fHeight - ((BlobsFeatures)m_arrTemplateBlobPads[i]).fHeight) / 2, 0, MidpointRounding.AwayFromZero);

                    // set one of the size (width or height) to zero if one side is bigger and another side is smaller
                    if ((intDiffSizeWidth > 0 && intDiffSizeHeight < 0) || (intDiffSizeHeight > 0 && intDiffSizeWidth < 0))
                    {
                        if (Math.Abs(intDiffSizeWidth) > Math.Abs(intDiffSizeHeight))    // the bigger value will set to 0
                            intDiffSizeHeight = 0;
                        else
                            intDiffSizeWidth = 0;
                    }

                    float fWidth, fHeight;
                    // get bigger size from sample pad or template pad
                    if ((intDiffSizeWidth > 0) || (intDiffSizeHeight > 0))
                    {
                        // Use sample size
                        fWidth = m_arrSampleBlobPads[i].fWidth;
                        fHeight = m_arrSampleBlobPads[i].fHeight;
                    }
                    else
                    {
                        // Use template size
                        fWidth = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fWidth;
                        fHeight = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fHeight;
                    }

                    // Get "template" pad start and end corner point with tolerance size added.
                    intAdjustX = 0;
                    intAdjustY = 0;
                    intStartX = (int)Math.Round(((BlobsFeatures)m_arrTemplateBlobPads[i]).fLimitCenterX - fWidth / 2 - intToleSize, 0, MidpointRounding.AwayFromZero);
                    if (intStartX < 0)  // Set to zero if value smaller than zero
                    {
                        intAdjustX = intStartX; // add adjust value when intStartX change from negative to 0
                        intStartX = 0;
                    }
                    intStartY = (int)Math.Round(((BlobsFeatures)m_arrTemplateBlobPads[i]).fLimitCenterY - fHeight / 2 - intToleSize, 0, MidpointRounding.AwayFromZero);
                    if (intStartY < 0)  // Set to zero if value smaller than zero
                    {
                        intAdjustY = intStartY; // add adjust value when intStartY change from negative to 0
                        intStartY = 0;
                    }

                    // Get "sample" pad start and end corner point with tolerance size added.
                    intStartX2 = (int)Math.Round(m_arrSampleBlobPads[i].fCenterX - fWidth / 2 - intToleSize, 0, MidpointRounding.AwayFromZero);
                    if (intStartX2 < 0) // Set to zero if value smaller than zero
                    {
                        if (intStartX2 > intAdjustX)    // set bigger value in adjust value // Why is bigger, not smaller?
                            intAdjustX = intStartX2;
                        intStartX2 = 0;
                    }
                    intStartY2 = (int)Math.Round(m_arrSampleBlobPads[i].fCenterY - fHeight / 2 - intToleSize, 0, MidpointRounding.AwayFromZero);
                    if (intStartY2 < 0) // Set to zero if value smaller than zero
                    {
                        if (intStartY2 > intAdjustY)    // set bigger value in adjust value // Why is bigger, not smaller?
                            intAdjustY = intStartY2;
                        intStartY2 = 0;
                    }

                    // Set "template" pad width with tolerance size and adjust value added
                    intWidth = (int)Math.Round(fWidth + intToleSize * 2, 0, MidpointRounding.AwayFromZero);
                    intEndX = intStartX + intWidth + intAdjustX;
                    int intEndAdjustX = 0;
                    if (intEndX > objTemplateROI.ref_ROIWidth - 1)
                    {
                        intEndAdjustX = (intEndX - (objTemplateROI.ref_ROIWidth - 1));  // Set end adjust value if endx bigger than roi area
                    }
                    intHeight = (int)Math.Round(fHeight + intToleSize * 2, 0, MidpointRounding.AwayFromZero);
                    intEndY = intStartY + intHeight + intAdjustY;
                    int intEndAdjustY = 0;
                    if (intEndY > objTemplateROI.ref_ROIHeight - 1)
                    {
                        intEndAdjustY = (intEndY - (objTemplateROI.ref_ROIHeight)); // Set end adjust value if endx bigger than roi area
                    }

                    // set pad corner end point value
                    //intEndX = intStartX2 + intWidth + intToleSize * 2 + intAdjustX;
                    intEndX = intStartX2 + intWidth + intAdjustX;
                    if (intEndX > m_ImgBlackUnitTemplateImage2.Width - 1)
                    {
                        if (intEndAdjustX < (intEndX - (m_ImgBlackUnitTemplateImage2.Width - 1)))
                            intEndAdjustX = (intEndX - (m_ImgBlackUnitTemplateImage2.Width - 1));
                    }
                    //intEndY = intStartY2 + intHeight + intToleSize * 2 + intAdjustY;
                    intEndY = intStartY2 + intHeight + intAdjustY;
                    if (intEndY > m_ImgBlackUnitTemplateImage2.Height - 1)
                    {
                        if (intEndAdjustY < (intEndY - (m_ImgBlackUnitTemplateImage2.Height - 1)))
                            intEndAdjustY = (intEndY - (m_ImgBlackUnitTemplateImage2.Height - 1));
                    }

                    intWidth -= intEndAdjustX;
                    intHeight -= intEndAdjustY;

                    // Get template pad roi
                    ROI objTemplatePadROI = new ROI();
                    objTemplatePadROI.AttachImage(objTemplateROI);
                    objTemplatePadROI.LoadROISetting(intStartX, intStartY, intWidth, intHeight);

                    if (blnDebugImage)
                    {
                        objTemplatePadROI.SaveImage("D:\\TS\\objTemplatePadROI.bmp");// debug
                    }

                    m_ImgMPUnitTemplateImage.SetSize(objTemplatePadROI.ref_ROIWidth, objTemplatePadROI.ref_ROIHeight);
                    EasyImage.Copy(objTemplatePadROI.ref_ROI, m_ImgMPUnitTemplateImage);

                    if (intDiffSizeWidth < -intToleSize)
                        intDiffSizeWidth = -intToleSize;
                    else if (intDiffSizeWidth > intToleSize)
                        intDiffSizeWidth = intToleSize;

                    if (intDiffSizeHeight < -intToleSize)
                        intDiffSizeHeight = -intToleSize;
                    else if (intDiffSizeHeight > intToleSize)
                        intDiffSizeHeight = intToleSize;
#if (Debug_2_12 || Release_2_12)
                    if ((intDiffSizeWidth < 0) || (intDiffSizeHeight < 0))
                    {
                        int intDiffSizeWidth2 = intDiffSizeWidth + m_intMPErodeHalfWidth;
                        int intDiffSizeHeight2 = intDiffSizeHeight + m_intMPErodeHalfWidth;
                        if ((intDiffSizeWidth2 > 0 && intDiffSizeHeight2 < 0) || (intDiffSizeHeight2 > 0 && intDiffSizeWidth2 < 0))
                        {
                            if (Math.Abs(intDiffSizeWidth2) > Math.Abs(intDiffSizeHeight2))
                                intDiffSizeHeight2 = 0;
                            else
                                intDiffSizeWidth2 = 0;
                        }

                        if ((intDiffSizeWidth2 < 0) || (intDiffSizeHeight2 < 0))
                        {
                            EasyImage.ErodeBox(m_ImgMPUnitTemplateImage, objTemplatePadROI.ref_ROI, (uint)Math.Abs(intDiffSizeWidth2), (uint)Math.Abs(intDiffSizeHeight2));
                        }
                        else
                        {

                            intDiffSizeWidth2 = intDiffSizeWidth + m_intMPDilateHalfWidth;
                            intDiffSizeHeight2 = intDiffSizeHeight2 + m_intMPDilateHalfWidth;
                            if ((intDiffSizeWidth2 > 0 && intDiffSizeHeight2 < 0) || (intDiffSizeHeight2 > 0 && intDiffSizeWidth2 < 0))
                            {
                                if (Math.Abs(intDiffSizeWidth2) > Math.Abs(intDiffSizeHeight2))
                                    intDiffSizeHeight2 = 0;
                                else
                                    intDiffSizeWidth2 = 0;
                            }

                            if ((intDiffSizeWidth2 < 0) || (intDiffSizeHeight2 < 0))
                            {
                            }
                            else
                            {
                                EasyImage.DilateBox(m_ImgMPUnitTemplateImage, objTemplatePadROI.ref_ROI, (uint)Math.Abs(intDiffSizeWidth2), (uint)Math.Abs(intDiffSizeHeight2));
                            }
                        }
                    }
                    else
                    {
                        if ((Math.Abs(intDiffSizeWidth) + m_intMPDilateHalfWidth) > 0 || (Math.Abs(intDiffSizeHeight) + m_intMPDilateHalfWidth) > 0)
                            EasyImage.DilateBox(m_ImgMPUnitTemplateImage, objTemplatePadROI.ref_ROI, (uint)(Math.Abs(intDiffSizeWidth) + m_intMPDilateHalfWidth), (uint)(Math.Abs(intDiffSizeHeight) + m_intMPDilateHalfWidth));
                    }

#elif (DEBUG || RELEASE || RTXRelease || RTXDebug)
                    if ((intDiffSizeWidth < 0) || (intDiffSizeHeight < 0))
                    {
                        int intDiffSizeWidth2 = intDiffSizeWidth + m_intMPErodeHalfWidth;
                        int intDiffSizeHeight2 = intDiffSizeHeight + m_intMPErodeHalfWidth;
                        if ((intDiffSizeWidth2 > 0 && intDiffSizeHeight2 < 0) || (intDiffSizeHeight2 > 0 && intDiffSizeWidth2 < 0))
                        {
                            if (Math.Abs(intDiffSizeWidth2) > Math.Abs(intDiffSizeHeight2))
                                intDiffSizeHeight2 = 0;
                            else
                                intDiffSizeWidth2 = 0;
                        }

                        if ((intDiffSizeWidth2 < 0) || (intDiffSizeHeight2 < 0))
                        {
                            EasyImage.ErodeBox(m_ImgMPUnitTemplateImage, objTemplatePadROI.ref_ROI, Math.Abs(intDiffSizeWidth2), Math.Abs(intDiffSizeHeight2));
                        }
                        else
                        {

                            intDiffSizeWidth2 = intDiffSizeWidth + m_intMPDilateHalfWidth;
                            intDiffSizeHeight2 = intDiffSizeHeight2 + m_intMPDilateHalfWidth;
                            if ((intDiffSizeWidth2 > 0 && intDiffSizeHeight2 < 0) || (intDiffSizeHeight2 > 0 && intDiffSizeWidth2 < 0))
                            {
                                if (Math.Abs(intDiffSizeWidth2) > Math.Abs(intDiffSizeHeight2))
                                    intDiffSizeHeight2 = 0;
                                else
                                    intDiffSizeWidth2 = 0;
                            }

                            if ((intDiffSizeWidth2 < 0) || (intDiffSizeHeight2 < 0))
                            {
                            }
                            else
                            {
                                EasyImage.DilateBox(m_ImgMPUnitTemplateImage, objTemplatePadROI.ref_ROI, Math.Abs(intDiffSizeWidth2), Math.Abs(intDiffSizeHeight2));
                            }
                        }
                    }
                    else
                    {
                        if ((Math.Abs(intDiffSizeWidth) + m_intMPDilateHalfWidth) > 0 || (Math.Abs(intDiffSizeHeight) + m_intMPDilateHalfWidth) > 0)
                            EasyImage.DilateBox(m_ImgMPUnitTemplateImage, objTemplatePadROI.ref_ROI, Math.Abs(intDiffSizeWidth) + m_intMPDilateHalfWidth, Math.Abs(intDiffSizeHeight) + m_intMPDilateHalfWidth);
                    }

#endif

                    // Get template2 pad ROI
                    ROI objTemplate2PadROI = new ROI();
                    objTemplate2PadROI.ref_ROI.Detach();
                    objTemplate2PadROI.ref_ROI.Attach(m_ImgBlackUnitTemplateImage2);
                    objTemplate2PadROI.LoadROISetting(intStartX2, intStartY2, intWidth, intHeight);

                    if (blnDebugImage)
                    {
                        m_ImgMPUnitTemplateImage.Save("D:\\TS\\B_BfMPTemplateImage.bmp");// debug
                        objTemplatePadROI.SaveImage("D:\\TS\\B_AfMPTemplateImage.bmp");// debug
                        objTemplate2PadROI.SaveImage("D:\\TS\\B_BfSBTemplate2PadImage.bmp");// debug
                    }

                    // Add sample pad roi - template pad roi
                    EasyImage.Oper(EArithmeticLogicOperation.Add, objTemplate2PadROI.ref_ROI, objTemplatePadROI.ref_ROI, objTemplate2PadROI.ref_ROI);

                    if (blnDebugImage)
                    {
                        objTemplate2PadROI.SaveImage("D:\\TS\\B_AfSBTemplate2PadImage.bmp");// debug
                        objTemplateROI2.SaveImage("D:\\TS\\B_objTemplate2ROI.bmp");// debug
                    }

                    objTemplatePadROI.Dispose();
                    objTemplate2PadROI.Dispose();
                }

#endregion
            }
            //else if (intInpectMode == 1)
            //{
            //    #region Inspect Mode == 1
            //    for (int i = 0; i < m_arrSampleBlobPads.Length; i++)
            //    {
            //        if (m_arrSampleBlobPads[i].intFailMask != 0)
            //            continue;

            //        intStartX = (int)Math.Floor(m_arrSampleBlobPads[i].fStartX);
            //        intStartY = (int)Math.Floor(m_arrSampleBlobPads[i].fStartY);

            //        intStartX2 = (int)Math.Floor(m_arrSampleBlobPads[i].fCenterX - m_arrSampleBlobPads[i].fWidth / 2);
            //        intStartY2 = (int)Math.Floor(m_arrSampleBlobPads[i].fCenterY - m_arrSampleBlobPads[i].fHeight / 2);

            //        intWidth = (int)Math.Ceiling(m_arrSampleBlobPads[i].fWidth) + 1;
            //        intHeight = (int)Math.Ceiling(m_arrSampleBlobPads[i].fHeight) + 1;

            //        // Get template pad roi
            //        ROI objTemplatePadROI = new ROI();
            //        objTemplatePadROI.AttachImage(objTemplateROI);
            //        objTemplatePadROI.LoadROISetting(intStartX, intStartY, intWidth, intHeight);

            //        // Get Sample pad ROI
            //        ROI objTemplate2PadROI = new ROI();
            //        objTemplate2PadROI.ref_ROI.Detach();
            //        objTemplate2PadROI.ref_ROI.Attach(m_ImgBlackUnitTemplateImage2);
            //        objTemplate2PadROI.LoadROISetting(intStartX2, intStartY2, intWidth, intHeight);

            //        // subtract sample pad roi - template pad roi
            //        EasyImage.Oper(EArithmeticLogicOperation.Add, objTemplate2PadROI.ref_ROI, objTemplatePadROI.ref_ROI, objTemplate2PadROI.ref_ROI);

            //        objTemplatePadROI.Dispose();
            //        objTemplate2PadROI.Dispose();
            //    }
            //    #endregion 
            //}
            //else
            //{
            //    #region Inspect mode == 2
            //    for (int i = 0; i < m_arrTemplateBlobPads.Count; i++)
            //    {
            //        if (m_arrSampleBlobPads[i].intFailMask != 0)
            //            continue;

            //        intAdjustX = 0;
            //        intAdjustY = 0;
            //        intStartX = ((BlobsFeatures)m_arrTemplateBlobPads[i]).intStartX - 3;
            //        if (intStartX < 0)
            //        {
            //            intAdjustX = intStartX;
            //            intStartX = 0;
            //        }
            //        intStartY = ((BlobsFeatures)m_arrTemplateBlobPads[i]).intStartY - 3;
            //        if (intStartY < 0)
            //        {
            //            intAdjustY = intStartY;
            //            intStartY = 0;
            //        }

            //        intStartX2 = (int)Math.Round(m_arrSampleBlobPads[i].fCenterX - ((BlobsFeatures)m_arrTemplateBlobPads[i]).fWidth / 2, 0, MidpointRounding.AwayFromZero);
            //        intStartX2 -= 3;
            //        if (intStartX2 < 0)
            //        {
            //            if (intStartX2 > intAdjustX)
            //                intAdjustX = intStartX2;
            //            intStartX2 = 0;
            //        }
            //        intStartY2 = (int)Math.Round(m_arrSampleBlobPads[i].fCenterY - ((BlobsFeatures)m_arrTemplateBlobPads[i]).fHeight / 2, 0, MidpointRounding.AwayFromZero);
            //        intStartY2 -= 3;
            //        if (intStartY2 < 0)
            //        {
            //            if (intStartY2 > intAdjustY)
            //                intAdjustY = intStartY2;
            //            intStartY2 = 0;
            //        }

            //        intWidth = (int)Math.Round(((BlobsFeatures)m_arrTemplateBlobPads[i]).fWidth, 0, MidpointRounding.AwayFromZero) + 6;
            //        intEndX = intStartX + intWidth + intAdjustX;
            //        int intEndAdjustX = 0;
            //        if (intEndX > objTemplateROI.ref_ROIWidth - 1)
            //        {
            //            intEndAdjustX = (intEndX - (objTemplateROI.ref_ROIWidth - 1));
            //        }
            //        intHeight = (int)Math.Round(((BlobsFeatures)m_arrTemplateBlobPads[i]).fHeight, 0, MidpointRounding.AwayFromZero) + 6;
            //        intEndY = intStartY + intHeight + intAdjustY;
            //        int intEndAdjustY = 0;
            //        if (intEndY > objTemplateROI.ref_ROIHeight - 1)
            //        {
            //            intEndAdjustY = (intEndY - (objTemplateROI.ref_ROIHeight - 1));
            //        }

            //        intEndX = intStartX2 + intWidth + 6 + intAdjustX;
            //        if (intEndX > m_ImgBlackUnitTemplateImage2.Width - 1)
            //        {
            //            if (intEndAdjustX < (intEndX - (m_ImgBlackUnitTemplateImage2.Width - 1)))
            //                intEndAdjustX = (intEndX - (m_ImgBlackUnitTemplateImage2.Width - 1));
            //        }
            //        intEndY = intStartY2 + intHeight + 6 + intAdjustY;
            //        if (intEndY > m_ImgBlackUnitTemplateImage2.Height - 1)
            //        {
            //            if (intEndAdjustY < (intEndY - (m_ImgBlackUnitTemplateImage2.Height - 1)))
            //                intEndAdjustY = (intEndY - (m_ImgBlackUnitTemplateImage2.Height - 1));
            //        }

            //        intWidth -= intEndAdjustX;
            //        intHeight -= intEndAdjustY;

            //        // Get template pad roi
            //        ROI objTemplatePadROI = new ROI();
            //        objTemplatePadROI.AttachImage(objTemplateROI);
            //        objTemplatePadROI.LoadROISetting(intStartX, intStartY, intWidth, intHeight);

            //        // Get Sample pad ROI
            //        ROI objTemplate2PadROI = new ROI();
            //        objTemplate2PadROI.ref_ROI.Detach();
            //        objTemplate2PadROI.ref_ROI.Attach(m_ImgBlackUnitTemplateImage2);
            //        objTemplate2PadROI.LoadROISetting(intStartX2, intStartY2, intWidth, intHeight);

            //        // subtract sample pad roi - template pad roi
            //        EasyImage.Oper(EArithmeticLogicOperation.Add, objTemplate2PadROI.ref_ROI, objTemplatePadROI.ref_ROI, objTemplate2PadROI.ref_ROI);

            //        objTemplatePadROI.Dispose();
            //        objTemplate2PadROI.Dispose();
            //    }

            //    #endregion
            //}

            if (blnDebugImage)
            {
                objSampleROI.SaveImage("D:\\TS\\20.B_BfSBSampleROI.bmp");// debug
                objTemplateROI2.SaveImage("D:\\TS\\21.B_objTemplate2ROI.bmp");// debug
            }

            // Subtract sample ROI - template ROI
            if (objSampleROI.ref_ROIWidth > objTemplateROI2.ref_ROIWidth)
                objSampleROI.ref_ROIWidth = objTemplateROI2.ref_ROIWidth;
            else
                objTemplateROI2.ref_ROIWidth = objSampleROI.ref_ROIWidth;

            if (objSampleROI.ref_ROIHeight > objTemplateROI2.ref_ROIHeight)
                objSampleROI.ref_ROIHeight = objTemplateROI2.ref_ROIHeight;
            else
                objTemplateROI2.ref_ROIHeight = objSampleROI.ref_ROIHeight;

            if (blnDebugImage)
            {
                objSampleROI.SaveImage("D:\\TS\\22.B_BfSBSampleROI.bmp");// debug
                objTemplateROI2.SaveImage("D:\\TS\\23.B_objTemplate2ROI.bmp");// debug
                objTemplateROI.SaveImage("D:\\TS\\24.objTemplateROI.bmp");
            }

            //EasyImage.Oper(EArithmeticLogicOperation.Subtract, objSampleROI.ref_ROI, objTemplateROI2.ref_ROI, objSampleROI.ref_ROI);    // 2019 05 14 - CCENG: Use templateROI2 because the pad location is according to sample ROI.
            //EasyImage.Oper(EArithmeticLogicOperation.Subtract, objSampleROI.ref_ROI, objTemplateROI.ref_ROI, objSampleROI.ref_ROI);
            if (blnDebugImage)
                objSampleROI.SaveImage("D:\\TS\\B_AfSBSampleROI.bmp");// debug

            // Check Unit Surface Contamination (m_intFailPkgOptionMask 0x10=Contamination Length, 0x20=Contamiation Area, 0x40=Contamination Total Area
            if (((m_intFailPkgOptionMask & 0xC0000) > 0))
            {
                objSampleROI.LoadROISetting(objImageUnitROI.ref_ROITotalX,
                                            objImageUnitROI.ref_ROITotalY,
                                            objImageUnitROI.ref_ROIWidth, objImageUnitROI.ref_ROIHeight);

                if (m_blnWantLinkDarkDefect)
                {
                    if (m_objRectGauge4L.GetGaugeTiltAngle() == 0)
                    {
                        if (!IsImage2UnitDarkFieldPackageFailed_WithLinkFunction(objSampleROI, objSampleROI.ref_ROITotalX, objSampleROI.ref_ROITotalY, intImageIndex))
                        {
                            objSampleROI.Dispose();
                            objTemplateROI.Dispose();
                            objTemplateROI2.Dispose();
                            return false;
                        }
                    }
                    else
                    {
                        if (!IsImage2UnitDarkFieldPackageFailed_TiltAngle_WithLinkFunction(objSampleROI, objSampleROI.ref_ROITotalX, objSampleROI.ref_ROITotalY, intImageIndex, intPadIndex))
                        {
                            objSampleROI.Dispose();
                            objTemplateROI.Dispose();
                            objTemplateROI2.Dispose();
                            return false;
                        }
                    }
                }
                else
                {
                    if (m_objRectGauge4L.GetGaugeTiltAngle() == 0)
                    {
                        if (!IsImage2UnitDarkFieldPackageFailed(objSampleROI, objSampleROI.ref_ROITotalX, objSampleROI.ref_ROITotalY, intImageIndex))
                        {
                            objSampleROI.Dispose();
                            objTemplateROI.Dispose();
                            objTemplateROI2.Dispose();
                            return false;
                        }
                    }
                    else
                    {
                        if (!IsImage2UnitDarkFieldPackageFailed_TiltAngle(objSampleROI, objSampleROI.ref_ROITotalX, objSampleROI.ref_ROITotalY, intImageIndex, intPadIndex))
                        {
                            objSampleROI.Dispose();
                            objTemplateROI.Dispose();
                            objTemplateROI2.Dispose();
                            return false;
                        }
                    }
                }
            }

            //// Check Unit Chipped off
            //if ((m_intFailPkgOptionMask & 0x04) > 0)
            //{
            //    objSampleROI.LoadROISetting(objImageUnitROI.ref_ROITotalX,
            //                                objImageUnitROI.ref_ROITotalY,
            //                                objImageUnitROI.ref_ROIWidth, objImageUnitROI.ref_ROIHeight);

            //    if (!IsImage1UnitChippedOff2_Area(objSampleROI, objSampleROI.ref_ROITotalX, objSampleROI.ref_ROITotalY, intImageIndex)) // IsImage1UnitChippedOff2
            //    {
            //        //objImageUnitROI.SaveImage("D:\\objImageUnitROI_"+intImageIndex.ToString()+".bmp");
            //        //objSampleROI.SaveImage("D:\\objSampleROI_" + intImageIndex.ToString() + ".bmp");
            //        //objTemplateROI.SaveImage("D:\\objTemplateROI_" + intImageIndex.ToString() + ".bmp");
            //        //objTemplateROI2.SaveImage("D:\\objTemplateROI2_" + intImageIndex.ToString() + ".bmp");

            //        objSampleROI.Dispose();
            //        objTemplateROI.Dispose();
            //        objTemplateROI2.Dispose();

            //        return false;
            //    }
            //}

            objSampleROI.Dispose();
            objTemplateROI.Dispose();
            objTemplateROI2.Dispose();

            return blnResult;
        }
        private bool IsImage1UnitContaminated(ROI objSampleROI, int intROIStartX, int intROIStartY, int intImageIndex)//, bool blnPadPkg)
        {
            bool blnDebugImage = false;

            if (blnDebugImage)
                objSampleROI.SaveImage("D:\\TS\\objSampleROI.bmp"); // debug

            // Calculate start point from actual measurement package size. Fyi, objSampleROI size is not same as package size, but is PadROI Size
            float fPkgOffsetX = (objSampleROI.ref_ROIWidth - Math.Max(GetResultUpWidth_RectGauge4L(0), GetResultDownWidth_RectGauge4L(0))) / 2;
            float fPkgOffsetY = (objSampleROI.ref_ROIHeight - Math.Max(GetResultLeftHeight_RectGauge4L(0), GetResultRightHeight_RectGauge4L(0))) / 2;

            int intStartPixelFromEdgeX = (int)Math.Round(fPkgOffsetX + m_fPkgStartPixelFromLeft, 0, MidpointRounding.AwayFromZero);
            int intStartPixelFromEdgeY = (int)Math.Round(fPkgOffsetY + m_fPkgStartPixelFromEdge, 0, MidpointRounding.AwayFromZero);
            int intStartPixelFromEdgeX2 = (int)Math.Round(fPkgOffsetX + m_fPkgStartPixelFromRight, 0, MidpointRounding.AwayFromZero);
            int intStartPixelFromEdgeY2 = (int)Math.Round(fPkgOffsetY + m_fPkgStartPixelFromBottom, 0, MidpointRounding.AwayFromZero);

            ROI objCheckAreaSampleROI = new ROI();
            objCheckAreaSampleROI.AttachImage(objSampleROI);
            objCheckAreaSampleROI.LoadROISetting(intStartPixelFromEdgeX, intStartPixelFromEdgeY,
                objSampleROI.ref_ROIWidth - intStartPixelFromEdgeX - intStartPixelFromEdgeX2,
                objSampleROI.ref_ROIHeight - intStartPixelFromEdgeY - intStartPixelFromEdgeY2);

            if (blnDebugImage)
                objCheckAreaSampleROI.SaveImage("D:\\objCheckAreaSampleROI.bmp");   // debug
            int intSelectedObjectNum = 0;

            switch (intImageIndex)
            {
                case 1: // Image 1 (Grab 1 & Grab 2 Merged)
                    {
                        intSelectedObjectNum = m_objImage1SurfaceEBlobs.BuildObjects_Filter_GetElement(objCheckAreaSampleROI, false, true, 0, 125,
              (int)m_fSurfaceMinArea, 999999, false, 0x0F);// 0x0D);

                    }
                    break;
                case 2: // Image 2 (Grab 3)
                    {
                        intSelectedObjectNum = m_objImage1SurfaceEBlobs.BuildObjects_Filter_GetElement(objCheckAreaSampleROI, false, true, 0, 125,
             (int)m_fImage2SurfaceMinArea, 999999, false, 0x0F);// 0x0D);

                    }
                    break;
            }

            if (blnDebugImage)
                objCheckAreaSampleROI.SaveImage("D:\\TS\\objCheckAreaSampleROI.bmp");   // debug

            bool blnOverallResult = true;
            if (intSelectedObjectNum > 0)
            {
                float fCenterX = 0, fCenterY = 0, fWidth = 0, fHeight = 0;
                float fStartX, fStartY, fEndX, fEndY;
                int intArea = 0;
                float fWidthMM, fHeightMM, fAreaInMM;
                int intFailCount = 0;

                int intTotalArea = 0;
                for (int i = 0; i < intSelectedObjectNum; i++)
                {
                    intArea = m_objImage1SurfaceEBlobs.ref_arrArea[i];
                    fHeight = m_objImage1SurfaceEBlobs.ref_arrHeight[i];
                    fWidth = m_objImage1SurfaceEBlobs.ref_arrWidth[i];
                    fCenterX = m_objImage1SurfaceEBlobs.ref_arrLimitCenterX[i];
                    fCenterY = m_objImage1SurfaceEBlobs.ref_arrLimitCenterY[i];

                    intTotalArea += intArea;
                    fCenterX += intStartPixelFromEdgeX;
                    fCenterY += intStartPixelFromEdgeY;
                    fStartX = (float)Math.Floor(fCenterX - (fWidth / 2));
                    fStartY = (float)Math.Floor(fCenterY - (fHeight / 2));
                    fEndX = (float)Math.Ceiling(fCenterX + (fWidth / 2));
                    fEndY = (float)Math.Ceiling(fCenterY + (fHeight / 2));

                    // convert width and height to mm
                    fWidthMM = fWidth / m_fMMToPixelXValue;
                    fHeightMM = fHeight / m_fMMToPixelYValue; // 11-04-2019 ZJYEOH : Changed m_fMMToPixelXValue to m_fMMToPixelYValue
                    fAreaInMM = intArea / m_fMMToPixelXValue / m_fMMToPixelYValue;

                    //if ((fWidthMM > m_fScratchLength) || (fHeightMM > m_fScratchLength) || (fAreaInMM > m_fScratchArea) &&
                    //    ((m_intFailPkgOptionMask & 0x08) > 0 || (m_intFailPkgOptionMask & 0x1000) > 0))
                    {
                        intFailCount++;
                        //0x04
                        m_intFailPkgResultMask |= 0x10; // Fail image 1 surface contamination

                        Defect objDefect = new Defect();

                        objDefect.ref_strName = "Contamination";
                        objDefect.ref_intFailMask = 0x10;
                        objDefect.ref_fCenterX = intROIStartX + fCenterX;
                        objDefect.ref_fCenterY = intROIStartY + fCenterY;
                        objDefect.ref_fStartX = intROIStartX + fStartX;
                        objDefect.ref_fStartY = intROIStartY + fStartY;
                        objDefect.ref_fEndX = intROIStartX + fEndX;
                        objDefect.ref_fEndY = intROIStartY + fEndY;
                        objDefect.ref_fWidth = fWidth;
                        objDefect.ref_fHeight = fHeight;
                        objDefect.ref_fArea = intArea;
                        objDefect.ref_fWidthInMM = fWidthMM;
                        objDefect.ref_fHeightInMM = fHeightMM;
                        objDefect.ref_fAreaInMM2 = fAreaInMM;
                        objDefect.ref_intImageNo = 1;

                        if ((m_intFailPkgOptionMask & 0x10) > 0)
                        {
                            if (fWidthMM > m_fExtraPadSetLength)
                            {
                                blnOverallResult = false;
                                objDefect.ref_fWidthFailValue = fWidthMM;
                                objDefect.ref_intFailCriteria |= 0x01;
                            }
                            if (fHeightMM > m_fExtraPadSetLength)
                            {
                                blnOverallResult = false;
                                objDefect.ref_fHeightFailValue = fHeightMM;
                                objDefect.ref_intFailCriteria |= 0x02;
                            }
                        }

                        if ((m_intFailPkgOptionMask & 0x20) > 0)
                        {
                            if (fAreaInMM > m_fExtraPadSetArea)
                            {
                                blnOverallResult = false;
                                objDefect.ref_fAreaFailValue = fAreaInMM;
                                objDefect.ref_intFailCriteria |= 0x04;
                            }
                        }

                        m_arrPkgDefectList.Add(objDefect);
                    }

                }

                if ((m_intFailPkgOptionMask & 0x40) > 0)
                {
                    fAreaInMM = intTotalArea / m_fMMToPixelXValue / m_fMMToPixelYValue;

                    if (fAreaInMM > m_fTotalExtraPadSetArea)
                    {
                        for (int i = 0; i < m_arrPkgDefectList.Count; i++)
                        {
                            Defect objDefect = m_arrPkgDefectList[i];
                            objDefect.ref_intFailMask |= 0x40;
                            objDefect.ref_intFailCriteria |= 0x08;
                            m_arrPkgDefectList[i] = objDefect;
                        }

                        Defect objDefect2 = new Defect();
                        for (int a = 0; a < m_arrPkgDefectList.Count; a++)
                        {
                            objDefect2 = m_arrPkgDefectList[a];
                            if (objDefect2.ref_strName.Contains("Contamination"))
                            {
                                objDefect2.ref_blnFailTotalArea = true;
                                m_arrPkgDefectList[a] = objDefect2;
                            }
                        }

                        m_intFailPkgResultMask |= 0x80; // Fail image 1 surface total contamination

                        // Collect total extra pad for display error message
                        m_fResultTotalExtraPadArea = fAreaInMM;

                        blnOverallResult = false;
                    }
                }
            }

            objCheckAreaSampleROI.Dispose();
            return blnOverallResult;
        }
        private bool IsImage1UnitContaminated_TiltAngle(ROI objSampleROI, int intROIStartX, int intROIStartY, int intImageIndex, int intPadIndex)//, bool blnPadPkg)
        {
            bool blnDebugImage = false;

            if (blnDebugImage)
                objSampleROI.SaveImage("D:\\TS\\objSampleROI.bmp"); // debug

            // Calculate start point from actual measurement package size. Fyi, objSampleROI size is not same as package size, but is PadROI Size
            float fPkgOffsetX = (objSampleROI.ref_ROIWidth - Math.Max(GetResultUpWidth_RectGauge4L(0), GetResultDownWidth_RectGauge4L(0))) / 2;
            float fPkgOffsetY = (objSampleROI.ref_ROIHeight - Math.Max(GetResultLeftHeight_RectGauge4L(0), GetResultRightHeight_RectGauge4L(0))) / 2;

            int intStartPixelFromEdgeX = (int)Math.Round(fPkgOffsetX + m_fPkgStartPixelFromLeft, 0, MidpointRounding.AwayFromZero);
            int intStartPixelFromEdgeY = (int)Math.Round(fPkgOffsetY + m_fPkgStartPixelFromEdge, 0, MidpointRounding.AwayFromZero);
            int intStartPixelFromEdgeX2 = (int)Math.Round(fPkgOffsetX + m_fPkgStartPixelFromRight, 0, MidpointRounding.AwayFromZero);
            int intStartPixelFromEdgeY2 = (int)Math.Round(fPkgOffsetY + m_fPkgStartPixelFromBottom, 0, MidpointRounding.AwayFromZero);

            ROI objCheckAreaSampleROI = new ROI();
            objCheckAreaSampleROI.AttachImage(objSampleROI);
            objCheckAreaSampleROI.LoadROISetting(intStartPixelFromEdgeX, intStartPixelFromEdgeY,
                objSampleROI.ref_ROIWidth - intStartPixelFromEdgeX - intStartPixelFromEdgeX2,
                objSampleROI.ref_ROIHeight - intStartPixelFromEdgeY - intStartPixelFromEdgeY2);

            //2020-01-09 ZJYEOH : Should subtract Dont care area with objCheckAreaSampleROI instead of objSampleROI
            //2019-09-23 ZJYEOH : Subtract tilt dont care area 
            if (intPadIndex == 1) // Top
            {
                ROI DontCareTop = new ROI();

                DontCareTop.LoadROISetting(0, 0, objCheckAreaSampleROI.ref_ROIWidth, objCheckAreaSampleROI.ref_ROIHeight);
                DontCareTop.AttachImage(m_ImgTilt_Top_L);
                EasyImage.Oper(EArithmeticLogicOperation.Subtract, objCheckAreaSampleROI.ref_ROI, DontCareTop.ref_ROI, objCheckAreaSampleROI.ref_ROI);
                DontCareTop.LoadROISetting(m_ImgTilt_Top_R.ref_intImageWidth - objCheckAreaSampleROI.ref_ROIWidth, 0, objCheckAreaSampleROI.ref_ROIWidth, objCheckAreaSampleROI.ref_ROIHeight);
                DontCareTop.AttachImage(m_ImgTilt_Top_R);
                EasyImage.Oper(EArithmeticLogicOperation.Subtract, objCheckAreaSampleROI.ref_ROI, DontCareTop.ref_ROI, objCheckAreaSampleROI.ref_ROI);
                if (blnDebugImage)
                    objCheckAreaSampleROI.SaveImage("D:\\IsImage1UnitContaminated_objCheckAreaSampleROITop.bmp");
                DontCareTop.Dispose();
            }
            if (intPadIndex == 2) // Right
            {
                ROI DontCareRight = new ROI();
                DontCareRight.LoadROISetting(m_ImgTilt_Top_R.ref_intImageWidth - objCheckAreaSampleROI.ref_ROIWidth, 0, objCheckAreaSampleROI.ref_ROIWidth, objCheckAreaSampleROI.ref_ROIHeight);
                DontCareRight.AttachImage(m_ImgTilt_Right_T);
                EasyImage.Oper(EArithmeticLogicOperation.Subtract, objCheckAreaSampleROI.ref_ROI, DontCareRight.ref_ROI, objCheckAreaSampleROI.ref_ROI);
                DontCareRight.LoadROISetting(m_ImgTilt_Top_R.ref_intImageWidth - objCheckAreaSampleROI.ref_ROIWidth, m_ImgTilt_Top_R.ref_intImageHeight - objCheckAreaSampleROI.ref_ROIHeight, objCheckAreaSampleROI.ref_ROIWidth, objCheckAreaSampleROI.ref_ROIHeight);
                DontCareRight.AttachImage(m_ImgTilt_Right_B);
                EasyImage.Oper(EArithmeticLogicOperation.Subtract, objCheckAreaSampleROI.ref_ROI, DontCareRight.ref_ROI, objCheckAreaSampleROI.ref_ROI);
                if (blnDebugImage)
                    objCheckAreaSampleROI.SaveImage("D:\\IsImage1UnitContaminated_objCheckAreaSampleROIRight.bmp");
                DontCareRight.Dispose();
            }
            if (intPadIndex == 3) // Bottom
            {
                ROI DontCareBottom = new ROI();

                DontCareBottom.LoadROISetting(0, m_ImgTilt_Top_R.ref_intImageHeight - objCheckAreaSampleROI.ref_ROIHeight, objCheckAreaSampleROI.ref_ROIWidth, objCheckAreaSampleROI.ref_ROIHeight);
                DontCareBottom.AttachImage(m_ImgTilt_Bottom_L);
                EasyImage.Oper(EArithmeticLogicOperation.Subtract, objCheckAreaSampleROI.ref_ROI, DontCareBottom.ref_ROI, objCheckAreaSampleROI.ref_ROI);
                DontCareBottom.LoadROISetting(m_ImgTilt_Top_R.ref_intImageWidth - objCheckAreaSampleROI.ref_ROIWidth, m_ImgTilt_Top_R.ref_intImageHeight - objCheckAreaSampleROI.ref_ROIHeight, objCheckAreaSampleROI.ref_ROIWidth, objCheckAreaSampleROI.ref_ROIHeight);
                DontCareBottom.AttachImage(m_ImgTilt_Bottom_R);
                EasyImage.Oper(EArithmeticLogicOperation.Subtract, objCheckAreaSampleROI.ref_ROI, DontCareBottom.ref_ROI, objCheckAreaSampleROI.ref_ROI);
                if (blnDebugImage)
                    objCheckAreaSampleROI.SaveImage("D:\\IsImage1UnitContaminated_objCheckAreaSampleROIBottom.bmp");
                DontCareBottom.Dispose();
            }
            if (intPadIndex == 4) // Left
            {
                ROI DontCareLeft = new ROI();

                DontCareLeft.LoadROISetting(0, 0, objCheckAreaSampleROI.ref_ROIWidth, objCheckAreaSampleROI.ref_ROIHeight);
                DontCareLeft.AttachImage(m_ImgTilt_Left_T);
                EasyImage.Oper(EArithmeticLogicOperation.Subtract, objCheckAreaSampleROI.ref_ROI, DontCareLeft.ref_ROI, objCheckAreaSampleROI.ref_ROI);
                DontCareLeft.LoadROISetting(0, m_ImgTilt_Top_R.ref_intImageHeight - objCheckAreaSampleROI.ref_ROIHeight, objCheckAreaSampleROI.ref_ROIWidth, objCheckAreaSampleROI.ref_ROIHeight);
                DontCareLeft.AttachImage(m_ImgTilt_Left_B);
                EasyImage.Oper(EArithmeticLogicOperation.Subtract, objCheckAreaSampleROI.ref_ROI, DontCareLeft.ref_ROI, objCheckAreaSampleROI.ref_ROI);
                if (blnDebugImage)
                    objCheckAreaSampleROI.SaveImage("D:\\IsImage1UnitContaminated_objCheckAreaSampleROILeft.bmp");
                DontCareLeft.Dispose();
            }
            if (blnDebugImage)
                objCheckAreaSampleROI.SaveImage("D:\\objCheckAreaSampleROI.bmp");   // debug
            int intSelectedObjectNum = 0;

            switch (intImageIndex)
            {
                case 1: // Image 1 (Grab 1 & Grab 2 Merged)
                    {
                        intSelectedObjectNum = m_objImage1SurfaceEBlobs.BuildObjects_Filter_GetElement(objCheckAreaSampleROI, false, true, 0, 125,
              (int)m_fSurfaceMinArea, 999999, false, 0x0F);// 0x0D);

                    }
                    break;
                case 2: // Image 2 (Grab 3)
                    {
                        intSelectedObjectNum = m_objImage1SurfaceEBlobs.BuildObjects_Filter_GetElement(objCheckAreaSampleROI, false, true, 0, 125,
             (int)m_fImage2SurfaceMinArea, 999999, false, 0x0F);// 0x0D);

                    }
                    break;
            }

            if (blnDebugImage)
                objCheckAreaSampleROI.SaveImage("D:\\TS\\objCheckAreaSampleROI.bmp");   // debug

            bool blnOverallResult = true;
            if (intSelectedObjectNum > 0)
            {
                float fCenterX = 0, fCenterY = 0, fWidth = 0, fHeight = 0;
                float fStartX, fStartY, fEndX, fEndY;
                int intArea = 0;
                float fWidthMM, fHeightMM, fAreaInMM;
                int intFailCount = 0;

                int intTotalArea = 0;
                for (int i = 0; i < intSelectedObjectNum; i++)
                {
                    intArea = m_objImage1SurfaceEBlobs.ref_arrArea[i];
                    fHeight = m_objImage1SurfaceEBlobs.ref_arrHeight[i];
                    fWidth = m_objImage1SurfaceEBlobs.ref_arrWidth[i];
                    fCenterX = m_objImage1SurfaceEBlobs.ref_arrLimitCenterX[i];
                    fCenterY = m_objImage1SurfaceEBlobs.ref_arrLimitCenterY[i];

                    intTotalArea += intArea;
                    fCenterX += intStartPixelFromEdgeX;
                    fCenterY += intStartPixelFromEdgeY;
                    fStartX = (float)Math.Floor(fCenterX - (fWidth / 2));
                    fStartY = (float)Math.Floor(fCenterY - (fHeight / 2));
                    fEndX = (float)Math.Ceiling(fCenterX + (fWidth / 2));
                    fEndY = (float)Math.Ceiling(fCenterY + (fHeight / 2));

                    // convert width and height to mm
                    fWidthMM = fWidth / m_fMMToPixelXValue;
                    fHeightMM = fHeight / m_fMMToPixelYValue; // 11-04-2019 ZJYEOH : Changed m_fMMToPixelXValue to m_fMMToPixelYValue
                    fAreaInMM = intArea / m_fMMToPixelXValue / m_fMMToPixelYValue;

                    //if ((fWidthMM > m_fScratchLength) || (fHeightMM > m_fScratchLength) || (fAreaInMM > m_fScratchArea) &&
                    //    ((m_intFailPkgOptionMask & 0x08) > 0 || (m_intFailPkgOptionMask & 0x1000) > 0))
                    {
                        intFailCount++;
                        //0x04
                        m_intFailPkgResultMask |= 0x10; // Fail image 1 surface contamination

                        Defect objDefect = new Defect();

                        objDefect.ref_strName = "Contamination";
                        objDefect.ref_intFailMask = 0x10;
                        objDefect.ref_fCenterX = intROIStartX + fCenterX;
                        objDefect.ref_fCenterY = intROIStartY + fCenterY;
                        objDefect.ref_fStartX = intROIStartX + fStartX;
                        objDefect.ref_fStartY = intROIStartY + fStartY;
                        objDefect.ref_fEndX = intROIStartX + fEndX;
                        objDefect.ref_fEndY = intROIStartY + fEndY;
                        objDefect.ref_fWidth = fWidth;
                        objDefect.ref_fHeight = fHeight;
                        objDefect.ref_fArea = intArea;
                        objDefect.ref_fWidthInMM = fWidthMM;
                        objDefect.ref_fHeightInMM = fHeightMM;
                        objDefect.ref_fAreaInMM2 = fAreaInMM;
                        objDefect.ref_intImageNo = 1;

                        if ((m_intFailPkgOptionMask & 0x10) > 0)
                        {
                            if (fWidthMM > m_fExtraPadSetLength)
                            {
                                blnOverallResult = false;
                                objDefect.ref_fWidthFailValue = fWidthMM;
                                objDefect.ref_intFailCriteria |= 0x01;
                            }
                            if (fHeightMM > m_fExtraPadSetLength)
                            {
                                blnOverallResult = false;
                                objDefect.ref_fHeightFailValue = fHeightMM;
                                objDefect.ref_intFailCriteria |= 0x02;
                            }
                        }

                        if ((m_intFailPkgOptionMask & 0x20) > 0)
                        {
                            if (fAreaInMM > m_fExtraPadSetArea)
                            {
                                blnOverallResult = false;
                                objDefect.ref_fAreaFailValue = fAreaInMM;
                                objDefect.ref_intFailCriteria |= 0x04;
                            }
                        }

                        m_arrPkgDefectList.Add(objDefect);
                    }

                }

                if ((m_intFailPkgOptionMask & 0x40) > 0)
                {
                    fAreaInMM = intTotalArea / m_fMMToPixelXValue / m_fMMToPixelYValue;

                    if (fAreaInMM > m_fTotalExtraPadSetArea)
                    {
                        for (int i = 0; i < m_arrPkgDefectList.Count; i++)
                        {
                            Defect objDefect = m_arrPkgDefectList[i];
                            objDefect.ref_intFailMask |= 0x40;
                            objDefect.ref_intFailCriteria |= 0x08;
                            m_arrPkgDefectList[i] = objDefect;
                        }

                        m_intFailPkgResultMask |= 0x80; // Fail image 1 surface total contamination

                        // Collect total extra pad for display error message
                        m_fResultTotalExtraPadArea = fAreaInMM;

                        blnOverallResult = false;
                    }
                }
            }

            objCheckAreaSampleROI.Dispose();
            return blnOverallResult;
        }
        private bool IsImage1UnitBrightFieldForeignMaterialFailed_TiltAngle(ROI objSampleROI, int intROIStartX, int intROIStartY, int intImageIndex, int intPadIndex)//, bool blnPadPkg)
        {
            bool blnDebugImage = false;

            if (blnDebugImage)
                objSampleROI.SaveImage("D:\\TS\\objSampleROI.bmp"); // debug

            // Calculate start point from actual measurement package size. Fyi, objSampleROI size is not same as package size, but is PadROI Size
            float fPkgOffsetX = (objSampleROI.ref_ROIWidth - Math.Max(GetResultUpWidth_RectGauge4L(0), GetResultDownWidth_RectGauge4L(0))) / 2;
            float fPkgOffsetY = (objSampleROI.ref_ROIHeight - Math.Max(GetResultLeftHeight_RectGauge4L(0), GetResultRightHeight_RectGauge4L(0))) / 2;

            int intStartPixelFromEdgeX = (int)Math.Round(fPkgOffsetX + m_fForeignMaterialStartPixelFromLeft, 0, MidpointRounding.AwayFromZero);
            int intStartPixelFromEdgeY = (int)Math.Round(fPkgOffsetY + m_fForeignMaterialStartPixelFromEdge, 0, MidpointRounding.AwayFromZero);
            int intStartPixelFromEdgeX2 = (int)Math.Round(fPkgOffsetX + m_fForeignMaterialStartPixelFromRight, 0, MidpointRounding.AwayFromZero);
            int intStartPixelFromEdgeY2 = (int)Math.Round(fPkgOffsetY + m_fForeignMaterialStartPixelFromBottom, 0, MidpointRounding.AwayFromZero);

            ROI objCheckAreaSampleROI = new ROI();
            objCheckAreaSampleROI.AttachImage(objSampleROI);
            objCheckAreaSampleROI.LoadROISetting(intStartPixelFromEdgeX, intStartPixelFromEdgeY,
                objSampleROI.ref_ROIWidth - intStartPixelFromEdgeX - intStartPixelFromEdgeX2,
                objSampleROI.ref_ROIHeight - intStartPixelFromEdgeY - intStartPixelFromEdgeY2);

            //2020-01-09 ZJYEOH : Should subtract Dont care area with objCheckAreaSampleROI instead of objSampleROI
            //2019-09-23 ZJYEOH : Subtract tilt dont care area 
            if (intPadIndex == 1) // Top
            {
                ROI DontCareTop = new ROI();

                DontCareTop.LoadROISetting(0, 0, objCheckAreaSampleROI.ref_ROIWidth, objCheckAreaSampleROI.ref_ROIHeight);
                DontCareTop.AttachImage(m_ImgTilt_Top_L);
                EasyImage.Oper(EArithmeticLogicOperation.Subtract, objCheckAreaSampleROI.ref_ROI, DontCareTop.ref_ROI, objCheckAreaSampleROI.ref_ROI);
                DontCareTop.LoadROISetting(m_ImgTilt_Top_R.ref_intImageWidth - objCheckAreaSampleROI.ref_ROIWidth, 0, objCheckAreaSampleROI.ref_ROIWidth, objCheckAreaSampleROI.ref_ROIHeight);
                DontCareTop.AttachImage(m_ImgTilt_Top_R);
                EasyImage.Oper(EArithmeticLogicOperation.Subtract, objCheckAreaSampleROI.ref_ROI, DontCareTop.ref_ROI, objCheckAreaSampleROI.ref_ROI);
                if (blnDebugImage)
                    objCheckAreaSampleROI.SaveImage("D:\\TS\\IsImage1UnitBrightFieldPackageFailed_objCheckAreaSampleROITop.bmp");
                DontCareTop.Dispose();
            }
            if (intPadIndex == 2) // Right
            {
                ROI DontCareRight = new ROI();
                DontCareRight.LoadROISetting(m_ImgTilt_Top_R.ref_intImageWidth - objCheckAreaSampleROI.ref_ROIWidth, 0, objCheckAreaSampleROI.ref_ROIWidth, objCheckAreaSampleROI.ref_ROIHeight);
                DontCareRight.AttachImage(m_ImgTilt_Right_T);
                EasyImage.Oper(EArithmeticLogicOperation.Subtract, objCheckAreaSampleROI.ref_ROI, DontCareRight.ref_ROI, objCheckAreaSampleROI.ref_ROI);
                DontCareRight.LoadROISetting(m_ImgTilt_Top_R.ref_intImageWidth - objCheckAreaSampleROI.ref_ROIWidth, m_ImgTilt_Top_R.ref_intImageHeight - objCheckAreaSampleROI.ref_ROIHeight, objCheckAreaSampleROI.ref_ROIWidth, objCheckAreaSampleROI.ref_ROIHeight);
                DontCareRight.AttachImage(m_ImgTilt_Right_B);
                EasyImage.Oper(EArithmeticLogicOperation.Subtract, objCheckAreaSampleROI.ref_ROI, DontCareRight.ref_ROI, objCheckAreaSampleROI.ref_ROI);
                if (blnDebugImage)
                    objCheckAreaSampleROI.SaveImage("D:\\TS\\IsImage1UnitBrightFieldPackageFailed_objCheckAreaSampleROIRight.bmp");
                DontCareRight.Dispose();
            }
            if (intPadIndex == 3) // Bottom
            {
                ROI DontCareBottom = new ROI();

                DontCareBottom.LoadROISetting(0, m_ImgTilt_Top_R.ref_intImageHeight - objCheckAreaSampleROI.ref_ROIHeight, objCheckAreaSampleROI.ref_ROIWidth, objCheckAreaSampleROI.ref_ROIHeight);
                DontCareBottom.AttachImage(m_ImgTilt_Bottom_L);
                EasyImage.Oper(EArithmeticLogicOperation.Subtract, objCheckAreaSampleROI.ref_ROI, DontCareBottom.ref_ROI, objCheckAreaSampleROI.ref_ROI);
                DontCareBottom.LoadROISetting(m_ImgTilt_Top_R.ref_intImageWidth - objCheckAreaSampleROI.ref_ROIWidth, m_ImgTilt_Top_R.ref_intImageHeight - objCheckAreaSampleROI.ref_ROIHeight, objCheckAreaSampleROI.ref_ROIWidth, objCheckAreaSampleROI.ref_ROIHeight);
                DontCareBottom.AttachImage(m_ImgTilt_Bottom_R);
                EasyImage.Oper(EArithmeticLogicOperation.Subtract, objCheckAreaSampleROI.ref_ROI, DontCareBottom.ref_ROI, objCheckAreaSampleROI.ref_ROI);
                if (blnDebugImage)
                    objCheckAreaSampleROI.SaveImage("D:\\TS\\IsImage1UnitBrightFieldPackageFailed_objCheckAreaSampleROIBottom.bmp");
                DontCareBottom.Dispose();
            }
            if (intPadIndex == 4) // Left
            {
                ROI DontCareLeft = new ROI();

                DontCareLeft.LoadROISetting(0, 0, objCheckAreaSampleROI.ref_ROIWidth, objCheckAreaSampleROI.ref_ROIHeight);
                DontCareLeft.AttachImage(m_ImgTilt_Left_T);
                EasyImage.Oper(EArithmeticLogicOperation.Subtract, objCheckAreaSampleROI.ref_ROI, DontCareLeft.ref_ROI, objCheckAreaSampleROI.ref_ROI);
                DontCareLeft.LoadROISetting(0, m_ImgTilt_Top_R.ref_intImageHeight - objCheckAreaSampleROI.ref_ROIHeight, objCheckAreaSampleROI.ref_ROIWidth, objCheckAreaSampleROI.ref_ROIHeight);
                DontCareLeft.AttachImage(m_ImgTilt_Left_B);
                EasyImage.Oper(EArithmeticLogicOperation.Subtract, objCheckAreaSampleROI.ref_ROI, DontCareLeft.ref_ROI, objCheckAreaSampleROI.ref_ROI);
                if (blnDebugImage)
                    objCheckAreaSampleROI.SaveImage("D:\\TS\\IsImage1UnitBrightFieldPackageFailed_objCheckAreaSampleROILeft.bmp");
                DontCareLeft.Dispose();
            }

            if (blnDebugImage)
                objCheckAreaSampleROI.SaveImage("D:\\TS\\objCheckAreaSampleROI.bmp");   // debug
            int intSelectedObjectNum = 0;

            switch (intImageIndex)
            {
                case 1: // Image 1 (Grab 1 & Grab 2 Merged)
                    {
                        intSelectedObjectNum = m_objImage1SurfaceEBlobs.BuildObjects_Filter_GetElement(objCheckAreaSampleROI, false, true, 0, 125,
              m_intForeignMaterialBrightFieldMinArea, objCheckAreaSampleROI.ref_ROIWidth * objCheckAreaSampleROI.ref_ROIHeight, false, 0xEF);// 0x0D);

                    }
                    break;
                    //   case 2: // Image 2 (Grab 3)
                    //       {
                    //           intSelectedObjectNum = m_objImage1SurfaceEBlobs.BuildObjects_Filter_GetElement(objCheckAreaSampleROI, false, true, 0, 125,
                    //m_intDarkFieldMinArea, objCheckAreaSampleROI.ref_ROIWidth * objCheckAreaSampleROI.ref_ROIHeight, false, 0xEF);// 0x0D);

                    //       }
                    //       break;
                    //   case 3: // Image 5 (Grab 5) // 2020-01-09 ZJYEOH : Changed case 4 to 3 
                    //       {
                    //           intSelectedObjectNum = m_objImage1SurfaceEBlobs.BuildObjects_Filter_GetElement(objCheckAreaSampleROI, false, true, 0, 125,
                    //m_intDarkFieldMinArea, objCheckAreaSampleROI.ref_ROIWidth * objCheckAreaSampleROI.ref_ROIHeight, false, 0xEF);// 0x0D);

                    //       }
                    //       break;
            }

            if (blnDebugImage)
                objCheckAreaSampleROI.SaveImage("D:\\TS\\objCheckAreaSampleROI.bmp");   // debug

            bool blnOverallResult = true;
            if (intSelectedObjectNum > 0)
            {
                float fCenterX = 0, fCenterY = 0, fWidth = 0, fHeight = 0;
                float fStartX, fStartY, fEndX, fEndY, fAngle = 0;
                int intArea = 0;
                float fWidthMM, fHeightMM, fAreaInMM;
                int intFailCount = 0;

                int intTotalArea = 0;
                for (int i = 0; i < intSelectedObjectNum; i++)
                {
                    intArea = m_objImage1SurfaceEBlobs.ref_arrArea[i];
                    //fHeight = m_objImage1SurfaceEBlobs.ref_arrHeight[i];
                    //fWidth = m_objImage1SurfaceEBlobs.ref_arrWidth[i];
                    //fCenterX = m_objImage1SurfaceEBlobs.ref_arrLimitCenterX[i];
                    //fCenterY = m_objImage1SurfaceEBlobs.ref_arrLimitCenterY[i];

                    if (m_objImage1SurfaceEBlobs.ref_arrRectWidth[i] < m_objImage1SurfaceEBlobs.ref_arrRectHeight[i])
                    {
                        fWidth = m_objImage1SurfaceEBlobs.ref_arrRectWidth[i];
                        fHeight = m_objImage1SurfaceEBlobs.ref_arrRectHeight[i];

                        fAngle = m_objImage1SurfaceEBlobs.ref_arrRectAngle[i];


                        if (fAngle < 0)
                            fAngle = -Math.Abs(fAngle);
                        else
                            fAngle = -fAngle;
                    }
                    else
                    {
                        fWidth = m_objImage1SurfaceEBlobs.ref_arrRectHeight[i];
                        fHeight = m_objImage1SurfaceEBlobs.ref_arrRectWidth[i];

                        fAngle = m_objImage1SurfaceEBlobs.ref_arrRectAngle[i];


                        if (fAngle < 0)
                            fAngle = Math.Abs(fAngle);
                        else
                            fAngle = 90 - (fAngle);
                    }
                    fCenterX = m_objImage1SurfaceEBlobs.ref_arrRectLimitCenterX[i];
                    fCenterY = m_objImage1SurfaceEBlobs.ref_arrRectLimitCenterY[i];


                    intTotalArea += intArea;
                    fCenterX += intStartPixelFromEdgeX;
                    fCenterY += intStartPixelFromEdgeY;
                    fStartX = (float)Math.Floor(fCenterX - (fWidth / 2));
                    fStartY = (float)Math.Floor(fCenterY - (fHeight / 2));
                    fEndX = (float)Math.Ceiling(fCenterX + (fWidth / 2));
                    fEndY = (float)Math.Ceiling(fCenterY + (fHeight / 2));

                    // convert width and height to mm
                    fWidthMM = fWidth / m_fMMToPixelXValue;
                    fHeightMM = fHeight / m_fMMToPixelYValue; // 11-04-2019 ZJYEOH : Changed m_fMMToPixelXValue to m_fMMToPixelYValue
                    fAreaInMM = intArea / m_fMMToPixelXValue / m_fMMToPixelYValue;

                    if (((m_intFailPkgOptionMask & 0x400000) > 0) || ((m_intFailPkgOptionMask & 0x800000) > 0))
                    {
                        intFailCount++;
                        //0x04
                        m_intFailPkgResultMask |= 0x40000; // Fail image 1 surface contamination

                        Defect objDefect = new Defect();

                        objDefect.ref_strName = "Foreign Material";
                        objDefect.ref_intFailMask = 0x40000;
                        objDefect.ref_fCenterX = intROIStartX + fCenterX;
                        objDefect.ref_fCenterY = intROIStartY + fCenterY;
                        objDefect.ref_fStartX = intROIStartX + fStartX;
                        objDefect.ref_fStartY = intROIStartY + fStartY;
                        objDefect.ref_fEndX = intROIStartX + fEndX;
                        objDefect.ref_fEndY = intROIStartY + fEndY;
                        objDefect.ref_fWidth = fWidth;
                        objDefect.ref_fHeight = fHeight;
                        objDefect.ref_fArea = intArea;
                        objDefect.ref_fAngle = fAngle;
                        objDefect.ref_fWidthInMM = fWidthMM;
                        objDefect.ref_fHeightInMM = fHeightMM;
                        objDefect.ref_fAreaInMM2 = fAreaInMM;
                        objDefect.ref_intImageNo = intImageIndex; //2020-01-09 ZJYEOH : Should not fixed to 1

                        if ((m_intFailPkgOptionMask & 0x800000) > 0)
                        {
                            if (m_intForeignMaterialBrightDefectDimensionFailCondition == 0)
                            {
                                if (fWidthMM > m_fBrightHorizontalForeignMaterial)
                                {
                                    blnOverallResult = false;
                                    objDefect.ref_fWidthFailValue = fWidthMM;
                                    objDefect.ref_intFailCriteria |= 0x01;
                                }
                                if (fHeightMM > m_fBrightVerticalForeignMaterial)
                                {
                                    blnOverallResult = false;
                                    objDefect.ref_fHeightFailValue = fHeightMM;
                                    objDefect.ref_intFailCriteria |= 0x02;
                                }
                            }
                            else
                            {
                                if ((fWidthMM > m_fBrightHorizontalForeignMaterial) && (fHeightMM > m_fBrightVerticalForeignMaterial))
                                {
                                    blnOverallResult = false;
                                    objDefect.ref_fWidthFailValue = fWidthMM;
                                    objDefect.ref_intFailCriteria |= 0x01;
                                    objDefect.ref_fHeightFailValue = fHeightMM;
                                    objDefect.ref_intFailCriteria |= 0x02;
                                }
                            }
                        }

                        if ((m_intFailPkgOptionMask & 0x400000) > 0)
                        {
                            if (fAreaInMM > m_fForeignMaterialArea)
                            {
                                blnOverallResult = false;
                                objDefect.ref_fAreaFailValue = fAreaInMM;
                                objDefect.ref_intFailCriteria |= 0x04;
                            }
                        }

                        m_arrPkgDefectList.Add(objDefect);
                    }

                }

            }

            objCheckAreaSampleROI.Dispose();
            return blnOverallResult;
        }
        private bool IsImage1UnitBrightFieldForeignMaterialFailed(ROI objSampleROI, int intROIStartX, int intROIStartY, int intImageIndex)//, bool blnPadPkg)
        {
            bool blnDebugImage = false;

            if (blnDebugImage)
                objSampleROI.SaveImage("D:\\TS\\objSampleROI.bmp"); // debug

            // Calculate start point from actual measurement package size. Fyi, objSampleROI size is not same as package size, but is PadROI Size
            float fPkgOffsetX = (objSampleROI.ref_ROIWidth - Math.Max(GetResultUpWidth_RectGauge4L(0), GetResultDownWidth_RectGauge4L(0))) / 2;
            float fPkgOffsetY = (objSampleROI.ref_ROIHeight - Math.Max(GetResultLeftHeight_RectGauge4L(0), GetResultRightHeight_RectGauge4L(0))) / 2;

            int intStartPixelFromEdgeX = (int)Math.Round(fPkgOffsetX + m_fForeignMaterialStartPixelFromLeft, 0, MidpointRounding.AwayFromZero);
            int intStartPixelFromEdgeY = (int)Math.Round(fPkgOffsetY + m_fForeignMaterialStartPixelFromEdge, 0, MidpointRounding.AwayFromZero);
            int intStartPixelFromEdgeX2 = (int)Math.Round(fPkgOffsetX + m_fForeignMaterialStartPixelFromRight, 0, MidpointRounding.AwayFromZero);
            int intStartPixelFromEdgeY2 = (int)Math.Round(fPkgOffsetY + m_fForeignMaterialStartPixelFromBottom, 0, MidpointRounding.AwayFromZero);

            ROI objCheckAreaSampleROI = new ROI();
            objCheckAreaSampleROI.AttachImage(objSampleROI);
            objCheckAreaSampleROI.LoadROISetting(intStartPixelFromEdgeX, intStartPixelFromEdgeY,
                objSampleROI.ref_ROIWidth - intStartPixelFromEdgeX - intStartPixelFromEdgeX2,
                objSampleROI.ref_ROIHeight - intStartPixelFromEdgeY - intStartPixelFromEdgeY2);

            if (blnDebugImage)
                objCheckAreaSampleROI.SaveImage("D:\\TS\\objCheckAreaSampleROI.bmp");   // debug
            int intSelectedObjectNum = 0;

            switch (intImageIndex)
            {
                case 1: // Image 1 (Grab 1 & Grab 2 Merged)
                    {
                        intSelectedObjectNum = m_objImage1SurfaceEBlobs.BuildObjects_Filter_GetElement(objCheckAreaSampleROI, false, true, 0, 125,
              m_intForeignMaterialBrightFieldMinArea, objCheckAreaSampleROI.ref_ROIWidth * objCheckAreaSampleROI.ref_ROIHeight, false, 0xEF);// 0x0D);

                    }
                    break;
                    //   case 2: // Image 2 (Grab 3)
                    //       {
                    //           intSelectedObjectNum = m_objImage1SurfaceEBlobs.BuildObjects_Filter_GetElement(objCheckAreaSampleROI, false, true, 0, 125,
                    //m_intDarkFieldMinArea, objCheckAreaSampleROI.ref_ROIWidth * objCheckAreaSampleROI.ref_ROIHeight, false, 0xEF);// 0x0D);

                    //       }
                    //       break;
                    //   case 3: // Image 5 (Grab 5) // 2020-01-09 ZJYEOH : Changed case 4 to 3 
                    //       {
                    //           intSelectedObjectNum = m_objImage1SurfaceEBlobs.BuildObjects_Filter_GetElement(objCheckAreaSampleROI, false, true, 0, 125,
                    //m_intDarkFieldMinArea, objCheckAreaSampleROI.ref_ROIWidth * objCheckAreaSampleROI.ref_ROIHeight, false, 0xEF);// 0x0D);

                    //       }
                    //       break;
            }

            if (blnDebugImage)
                objCheckAreaSampleROI.SaveImage("D:\\TS\\objCheckAreaSampleROI.bmp");   // debug

            bool blnOverallResult = true;
            if (intSelectedObjectNum > 0)
            {
                float fCenterX = 0, fCenterY = 0, fWidth = 0, fHeight = 0;
                float fStartX, fStartY, fEndX, fEndY, fAngle = 0;
                int intArea = 0;
                float fWidthMM, fHeightMM, fAreaInMM;
                int intFailCount = 0;

                int intTotalArea = 0;
                for (int i = 0; i < intSelectedObjectNum; i++)
                {
                    intArea = m_objImage1SurfaceEBlobs.ref_arrArea[i];
                    //fHeight = m_objImage1SurfaceEBlobs.ref_arrHeight[i];
                    //fWidth = m_objImage1SurfaceEBlobs.ref_arrWidth[i];
                    //fCenterX = m_objImage1SurfaceEBlobs.ref_arrLimitCenterX[i];
                    //fCenterY = m_objImage1SurfaceEBlobs.ref_arrLimitCenterY[i];

                    if (m_objImage1SurfaceEBlobs.ref_arrRectWidth[i] < m_objImage1SurfaceEBlobs.ref_arrRectHeight[i])
                    {
                        fWidth = m_objImage1SurfaceEBlobs.ref_arrRectWidth[i];
                        fHeight = m_objImage1SurfaceEBlobs.ref_arrRectHeight[i];

                        fAngle = m_objImage1SurfaceEBlobs.ref_arrRectAngle[i];


                        if (fAngle < 0)
                            fAngle = -Math.Abs(fAngle);
                        else
                            fAngle = -fAngle;
                    }
                    else
                    {
                        fWidth = m_objImage1SurfaceEBlobs.ref_arrRectHeight[i];
                        fHeight = m_objImage1SurfaceEBlobs.ref_arrRectWidth[i];

                        fAngle = m_objImage1SurfaceEBlobs.ref_arrRectAngle[i];


                        if (fAngle < 0)
                            fAngle = Math.Abs(fAngle);
                        else
                            fAngle = 90 - (fAngle);
                    }
                    fCenterX = m_objImage1SurfaceEBlobs.ref_arrRectLimitCenterX[i];
                    fCenterY = m_objImage1SurfaceEBlobs.ref_arrRectLimitCenterY[i];


                    intTotalArea += intArea;
                    fCenterX += intStartPixelFromEdgeX;
                    fCenterY += intStartPixelFromEdgeY;
                    fStartX = (float)Math.Floor(fCenterX - (fWidth / 2));
                    fStartY = (float)Math.Floor(fCenterY - (fHeight / 2));
                    fEndX = (float)Math.Ceiling(fCenterX + (fWidth / 2));
                    fEndY = (float)Math.Ceiling(fCenterY + (fHeight / 2));

                    // convert width and height to mm
                    fWidthMM = fWidth / m_fMMToPixelXValue;
                    fHeightMM = fHeight / m_fMMToPixelYValue; // 11-04-2019 ZJYEOH : Changed m_fMMToPixelXValue to m_fMMToPixelYValue
                    fAreaInMM = intArea / m_fMMToPixelXValue / m_fMMToPixelYValue;

                    if (((m_intFailPkgOptionMask & 0x400000) > 0) || ((m_intFailPkgOptionMask & 0x800000) > 0))
                    {
                        intFailCount++;
                        m_intFailPkgResultMask |= 0x40000;

                        Defect objDefect = new Defect();

                        objDefect.ref_strName = "Foreign Material";
                        objDefect.ref_intFailMask = 0x40000;
                        objDefect.ref_fCenterX = intROIStartX + fCenterX;
                        objDefect.ref_fCenterY = intROIStartY + fCenterY;
                        objDefect.ref_fStartX = intROIStartX + fStartX;
                        objDefect.ref_fStartY = intROIStartY + fStartY;
                        objDefect.ref_fEndX = intROIStartX + fEndX;
                        objDefect.ref_fEndY = intROIStartY + fEndY;
                        objDefect.ref_fWidth = fWidth;
                        objDefect.ref_fHeight = fHeight;
                        objDefect.ref_fArea = intArea;
                        objDefect.ref_fAngle = fAngle;
                        objDefect.ref_fWidthInMM = fWidthMM;
                        objDefect.ref_fHeightInMM = fHeightMM;
                        objDefect.ref_fAreaInMM2 = fAreaInMM;
                        objDefect.ref_intImageNo = intImageIndex; //2020-01-09 ZJYEOH : Should not fixed to 1

                        if ((m_intFailPkgOptionMask & 0x800000) > 0)
                        {
                            if (m_intForeignMaterialBrightDefectDimensionFailCondition == 0)
                            {
                                if (fWidthMM > m_fBrightHorizontalForeignMaterial)
                                {
                                    blnOverallResult = false;
                                    objDefect.ref_fWidthFailValue = fWidthMM;
                                    objDefect.ref_intFailCriteria |= 0x01;
                                }
                                if (fHeightMM > m_fBrightVerticalForeignMaterial)
                                {
                                    blnOverallResult = false;
                                    objDefect.ref_fHeightFailValue = fHeightMM;
                                    objDefect.ref_intFailCriteria |= 0x02;
                                }
                            }
                            else
                            {
                                if ((fWidthMM > m_fBrightHorizontalForeignMaterial) && (fHeightMM > m_fBrightVerticalForeignMaterial))
                                {
                                    blnOverallResult = false;
                                    objDefect.ref_fWidthFailValue = fWidthMM;
                                    objDefect.ref_intFailCriteria |= 0x01;
                                    objDefect.ref_fHeightFailValue = fHeightMM;
                                    objDefect.ref_intFailCriteria |= 0x02;
                                }
                            }
                        }

                        if ((m_intFailPkgOptionMask & 0x400000) > 0)
                        {
                            if (fAreaInMM > m_fForeignMaterialArea)
                            {
                                blnOverallResult = false;
                                objDefect.ref_fAreaFailValue = fAreaInMM;
                                objDefect.ref_intFailCriteria |= 0x04;
                            }
                        }

                        m_arrPkgDefectList.Add(objDefect);
                    }

                }
            }

            objCheckAreaSampleROI.Dispose();
            return blnOverallResult;
        }
        private bool IsImage1UnitBrightFieldPackageFailed(ROI objSampleROI, int intROIStartX, int intROIStartY, int intImageIndex)//, bool blnPadPkg)
        {
            bool blnDebugImage = false;

            if (blnDebugImage)
                objSampleROI.SaveImage("D:\\TS\\objSampleROI.bmp"); // debug

            // Calculate start point from actual measurement package size. Fyi, objSampleROI size is not same as package size, but is PadROI Size
            float fPkgOffsetX = (objSampleROI.ref_ROIWidth - Math.Max(GetResultUpWidth_RectGauge4L(0), GetResultDownWidth_RectGauge4L(0))) / 2;
            float fPkgOffsetY = (objSampleROI.ref_ROIHeight - Math.Max(GetResultLeftHeight_RectGauge4L(0), GetResultRightHeight_RectGauge4L(0))) / 2;

            int intStartPixelFromEdgeX = (int)Math.Round(fPkgOffsetX + m_fPkgStartPixelFromLeft, 0, MidpointRounding.AwayFromZero);
            int intStartPixelFromEdgeY = (int)Math.Round(fPkgOffsetY + m_fPkgStartPixelFromEdge, 0, MidpointRounding.AwayFromZero);
            int intStartPixelFromEdgeX2 = (int)Math.Round(fPkgOffsetX + m_fPkgStartPixelFromRight, 0, MidpointRounding.AwayFromZero);
            int intStartPixelFromEdgeY2 = (int)Math.Round(fPkgOffsetY + m_fPkgStartPixelFromBottom, 0, MidpointRounding.AwayFromZero);

            ROI objCheckAreaSampleROI = new ROI();
            objCheckAreaSampleROI.AttachImage(objSampleROI);
            objCheckAreaSampleROI.LoadROISetting(intStartPixelFromEdgeX, intStartPixelFromEdgeY,
                objSampleROI.ref_ROIWidth - intStartPixelFromEdgeX - intStartPixelFromEdgeX2,
                objSampleROI.ref_ROIHeight - intStartPixelFromEdgeY - intStartPixelFromEdgeY2);

            if (blnDebugImage)
                objCheckAreaSampleROI.SaveImage("D:\\objCheckAreaSampleROI.bmp");   // debug
            int intSelectedObjectNum = 0;

            switch (intImageIndex)
            {
                case 1: // Image 1 (Grab 1 & Grab 2 Merged)
                    {
                        intSelectedObjectNum = m_objImage1SurfaceEBlobs.BuildObjects_Filter_GetElement(objCheckAreaSampleROI, false, true, 0, 125,
              m_intBrightFieldMinArea, 999999, false, 0xEF);// 0x0D);

                    }
                    break;
                case 2: // Image 2 (Grab 3)
                    {
                        intSelectedObjectNum = m_objImage1SurfaceEBlobs.BuildObjects_Filter_GetElement(objCheckAreaSampleROI, false, true, 0, 125,
             m_intDarkFieldMinArea, 999999, false, 0xEF);// 0x0D);

                    }
                    break;
                case 3: // Image 5 (Grab 5) // 2020-01-09 ZJYEOH : Changed case 4 to 3 
                    {
                        intSelectedObjectNum = m_objImage1SurfaceEBlobs.BuildObjects_Filter_GetElement(objCheckAreaSampleROI, false, true, 0, 125,
             m_intDarkFieldMinArea, 999999, false, 0xEF);// 0x0D);

                    }
                    break;
            }

            if (blnDebugImage)
                objCheckAreaSampleROI.SaveImage("D:\\TS\\objCheckAreaSampleROI.bmp");   // debug

            bool blnOverallResult = true;
            if (intSelectedObjectNum > 0)
            {
                float fCenterX = 0, fCenterY = 0, fWidth = 0, fHeight = 0;
                float fStartX, fStartY, fEndX, fEndY, fAngle = 0;
                int intArea = 0;
                float fWidthMM, fHeightMM, fAreaInMM;
                int intFailCount = 0;

                int intTotalArea = 0;
                for (int i = 0; i < intSelectedObjectNum; i++)
                {
                    intArea = m_objImage1SurfaceEBlobs.ref_arrArea[i];
                    //fHeight = m_objImage1SurfaceEBlobs.ref_arrHeight[i];
                    //fWidth = m_objImage1SurfaceEBlobs.ref_arrWidth[i];
                    //fCenterX = m_objImage1SurfaceEBlobs.ref_arrLimitCenterX[i];
                    //fCenterY = m_objImage1SurfaceEBlobs.ref_arrLimitCenterY[i];

                    if (m_objImage1SurfaceEBlobs.ref_arrRectWidth[i] < m_objImage1SurfaceEBlobs.ref_arrRectHeight[i])
                    {
                        fWidth = m_objImage1SurfaceEBlobs.ref_arrRectWidth[i];
                        fHeight = m_objImage1SurfaceEBlobs.ref_arrRectHeight[i];

                        fAngle = m_objImage1SurfaceEBlobs.ref_arrRectAngle[i];
                        
                        //if (fAngle < 0)
                        //    fAngle = -Math.Abs(fAngle);
                        //else
                        //    fAngle = -fAngle;
                    }
                    else
                    {
                        fWidth = m_objImage1SurfaceEBlobs.ref_arrRectHeight[i];
                        fHeight = m_objImage1SurfaceEBlobs.ref_arrRectWidth[i];

                        fAngle = m_objImage1SurfaceEBlobs.ref_arrRectAngle[i];

                        //if (fAngle < 0)
                        //    fAngle = Math.Abs(fAngle);
                        //else
                        //    fAngle = 90 - (fAngle);

                        if (fAngle >= 10)//&& fAngle <= 80)
                            fAngle = m_objImage1SurfaceEBlobs.ref_arrRectAngle[i] - 90;
                        else
                            fAngle = 90 + m_objImage1SurfaceEBlobs.ref_arrRectAngle[i];

                    }
                    fCenterX = m_objImage1SurfaceEBlobs.ref_arrRectLimitCenterX[i];
                    fCenterY = m_objImage1SurfaceEBlobs.ref_arrRectLimitCenterY[i];


                    intTotalArea += intArea;
                    fCenterX += intStartPixelFromEdgeX;
                    fCenterY += intStartPixelFromEdgeY;
                    fStartX = (float)Math.Floor(fCenterX - (fWidth / 2));
                    fStartY = (float)Math.Floor(fCenterY - (fHeight / 2));
                    fEndX = (float)Math.Ceiling(fCenterX + (fWidth / 2));
                    fEndY = (float)Math.Ceiling(fCenterY + (fHeight / 2));

                    // convert width and height to mm
                    fWidthMM = fWidth / m_fMMToPixelXValue;
                    fHeightMM = fHeight / m_fMMToPixelYValue; // 11-04-2019 ZJYEOH : Changed m_fMMToPixelXValue to m_fMMToPixelYValue
                    fAreaInMM = intArea / m_fMMToPixelXValue / m_fMMToPixelYValue;

                    //if ((fWidthMM > m_fScratchLength) || (fHeightMM > m_fScratchLength) || (fAreaInMM > m_fScratchArea) &&
                    //    ((m_intFailPkgOptionMask & 0x08) > 0 || (m_intFailPkgOptionMask & 0x1000) > 0))
                    {
                        intFailCount++;
                        //0x04
                        m_intFailPkgResultMask |= 0x10000; // Fail image 1 surface contamination

                        Defect objDefect = new Defect();

                        objDefect.ref_strName = "Bright";
                        objDefect.ref_intFailMask = 0x10000;
                        objDefect.ref_fCenterX = intROIStartX + fCenterX;
                        objDefect.ref_fCenterY = intROIStartY + fCenterY;
                        objDefect.ref_fStartX = intROIStartX + fStartX;
                        objDefect.ref_fStartY = intROIStartY + fStartY;
                        objDefect.ref_fEndX = intROIStartX + fEndX;
                        objDefect.ref_fEndY = intROIStartY + fEndY;
                        objDefect.ref_fWidth = fWidth;
                        objDefect.ref_fHeight = fHeight;
                        objDefect.ref_fArea = intArea;
                        objDefect.ref_fAngle = fAngle;
                        objDefect.ref_fWidthInMM = fWidthMM;
                        objDefect.ref_fHeightInMM = fHeightMM;
                        objDefect.ref_fAreaInMM2 = fAreaInMM;
                        objDefect.ref_intImageNo = intImageIndex; //2020-01-09 ZJYEOH : Should not fixed to 1

                        if ((m_intFailPkgOptionMask & 0x20000) > 0)
                        {
                            if (m_intBrightDefectDimensionFailCondition == 0)
                            {
                                if (fWidthMM > m_fBrightWidth)
                                {
                                    blnOverallResult = false;
                                    objDefect.ref_fWidthFailValue = fWidthMM;
                                    objDefect.ref_intFailCriteria |= 0x01;
                                }
                                if (fHeightMM > m_fBrightLength)
                                {
                                    blnOverallResult = false;
                                    objDefect.ref_fHeightFailValue = fHeightMM;
                                    objDefect.ref_intFailCriteria |= 0x02;
                                }
                            }
                            else
                            {
                                if ((fWidthMM > m_fBrightWidth) && (fHeightMM > m_fBrightLength))
                                {
                                    blnOverallResult = false;
                                    objDefect.ref_fWidthFailValue = fWidthMM;
                                    objDefect.ref_intFailCriteria |= 0x01;
                                    objDefect.ref_fHeightFailValue = fHeightMM;
                                    objDefect.ref_intFailCriteria |= 0x02;
                                }
                            }
                        }

                        if ((m_intFailPkgOptionMask & 0x10000) > 0)
                        {
                            if (fAreaInMM > m_fBrightArea)
                            {
                                blnOverallResult = false;
                                objDefect.ref_fAreaFailValue = fAreaInMM;
                                objDefect.ref_intFailCriteria |= 0x04;
                            }
                        }

                        m_arrPkgDefectList.Add(objDefect);
                    }

                }

                if ((m_intFailPkgOptionMask & 0x10000) > 0)
                {
                    fAreaInMM = intTotalArea / m_fMMToPixelXValue / m_fMMToPixelYValue;

                    if (fAreaInMM > m_fBrightTotalArea)
                    {
                        Defect objDefect = new Defect();

                        objDefect.ref_strName = "Total Bright";
                        objDefect.ref_intFailMask = 0x10000;
                        objDefect.ref_fCenterX = -1;
                        objDefect.ref_fCenterY = -1;
                        objDefect.ref_fStartX = -1;
                        objDefect.ref_fStartY = -1;
                        objDefect.ref_fEndX = -1;
                        objDefect.ref_fEndY = -1;
                        objDefect.ref_fWidth = -1;
                        objDefect.ref_fHeight = -1;
                        objDefect.ref_fArea = intTotalArea;
                        objDefect.ref_fWidthInMM = -1;
                        objDefect.ref_fHeightInMM = -1;
                        objDefect.ref_fAreaInMM2 = fAreaInMM;
                        objDefect.ref_intImageNo = intImageIndex; //2020-01-09 ZJYEOH : Should not fixed to 1

                        blnOverallResult = false;
                        objDefect.ref_fAreaFailValue = fAreaInMM;
                        objDefect.ref_intFailCriteria |= 0x08;

                        m_arrPkgDefectList.Add(objDefect);

                        Defect objDefect2 = new Defect();
                        for (int a = 0; a < m_arrPkgDefectList.Count; a++)
                        {
                            objDefect2 = m_arrPkgDefectList[a];
                            if (objDefect2.ref_strName.Contains("Bright"))
                            {
                                objDefect2.ref_blnFailTotalArea = true;
                                m_arrPkgDefectList[a] = objDefect2;
                            }
                        }

                        m_intFailPkgResultMask |= 0x80000; // Fail image 1 surface total bright field

                        // Collect total extra pad for display error message
                        m_fResultBrightFieldTotalArea = fAreaInMM;
                    }
                }
            }

            objCheckAreaSampleROI.Dispose();
            return blnOverallResult;
        }
        private bool IsImage1UnitBrightFieldPackageFailed_WithLinkFunction(ROI objSampleROI, int intROIStartX, int intROIStartY, int intImageIndex)//, bool blnPadPkg)
        {
            bool blnDebugImage = false;

            if (blnDebugImage)
                objSampleROI.SaveImage("D:\\TS\\objSampleROI.bmp"); // debug

            // Calculate start point from actual measurement package size. Fyi, objSampleROI size is not same as package size, but is PadROI Size
            float fPkgOffsetX = (objSampleROI.ref_ROIWidth - Math.Max(GetResultUpWidth_RectGauge4L(0), GetResultDownWidth_RectGauge4L(0))) / 2;
            float fPkgOffsetY = (objSampleROI.ref_ROIHeight - Math.Max(GetResultLeftHeight_RectGauge4L(0), GetResultRightHeight_RectGauge4L(0))) / 2;

            int intStartPixelFromEdgeX = (int)Math.Round(fPkgOffsetX + m_fPkgStartPixelFromLeft, 0, MidpointRounding.AwayFromZero);
            int intStartPixelFromEdgeY = (int)Math.Round(fPkgOffsetY + m_fPkgStartPixelFromEdge, 0, MidpointRounding.AwayFromZero);
            int intStartPixelFromEdgeX2 = (int)Math.Round(fPkgOffsetX + m_fPkgStartPixelFromRight, 0, MidpointRounding.AwayFromZero);
            int intStartPixelFromEdgeY2 = (int)Math.Round(fPkgOffsetY + m_fPkgStartPixelFromBottom, 0, MidpointRounding.AwayFromZero);

            ROI objCheckAreaSampleROI = new ROI();
            objCheckAreaSampleROI.AttachImage(objSampleROI);
            objCheckAreaSampleROI.LoadROISetting(intStartPixelFromEdgeX, intStartPixelFromEdgeY,
                objSampleROI.ref_ROIWidth - intStartPixelFromEdgeX - intStartPixelFromEdgeX2,
                objSampleROI.ref_ROIHeight - intStartPixelFromEdgeY - intStartPixelFromEdgeY2);

            if (blnDebugImage)
                objCheckAreaSampleROI.SaveImage("D:\\objCheckAreaSampleROI.bmp");   // debug
            int intSelectedObjectNum = 0;

            switch (intImageIndex)
            {
                case 1: // Image 1 (Grab 1 & Grab 2 Merged)
                    {
                        intSelectedObjectNum = m_objImage1SurfaceEBlobs.BuildObjects_Filter_GetElement(objCheckAreaSampleROI, false, true, 0, 125,
              m_intBrightFieldMinArea, 999999, false, 0xEF);// 0x0D);

                    }
                    break;
                case 2: // Image 2 (Grab 3)
                    {
                        intSelectedObjectNum = m_objImage1SurfaceEBlobs.BuildObjects_Filter_GetElement(objCheckAreaSampleROI, false, true, 0, 125,
             m_intDarkFieldMinArea, 999999, false, 0xEF);// 0x0D);

                    }
                    break;
                case 3: // Image 5 (Grab 5) // 2020-01-09 ZJYEOH : Changed case 4 to 3 
                    {
                        intSelectedObjectNum = m_objImage1SurfaceEBlobs.BuildObjects_Filter_GetElement(objCheckAreaSampleROI, false, true, 0, 125,
             m_intDarkFieldMinArea, 999999, false, 0xEF);// 0x0D);

                    }
                    break;
            }

            if (blnDebugImage)
                objCheckAreaSampleROI.SaveImage("D:\\TS\\objCheckAreaSampleROI.bmp");   // debug

            bool blnOverallResult = true;
            if (intSelectedObjectNum > 0)
            {
                List<List<System.Windows.Point>> arr2DPoints = new List<List<System.Windows.Point>>();
                List<List<PointF>> arrRotatedPoints = new List<List<PointF>>();
                List<float> fObjectHeightList = new List<float>(), fObjectWidthList = new List<float>(), fObjectCenterXList = new List<float>(), fObjectCenterYList = new List<float>(), fObjectAngleList = new List<float>();
                List<float> fObjectLimitHeightList = new List<float>(), fObjectLimitWidthList = new List<float>(), fObjectLimitCenterXList = new List<float>(), fObjectLimitCenterYList = new List<float>();
                List<int> fObjectAreaList = new List<int>(), fObjectAreaList2 = new List<int>();
                float fCenterX = 0, fCenterY = 0, fWidth = 0, fHeight = 0;
                float fStartX, fStartY, fEndX, fEndY, fAngle = 0;
                int intArea = 0;
                float fWidthMM, fHeightMM, fAreaInMM;
                int intFailCount = 0;
                int intTolerance = m_intBrightDefectLinkTolerance;
                int intTotalArea = 0;
                for (int i = 0; i < intSelectedObjectNum; i++)
                {
                    arrRotatedPoints.Add(new List<PointF>());
                    arr2DPoints.Add(new List<System.Windows.Point>());
                    intArea = m_objImage1SurfaceEBlobs.ref_arrArea[i];
                    //fHeight = m_objImage1SurfaceEBlobs.ref_arrHeight[i];
                    //fWidth = m_objImage1SurfaceEBlobs.ref_arrWidth[i];
                    //fCenterX = m_objImage1SurfaceEBlobs.ref_arrLimitCenterX[i];
                    //fCenterY = m_objImage1SurfaceEBlobs.ref_arrLimitCenterY[i];

                    if (m_objImage1SurfaceEBlobs.ref_arrRectWidth[i] < m_objImage1SurfaceEBlobs.ref_arrRectHeight[i])
                    {
                        fWidth = m_objImage1SurfaceEBlobs.ref_arrRectWidth[i];
                        fHeight = m_objImage1SurfaceEBlobs.ref_arrRectHeight[i];

                        fAngle = m_objImage1SurfaceEBlobs.ref_arrRectAngle[i];

                        //if (fAngle < 0)
                        //    fAngle = -Math.Abs(fAngle);
                        //else
                        //    fAngle = -fAngle;

                    }
                    else
                    {
                        fWidth = m_objImage1SurfaceEBlobs.ref_arrRectHeight[i];
                        fHeight = m_objImage1SurfaceEBlobs.ref_arrRectWidth[i];

                        fAngle = m_objImage1SurfaceEBlobs.ref_arrRectAngle[i];

                        //if (fAngle < 0)
                        //    fAngle = Math.Abs(fAngle);
                        //else
                        //    fAngle = 90 - (fAngle);

                        if (fAngle >= 10)//&& fAngle <= 80)
                            fAngle = m_objImage1SurfaceEBlobs.ref_arrRectAngle[i] - 90;
                        else
                            fAngle = 90 + m_objImage1SurfaceEBlobs.ref_arrRectAngle[i];

                    }
                    fCenterX = m_objImage1SurfaceEBlobs.ref_arrRectLimitCenterX[i];
                    fCenterY = m_objImage1SurfaceEBlobs.ref_arrRectLimitCenterY[i];
                    
                    intTotalArea += intArea;
                    fCenterX += intStartPixelFromEdgeX;
                    fCenterY += intStartPixelFromEdgeY;
                    //fStartX = (float)Math.Floor(fCenterX - (fWidth / 2));
                    //fStartY = (float)Math.Floor(fCenterY - (fHeight / 2));
                    //fEndX = (float)Math.Ceiling(fCenterX + (fWidth / 2));
                    //fEndY = (float)Math.Ceiling(fCenterY + (fHeight / 2));

                    float newX1 = 0, newY1 = 0;  // new point 1
                    float newX2 = 0, newY2 = 0; // new point 2
                    float newX3 = 0, newY3 = 0; // new point 3
                    float newX4 = 0, newY4 = 0; // new point 4

                    //2020-12-18 ZJYEOH : Change to this format
                    //  Point 1 *-------------* Point 2
                    //          |             |
                    //          |             |
                    //          |             |
                    //  Point 4 *-------------* Point 3

                    Math2.RotateWithAngleAccordingToReferencePoint(fCenterX, fCenterY, (fCenterX - (fWidth / 2)), (fCenterY - (fHeight / 2)), fAngle, ref newX1, ref newY1);
                    Math2.RotateWithAngleAccordingToReferencePoint(fCenterX, fCenterY, (fCenterX + (fWidth / 2)), (fCenterY - (fHeight / 2)), fAngle, ref newX2, ref newY2);
                    Math2.RotateWithAngleAccordingToReferencePoint(fCenterX, fCenterY, (fCenterX + (fWidth / 2)), (fCenterY + (fHeight / 2)), fAngle, ref newX3, ref newY3);
                    Math2.RotateWithAngleAccordingToReferencePoint(fCenterX, fCenterY, (fCenterX - (fWidth / 2)), (fCenterY + (fHeight / 2)), fAngle, ref newX4, ref newY4);


                    arrRotatedPoints[i].Add(new PointF(newX1, newY1));
                    arrRotatedPoints[i].Add(new PointF(newX2, newY2));
                    arrRotatedPoints[i].Add(new PointF(newX3, newY3));
                    arrRotatedPoints[i].Add(new PointF(newX4, newY4));

                    Math2.RotateWithAngleAccordingToReferencePoint(fCenterX, fCenterY, (fCenterX - (fWidth / 2)) - intTolerance, (fCenterY - (fHeight / 2)) - intTolerance, fAngle, ref newX1, ref newY1);
                    Math2.RotateWithAngleAccordingToReferencePoint(fCenterX, fCenterY, (fCenterX + (fWidth / 2)) + intTolerance, (fCenterY - (fHeight / 2)) - intTolerance, fAngle, ref newX2, ref newY2);
                    Math2.RotateWithAngleAccordingToReferencePoint(fCenterX, fCenterY, (fCenterX + (fWidth / 2)) + intTolerance, (fCenterY + (fHeight / 2)) + intTolerance, fAngle, ref newX3, ref newY3);
                    Math2.RotateWithAngleAccordingToReferencePoint(fCenterX, fCenterY, (fCenterX - (fWidth / 2)) - intTolerance, (fCenterY + (fHeight / 2)) + intTolerance, fAngle, ref newX4, ref newY4);

                    arr2DPoints[i].Add(new System.Windows.Point(newX1, newY1));
                    arr2DPoints[i].Add(new System.Windows.Point(newX2, newY2));
                    arr2DPoints[i].Add(new System.Windows.Point(newX3, newY3));
                    arr2DPoints[i].Add(new System.Windows.Point(newX4, newY4));

                    fObjectHeightList.Add(fHeight);
                    fObjectWidthList.Add(fWidth);
                    fObjectCenterXList.Add(fCenterX);
                    fObjectCenterYList.Add(fCenterY);
                    fObjectAngleList.Add(fAngle);
                    fObjectAreaList.Add(intArea);
                    fObjectAreaList2.Add(intArea);
                    
                }
                
                int intAngleTolerance = 10;
                bool blnDecrement = false;
                if (intTolerance >= 0)
                {
                    for (int i = 0; i < fObjectHeightList.Count; i++)
                    {
                        if (blnDecrement)
                        {
                            blnDecrement = false;
                            if (i > 0)
                                i--;
                        }
                        for (int j = 0; j < fObjectHeightList.Count; j++)
                        {
                            if (i != j && i < fObjectHeightList.Count && j < fObjectHeightList.Count)
                            {
                                if (Intersection.CheckRectRectIntersection(arr2DPoints[i].ToArray(), arr2DPoints[j].ToArray(), intTolerance))
                                {

                                    PointF[] arrPoints = new PointF[8];

                                    arrPoints[0] = arrRotatedPoints[i][0];
                                    arrPoints[1] = arrRotatedPoints[i][1];
                                    arrPoints[2] = arrRotatedPoints[i][2];
                                    arrPoints[3] = arrRotatedPoints[i][3];
                                    arrPoints[4] = arrRotatedPoints[j][0];
                                    arrPoints[5] = arrRotatedPoints[j][1];
                                    arrPoints[6] = arrRotatedPoints[j][2];
                                    arrPoints[7] = arrRotatedPoints[j][3];

                                    float fMinAngle = 0;
                                    List<PointF> arrMinRect = new List<PointF>();
                                    arrMinRect = MinimumBoundingBox.CalculateMinimumBoundingBox(arrPoints, ref fMinAngle);
                                    //fObjectAngleList[i] = fMinAngle;
                                    if (fMinAngle < 0)
                                        fObjectAngleList[i] = -(90 + fMinAngle);
                                    else
                                        fObjectAngleList[i] = 90 - fMinAngle;

                                    //if (fMinAngle < 0)
                                    //    fObjectAngleList[i] = -(90 + fMinAngle);
                                    //else
                                    //    fObjectAngleList[i] = 90 - fMinAngle;

                                    Line onjLine1 = new Line();
                                    Line onjLine2 = new Line();
                                    onjLine1.CalculateStraightLine(arrMinRect[0], arrMinRect[2]);
                                    onjLine2.CalculateStraightLine(arrMinRect[1], arrMinRect[3]);
                                    PointF pCenter = Line.GetCrossPoint(onjLine1, onjLine2);
                                    float p1X = 0, p1Y = 0;
                                    float p2X = 0, p2Y = 0;
                                    float p3X = 0, p3Y = 0;
                                    float p4X = 0, p4Y = 0;
                                    Math2.RotateWithAngleAccordingToReferencePoint(pCenter.X, pCenter.Y, arrMinRect[0].X, arrMinRect[0].Y, -fObjectAngleList[i], ref p1X, ref p1Y);
                                    Math2.RotateWithAngleAccordingToReferencePoint(pCenter.X, pCenter.Y, arrMinRect[1].X, arrMinRect[1].Y, -fObjectAngleList[i], ref p2X, ref p2Y);
                                    Math2.RotateWithAngleAccordingToReferencePoint(pCenter.X, pCenter.Y, arrMinRect[2].X, arrMinRect[2].Y, -fObjectAngleList[i], ref p3X, ref p3Y);
                                    Math2.RotateWithAngleAccordingToReferencePoint(pCenter.X, pCenter.Y, arrMinRect[3].X, arrMinRect[3].Y, -fObjectAngleList[i], ref p4X, ref p4Y);

                                    float pR1X = 0, pR1Y = 0;
                                    float pR2X = 0, pR2Y = 0;
                                    float pR3X = 0, pR3Y = 0;
                                    float pR4X = 0, pR4Y = 0;
                                    Math2.RotateWithAngleAccordingToReferencePoint(pCenter.X, pCenter.Y, Math.Min(Math.Min(p1X, p2X), Math.Min(p3X, p4X)), Math.Min(Math.Min(p1Y, p2Y), Math.Min(p3Y, p4Y)), fObjectAngleList[i], ref pR1X, ref pR1Y); // Top Left
                                    Math2.RotateWithAngleAccordingToReferencePoint(pCenter.X, pCenter.Y, Math.Max(Math.Max(p1X, p2X), Math.Max(p3X, p4X)), Math.Min(Math.Min(p1Y, p2Y), Math.Min(p3Y, p4Y)), fObjectAngleList[i], ref pR2X, ref pR2Y); // Top Right
                                    Math2.RotateWithAngleAccordingToReferencePoint(pCenter.X, pCenter.Y, Math.Max(Math.Max(p1X, p2X), Math.Max(p3X, p4X)), Math.Max(Math.Max(p1Y, p2Y), Math.Max(p3Y, p4Y)), fObjectAngleList[i], ref pR3X, ref pR3Y); // Bottom Right
                                    Math2.RotateWithAngleAccordingToReferencePoint(pCenter.X, pCenter.Y, Math.Min(Math.Min(p1X, p2X), Math.Min(p3X, p4X)), Math.Max(Math.Max(p1Y, p2Y), Math.Max(p3Y, p4Y)), fObjectAngleList[i], ref pR4X, ref pR4Y); // Bottom Left
                                    arrMinRect[0] = new PointF(pR1X, pR1Y);
                                    arrMinRect[1] = new PointF(pR2X, pR2Y);
                                    arrMinRect[2] = new PointF(pR3X, pR3Y);
                                    arrMinRect[3] = new PointF(pR4X, pR4Y);

                                    arrRotatedPoints[i][0] = arrMinRect[0];
                                    arrRotatedPoints[i][1] = arrMinRect[1];
                                    arrRotatedPoints[i][2] = arrMinRect[2];
                                    arrRotatedPoints[i][3] = arrMinRect[3];

                                    Math2.RotateWithAngleAccordingToReferencePoint(pCenter.X, pCenter.Y, Math.Min(Math.Min(p1X, p2X), Math.Min(p3X, p4X)) - intTolerance, Math.Min(Math.Min(p1Y, p2Y), Math.Min(p3Y, p4Y)) - intTolerance, fObjectAngleList[i], ref pR1X, ref pR1Y); // Top Left
                                    Math2.RotateWithAngleAccordingToReferencePoint(pCenter.X, pCenter.Y, Math.Max(Math.Max(p1X, p2X), Math.Max(p3X, p4X)) + intTolerance, Math.Min(Math.Min(p1Y, p2Y), Math.Min(p3Y, p4Y)) - intTolerance, fObjectAngleList[i], ref pR2X, ref pR2Y); // Top Right
                                    Math2.RotateWithAngleAccordingToReferencePoint(pCenter.X, pCenter.Y, Math.Max(Math.Max(p1X, p2X), Math.Max(p3X, p4X)) + intTolerance, Math.Max(Math.Max(p1Y, p2Y), Math.Max(p3Y, p4Y)) + intTolerance, fObjectAngleList[i], ref pR3X, ref pR3Y); // Bottom Right
                                    Math2.RotateWithAngleAccordingToReferencePoint(pCenter.X, pCenter.Y, Math.Min(Math.Min(p1X, p2X), Math.Min(p3X, p4X)) - intTolerance, Math.Max(Math.Max(p1Y, p2Y), Math.Max(p3Y, p4Y)) + intTolerance, fObjectAngleList[i], ref pR4X, ref pR4Y); // Bottom Left

                                    arr2DPoints[i][0] = new System.Windows.Point(pR1X, pR1Y);
                                    arr2DPoints[i][1] = new System.Windows.Point(pR2X, pR2Y);
                                    arr2DPoints[i][2] = new System.Windows.Point(pR3X, pR3Y);
                                    arr2DPoints[i][3] = new System.Windows.Point(pR4X, pR4Y);

                                    arrRotatedPoints.RemoveAt(j);
                                    arr2DPoints.RemoveAt(j);

                                    float fDiffX = Math.Max(Math.Abs(p1X - p4X), Math.Abs(p2X - p3X));
                                    float fDiffY = Math.Max(Math.Abs(p3Y - p4Y), Math.Abs(p2Y - p1Y));

                                    fObjectWidthList[i] = fDiffX;
                                    fObjectHeightList[i] = fDiffY;

                                    fObjectCenterXList[i] = pCenter.X;
                                    fObjectCenterYList[i] = pCenter.Y;

                                    fObjectAreaList2.RemoveAt(j);
                                    fObjectAreaList[i] = fObjectAreaList[i] + fObjectAreaList[j];

                                    fObjectHeightList.RemoveAt(j);
                                    fObjectWidthList.RemoveAt(j);
                                    fObjectCenterXList.RemoveAt(j);
                                    fObjectCenterYList.RemoveAt(j);
                                    fObjectAngleList.RemoveAt(j);
                                    fObjectAreaList.RemoveAt(j);

                                    if (j > 0)
                                        j = -1;
                                    if (i > 0)
                                    {
                                        i = 0;
                                    }
                                    else
                                        blnDecrement = true;

                                }

                            }
                        }
                    }
                }
                for (int i = 0; i < fObjectHeightList.Count; i++)
                {
                    if (fObjectHeightList[i] < fObjectWidthList[i])
                    {
                        float fObjectWidth = fObjectHeightList[i];
                        float fObjectHeight = fObjectWidthList[i];

                        float fObjectAngle = fObjectAngleList[i];

                        if (fObjectAngle >= 10)//&& fAngle <= 80)
                            fObjectAngle = fObjectAngleList[i] - 90;
                        else
                            fObjectAngle = 90 + fObjectAngleList[i];

                        fObjectWidthList[i] = fObjectWidth;
                        fObjectHeightList[i] = fObjectHeight;
                        fObjectAngleList[i] = fObjectAngle;
                    }
                    else
                    {
                        float fObjectHeight = fObjectHeightList[i];
                        float fObjectWidth = fObjectWidthList[i];

                        float fObjectAngle = fObjectAngleList[i];

                        fObjectWidthList[i] = fObjectWidth;
                        fObjectHeightList[i] = fObjectHeight;
                        fObjectAngleList[i] = fObjectAngle;
                    }

                    // convert width and height to mm
                    //fWidthMM = fWidth / m_fMMToPixelXValue;
                    //fHeightMM = fHeight / m_fMMToPixelYValue; // 11-04-2019 ZJYEOH : Changed m_fMMToPixelXValue to m_fMMToPixelYValue
                    //fAreaInMM = intArea / m_fMMToPixelXValue / m_fMMToPixelYValue;
                    fWidthMM = fObjectWidthList[i] / m_fMMToPixelXValue;
                    fHeightMM = fObjectHeightList[i] / m_fMMToPixelYValue;
                    fAreaInMM = fObjectAreaList[i] / (m_fMMToPixelXValue * m_fMMToPixelYValue);

                    //if ((fWidthMM > m_fScratchLength) || (fHeightMM > m_fScratchLength) || (fAreaInMM > m_fScratchArea) &&
                    //    ((m_intFailPkgOptionMask & 0x08) > 0 || (m_intFailPkgOptionMask & 0x1000) > 0))
                    {
                        intFailCount++;
                        //0x04
                        m_intFailPkgResultMask |= 0x10000; // Fail image 1 surface contamination
                        
                        Defect objDefect = new Defect();
                        objDefect.ref_strName = "Bright";
                        objDefect.ref_intFailMask = 0x10000;
                        objDefect.ref_fCenterX = intROIStartX + fObjectCenterXList[i];
                        objDefect.ref_fCenterY = intROIStartY + fObjectCenterYList[i];
                        objDefect.ref_fStartX = intROIStartX + (float)Math.Floor(fObjectCenterXList[i] - (fObjectWidthList[i] / 2));
                        objDefect.ref_fStartY = intROIStartY + (float)Math.Floor(fObjectCenterYList[i] - (fObjectHeightList[i] / 2));
                        objDefect.ref_fEndX = intROIStartX + (float)Math.Ceiling(fObjectCenterXList[i] + (fObjectWidthList[i] / 2));
                        objDefect.ref_fEndY = intROIStartY + (float)Math.Ceiling(fObjectCenterYList[i] + (fObjectHeightList[i] / 2));
                        objDefect.ref_fWidth = fObjectWidthList[i];
                        objDefect.ref_fHeight = fObjectHeightList[i];
                        objDefect.ref_fArea = fObjectAreaList[i];
                        objDefect.ref_fAngle = fObjectAngleList[i];
                        objDefect.ref_fWidthInMM = fWidthMM;
                        objDefect.ref_fHeightInMM = fHeightMM;
                        objDefect.ref_fAreaInMM2 = fAreaInMM;
                        objDefect.ref_intImageNo = intImageIndex; //2020-01-09 ZJYEOH : Should not fixed to 1

                        if ((m_intFailPkgOptionMask & 0x20000) > 0)
                        {
                            if (m_intBrightDefectDimensionFailCondition == 0)
                            {
                                if (fWidthMM > m_fBrightWidth)
                                {
                                    blnOverallResult = false;
                                    objDefect.ref_fWidthFailValue = fWidthMM;
                                    objDefect.ref_intFailCriteria |= 0x01;
                                }
                                if (fHeightMM > m_fBrightLength)
                                {
                                    blnOverallResult = false;
                                    objDefect.ref_fHeightFailValue = fHeightMM;
                                    objDefect.ref_intFailCriteria |= 0x02;
                                }
                            }
                            else
                            {
                                if ((fWidthMM > m_fBrightWidth) && (fHeightMM > m_fBrightLength))
                                {
                                    blnOverallResult = false;
                                    objDefect.ref_fWidthFailValue = fWidthMM;
                                    objDefect.ref_intFailCriteria |= 0x01;
                                    objDefect.ref_fHeightFailValue = fHeightMM;
                                    objDefect.ref_intFailCriteria |= 0x02;
                                }
                            }
                        }

                        if ((m_intFailPkgOptionMask & 0x10000) > 0)
                        {
                            if (fAreaInMM > m_fBrightArea)
                            {
                                blnOverallResult = false;
                                objDefect.ref_fAreaFailValue = fAreaInMM;
                                objDefect.ref_intFailCriteria |= 0x04;
                            }
                        }

                        m_arrPkgDefectList.Add(objDefect);
                    }
                }
                

                if ((m_intFailPkgOptionMask & 0x10000) > 0)
                {
                    fAreaInMM = intTotalArea / (m_fMMToPixelXValue * m_fMMToPixelYValue);

                    if (fAreaInMM > m_fBrightTotalArea)
                    {
                        Defect objDefect = new Defect();

                        objDefect.ref_strName = "Total Bright";
                        objDefect.ref_intFailMask = 0x10000;
                        objDefect.ref_fCenterX = -1;
                        objDefect.ref_fCenterY = -1;
                        objDefect.ref_fStartX = -1;
                        objDefect.ref_fStartY = -1;
                        objDefect.ref_fEndX = -1;
                        objDefect.ref_fEndY = -1;
                        objDefect.ref_fWidth = -1;
                        objDefect.ref_fHeight = -1;
                        objDefect.ref_fArea = intTotalArea;
                        objDefect.ref_fWidthInMM = -1;
                        objDefect.ref_fHeightInMM = -1;
                        objDefect.ref_fAreaInMM2 = fAreaInMM;
                        objDefect.ref_intImageNo = intImageIndex; //2020-01-09 ZJYEOH : Should not fixed to 1

                        blnOverallResult = false;
                        objDefect.ref_fAreaFailValue = fAreaInMM;
                        objDefect.ref_intFailCriteria |= 0x08;

                        m_arrPkgDefectList.Add(objDefect);

                        Defect objDefect2 = new Defect();
                        for (int a = 0; a < m_arrPkgDefectList.Count; a++)
                        {
                            objDefect2 = m_arrPkgDefectList[a];
                            if (objDefect2.ref_strName.Contains("Bright"))
                            {
                                objDefect2.ref_blnFailTotalArea = true;
                                m_arrPkgDefectList[a] = objDefect2;
                            }
                        }

                        m_intFailPkgResultMask |= 0x80000; // Fail image 1 surface total bright field

                        // Collect total extra pad for display error message
                        m_fResultBrightFieldTotalArea = fAreaInMM;
                    }
                }
            }

            objCheckAreaSampleROI.Dispose();
            return blnOverallResult;
        }
        private bool IsImage1UnitBrightFieldPackageFailed_TiltAngle(ROI objSampleROI, int intROIStartX, int intROIStartY, int intImageIndex, int intPadIndex)//, bool blnPadPkg)
        {
            bool blnDebugImage = false;

            if (blnDebugImage)
                objSampleROI.SaveImage("D:\\TS\\objSampleROI.bmp"); // debug

            // Calculate start point from actual measurement package size. Fyi, objSampleROI size is not same as package size, but is PadROI Size
            float fPkgOffsetX = (objSampleROI.ref_ROIWidth - Math.Max(GetResultUpWidth_RectGauge4L(0), GetResultDownWidth_RectGauge4L(0))) / 2;
            float fPkgOffsetY = (objSampleROI.ref_ROIHeight - Math.Max(GetResultLeftHeight_RectGauge4L(0), GetResultRightHeight_RectGauge4L(0))) / 2;

            int intStartPixelFromEdgeX = (int)Math.Round(fPkgOffsetX + m_fPkgStartPixelFromLeft, 0, MidpointRounding.AwayFromZero);
            int intStartPixelFromEdgeY = (int)Math.Round(fPkgOffsetY + m_fPkgStartPixelFromEdge, 0, MidpointRounding.AwayFromZero);
            int intStartPixelFromEdgeX2 = (int)Math.Round(fPkgOffsetX + m_fPkgStartPixelFromRight, 0, MidpointRounding.AwayFromZero);
            int intStartPixelFromEdgeY2 = (int)Math.Round(fPkgOffsetY + m_fPkgStartPixelFromBottom, 0, MidpointRounding.AwayFromZero);

            ROI objCheckAreaSampleROI = new ROI();
            objCheckAreaSampleROI.AttachImage(objSampleROI);
            objCheckAreaSampleROI.LoadROISetting(intStartPixelFromEdgeX, intStartPixelFromEdgeY,
                objSampleROI.ref_ROIWidth - intStartPixelFromEdgeX - intStartPixelFromEdgeX2,
                objSampleROI.ref_ROIHeight - intStartPixelFromEdgeY - intStartPixelFromEdgeY2);

            //2020-01-09 ZJYEOH : Should subtract Dont care area with objCheckAreaSampleROI instead of objSampleROI
            //2019-09-23 ZJYEOH : Subtract tilt dont care area 
            if (intPadIndex == 1) // Top
            {
                ROI DontCareTop = new ROI();

                DontCareTop.LoadROISetting(0, 0, objCheckAreaSampleROI.ref_ROIWidth, objCheckAreaSampleROI.ref_ROIHeight);
                DontCareTop.AttachImage(m_ImgTilt_Top_L);
                EasyImage.Oper(EArithmeticLogicOperation.Subtract, objCheckAreaSampleROI.ref_ROI, DontCareTop.ref_ROI, objCheckAreaSampleROI.ref_ROI);
                DontCareTop.LoadROISetting(m_ImgTilt_Top_R.ref_intImageWidth - objCheckAreaSampleROI.ref_ROIWidth, 0, objCheckAreaSampleROI.ref_ROIWidth, objCheckAreaSampleROI.ref_ROIHeight);
                DontCareTop.AttachImage(m_ImgTilt_Top_R);
                EasyImage.Oper(EArithmeticLogicOperation.Subtract, objCheckAreaSampleROI.ref_ROI, DontCareTop.ref_ROI, objCheckAreaSampleROI.ref_ROI);
                if (blnDebugImage)
                    objCheckAreaSampleROI.SaveImage("D:\\TS\\IsImage1UnitBrightFieldPackageFailed_objCheckAreaSampleROITop.bmp");
                DontCareTop.Dispose();
            }
            if (intPadIndex == 2) // Right
            {
                ROI DontCareRight = new ROI();
                DontCareRight.LoadROISetting(m_ImgTilt_Top_R.ref_intImageWidth - objCheckAreaSampleROI.ref_ROIWidth, 0, objCheckAreaSampleROI.ref_ROIWidth, objCheckAreaSampleROI.ref_ROIHeight);
                DontCareRight.AttachImage(m_ImgTilt_Right_T);
                EasyImage.Oper(EArithmeticLogicOperation.Subtract, objCheckAreaSampleROI.ref_ROI, DontCareRight.ref_ROI, objCheckAreaSampleROI.ref_ROI);
                DontCareRight.LoadROISetting(m_ImgTilt_Top_R.ref_intImageWidth - objCheckAreaSampleROI.ref_ROIWidth, m_ImgTilt_Top_R.ref_intImageHeight - objCheckAreaSampleROI.ref_ROIHeight, objCheckAreaSampleROI.ref_ROIWidth, objCheckAreaSampleROI.ref_ROIHeight);
                DontCareRight.AttachImage(m_ImgTilt_Right_B);
                EasyImage.Oper(EArithmeticLogicOperation.Subtract, objCheckAreaSampleROI.ref_ROI, DontCareRight.ref_ROI, objCheckAreaSampleROI.ref_ROI);
                if (blnDebugImage)
                    objCheckAreaSampleROI.SaveImage("D:\\TS\\IsImage1UnitBrightFieldPackageFailed_objCheckAreaSampleROIRight.bmp");
                DontCareRight.Dispose();
            }
            if (intPadIndex == 3) // Bottom
            {
                ROI DontCareBottom = new ROI();

                DontCareBottom.LoadROISetting(0, m_ImgTilt_Top_R.ref_intImageHeight - objCheckAreaSampleROI.ref_ROIHeight, objCheckAreaSampleROI.ref_ROIWidth, objCheckAreaSampleROI.ref_ROIHeight);
                DontCareBottom.AttachImage(m_ImgTilt_Bottom_L);
                EasyImage.Oper(EArithmeticLogicOperation.Subtract, objCheckAreaSampleROI.ref_ROI, DontCareBottom.ref_ROI, objCheckAreaSampleROI.ref_ROI);
                DontCareBottom.LoadROISetting(m_ImgTilt_Top_R.ref_intImageWidth - objCheckAreaSampleROI.ref_ROIWidth, m_ImgTilt_Top_R.ref_intImageHeight - objCheckAreaSampleROI.ref_ROIHeight, objCheckAreaSampleROI.ref_ROIWidth, objCheckAreaSampleROI.ref_ROIHeight);
                DontCareBottom.AttachImage(m_ImgTilt_Bottom_R);
                EasyImage.Oper(EArithmeticLogicOperation.Subtract, objCheckAreaSampleROI.ref_ROI, DontCareBottom.ref_ROI, objCheckAreaSampleROI.ref_ROI);
                if (blnDebugImage)
                    objCheckAreaSampleROI.SaveImage("D:\\TS\\IsImage1UnitBrightFieldPackageFailed_objCheckAreaSampleROIBottom.bmp");
                DontCareBottom.Dispose();
            }
            if (intPadIndex == 4) // Left
            {
                ROI DontCareLeft = new ROI();

                DontCareLeft.LoadROISetting(0, 0, objCheckAreaSampleROI.ref_ROIWidth, objCheckAreaSampleROI.ref_ROIHeight);
                DontCareLeft.AttachImage(m_ImgTilt_Left_T);
                EasyImage.Oper(EArithmeticLogicOperation.Subtract, objCheckAreaSampleROI.ref_ROI, DontCareLeft.ref_ROI, objCheckAreaSampleROI.ref_ROI);
                DontCareLeft.LoadROISetting(0, m_ImgTilt_Top_R.ref_intImageHeight - objCheckAreaSampleROI.ref_ROIHeight, objCheckAreaSampleROI.ref_ROIWidth, objCheckAreaSampleROI.ref_ROIHeight);
                DontCareLeft.AttachImage(m_ImgTilt_Left_B);
                EasyImage.Oper(EArithmeticLogicOperation.Subtract, objCheckAreaSampleROI.ref_ROI, DontCareLeft.ref_ROI, objCheckAreaSampleROI.ref_ROI);
                if (blnDebugImage)
                    objCheckAreaSampleROI.SaveImage("D:\\TS\\IsImage1UnitBrightFieldPackageFailed_objCheckAreaSampleROILeft.bmp");
                DontCareLeft.Dispose();
            }

            if (blnDebugImage)
                objCheckAreaSampleROI.SaveImage("D:\\TS\\objCheckAreaSampleROI.bmp");   // debug
            int intSelectedObjectNum = 0;

            switch (intImageIndex)
            {
                case 1: // Image 1 (Grab 1 & Grab 2 Merged)
                    {
                        intSelectedObjectNum = m_objImage1SurfaceEBlobs.BuildObjects_Filter_GetElement(objCheckAreaSampleROI, false, true, 0, 125,
              m_intBrightFieldMinArea, 999999, false, 0xEF);// 0x0D);

                    }
                    break;
                case 2: // Image 2 (Grab 3)
                    {
                        intSelectedObjectNum = m_objImage1SurfaceEBlobs.BuildObjects_Filter_GetElement(objCheckAreaSampleROI, false, true, 0, 125,
             m_intDarkFieldMinArea, 999999, false, 0xEF);// 0x0D);

                    }
                    break;
                case 3: // Image 5 (Grab 5) // 2020-01-09 ZJYEOH : Changed case 4 to 3 
                    {
                        intSelectedObjectNum = m_objImage1SurfaceEBlobs.BuildObjects_Filter_GetElement(objCheckAreaSampleROI, false, true, 0, 125,
             m_intDarkFieldMinArea, 999999, false, 0xEF);// 0x0D);

                    }
                    break;
            }

            if (blnDebugImage)
                objCheckAreaSampleROI.SaveImage("D:\\TS\\objCheckAreaSampleROI.bmp");   // debug

            bool blnOverallResult = true;
            if (intSelectedObjectNum > 0)
            {
                float fCenterX = 0, fCenterY = 0, fWidth = 0, fHeight = 0;
                float fStartX, fStartY, fEndX, fEndY, fAngle = 0;
                int intArea = 0;
                float fWidthMM, fHeightMM, fAreaInMM;
                int intFailCount = 0;

                int intTotalArea = 0;
                for (int i = 0; i < intSelectedObjectNum; i++)
                {
                    intArea = m_objImage1SurfaceEBlobs.ref_arrArea[i];
                    //fHeight = m_objImage1SurfaceEBlobs.ref_arrHeight[i];
                    //fWidth = m_objImage1SurfaceEBlobs.ref_arrWidth[i];
                    //fCenterX = m_objImage1SurfaceEBlobs.ref_arrLimitCenterX[i];
                    //fCenterY = m_objImage1SurfaceEBlobs.ref_arrLimitCenterY[i];

                    if (m_objImage1SurfaceEBlobs.ref_arrRectWidth[i] < m_objImage1SurfaceEBlobs.ref_arrRectHeight[i])
                    {
                        fWidth = m_objImage1SurfaceEBlobs.ref_arrRectWidth[i];
                        fHeight = m_objImage1SurfaceEBlobs.ref_arrRectHeight[i];

                        fAngle = m_objImage1SurfaceEBlobs.ref_arrRectAngle[i];
                        
                        //if (fAngle < 0)
                        //    fAngle = -Math.Abs(fAngle);
                        //else
                        //    fAngle = -fAngle;
                    }
                    else
                    {
                        fWidth = m_objImage1SurfaceEBlobs.ref_arrRectHeight[i];
                        fHeight = m_objImage1SurfaceEBlobs.ref_arrRectWidth[i];

                        fAngle = m_objImage1SurfaceEBlobs.ref_arrRectAngle[i];

                        //if (fAngle < 0)
                        //    fAngle = Math.Abs(fAngle);
                        //else
                        //    fAngle = 90 - (fAngle);

                        if (fAngle >= 10)//&& fAngle <= 80)
                            fAngle = m_objImage1SurfaceEBlobs.ref_arrRectAngle[i] - 90;
                        else
                            fAngle = 90 + m_objImage1SurfaceEBlobs.ref_arrRectAngle[i];

                    }
                    fCenterX = m_objImage1SurfaceEBlobs.ref_arrRectLimitCenterX[i];
                    fCenterY = m_objImage1SurfaceEBlobs.ref_arrRectLimitCenterY[i];


                    intTotalArea += intArea;
                    fCenterX += intStartPixelFromEdgeX;
                    fCenterY += intStartPixelFromEdgeY;
                    fStartX = (float)Math.Floor(fCenterX - (fWidth / 2));
                    fStartY = (float)Math.Floor(fCenterY - (fHeight / 2));
                    fEndX = (float)Math.Ceiling(fCenterX + (fWidth / 2));
                    fEndY = (float)Math.Ceiling(fCenterY + (fHeight / 2));

                    // convert width and height to mm
                    fWidthMM = fWidth / m_fMMToPixelXValue;
                    fHeightMM = fHeight / m_fMMToPixelYValue; // 11-04-2019 ZJYEOH : Changed m_fMMToPixelXValue to m_fMMToPixelYValue
                    fAreaInMM = intArea / m_fMMToPixelXValue / m_fMMToPixelYValue;

                    //if ((fWidthMM > m_fScratchLength) || (fHeightMM > m_fScratchLength) || (fAreaInMM > m_fScratchArea) &&
                    //    ((m_intFailPkgOptionMask & 0x08) > 0 || (m_intFailPkgOptionMask & 0x1000) > 0))
                    {
                        intFailCount++;
                        //0x04
                        m_intFailPkgResultMask |= 0x10000; // Fail image 1 surface contamination

                        Defect objDefect = new Defect();

                        objDefect.ref_strName = "Bright";
                        objDefect.ref_intFailMask = 0x10000;
                        objDefect.ref_fCenterX = intROIStartX + fCenterX;
                        objDefect.ref_fCenterY = intROIStartY + fCenterY;
                        objDefect.ref_fStartX = intROIStartX + fStartX;
                        objDefect.ref_fStartY = intROIStartY + fStartY;
                        objDefect.ref_fEndX = intROIStartX + fEndX;
                        objDefect.ref_fEndY = intROIStartY + fEndY;
                        objDefect.ref_fWidth = fWidth;
                        objDefect.ref_fHeight = fHeight;
                        objDefect.ref_fArea = intArea;
                        objDefect.ref_fAngle = fAngle;
                        objDefect.ref_fWidthInMM = fWidthMM;
                        objDefect.ref_fHeightInMM = fHeightMM;
                        objDefect.ref_fAreaInMM2 = fAreaInMM;
                        objDefect.ref_intImageNo = intImageIndex; //2020-01-09 ZJYEOH : Should not fixed to 1

                        if ((m_intFailPkgOptionMask & 0x20000) > 0)
                        {
                            if (m_intBrightDefectDimensionFailCondition == 0)
                            {
                                if (fWidthMM > m_fBrightWidth)
                                {
                                    blnOverallResult = false;
                                    objDefect.ref_fWidthFailValue = fWidthMM;
                                    objDefect.ref_intFailCriteria |= 0x01;
                                }
                                if (fHeightMM > m_fBrightLength)
                                {
                                    blnOverallResult = false;
                                    objDefect.ref_fHeightFailValue = fHeightMM;
                                    objDefect.ref_intFailCriteria |= 0x02;
                                }
                            }
                            else
                            {
                                if ((fWidthMM > m_fBrightWidth) && (fHeightMM > m_fBrightLength))
                                {
                                    blnOverallResult = false;
                                    objDefect.ref_fWidthFailValue = fWidthMM;
                                    objDefect.ref_intFailCriteria |= 0x01;
                                    objDefect.ref_fHeightFailValue = fHeightMM;
                                    objDefect.ref_intFailCriteria |= 0x02;
                                }
                            }
                        }

                        if ((m_intFailPkgOptionMask & 0x10000) > 0)
                        {
                            if (fAreaInMM > m_fBrightArea)
                            {
                                blnOverallResult = false;
                                objDefect.ref_fAreaFailValue = fAreaInMM;
                                objDefect.ref_intFailCriteria |= 0x04;
                            }
                        }

                        m_arrPkgDefectList.Add(objDefect);
                    }

                }

                if ((m_intFailPkgOptionMask & 0x10000) > 0)
                {
                    fAreaInMM = intTotalArea / m_fMMToPixelXValue / m_fMMToPixelYValue;

                    if (fAreaInMM > m_fBrightTotalArea)
                    {
                        Defect objDefect = new Defect();

                        objDefect.ref_strName = "Total Bright";
                        objDefect.ref_intFailMask = 0x10000;
                        objDefect.ref_fCenterX = -1;
                        objDefect.ref_fCenterY = -1;
                        objDefect.ref_fStartX = -1;
                        objDefect.ref_fStartY = -1;
                        objDefect.ref_fEndX = -1;
                        objDefect.ref_fEndY = -1;
                        objDefect.ref_fWidth = -1;
                        objDefect.ref_fHeight = -1;
                        objDefect.ref_fArea = intTotalArea;
                        objDefect.ref_fWidthInMM = -1;
                        objDefect.ref_fHeightInMM = -1;
                        objDefect.ref_fAreaInMM2 = fAreaInMM;
                        objDefect.ref_intImageNo = intImageIndex; //2020-01-09 ZJYEOH : Should not fixed to 1

                        blnOverallResult = false;
                        objDefect.ref_fAreaFailValue = fAreaInMM;
                        objDefect.ref_intFailCriteria |= 0x08;

                        m_arrPkgDefectList.Add(objDefect);

                        Defect objDefect2 = new Defect();
                        for (int a = 0; a < m_arrPkgDefectList.Count; a++)
                        {
                            objDefect2 = m_arrPkgDefectList[a];
                            if (objDefect2.ref_strName.Contains("Bright"))
                            {
                                objDefect2.ref_blnFailTotalArea = true;
                                m_arrPkgDefectList[a] = objDefect2;
                            }
                        }

                        m_intFailPkgResultMask |= 0x80000; // Fail image 1 surface total bright field

                        // Collect total extra pad for display error message
                        m_fResultBrightFieldTotalArea = fAreaInMM;
                    }
                }
            }

            objCheckAreaSampleROI.Dispose();
            return blnOverallResult;
        }
        private bool IsImage1UnitBrightFieldPackageFailed_TiltAngle_WithLinkFunction(ROI objSampleROI, int intROIStartX, int intROIStartY, int intImageIndex, int intPadIndex)//, bool blnPadPkg)
        {
            bool blnDebugImage = false;

            if (blnDebugImage)
                objSampleROI.SaveImage("D:\\TS\\objSampleROI.bmp"); // debug

            // Calculate start point from actual measurement package size. Fyi, objSampleROI size is not same as package size, but is PadROI Size
            float fPkgOffsetX = (objSampleROI.ref_ROIWidth - Math.Max(GetResultUpWidth_RectGauge4L(0), GetResultDownWidth_RectGauge4L(0))) / 2;
            float fPkgOffsetY = (objSampleROI.ref_ROIHeight - Math.Max(GetResultLeftHeight_RectGauge4L(0), GetResultRightHeight_RectGauge4L(0))) / 2;

            int intStartPixelFromEdgeX = (int)Math.Round(fPkgOffsetX + m_fPkgStartPixelFromLeft, 0, MidpointRounding.AwayFromZero);
            int intStartPixelFromEdgeY = (int)Math.Round(fPkgOffsetY + m_fPkgStartPixelFromEdge, 0, MidpointRounding.AwayFromZero);
            int intStartPixelFromEdgeX2 = (int)Math.Round(fPkgOffsetX + m_fPkgStartPixelFromRight, 0, MidpointRounding.AwayFromZero);
            int intStartPixelFromEdgeY2 = (int)Math.Round(fPkgOffsetY + m_fPkgStartPixelFromBottom, 0, MidpointRounding.AwayFromZero);

            ROI objCheckAreaSampleROI = new ROI();
            objCheckAreaSampleROI.AttachImage(objSampleROI);
            objCheckAreaSampleROI.LoadROISetting(intStartPixelFromEdgeX, intStartPixelFromEdgeY,
                objSampleROI.ref_ROIWidth - intStartPixelFromEdgeX - intStartPixelFromEdgeX2,
                objSampleROI.ref_ROIHeight - intStartPixelFromEdgeY - intStartPixelFromEdgeY2);

            //2020-01-09 ZJYEOH : Should subtract Dont care area with objCheckAreaSampleROI instead of objSampleROI
            //2019-09-23 ZJYEOH : Subtract tilt dont care area 
            if (intPadIndex == 1) // Top
            {
                ROI DontCareTop = new ROI();

                DontCareTop.LoadROISetting(0, 0, objCheckAreaSampleROI.ref_ROIWidth, objCheckAreaSampleROI.ref_ROIHeight);
                DontCareTop.AttachImage(m_ImgTilt_Top_L);
                EasyImage.Oper(EArithmeticLogicOperation.Subtract, objCheckAreaSampleROI.ref_ROI, DontCareTop.ref_ROI, objCheckAreaSampleROI.ref_ROI);
                DontCareTop.LoadROISetting(m_ImgTilt_Top_R.ref_intImageWidth - objCheckAreaSampleROI.ref_ROIWidth, 0, objCheckAreaSampleROI.ref_ROIWidth, objCheckAreaSampleROI.ref_ROIHeight);
                DontCareTop.AttachImage(m_ImgTilt_Top_R);
                EasyImage.Oper(EArithmeticLogicOperation.Subtract, objCheckAreaSampleROI.ref_ROI, DontCareTop.ref_ROI, objCheckAreaSampleROI.ref_ROI);
                if (blnDebugImage)
                    objCheckAreaSampleROI.SaveImage("D:\\TS\\IsImage1UnitBrightFieldPackageFailed_objCheckAreaSampleROITop.bmp");
                DontCareTop.Dispose();
            }
            if (intPadIndex == 2) // Right
            {
                ROI DontCareRight = new ROI();
                DontCareRight.LoadROISetting(m_ImgTilt_Top_R.ref_intImageWidth - objCheckAreaSampleROI.ref_ROIWidth, 0, objCheckAreaSampleROI.ref_ROIWidth, objCheckAreaSampleROI.ref_ROIHeight);
                DontCareRight.AttachImage(m_ImgTilt_Right_T);
                EasyImage.Oper(EArithmeticLogicOperation.Subtract, objCheckAreaSampleROI.ref_ROI, DontCareRight.ref_ROI, objCheckAreaSampleROI.ref_ROI);
                DontCareRight.LoadROISetting(m_ImgTilt_Top_R.ref_intImageWidth - objCheckAreaSampleROI.ref_ROIWidth, m_ImgTilt_Top_R.ref_intImageHeight - objCheckAreaSampleROI.ref_ROIHeight, objCheckAreaSampleROI.ref_ROIWidth, objCheckAreaSampleROI.ref_ROIHeight);
                DontCareRight.AttachImage(m_ImgTilt_Right_B);
                EasyImage.Oper(EArithmeticLogicOperation.Subtract, objCheckAreaSampleROI.ref_ROI, DontCareRight.ref_ROI, objCheckAreaSampleROI.ref_ROI);
                if (blnDebugImage)
                    objCheckAreaSampleROI.SaveImage("D:\\TS\\IsImage1UnitBrightFieldPackageFailed_objCheckAreaSampleROIRight.bmp");
                DontCareRight.Dispose();
            }
            if (intPadIndex == 3) // Bottom
            {
                ROI DontCareBottom = new ROI();

                DontCareBottom.LoadROISetting(0, m_ImgTilt_Top_R.ref_intImageHeight - objCheckAreaSampleROI.ref_ROIHeight, objCheckAreaSampleROI.ref_ROIWidth, objCheckAreaSampleROI.ref_ROIHeight);
                DontCareBottom.AttachImage(m_ImgTilt_Bottom_L);
                EasyImage.Oper(EArithmeticLogicOperation.Subtract, objCheckAreaSampleROI.ref_ROI, DontCareBottom.ref_ROI, objCheckAreaSampleROI.ref_ROI);
                DontCareBottom.LoadROISetting(m_ImgTilt_Top_R.ref_intImageWidth - objCheckAreaSampleROI.ref_ROIWidth, m_ImgTilt_Top_R.ref_intImageHeight - objCheckAreaSampleROI.ref_ROIHeight, objCheckAreaSampleROI.ref_ROIWidth, objCheckAreaSampleROI.ref_ROIHeight);
                DontCareBottom.AttachImage(m_ImgTilt_Bottom_R);
                EasyImage.Oper(EArithmeticLogicOperation.Subtract, objCheckAreaSampleROI.ref_ROI, DontCareBottom.ref_ROI, objCheckAreaSampleROI.ref_ROI);
                if (blnDebugImage)
                    objCheckAreaSampleROI.SaveImage("D:\\TS\\IsImage1UnitBrightFieldPackageFailed_objCheckAreaSampleROIBottom.bmp");
                DontCareBottom.Dispose();
            }
            if (intPadIndex == 4) // Left
            {
                ROI DontCareLeft = new ROI();

                DontCareLeft.LoadROISetting(0, 0, objCheckAreaSampleROI.ref_ROIWidth, objCheckAreaSampleROI.ref_ROIHeight);
                DontCareLeft.AttachImage(m_ImgTilt_Left_T);
                EasyImage.Oper(EArithmeticLogicOperation.Subtract, objCheckAreaSampleROI.ref_ROI, DontCareLeft.ref_ROI, objCheckAreaSampleROI.ref_ROI);
                DontCareLeft.LoadROISetting(0, m_ImgTilt_Top_R.ref_intImageHeight - objCheckAreaSampleROI.ref_ROIHeight, objCheckAreaSampleROI.ref_ROIWidth, objCheckAreaSampleROI.ref_ROIHeight);
                DontCareLeft.AttachImage(m_ImgTilt_Left_B);
                EasyImage.Oper(EArithmeticLogicOperation.Subtract, objCheckAreaSampleROI.ref_ROI, DontCareLeft.ref_ROI, objCheckAreaSampleROI.ref_ROI);
                if (blnDebugImage)
                    objCheckAreaSampleROI.SaveImage("D:\\TS\\IsImage1UnitBrightFieldPackageFailed_objCheckAreaSampleROILeft.bmp");
                DontCareLeft.Dispose();
            }

            if (blnDebugImage)
                objCheckAreaSampleROI.SaveImage("D:\\TS\\objCheckAreaSampleROI.bmp");   // debug
            int intSelectedObjectNum = 0;

            switch (intImageIndex)
            {
                case 1: // Image 1 (Grab 1 & Grab 2 Merged)
                    {
                        intSelectedObjectNum = m_objImage1SurfaceEBlobs.BuildObjects_Filter_GetElement(objCheckAreaSampleROI, false, true, 0, 125,
              m_intBrightFieldMinArea, 999999, false, 0xEF);// 0x0D);

                    }
                    break;
                case 2: // Image 2 (Grab 3)
                    {
                        intSelectedObjectNum = m_objImage1SurfaceEBlobs.BuildObjects_Filter_GetElement(objCheckAreaSampleROI, false, true, 0, 125,
             m_intDarkFieldMinArea, 999999, false, 0xEF);// 0x0D);

                    }
                    break;
                case 3: // Image 5 (Grab 5) // 2020-01-09 ZJYEOH : Changed case 4 to 3 
                    {
                        intSelectedObjectNum = m_objImage1SurfaceEBlobs.BuildObjects_Filter_GetElement(objCheckAreaSampleROI, false, true, 0, 125,
             m_intDarkFieldMinArea, 999999, false, 0xEF);// 0x0D);

                    }
                    break;
            }

            if (blnDebugImage)
                objCheckAreaSampleROI.SaveImage("D:\\TS\\objCheckAreaSampleROI.bmp");   // debug

            bool blnOverallResult = true;
            if (intSelectedObjectNum > 0)
            {
                List<List<System.Windows.Point>> arr2DPoints = new List<List<System.Windows.Point>>();
                List<List<PointF>> arrRotatedPoints = new List<List<PointF>>();
                List<float> fObjectHeightList = new List<float>(), fObjectWidthList = new List<float>(), fObjectCenterXList = new List<float>(), fObjectCenterYList = new List<float>(), fObjectAngleList = new List<float>();
                List<float> fObjectLimitHeightList = new List<float>(), fObjectLimitWidthList = new List<float>(), fObjectLimitCenterXList = new List<float>(), fObjectLimitCenterYList = new List<float>();
                List<int> fObjectAreaList = new List<int>(), fObjectAreaList2 = new List<int>();
                float fCenterX = 0, fCenterY = 0, fWidth = 0, fHeight = 0;
                float fStartX, fStartY, fEndX, fEndY, fAngle = 0;
                int intArea = 0;
                float fWidthMM, fHeightMM, fAreaInMM;
                int intFailCount = 0;
                int intTolerance = m_intBrightDefectLinkTolerance;
                int intTotalArea = 0;
                for (int i = 0; i < intSelectedObjectNum; i++)
                {
                    arrRotatedPoints.Add(new List<PointF>());
                    arr2DPoints.Add(new List<System.Windows.Point>());
                    intArea = m_objImage1SurfaceEBlobs.ref_arrArea[i];
                    //fHeight = m_objImage1SurfaceEBlobs.ref_arrHeight[i];
                    //fWidth = m_objImage1SurfaceEBlobs.ref_arrWidth[i];
                    //fCenterX = m_objImage1SurfaceEBlobs.ref_arrLimitCenterX[i];
                    //fCenterY = m_objImage1SurfaceEBlobs.ref_arrLimitCenterY[i];

                    if (m_objImage1SurfaceEBlobs.ref_arrRectWidth[i] < m_objImage1SurfaceEBlobs.ref_arrRectHeight[i])
                    {
                        fWidth = m_objImage1SurfaceEBlobs.ref_arrRectWidth[i];
                        fHeight = m_objImage1SurfaceEBlobs.ref_arrRectHeight[i];

                        fAngle = m_objImage1SurfaceEBlobs.ref_arrRectAngle[i];

                        //if (fAngle < 0)
                        //    fAngle = -Math.Abs(fAngle);
                        //else
                        //    fAngle = -fAngle;
                    }
                    else
                    {
                        fWidth = m_objImage1SurfaceEBlobs.ref_arrRectHeight[i];
                        fHeight = m_objImage1SurfaceEBlobs.ref_arrRectWidth[i];

                        fAngle = m_objImage1SurfaceEBlobs.ref_arrRectAngle[i];

                        //if (fAngle < 0)
                        //    fAngle = Math.Abs(fAngle);
                        //else
                        //    fAngle = 90 - (fAngle);

                        if (fAngle >= 10)//&& fAngle <= 80)
                            fAngle = m_objImage1SurfaceEBlobs.ref_arrRectAngle[i] - 90;
                        else
                            fAngle = 90 + m_objImage1SurfaceEBlobs.ref_arrRectAngle[i];

                    }
                    fCenterX = m_objImage1SurfaceEBlobs.ref_arrRectLimitCenterX[i];
                    fCenterY = m_objImage1SurfaceEBlobs.ref_arrRectLimitCenterY[i];


                    intTotalArea += intArea;
                    fCenterX += intStartPixelFromEdgeX;
                    fCenterY += intStartPixelFromEdgeY;
                    //fStartX = (float)Math.Floor(fCenterX - (fWidth / 2));
                    //fStartY = (float)Math.Floor(fCenterY - (fHeight / 2));
                    //fEndX = (float)Math.Ceiling(fCenterX + (fWidth / 2));
                    //fEndY = (float)Math.Ceiling(fCenterY + (fHeight / 2));

                    float newX1 = 0, newY1 = 0;  // new point 1
                    float newX2 = 0, newY2 = 0; // new point 2
                    float newX3 = 0, newY3 = 0; // new point 3
                    float newX4 = 0, newY4 = 0; // new point 4

                    //2020-12-18 ZJYEOH : Change to this format
                    //  Point 1 *-------------* Point 2
                    //          |             |
                    //          |             |
                    //          |             |
                    //  Point 4 *-------------* Point 3

                    Math2.RotateWithAngleAccordingToReferencePoint(fCenterX, fCenterY, (fCenterX - (fWidth / 2)), (fCenterY - (fHeight / 2)), fAngle, ref newX1, ref newY1);
                    Math2.RotateWithAngleAccordingToReferencePoint(fCenterX, fCenterY, (fCenterX + (fWidth / 2)), (fCenterY - (fHeight / 2)), fAngle, ref newX2, ref newY2);
                    Math2.RotateWithAngleAccordingToReferencePoint(fCenterX, fCenterY, (fCenterX + (fWidth / 2)), (fCenterY + (fHeight / 2)), fAngle, ref newX3, ref newY3);
                    Math2.RotateWithAngleAccordingToReferencePoint(fCenterX, fCenterY, (fCenterX - (fWidth / 2)), (fCenterY + (fHeight / 2)), fAngle, ref newX4, ref newY4);


                    arrRotatedPoints[i].Add(new PointF(newX1, newY1));
                    arrRotatedPoints[i].Add(new PointF(newX2, newY2));
                    arrRotatedPoints[i].Add(new PointF(newX3, newY3));
                    arrRotatedPoints[i].Add(new PointF(newX4, newY4));

                    Math2.RotateWithAngleAccordingToReferencePoint(fCenterX, fCenterY, (fCenterX - (fWidth / 2)) - intTolerance, (fCenterY - (fHeight / 2)) - intTolerance, fAngle, ref newX1, ref newY1);
                    Math2.RotateWithAngleAccordingToReferencePoint(fCenterX, fCenterY, (fCenterX + (fWidth / 2)) + intTolerance, (fCenterY - (fHeight / 2)) - intTolerance, fAngle, ref newX2, ref newY2);
                    Math2.RotateWithAngleAccordingToReferencePoint(fCenterX, fCenterY, (fCenterX + (fWidth / 2)) + intTolerance, (fCenterY + (fHeight / 2)) + intTolerance, fAngle, ref newX3, ref newY3);
                    Math2.RotateWithAngleAccordingToReferencePoint(fCenterX, fCenterY, (fCenterX - (fWidth / 2)) - intTolerance, (fCenterY + (fHeight / 2)) + intTolerance, fAngle, ref newX4, ref newY4);

                    arr2DPoints[i].Add(new System.Windows.Point(newX1, newY1));
                    arr2DPoints[i].Add(new System.Windows.Point(newX2, newY2));
                    arr2DPoints[i].Add(new System.Windows.Point(newX3, newY3));
                    arr2DPoints[i].Add(new System.Windows.Point(newX4, newY4));

                    fObjectHeightList.Add(fHeight);
                    fObjectWidthList.Add(fWidth);
                    fObjectCenterXList.Add(fCenterX);
                    fObjectCenterYList.Add(fCenterY);
                    fObjectAngleList.Add(fAngle);
                    fObjectAreaList.Add(intArea);
                    fObjectAreaList2.Add(intArea);

                }
                int intAngleTolerance = 10;
                bool blnDecrement = false;
                if (intTolerance >= 0)
                {
                    for (int i = 0; i < fObjectHeightList.Count; i++)
                    {
                        if (blnDecrement)
                        {
                            blnDecrement = false;
                            if (i > 0)
                                i--;
                        }
                        for (int j = 0; j < fObjectHeightList.Count; j++)
                        {
                            if (i != j && i < fObjectHeightList.Count && j < fObjectHeightList.Count)
                            {
                                if (Intersection.CheckRectRectIntersection(arr2DPoints[i].ToArray(), arr2DPoints[j].ToArray(), intTolerance))
                                {

                                    PointF[] arrPoints = new PointF[8];

                                    arrPoints[0] = arrRotatedPoints[i][0];
                                    arrPoints[1] = arrRotatedPoints[i][1];
                                    arrPoints[2] = arrRotatedPoints[i][2];
                                    arrPoints[3] = arrRotatedPoints[i][3];
                                    arrPoints[4] = arrRotatedPoints[j][0];
                                    arrPoints[5] = arrRotatedPoints[j][1];
                                    arrPoints[6] = arrRotatedPoints[j][2];
                                    arrPoints[7] = arrRotatedPoints[j][3];

                                    float fMinAngle = 0;
                                    List<PointF> arrMinRect = new List<PointF>();
                                    arrMinRect = MinimumBoundingBox.CalculateMinimumBoundingBox(arrPoints, ref fMinAngle);
                                    //fObjectAngleList[i] = 90 + fMinAngle;
                                    if (fMinAngle < 0)
                                        fObjectAngleList[i] = -(90 + fMinAngle);
                                    else
                                        fObjectAngleList[i] = 90 - fMinAngle;

                                    //if (fMinAngle < 0)
                                    //    fObjectAngleList[i] = -(90 + fMinAngle);
                                    //else
                                    //    fObjectAngleList[i] = 90 - fMinAngle;

                                    Line onjLine1 = new Line();
                                    Line onjLine2 = new Line();
                                    onjLine1.CalculateStraightLine(arrMinRect[0], arrMinRect[2]);
                                    onjLine2.CalculateStraightLine(arrMinRect[1], arrMinRect[3]);
                                    PointF pCenter = Line.GetCrossPoint(onjLine1, onjLine2);
                                    float p1X = 0, p1Y = 0;
                                    float p2X = 0, p2Y = 0;
                                    float p3X = 0, p3Y = 0;
                                    float p4X = 0, p4Y = 0;
                                    Math2.RotateWithAngleAccordingToReferencePoint(pCenter.X, pCenter.Y, arrMinRect[0].X, arrMinRect[0].Y, -fObjectAngleList[i], ref p1X, ref p1Y);
                                    Math2.RotateWithAngleAccordingToReferencePoint(pCenter.X, pCenter.Y, arrMinRect[1].X, arrMinRect[1].Y, -fObjectAngleList[i], ref p2X, ref p2Y);
                                    Math2.RotateWithAngleAccordingToReferencePoint(pCenter.X, pCenter.Y, arrMinRect[2].X, arrMinRect[2].Y, -fObjectAngleList[i], ref p3X, ref p3Y);
                                    Math2.RotateWithAngleAccordingToReferencePoint(pCenter.X, pCenter.Y, arrMinRect[3].X, arrMinRect[3].Y, -fObjectAngleList[i], ref p4X, ref p4Y);

                                    float pR1X = 0, pR1Y = 0;
                                    float pR2X = 0, pR2Y = 0;
                                    float pR3X = 0, pR3Y = 0;
                                    float pR4X = 0, pR4Y = 0;
                                    Math2.RotateWithAngleAccordingToReferencePoint(pCenter.X, pCenter.Y, Math.Min(Math.Min(p1X, p2X), Math.Min(p3X, p4X)), Math.Min(Math.Min(p1Y, p2Y), Math.Min(p3Y, p4Y)), fObjectAngleList[i], ref pR1X, ref pR1Y); // Top Left
                                    Math2.RotateWithAngleAccordingToReferencePoint(pCenter.X, pCenter.Y, Math.Max(Math.Max(p1X, p2X), Math.Max(p3X, p4X)), Math.Min(Math.Min(p1Y, p2Y), Math.Min(p3Y, p4Y)), fObjectAngleList[i], ref pR2X, ref pR2Y); // Top Right
                                    Math2.RotateWithAngleAccordingToReferencePoint(pCenter.X, pCenter.Y, Math.Max(Math.Max(p1X, p2X), Math.Max(p3X, p4X)), Math.Max(Math.Max(p1Y, p2Y), Math.Max(p3Y, p4Y)), fObjectAngleList[i], ref pR3X, ref pR3Y); // Bottom Right
                                    Math2.RotateWithAngleAccordingToReferencePoint(pCenter.X, pCenter.Y, Math.Min(Math.Min(p1X, p2X), Math.Min(p3X, p4X)), Math.Max(Math.Max(p1Y, p2Y), Math.Max(p3Y, p4Y)), fObjectAngleList[i], ref pR4X, ref pR4Y); // Bottom Left
                                    arrMinRect[0] = new PointF(pR1X, pR1Y);
                                    arrMinRect[1] = new PointF(pR2X, pR2Y);
                                    arrMinRect[2] = new PointF(pR3X, pR3Y);
                                    arrMinRect[3] = new PointF(pR4X, pR4Y);

                                    arrRotatedPoints[i][0] = arrMinRect[0];
                                    arrRotatedPoints[i][1] = arrMinRect[1];
                                    arrRotatedPoints[i][2] = arrMinRect[2];
                                    arrRotatedPoints[i][3] = arrMinRect[3];

                                    Math2.RotateWithAngleAccordingToReferencePoint(pCenter.X, pCenter.Y, Math.Min(Math.Min(p1X, p2X), Math.Min(p3X, p4X)) - intTolerance, Math.Min(Math.Min(p1Y, p2Y), Math.Min(p3Y, p4Y)) - intTolerance, fObjectAngleList[i], ref pR1X, ref pR1Y); // Top Left
                                    Math2.RotateWithAngleAccordingToReferencePoint(pCenter.X, pCenter.Y, Math.Max(Math.Max(p1X, p2X), Math.Max(p3X, p4X)) + intTolerance, Math.Min(Math.Min(p1Y, p2Y), Math.Min(p3Y, p4Y)) - intTolerance, fObjectAngleList[i], ref pR2X, ref pR2Y); // Top Right
                                    Math2.RotateWithAngleAccordingToReferencePoint(pCenter.X, pCenter.Y, Math.Max(Math.Max(p1X, p2X), Math.Max(p3X, p4X)) + intTolerance, Math.Max(Math.Max(p1Y, p2Y), Math.Max(p3Y, p4Y)) + intTolerance, fObjectAngleList[i], ref pR3X, ref pR3Y); // Bottom Right
                                    Math2.RotateWithAngleAccordingToReferencePoint(pCenter.X, pCenter.Y, Math.Min(Math.Min(p1X, p2X), Math.Min(p3X, p4X)) - intTolerance, Math.Max(Math.Max(p1Y, p2Y), Math.Max(p3Y, p4Y)) + intTolerance, fObjectAngleList[i], ref pR4X, ref pR4Y); // Bottom Left

                                    arr2DPoints[i][0] = new System.Windows.Point(pR1X, pR1Y);
                                    arr2DPoints[i][1] = new System.Windows.Point(pR2X, pR2Y);
                                    arr2DPoints[i][2] = new System.Windows.Point(pR3X, pR3Y);
                                    arr2DPoints[i][3] = new System.Windows.Point(pR4X, pR4Y);

                                    arrRotatedPoints.RemoveAt(j);
                                    arr2DPoints.RemoveAt(j);

                                    float fDiffX = Math.Max(Math.Abs(p1X - p4X), Math.Abs(p2X - p3X));
                                    float fDiffY = Math.Max(Math.Abs(p3Y - p4Y), Math.Abs(p2Y - p1Y));

                                    fObjectWidthList[i] = fDiffX;
                                    fObjectHeightList[i] = fDiffY;

                                    fObjectCenterXList[i] = pCenter.X;
                                    fObjectCenterYList[i] = pCenter.Y;

                                    fObjectAreaList2.RemoveAt(j);
                                    fObjectAreaList[i] = fObjectAreaList[i] + fObjectAreaList[j];

                                    fObjectHeightList.RemoveAt(j);
                                    fObjectWidthList.RemoveAt(j);
                                    fObjectCenterXList.RemoveAt(j);
                                    fObjectCenterYList.RemoveAt(j);
                                    fObjectAngleList.RemoveAt(j);
                                    fObjectAreaList.RemoveAt(j);

                                    if (j > 0)
                                        j = -1;
                                    if (i > 0)
                                    {
                                        i = 0;
                                    }
                                    else
                                        blnDecrement = true;

                                }

                            }
                        }
                    }
                }
                for (int i = 0; i < fObjectHeightList.Count; i++)
                {
                    if (fObjectHeightList[i] < fObjectWidthList[i])
                    {
                        float fObjectWidth = fObjectHeightList[i];
                        float fObjectHeight = fObjectWidthList[i];

                        float fObjectAngle = fObjectAngleList[i];

                        if (fObjectAngle >= 10)//&& fAngle <= 80)
                            fObjectAngle = fObjectAngleList[i] - 90;
                        else
                            fObjectAngle = 90 + fObjectAngleList[i];

                        fObjectWidthList[i] = fObjectWidth;
                        fObjectHeightList[i] = fObjectHeight;
                        fObjectAngleList[i] = fObjectAngle;
                    }
                    else
                    {
                        float fObjectHeight = fObjectHeightList[i];
                        float fObjectWidth = fObjectWidthList[i];

                        float fObjectAngle = fObjectAngleList[i];

                        fObjectWidthList[i] = fObjectWidth;
                        fObjectHeightList[i] = fObjectHeight;
                        fObjectAngleList[i] = fObjectAngle;
                    }

                    // convert width and height to mm
                    //fWidthMM = fWidth / m_fMMToPixelXValue;
                    //fHeightMM = fHeight / m_fMMToPixelYValue; // 11-04-2019 ZJYEOH : Changed m_fMMToPixelXValue to m_fMMToPixelYValue
                    //fAreaInMM = intArea / m_fMMToPixelXValue / m_fMMToPixelYValue;
                    fWidthMM = fObjectWidthList[i] / m_fMMToPixelXValue;
                    fHeightMM = fObjectHeightList[i] / m_fMMToPixelYValue;
                    fAreaInMM = fObjectAreaList[i] / (m_fMMToPixelXValue * m_fMMToPixelYValue);

                    //if ((fWidthMM > m_fScratchLength) || (fHeightMM > m_fScratchLength) || (fAreaInMM > m_fScratchArea) &&
                    //    ((m_intFailPkgOptionMask & 0x08) > 0 || (m_intFailPkgOptionMask & 0x1000) > 0))
                    {
                        intFailCount++;
                        //0x04
                        m_intFailPkgResultMask |= 0x10000; // Fail image 1 surface contamination

                        Defect objDefect = new Defect();

                        objDefect.ref_strName = "Bright";
                        objDefect.ref_intFailMask = 0x10000;
                        objDefect.ref_fCenterX = intROIStartX + fObjectCenterXList[i];
                        objDefect.ref_fCenterY = intROIStartY + fObjectCenterYList[i];
                        objDefect.ref_fStartX = intROIStartX + (float)Math.Floor(fObjectCenterXList[i] - (fObjectWidthList[i] / 2));
                        objDefect.ref_fStartY = intROIStartY + (float)Math.Floor(fObjectCenterYList[i] - (fObjectHeightList[i] / 2));
                        objDefect.ref_fEndX = intROIStartX + (float)Math.Ceiling(fObjectCenterXList[i] + (fObjectWidthList[i] / 2));
                        objDefect.ref_fEndY = intROIStartY + (float)Math.Ceiling(fObjectCenterYList[i] + (fObjectHeightList[i] / 2));
                        objDefect.ref_fWidth = fObjectWidthList[i];
                        objDefect.ref_fHeight = fObjectHeightList[i];
                        objDefect.ref_fArea = fObjectAreaList[i];
                        objDefect.ref_fAngle = fObjectAngleList[i];
                        objDefect.ref_fWidthInMM = fWidthMM;
                        objDefect.ref_fHeightInMM = fHeightMM;
                        objDefect.ref_fAreaInMM2 = fAreaInMM;
                        objDefect.ref_intImageNo = intImageIndex; //2020-01-09 ZJYEOH : Should not fixed to 1

                        if ((m_intFailPkgOptionMask & 0x20000) > 0)
                        {
                            if (m_intBrightDefectDimensionFailCondition == 0)
                            {
                                if (fWidthMM > m_fBrightWidth)
                                {
                                    blnOverallResult = false;
                                    objDefect.ref_fWidthFailValue = fWidthMM;
                                    objDefect.ref_intFailCriteria |= 0x01;
                                }
                                if (fHeightMM > m_fBrightLength)
                                {
                                    blnOverallResult = false;
                                    objDefect.ref_fHeightFailValue = fHeightMM;
                                    objDefect.ref_intFailCriteria |= 0x02;
                                }
                            }
                            else
                            {
                                if ((fWidthMM > m_fBrightWidth) && (fHeightMM > m_fBrightLength))
                                {
                                    blnOverallResult = false;
                                    objDefect.ref_fWidthFailValue = fWidthMM;
                                    objDefect.ref_intFailCriteria |= 0x01;
                                    objDefect.ref_fHeightFailValue = fHeightMM;
                                    objDefect.ref_intFailCriteria |= 0x02;
                                }
                            }
                        }

                        if ((m_intFailPkgOptionMask & 0x10000) > 0)
                        {
                            if (fAreaInMM > m_fBrightArea)
                            {
                                blnOverallResult = false;
                                objDefect.ref_fAreaFailValue = fAreaInMM;
                                objDefect.ref_intFailCriteria |= 0x04;
                            }
                        }

                        m_arrPkgDefectList.Add(objDefect);
                    }

                }

                if ((m_intFailPkgOptionMask & 0x10000) > 0)
                {
                    fAreaInMM = intTotalArea / (m_fMMToPixelXValue * m_fMMToPixelYValue);

                    if (fAreaInMM > m_fBrightTotalArea)
                    {
                        Defect objDefect = new Defect();

                        objDefect.ref_strName = "Total Bright";
                        objDefect.ref_intFailMask = 0x10000;
                        objDefect.ref_fCenterX = -1;
                        objDefect.ref_fCenterY = -1;
                        objDefect.ref_fStartX = -1;
                        objDefect.ref_fStartY = -1;
                        objDefect.ref_fEndX = -1;
                        objDefect.ref_fEndY = -1;
                        objDefect.ref_fWidth = -1;
                        objDefect.ref_fHeight = -1;
                        objDefect.ref_fArea = intTotalArea;
                        objDefect.ref_fWidthInMM = -1;
                        objDefect.ref_fHeightInMM = -1;
                        objDefect.ref_fAreaInMM2 = fAreaInMM;
                        objDefect.ref_intImageNo = intImageIndex; //2020-01-09 ZJYEOH : Should not fixed to 1

                        blnOverallResult = false;
                        objDefect.ref_fAreaFailValue = fAreaInMM;
                        objDefect.ref_intFailCriteria |= 0x08;

                        m_arrPkgDefectList.Add(objDefect);

                        Defect objDefect2 = new Defect();
                        for (int a = 0; a < m_arrPkgDefectList.Count; a++)
                        {
                            objDefect2 = m_arrPkgDefectList[a];
                            if (objDefect2.ref_strName.Contains("Bright"))
                            {
                                objDefect2.ref_blnFailTotalArea = true;
                                m_arrPkgDefectList[a] = objDefect2;
                            }
                        }

                        m_intFailPkgResultMask |= 0x80000; // Fail image 1 surface total bright field

                        // Collect total extra pad for display error message
                        m_fResultBrightFieldTotalArea = fAreaInMM;
                    }
                }
            }

            objCheckAreaSampleROI.Dispose();
            return blnOverallResult;
        }
        private bool IsImage2UnitDarkFieldPackageFailed(ROI objSampleROI, int intROIStartX, int intROIStartY, int intImageIndex)//, bool blnPadPkg)
        {
            bool blnDebugImage = false;

            if (blnDebugImage)
                objSampleROI.SaveImage("D:\\TS\\objSampleROI.bmp"); // debug

            // Calculate start point from actual measurement package size. Fyi, objSampleROI size is not same as package size, but is PadROI Size
            float fPkgOffsetX = (objSampleROI.ref_ROIWidth - Math.Max(GetResultUpWidth_RectGauge4L(0), GetResultDownWidth_RectGauge4L(0))) / 2;
            float fPkgOffsetY = (objSampleROI.ref_ROIHeight - Math.Max(GetResultLeftHeight_RectGauge4L(0), GetResultRightHeight_RectGauge4L(0))) / 2;

            float fROIToleranceLeft = 0, fROIToleranceTop = 0, fROIToleranceRight = 0, fROIToleranceBottom = 0;
            if (m_blnSeperateBrightDarkROITolerance)
            {
                fROIToleranceLeft = m_fPkgStartPixelFromLeft_Dark;
                fROIToleranceTop = m_fPkgStartPixelFromEdge_Dark;
                fROIToleranceRight = m_fPkgStartPixelFromRight_Dark;
                fROIToleranceBottom = m_fPkgStartPixelFromBottom_Dark;
            }
            else
            {
                fROIToleranceLeft = m_fPkgStartPixelFromLeft;
                fROIToleranceTop = m_fPkgStartPixelFromEdge;
                fROIToleranceRight = m_fPkgStartPixelFromRight;
                fROIToleranceBottom = m_fPkgStartPixelFromBottom;
            }

            int intStartPixelFromEdgeX = (int)Math.Round(fPkgOffsetX + fROIToleranceLeft, 0, MidpointRounding.AwayFromZero);
            int intStartPixelFromEdgeY = (int)Math.Round(fPkgOffsetY + fROIToleranceTop, 0, MidpointRounding.AwayFromZero);
            int intStartPixelFromEdgeX2 = (int)Math.Round(fPkgOffsetX + fROIToleranceRight, 0, MidpointRounding.AwayFromZero);
            int intStartPixelFromEdgeY2 = (int)Math.Round(fPkgOffsetY + fROIToleranceBottom, 0, MidpointRounding.AwayFromZero);

            ROI objCheckAreaSampleROI = new ROI();
            objCheckAreaSampleROI.AttachImage(objSampleROI);
            objCheckAreaSampleROI.LoadROISetting(intStartPixelFromEdgeX, intStartPixelFromEdgeY,
                objSampleROI.ref_ROIWidth - intStartPixelFromEdgeX - intStartPixelFromEdgeX2,
                objSampleROI.ref_ROIHeight - intStartPixelFromEdgeY - intStartPixelFromEdgeY2);

            if (blnDebugImage)
                objCheckAreaSampleROI.SaveImage("D:\\objCheckAreaSampleROI.bmp");   // debug
            int intSelectedObjectNum = 0;

            switch (intImageIndex)
            {
                case 1: // Image 1 (Grab 1 & Grab 2 Merged)
                    {
                        intSelectedObjectNum = m_objImage2SurfaceEBlobs.BuildObjects_Filter_GetElement(objCheckAreaSampleROI, false, true, 0, 125,
                                                m_intBrightFieldMinArea, 999999, false, 0xEF);// 0x0D);

                    }
                    break;
                case 2: // Image 2 (Grab 3)
                    {
                        intSelectedObjectNum = m_objImage2SurfaceEBlobs.BuildObjects_Filter_GetElement(objCheckAreaSampleROI, false, true, 0, 125,
                                                m_intDarkFieldMinArea, 999999, false, 0xEF);// 0x0D);

                    }
                    break;
                case 3: // Image 5 (Grab 5) // 2020-01-09 ZJYEOH : Changed case 4 to 3 
                    {
                        intSelectedObjectNum = m_objImage2SurfaceEBlobs.BuildObjects_Filter_GetElement(objCheckAreaSampleROI, false, true, 0, 125,
                                                m_intDarkFieldMinArea, 999999, false, 0xEF);// 0x0D);

                    }
                    break;
            }

            if (blnDebugImage)
                objCheckAreaSampleROI.SaveImage("D:\\TS\\objCheckAreaSampleROI.bmp");   // debug

            bool blnOverallResult = true;
            if (intSelectedObjectNum > 0)
            {
                float fCenterX = 0, fCenterY = 0, fWidth = 0, fHeight = 0;
                float fStartX, fStartY, fEndX, fEndY, fAngle = 0;
                int intArea = 0;
                float fWidthMM, fHeightMM, fAreaInMM;
                int intFailCount = 0;

                int intTotalArea = 0;
                for (int i = 0; i < intSelectedObjectNum; i++)
                {
                    intArea = m_objImage2SurfaceEBlobs.ref_arrArea[i];
                    if (m_objImage2SurfaceEBlobs.ref_arrRectWidth[i] < m_objImage2SurfaceEBlobs.ref_arrRectHeight[i])
                    {
                        fWidth = m_objImage2SurfaceEBlobs.ref_arrRectWidth[i];
                        fHeight = m_objImage2SurfaceEBlobs.ref_arrRectHeight[i];

                        fAngle = m_objImage2SurfaceEBlobs.ref_arrRectAngle[i];
                        
                        //if (fAngle < 0)
                        //    fAngle = -Math.Abs(fAngle);
                        //else
                        //    fAngle = -fAngle;
                    }
                    else
                    {
                        fWidth = m_objImage2SurfaceEBlobs.ref_arrRectHeight[i];
                        fHeight = m_objImage2SurfaceEBlobs.ref_arrRectWidth[i];

                        fAngle = m_objImage2SurfaceEBlobs.ref_arrRectAngle[i];

                        //if (fAngle < 0)
                        //    fAngle = Math.Abs(fAngle);
                        //else
                        //    fAngle = 90 - (fAngle);

                        if (fAngle >= 10)//&& fAngle <= 80)
                            fAngle = m_objImage2SurfaceEBlobs.ref_arrRectAngle[i] - 90;
                        else
                            fAngle = 90 + m_objImage2SurfaceEBlobs.ref_arrRectAngle[i];

                    }
                    fCenterX = m_objImage2SurfaceEBlobs.ref_arrRectLimitCenterX[i];
                    fCenterY = m_objImage2SurfaceEBlobs.ref_arrRectLimitCenterY[i];

                    intTotalArea += intArea;
                    fCenterX += intStartPixelFromEdgeX;
                    fCenterY += intStartPixelFromEdgeY;
                    fStartX = (float)Math.Floor(fCenterX - (fWidth / 2));
                    fStartY = (float)Math.Floor(fCenterY - (fHeight / 2));
                    fEndX = (float)Math.Ceiling(fCenterX + (fWidth / 2));
                    fEndY = (float)Math.Ceiling(fCenterY + (fHeight / 2));

                    // convert width and height to mm
                    fWidthMM = fWidth / m_fMMToPixelXValue;
                    fHeightMM = fHeight / m_fMMToPixelYValue; // 11-04-2019 ZJYEOH : Changed m_fMMToPixelXValue to m_fMMToPixelYValue
                    fAreaInMM = intArea / m_fMMToPixelXValue / m_fMMToPixelYValue;

                    //if ((fWidthMM > m_fScratchLength) || (fHeightMM > m_fScratchLength) || (fAreaInMM > m_fScratchArea) &&
                    //    ((m_intFailPkgOptionMask & 0x08) > 0 || (m_intFailPkgOptionMask & 0x1000) > 0))
                    {
                        intFailCount++;
                        //0x04
                        m_intFailPkgResultMask |= 0x20000; // Fail image 1 surface contamination

                        Defect objDefect = new Defect();

                        objDefect.ref_strName = "Dark";
                        objDefect.ref_intFailMask = 0x20000;
                        objDefect.ref_fCenterX = intROIStartX + fCenterX;
                        objDefect.ref_fCenterY = intROIStartY + fCenterY;
                        objDefect.ref_fStartX = intROIStartX + fStartX;
                        objDefect.ref_fStartY = intROIStartY + fStartY;
                        objDefect.ref_fEndX = intROIStartX + fEndX;
                        objDefect.ref_fEndY = intROIStartY + fEndY;
                        objDefect.ref_fWidth = fWidth;
                        objDefect.ref_fHeight = fHeight;
                        objDefect.ref_fArea = intArea;
                        objDefect.ref_fAngle = fAngle; // 2019-10-09 ZJYEOH : Need to add angle, if no add, defect in drawing will always draw 0 degree only
                        objDefect.ref_fWidthInMM = fWidthMM;
                        objDefect.ref_fHeightInMM = fHeightMM;
                        objDefect.ref_fAreaInMM2 = fAreaInMM;
                        objDefect.ref_intImageNo = intImageIndex; //2020-01-09 ZJYEOH : Should not fixed to 1

                        if ((m_intFailPkgOptionMask & 0x80000) > 0)
                        {
                            if (m_intDarkDefectDimensionFailCondition == 0)
                            {
                                if (fWidthMM > m_fDarkWidth)
                                {
                                    blnOverallResult = false;
                                    objDefect.ref_fWidthFailValue = fWidthMM;
                                    objDefect.ref_intFailCriteria |= 0x01;
                                }
                                if (fHeightMM > m_fDarkLength)
                                {
                                    blnOverallResult = false;
                                    objDefect.ref_fHeightFailValue = fHeightMM;
                                    objDefect.ref_intFailCriteria |= 0x02;
                                }
                            }
                            else
                            {
                                if ((fWidthMM > m_fDarkWidth) && (fHeightMM > m_fDarkLength))
                                {
                                    blnOverallResult = false;
                                    objDefect.ref_fWidthFailValue = fWidthMM;
                                    objDefect.ref_intFailCriteria |= 0x01;
                                    objDefect.ref_fHeightFailValue = fHeightMM;
                                    objDefect.ref_intFailCriteria |= 0x02;
                                }
                            }
                        }

                        if ((m_intFailPkgOptionMask & 0x40000) > 0)
                        {
                            if (fAreaInMM > m_fDarkArea)
                            {
                                blnOverallResult = false;
                                objDefect.ref_fAreaFailValue = fAreaInMM;
                                objDefect.ref_intFailCriteria |= 0x04;
                            }
                        }

                        m_arrPkgDefectList.Add(objDefect);
                    }

                }

                if ((m_intFailPkgOptionMask & 0x40000) > 0)
                {
                    fAreaInMM = intTotalArea / m_fMMToPixelXValue / m_fMMToPixelYValue;

                    if (fAreaInMM > m_fDarkTotalArea)
                    {
                        Defect objDefect = new Defect();

                        objDefect.ref_strName = "Total Dark";
                        objDefect.ref_intFailMask = 0x20000;
                        objDefect.ref_fCenterX = -1;
                        objDefect.ref_fCenterY = -1;
                        objDefect.ref_fStartX = -1;
                        objDefect.ref_fStartY = -1;
                        objDefect.ref_fEndX = -1;
                        objDefect.ref_fEndY = -1;
                        objDefect.ref_fWidth = -1;
                        objDefect.ref_fHeight = -1;
                        objDefect.ref_fArea = intTotalArea;
                        objDefect.ref_fWidthInMM = -1;
                        objDefect.ref_fHeightInMM = -1;
                        objDefect.ref_fAreaInMM2 = fAreaInMM;
                        objDefect.ref_intImageNo = intImageIndex;

                        blnOverallResult = false;
                        objDefect.ref_fAreaFailValue = fAreaInMM;
                        objDefect.ref_intFailCriteria |= 0x08;

                        m_arrPkgDefectList.Add(objDefect);

                        Defect objDefect2 = new Defect();
                        for (int a = 0; a < m_arrPkgDefectList.Count; a++)
                        {
                            objDefect2 = m_arrPkgDefectList[a];
                            if (objDefect2.ref_strName.Contains("Dark"))
                            {
                                objDefect2.ref_blnFailTotalArea = true;
                                m_arrPkgDefectList[a] = objDefect2;
                            }
                        }

                        m_intFailPkgResultMask |= 0x20000; // Fail image 1 surface total dark field

                        // Collect total extra pad for display error message
                        m_fResultDarkFieldTotalArea = fAreaInMM;
                    }
                }
            }

            objCheckAreaSampleROI.Dispose();
            return blnOverallResult;
        }
        private bool IsImage2UnitDarkFieldPackageFailed_WithLinkFunction(ROI objSampleROI, int intROIStartX, int intROIStartY, int intImageIndex)//, bool blnPadPkg)
        {
            bool blnDebugImage = false;

            if (blnDebugImage)
                objSampleROI.SaveImage("D:\\TS\\objSampleROI.bmp"); // debug

            // Calculate start point from actual measurement package size. Fyi, objSampleROI size is not same as package size, but is PadROI Size
            float fPkgOffsetX = (objSampleROI.ref_ROIWidth - Math.Max(GetResultUpWidth_RectGauge4L(0), GetResultDownWidth_RectGauge4L(0))) / 2;
            float fPkgOffsetY = (objSampleROI.ref_ROIHeight - Math.Max(GetResultLeftHeight_RectGauge4L(0), GetResultRightHeight_RectGauge4L(0))) / 2;

            float fROIToleranceLeft = 0, fROIToleranceTop = 0, fROIToleranceRight = 0, fROIToleranceBottom = 0;
            if (m_blnSeperateBrightDarkROITolerance)
            {
                fROIToleranceLeft = m_fPkgStartPixelFromLeft_Dark;
                fROIToleranceTop = m_fPkgStartPixelFromEdge_Dark;
                fROIToleranceRight = m_fPkgStartPixelFromRight_Dark;
                fROIToleranceBottom = m_fPkgStartPixelFromBottom_Dark;
            }
            else
            {
                fROIToleranceLeft = m_fPkgStartPixelFromLeft;
                fROIToleranceTop = m_fPkgStartPixelFromEdge;
                fROIToleranceRight = m_fPkgStartPixelFromRight;
                fROIToleranceBottom = m_fPkgStartPixelFromBottom;
            }

            int intStartPixelFromEdgeX = (int)Math.Round(fPkgOffsetX + fROIToleranceLeft, 0, MidpointRounding.AwayFromZero);
            int intStartPixelFromEdgeY = (int)Math.Round(fPkgOffsetY + fROIToleranceTop, 0, MidpointRounding.AwayFromZero);
            int intStartPixelFromEdgeX2 = (int)Math.Round(fPkgOffsetX + fROIToleranceRight, 0, MidpointRounding.AwayFromZero);
            int intStartPixelFromEdgeY2 = (int)Math.Round(fPkgOffsetY + fROIToleranceBottom, 0, MidpointRounding.AwayFromZero);

            ROI objCheckAreaSampleROI = new ROI();
            objCheckAreaSampleROI.AttachImage(objSampleROI);
            objCheckAreaSampleROI.LoadROISetting(intStartPixelFromEdgeX, intStartPixelFromEdgeY,
                objSampleROI.ref_ROIWidth - intStartPixelFromEdgeX - intStartPixelFromEdgeX2,
                objSampleROI.ref_ROIHeight - intStartPixelFromEdgeY - intStartPixelFromEdgeY2);

            if (blnDebugImage)
                objCheckAreaSampleROI.SaveImage("D:\\objCheckAreaSampleROI.bmp");   // debug
            int intSelectedObjectNum = 0;

            switch (intImageIndex)
            {
                case 1: // Image 1 (Grab 1 & Grab 2 Merged)
                    {
                        intSelectedObjectNum = m_objImage2SurfaceEBlobs.BuildObjects_Filter_GetElement(objCheckAreaSampleROI, false, true, 0, 125,
                                                m_intBrightFieldMinArea, 999999, false, 0xEF);// 0x0D);

                    }
                    break;
                case 2: // Image 2 (Grab 3)
                    {
                        intSelectedObjectNum = m_objImage2SurfaceEBlobs.BuildObjects_Filter_GetElement(objCheckAreaSampleROI, false, true, 0, 125,
                                                m_intDarkFieldMinArea, 999999, false, 0xEF);// 0x0D);

                    }
                    break;
                case 3: // Image 5 (Grab 5) // 2020-01-09 ZJYEOH : Changed case 4 to 3 
                    {
                        intSelectedObjectNum = m_objImage2SurfaceEBlobs.BuildObjects_Filter_GetElement(objCheckAreaSampleROI, false, true, 0, 125,
                                                m_intDarkFieldMinArea, 999999, false, 0xEF);// 0x0D);

                    }
                    break;
            }

            if (blnDebugImage)
                objCheckAreaSampleROI.SaveImage("D:\\TS\\objCheckAreaSampleROI.bmp");   // debug

            bool blnOverallResult = true;
            if (intSelectedObjectNum > 0)
            {
                List<List<System.Windows.Point>> arr2DPoints = new List<List<System.Windows.Point>>();
                List<List<PointF>> arrRotatedPoints = new List<List<PointF>>();
                List<float> fObjectHeightList = new List<float>(), fObjectWidthList = new List<float>(), fObjectCenterXList = new List<float>(), fObjectCenterYList = new List<float>(), fObjectAngleList = new List<float>();
                List<float> fObjectLimitHeightList = new List<float>(), fObjectLimitWidthList = new List<float>(), fObjectLimitCenterXList = new List<float>(), fObjectLimitCenterYList = new List<float>();
                List<int> fObjectAreaList = new List<int>(), fObjectAreaList2 = new List<int>();
                float fCenterX = 0, fCenterY = 0, fWidth = 0, fHeight = 0;
                float fStartX, fStartY, fEndX, fEndY, fAngle = 0;
                int intArea = 0;
                float fWidthMM, fHeightMM, fAreaInMM;
                int intFailCount = 0;
                int intTolerance = m_intDarkDefectLinkTolerance;
                int intTotalArea = 0;
                for (int i = 0; i < intSelectedObjectNum; i++)
                {
                    arrRotatedPoints.Add(new List<PointF>());
                    arr2DPoints.Add(new List<System.Windows.Point>());
                    intArea = m_objImage2SurfaceEBlobs.ref_arrArea[i];
                    if (m_objImage2SurfaceEBlobs.ref_arrRectWidth[i] < m_objImage2SurfaceEBlobs.ref_arrRectHeight[i])
                    {
                        fWidth = m_objImage2SurfaceEBlobs.ref_arrRectWidth[i];
                        fHeight = m_objImage2SurfaceEBlobs.ref_arrRectHeight[i];

                        fAngle = m_objImage2SurfaceEBlobs.ref_arrRectAngle[i];

                        //if (fAngle < 0)
                        //    fAngle = -Math.Abs(fAngle);
                        //else
                        //    fAngle = -fAngle;
                    }
                    else
                    {
                        fWidth = m_objImage2SurfaceEBlobs.ref_arrRectHeight[i];
                        fHeight = m_objImage2SurfaceEBlobs.ref_arrRectWidth[i];

                        fAngle = m_objImage2SurfaceEBlobs.ref_arrRectAngle[i];

                        //if (fAngle < 0)
                        //    fAngle = Math.Abs(fAngle);
                        //else
                        //    fAngle = 90 - (fAngle);

                        if (fAngle >= 10)//&& fAngle <= 80)
                            fAngle = m_objImage2SurfaceEBlobs.ref_arrRectAngle[i] - 90;
                        else
                            fAngle = 90 + m_objImage2SurfaceEBlobs.ref_arrRectAngle[i];

                    }
                    fCenterX = m_objImage2SurfaceEBlobs.ref_arrRectLimitCenterX[i];
                    fCenterY = m_objImage2SurfaceEBlobs.ref_arrRectLimitCenterY[i];

                    intTotalArea += intArea;
                    fCenterX += intStartPixelFromEdgeX;
                    fCenterY += intStartPixelFromEdgeY;
                    //fStartX = (float)Math.Floor(fCenterX - (fWidth / 2));
                    //fStartY = (float)Math.Floor(fCenterY - (fHeight / 2));
                    //fEndX = (float)Math.Ceiling(fCenterX + (fWidth / 2));
                    //fEndY = (float)Math.Ceiling(fCenterY + (fHeight / 2));

                    float newX1 = 0, newY1 = 0;  // new point 1
                    float newX2 = 0, newY2 = 0; // new point 2
                    float newX3 = 0, newY3 = 0; // new point 3
                    float newX4 = 0, newY4 = 0; // new point 4

                    //2020-12-18 ZJYEOH : Change to this format
                    //  Point 1 *-------------* Point 2
                    //          |             |
                    //          |             |
                    //          |             |
                    //  Point 4 *-------------* Point 3

                    Math2.RotateWithAngleAccordingToReferencePoint(fCenterX, fCenterY, (fCenterX - (fWidth / 2)), (fCenterY - (fHeight / 2)), fAngle, ref newX1, ref newY1);
                    Math2.RotateWithAngleAccordingToReferencePoint(fCenterX, fCenterY, (fCenterX + (fWidth / 2)), (fCenterY - (fHeight / 2)), fAngle, ref newX2, ref newY2);
                    Math2.RotateWithAngleAccordingToReferencePoint(fCenterX, fCenterY, (fCenterX + (fWidth / 2)), (fCenterY + (fHeight / 2)), fAngle, ref newX3, ref newY3);
                    Math2.RotateWithAngleAccordingToReferencePoint(fCenterX, fCenterY, (fCenterX - (fWidth / 2)), (fCenterY + (fHeight / 2)), fAngle, ref newX4, ref newY4);


                    arrRotatedPoints[i].Add(new PointF(newX1, newY1));
                    arrRotatedPoints[i].Add(new PointF(newX2, newY2));
                    arrRotatedPoints[i].Add(new PointF(newX3, newY3));
                    arrRotatedPoints[i].Add(new PointF(newX4, newY4));

                    Math2.RotateWithAngleAccordingToReferencePoint(fCenterX, fCenterY, (fCenterX - (fWidth / 2)) - intTolerance, (fCenterY - (fHeight / 2)) - intTolerance, fAngle, ref newX1, ref newY1);
                    Math2.RotateWithAngleAccordingToReferencePoint(fCenterX, fCenterY, (fCenterX + (fWidth / 2)) + intTolerance, (fCenterY - (fHeight / 2)) - intTolerance, fAngle, ref newX2, ref newY2);
                    Math2.RotateWithAngleAccordingToReferencePoint(fCenterX, fCenterY, (fCenterX + (fWidth / 2)) + intTolerance, (fCenterY + (fHeight / 2)) + intTolerance, fAngle, ref newX3, ref newY3);
                    Math2.RotateWithAngleAccordingToReferencePoint(fCenterX, fCenterY, (fCenterX - (fWidth / 2)) - intTolerance, (fCenterY + (fHeight / 2)) + intTolerance, fAngle, ref newX4, ref newY4);

                    arr2DPoints[i].Add(new System.Windows.Point(newX1, newY1));
                    arr2DPoints[i].Add(new System.Windows.Point(newX2, newY2));
                    arr2DPoints[i].Add(new System.Windows.Point(newX3, newY3));
                    arr2DPoints[i].Add(new System.Windows.Point(newX4, newY4));

                    fObjectHeightList.Add(fHeight);
                    fObjectWidthList.Add(fWidth);
                    fObjectCenterXList.Add(fCenterX);
                    fObjectCenterYList.Add(fCenterY);
                    fObjectAngleList.Add(fAngle);
                    fObjectAreaList.Add(intArea);
                    fObjectAreaList2.Add(intArea);

                }
                int intAngleTolerance = 10;
                bool blnDecrement = false;
                if (intTolerance >= 0)
                {
                    for (int i = 0; i < fObjectHeightList.Count; i++)
                    {
                        if (blnDecrement)
                        {
                            blnDecrement = false;
                            if (i > 0)
                                i--;
                        }
                        for (int j = 0; j < fObjectHeightList.Count; j++)
                        {
                            if (i != j && i < fObjectHeightList.Count && j < fObjectHeightList.Count)
                            {
                                if (Intersection.CheckRectRectIntersection(arr2DPoints[i].ToArray(), arr2DPoints[j].ToArray(), intTolerance))
                                {

                                    PointF[] arrPoints = new PointF[8];

                                    arrPoints[0] = arrRotatedPoints[i][0];
                                    arrPoints[1] = arrRotatedPoints[i][1];
                                    arrPoints[2] = arrRotatedPoints[i][2];
                                    arrPoints[3] = arrRotatedPoints[i][3];
                                    arrPoints[4] = arrRotatedPoints[j][0];
                                    arrPoints[5] = arrRotatedPoints[j][1];
                                    arrPoints[6] = arrRotatedPoints[j][2];
                                    arrPoints[7] = arrRotatedPoints[j][3];

                                    float fMinAngle = 0;
                                    List<PointF> arrMinRect = new List<PointF>();
                                    arrMinRect = MinimumBoundingBox.CalculateMinimumBoundingBox(arrPoints, ref fMinAngle);
                                    //fObjectAngleList[i] = fMinAngle;
                                    if (fMinAngle < 0)
                                        fObjectAngleList[i] = -(90 + fMinAngle);
                                    else
                                        fObjectAngleList[i] = 90 - fMinAngle;

                                    //if (fMinAngle < 0)
                                    //    fObjectAngleList[i] = -(90 + fMinAngle);
                                    //else
                                    //    fObjectAngleList[i] = 90 - fMinAngle;

                                    Line onjLine1 = new Line();
                                    Line onjLine2 = new Line();
                                    onjLine1.CalculateStraightLine(arrMinRect[0], arrMinRect[2]);
                                    onjLine2.CalculateStraightLine(arrMinRect[1], arrMinRect[3]);
                                    PointF pCenter = Line.GetCrossPoint(onjLine1, onjLine2);
                                    float p1X = 0, p1Y = 0;
                                    float p2X = 0, p2Y = 0;
                                    float p3X = 0, p3Y = 0;
                                    float p4X = 0, p4Y = 0;
                                    Math2.RotateWithAngleAccordingToReferencePoint(pCenter.X, pCenter.Y, arrMinRect[0].X, arrMinRect[0].Y, -fObjectAngleList[i], ref p1X, ref p1Y);
                                    Math2.RotateWithAngleAccordingToReferencePoint(pCenter.X, pCenter.Y, arrMinRect[1].X, arrMinRect[1].Y, -fObjectAngleList[i], ref p2X, ref p2Y);
                                    Math2.RotateWithAngleAccordingToReferencePoint(pCenter.X, pCenter.Y, arrMinRect[2].X, arrMinRect[2].Y, -fObjectAngleList[i], ref p3X, ref p3Y);
                                    Math2.RotateWithAngleAccordingToReferencePoint(pCenter.X, pCenter.Y, arrMinRect[3].X, arrMinRect[3].Y, -fObjectAngleList[i], ref p4X, ref p4Y);

                                    float pR1X = 0, pR1Y = 0;
                                    float pR2X = 0, pR2Y = 0;
                                    float pR3X = 0, pR3Y = 0;
                                    float pR4X = 0, pR4Y = 0;
                                    Math2.RotateWithAngleAccordingToReferencePoint(pCenter.X, pCenter.Y, Math.Min(Math.Min(p1X, p2X), Math.Min(p3X, p4X)), Math.Min(Math.Min(p1Y, p2Y), Math.Min(p3Y, p4Y)), fObjectAngleList[i], ref pR1X, ref pR1Y); // Top Left
                                    Math2.RotateWithAngleAccordingToReferencePoint(pCenter.X, pCenter.Y, Math.Max(Math.Max(p1X, p2X), Math.Max(p3X, p4X)), Math.Min(Math.Min(p1Y, p2Y), Math.Min(p3Y, p4Y)), fObjectAngleList[i], ref pR2X, ref pR2Y); // Top Right
                                    Math2.RotateWithAngleAccordingToReferencePoint(pCenter.X, pCenter.Y, Math.Max(Math.Max(p1X, p2X), Math.Max(p3X, p4X)), Math.Max(Math.Max(p1Y, p2Y), Math.Max(p3Y, p4Y)), fObjectAngleList[i], ref pR3X, ref pR3Y); // Bottom Right
                                    Math2.RotateWithAngleAccordingToReferencePoint(pCenter.X, pCenter.Y, Math.Min(Math.Min(p1X, p2X), Math.Min(p3X, p4X)), Math.Max(Math.Max(p1Y, p2Y), Math.Max(p3Y, p4Y)), fObjectAngleList[i], ref pR4X, ref pR4Y); // Bottom Left
                                    arrMinRect[0] = new PointF(pR1X, pR1Y);
                                    arrMinRect[1] = new PointF(pR2X, pR2Y);
                                    arrMinRect[2] = new PointF(pR3X, pR3Y);
                                    arrMinRect[3] = new PointF(pR4X, pR4Y);

                                    arrRotatedPoints[i][0] = arrMinRect[0];
                                    arrRotatedPoints[i][1] = arrMinRect[1];
                                    arrRotatedPoints[i][2] = arrMinRect[2];
                                    arrRotatedPoints[i][3] = arrMinRect[3];

                                    Math2.RotateWithAngleAccordingToReferencePoint(pCenter.X, pCenter.Y, Math.Min(Math.Min(p1X, p2X), Math.Min(p3X, p4X)) - intTolerance, Math.Min(Math.Min(p1Y, p2Y), Math.Min(p3Y, p4Y)) - intTolerance, fObjectAngleList[i], ref pR1X, ref pR1Y); // Top Left
                                    Math2.RotateWithAngleAccordingToReferencePoint(pCenter.X, pCenter.Y, Math.Max(Math.Max(p1X, p2X), Math.Max(p3X, p4X)) + intTolerance, Math.Min(Math.Min(p1Y, p2Y), Math.Min(p3Y, p4Y)) - intTolerance, fObjectAngleList[i], ref pR2X, ref pR2Y); // Top Right
                                    Math2.RotateWithAngleAccordingToReferencePoint(pCenter.X, pCenter.Y, Math.Max(Math.Max(p1X, p2X), Math.Max(p3X, p4X)) + intTolerance, Math.Max(Math.Max(p1Y, p2Y), Math.Max(p3Y, p4Y)) + intTolerance, fObjectAngleList[i], ref pR3X, ref pR3Y); // Bottom Right
                                    Math2.RotateWithAngleAccordingToReferencePoint(pCenter.X, pCenter.Y, Math.Min(Math.Min(p1X, p2X), Math.Min(p3X, p4X)) - intTolerance, Math.Max(Math.Max(p1Y, p2Y), Math.Max(p3Y, p4Y)) + intTolerance, fObjectAngleList[i], ref pR4X, ref pR4Y); // Bottom Left

                                    arr2DPoints[i][0] = new System.Windows.Point(pR1X, pR1Y);
                                    arr2DPoints[i][1] = new System.Windows.Point(pR2X, pR2Y);
                                    arr2DPoints[i][2] = new System.Windows.Point(pR3X, pR3Y);
                                    arr2DPoints[i][3] = new System.Windows.Point(pR4X, pR4Y);

                                    arrRotatedPoints.RemoveAt(j);
                                    arr2DPoints.RemoveAt(j);

                                    float fDiffX = Math.Max(Math.Abs(p1X - p4X), Math.Abs(p2X - p3X));
                                    float fDiffY = Math.Max(Math.Abs(p3Y - p4Y), Math.Abs(p2Y - p1Y));

                                    fObjectWidthList[i] = fDiffX;
                                    fObjectHeightList[i] = fDiffY;

                                    fObjectCenterXList[i] = pCenter.X;
                                    fObjectCenterYList[i] = pCenter.Y;

                                    fObjectAreaList2.RemoveAt(j);
                                    fObjectAreaList[i] = fObjectAreaList[i] + fObjectAreaList[j];

                                    fObjectHeightList.RemoveAt(j);
                                    fObjectWidthList.RemoveAt(j);
                                    fObjectCenterXList.RemoveAt(j);
                                    fObjectCenterYList.RemoveAt(j);
                                    fObjectAngleList.RemoveAt(j);
                                    fObjectAreaList.RemoveAt(j);

                                    if (j > 0)
                                        j = -1;
                                    if (i > 0)
                                    {
                                        i = 0;
                                    }
                                    else
                                        blnDecrement = true;

                                }

                            }
                        }
                    }
                }
                for (int i = 0; i < fObjectHeightList.Count; i++)
                {
                    if (fObjectHeightList[i] < fObjectWidthList[i])
                    {
                        float fObjectWidth = fObjectHeightList[i];
                        float fObjectHeight = fObjectWidthList[i];

                        float fObjectAngle = fObjectAngleList[i];

                        if (fObjectAngle >= 10)//&& fAngle <= 80)
                            fObjectAngle = fObjectAngleList[i] - 90;
                        else
                            fObjectAngle = 90 + fObjectAngleList[i];

                        fObjectWidthList[i] = fObjectWidth;
                        fObjectHeightList[i] = fObjectHeight;
                        fObjectAngleList[i] = fObjectAngle;
                    }
                    else
                    {
                        float fObjectHeight = fObjectHeightList[i];
                        float fObjectWidth = fObjectWidthList[i];

                        float fObjectAngle = fObjectAngleList[i];

                        fObjectWidthList[i] = fObjectWidth;
                        fObjectHeightList[i] = fObjectHeight;
                        fObjectAngleList[i] = fObjectAngle;
                    }

                    // convert width and height to mm
                    //fWidthMM = fWidth / m_fMMToPixelXValue;
                    //fHeightMM = fHeight / m_fMMToPixelYValue; // 11-04-2019 ZJYEOH : Changed m_fMMToPixelXValue to m_fMMToPixelYValue
                    //fAreaInMM = intArea / m_fMMToPixelXValue / m_fMMToPixelYValue;
                    fWidthMM = fObjectWidthList[i] / m_fMMToPixelXValue;
                    fHeightMM = fObjectHeightList[i] / m_fMMToPixelYValue;
                    fAreaInMM = fObjectAreaList[i] / (m_fMMToPixelXValue * m_fMMToPixelYValue);

                    //if ((fWidthMM > m_fScratchLength) || (fHeightMM > m_fScratchLength) || (fAreaInMM > m_fScratchArea) &&
                    //    ((m_intFailPkgOptionMask & 0x08) > 0 || (m_intFailPkgOptionMask & 0x1000) > 0))
                    {
                        intFailCount++;
                        //0x04
                        m_intFailPkgResultMask |= 0x20000; // Fail image 1 surface contamination

                        Defect objDefect = new Defect();

                        objDefect.ref_strName = "Dark";
                        objDefect.ref_intFailMask = 0x20000;
                        objDefect.ref_fCenterX = intROIStartX + fObjectCenterXList[i];
                        objDefect.ref_fCenterY = intROIStartY + fObjectCenterYList[i];
                        objDefect.ref_fStartX = intROIStartX + (float)Math.Floor(fObjectCenterXList[i] - (fObjectWidthList[i] / 2));
                        objDefect.ref_fStartY = intROIStartY + (float)Math.Floor(fObjectCenterYList[i] - (fObjectHeightList[i] / 2));
                        objDefect.ref_fEndX = intROIStartX + (float)Math.Ceiling(fObjectCenterXList[i] + (fObjectWidthList[i] / 2));
                        objDefect.ref_fEndY = intROIStartY + (float)Math.Ceiling(fObjectCenterYList[i] + (fObjectHeightList[i] / 2));
                        objDefect.ref_fWidth = fObjectWidthList[i];
                        objDefect.ref_fHeight = fObjectHeightList[i];
                        objDefect.ref_fArea = fObjectAreaList[i];
                        objDefect.ref_fAngle = fObjectAngleList[i];
                        objDefect.ref_fWidthInMM = fWidthMM;
                        objDefect.ref_fHeightInMM = fHeightMM;
                        objDefect.ref_fAreaInMM2 = fAreaInMM;
                        objDefect.ref_intImageNo = intImageIndex; //2020-01-09 ZJYEOH : Should not fixed to 1

                        if ((m_intFailPkgOptionMask & 0x80000) > 0)
                        {
                            if (m_intDarkDefectDimensionFailCondition == 0)
                            {
                                if (fWidthMM > m_fDarkWidth)
                                {
                                    blnOverallResult = false;
                                    objDefect.ref_fWidthFailValue = fWidthMM;
                                    objDefect.ref_intFailCriteria |= 0x01;
                                }
                                if (fHeightMM > m_fDarkLength)
                                {
                                    blnOverallResult = false;
                                    objDefect.ref_fHeightFailValue = fHeightMM;
                                    objDefect.ref_intFailCriteria |= 0x02;
                                }
                            }
                            else
                            {
                                if ((fWidthMM > m_fDarkWidth) && (fHeightMM > m_fDarkLength))
                                {
                                    blnOverallResult = false;
                                    objDefect.ref_fWidthFailValue = fWidthMM;
                                    objDefect.ref_intFailCriteria |= 0x01;
                                    objDefect.ref_fHeightFailValue = fHeightMM;
                                    objDefect.ref_intFailCriteria |= 0x02;
                                }
                            }
                        }

                        if ((m_intFailPkgOptionMask & 0x40000) > 0)
                        {
                            if (fAreaInMM > m_fDarkArea)
                            {
                                blnOverallResult = false;
                                objDefect.ref_fAreaFailValue = fAreaInMM;
                                objDefect.ref_intFailCriteria |= 0x04;
                            }
                        }

                        m_arrPkgDefectList.Add(objDefect);
                    }
                }


                if ((m_intFailPkgOptionMask & 0x40000) > 0)
                {
                    fAreaInMM = intTotalArea / m_fMMToPixelXValue / m_fMMToPixelYValue;

                    if (fAreaInMM > m_fDarkTotalArea)
                    {
                        Defect objDefect = new Defect();

                        objDefect.ref_strName = "Total Dark";
                        objDefect.ref_intFailMask = 0x20000;
                        objDefect.ref_fCenterX = -1;
                        objDefect.ref_fCenterY = -1;
                        objDefect.ref_fStartX = -1;
                        objDefect.ref_fStartY = -1;
                        objDefect.ref_fEndX = -1;
                        objDefect.ref_fEndY = -1;
                        objDefect.ref_fWidth = -1;
                        objDefect.ref_fHeight = -1;
                        objDefect.ref_fArea = intTotalArea;
                        objDefect.ref_fWidthInMM = -1;
                        objDefect.ref_fHeightInMM = -1;
                        objDefect.ref_fAreaInMM2 = fAreaInMM;
                        objDefect.ref_intImageNo = intImageIndex;

                        blnOverallResult = false;
                        objDefect.ref_fAreaFailValue = fAreaInMM;
                        objDefect.ref_intFailCriteria |= 0x08;

                        m_arrPkgDefectList.Add(objDefect);

                        Defect objDefect2 = new Defect();
                        for (int a = 0; a < m_arrPkgDefectList.Count; a++)
                        {
                            objDefect2 = m_arrPkgDefectList[a];
                            if (objDefect2.ref_strName.Contains("Dark"))
                            {
                                objDefect2.ref_blnFailTotalArea = true;
                                m_arrPkgDefectList[a] = objDefect2;
                            }
                        }

                        m_intFailPkgResultMask |= 0x20000; // Fail image 1 surface total dark field

                        // Collect total extra pad for display error message
                        m_fResultDarkFieldTotalArea = fAreaInMM;
                    }
                }
            }

            objCheckAreaSampleROI.Dispose();
            return blnOverallResult;
        }
        private bool IsImage2UnitDarkFieldPackageFailed_TiltAngle(ROI objSampleROI, int intROIStartX, int intROIStartY, int intImageIndex, int intPadIndex)//, bool blnPadPkg)
        {
            bool blnDebugImage = false;

            if (blnDebugImage)
                objSampleROI.SaveImage("D:\\TS\\objSampleROI.bmp"); // debug

            // Calculate start point from actual measurement package size. Fyi, objSampleROI size is not same as package size, but is PadROI Size
            float fPkgOffsetX = (objSampleROI.ref_ROIWidth - Math.Max(GetResultUpWidth_RectGauge4L(0), GetResultDownWidth_RectGauge4L(0))) / 2;
            float fPkgOffsetY = (objSampleROI.ref_ROIHeight - Math.Max(GetResultLeftHeight_RectGauge4L(0), GetResultRightHeight_RectGauge4L(0))) / 2;

            float fROIToleranceLeft = 0, fROIToleranceTop = 0, fROIToleranceRight = 0, fROIToleranceBottom = 0;
            if (m_blnSeperateBrightDarkROITolerance)
            {
                fROIToleranceLeft = m_fPkgStartPixelFromLeft_Dark;
                fROIToleranceTop = m_fPkgStartPixelFromEdge_Dark;
                fROIToleranceRight = m_fPkgStartPixelFromRight_Dark;
                fROIToleranceBottom = m_fPkgStartPixelFromBottom_Dark;
            }
            else
            {
                fROIToleranceLeft = m_fPkgStartPixelFromLeft;
                fROIToleranceTop = m_fPkgStartPixelFromEdge;
                fROIToleranceRight = m_fPkgStartPixelFromRight;
                fROIToleranceBottom = m_fPkgStartPixelFromBottom;
            }

            int intStartPixelFromEdgeX = (int)Math.Round(fPkgOffsetX + fROIToleranceLeft, 0, MidpointRounding.AwayFromZero);
            int intStartPixelFromEdgeY = (int)Math.Round(fPkgOffsetY + fROIToleranceTop, 0, MidpointRounding.AwayFromZero);
            int intStartPixelFromEdgeX2 = (int)Math.Round(fPkgOffsetX + fROIToleranceRight, 0, MidpointRounding.AwayFromZero);
            int intStartPixelFromEdgeY2 = (int)Math.Round(fPkgOffsetY + fROIToleranceBottom, 0, MidpointRounding.AwayFromZero);

            ROI objCheckAreaSampleROI = new ROI();
            objCheckAreaSampleROI.AttachImage(objSampleROI);
            objCheckAreaSampleROI.LoadROISetting(intStartPixelFromEdgeX, intStartPixelFromEdgeY,
                objSampleROI.ref_ROIWidth - intStartPixelFromEdgeX - intStartPixelFromEdgeX2,
                objSampleROI.ref_ROIHeight - intStartPixelFromEdgeY - intStartPixelFromEdgeY2);

            //2019-09-23 ZJYEOH : Subtract tilt dont care area 
            if (intPadIndex == 1) // Top
            {
                ROI DontCareTop = new ROI();

                DontCareTop.LoadROISetting(0, 0, objCheckAreaSampleROI.ref_ROIWidth, objCheckAreaSampleROI.ref_ROIHeight);
                DontCareTop.AttachImage(m_ImgTilt_Top_L);
                EasyImage.Oper(EArithmeticLogicOperation.Subtract, objCheckAreaSampleROI.ref_ROI, DontCareTop.ref_ROI, objCheckAreaSampleROI.ref_ROI);
                DontCareTop.LoadROISetting(m_ImgTilt_Top_R.ref_intImageWidth - objCheckAreaSampleROI.ref_ROIWidth, 0, objCheckAreaSampleROI.ref_ROIWidth, objCheckAreaSampleROI.ref_ROIHeight);
                DontCareTop.AttachImage(m_ImgTilt_Top_R);
                EasyImage.Oper(EArithmeticLogicOperation.Subtract, objCheckAreaSampleROI.ref_ROI, DontCareTop.ref_ROI, objCheckAreaSampleROI.ref_ROI);
                if (blnDebugImage)
                    objCheckAreaSampleROI.SaveImage("D:\\IsImage2UnitDarkFieldPackageFailed_objCheckAreaSampleROITop.bmp");
                DontCareTop.Dispose();
            }
            if (intPadIndex == 2) // Right
            {
                ROI DontCareRight = new ROI();
                DontCareRight.LoadROISetting(m_ImgTilt_Top_R.ref_intImageWidth - objCheckAreaSampleROI.ref_ROIWidth, 0, objCheckAreaSampleROI.ref_ROIWidth, objCheckAreaSampleROI.ref_ROIHeight);
                DontCareRight.AttachImage(m_ImgTilt_Right_T);
                EasyImage.Oper(EArithmeticLogicOperation.Subtract, objCheckAreaSampleROI.ref_ROI, DontCareRight.ref_ROI, objCheckAreaSampleROI.ref_ROI);
                DontCareRight.LoadROISetting(m_ImgTilt_Top_R.ref_intImageWidth - objCheckAreaSampleROI.ref_ROIWidth, m_ImgTilt_Top_R.ref_intImageHeight - objCheckAreaSampleROI.ref_ROIHeight, objCheckAreaSampleROI.ref_ROIWidth, objCheckAreaSampleROI.ref_ROIHeight);
                DontCareRight.AttachImage(m_ImgTilt_Right_B);
                EasyImage.Oper(EArithmeticLogicOperation.Subtract, objCheckAreaSampleROI.ref_ROI, DontCareRight.ref_ROI, objCheckAreaSampleROI.ref_ROI);
                if (blnDebugImage)
                    objCheckAreaSampleROI.SaveImage("D:\\IsImage2UnitDarkFieldPackageFailed_objCheckAreaSampleROIRight.bmp");
                DontCareRight.Dispose();
            }
            if (intPadIndex == 3) // Bottom
            {
                ROI DontCareBottom = new ROI();

                DontCareBottom.LoadROISetting(0, m_ImgTilt_Top_R.ref_intImageHeight - objCheckAreaSampleROI.ref_ROIHeight, objCheckAreaSampleROI.ref_ROIWidth, objCheckAreaSampleROI.ref_ROIHeight);
                DontCareBottom.AttachImage(m_ImgTilt_Bottom_L);
                EasyImage.Oper(EArithmeticLogicOperation.Subtract, objCheckAreaSampleROI.ref_ROI, DontCareBottom.ref_ROI, objCheckAreaSampleROI.ref_ROI);
                DontCareBottom.LoadROISetting(m_ImgTilt_Top_R.ref_intImageWidth - objCheckAreaSampleROI.ref_ROIWidth, m_ImgTilt_Top_R.ref_intImageHeight - objCheckAreaSampleROI.ref_ROIHeight, objCheckAreaSampleROI.ref_ROIWidth, objCheckAreaSampleROI.ref_ROIHeight);
                DontCareBottom.AttachImage(m_ImgTilt_Bottom_R);
                EasyImage.Oper(EArithmeticLogicOperation.Subtract, objCheckAreaSampleROI.ref_ROI, DontCareBottom.ref_ROI, objCheckAreaSampleROI.ref_ROI);
                if (blnDebugImage)
                    objCheckAreaSampleROI.SaveImage("D:\\IsImage2UnitDarkFieldPackageFailed_objCheckAreaSampleROIBottom.bmp");
                DontCareBottom.Dispose();
            }
            if (intPadIndex == 4) // Left
            {
                ROI DontCareLeft = new ROI();

                DontCareLeft.LoadROISetting(0, 0, objCheckAreaSampleROI.ref_ROIWidth, objCheckAreaSampleROI.ref_ROIHeight);
                DontCareLeft.AttachImage(m_ImgTilt_Left_T);
                EasyImage.Oper(EArithmeticLogicOperation.Subtract, objCheckAreaSampleROI.ref_ROI, DontCareLeft.ref_ROI, objCheckAreaSampleROI.ref_ROI);
                DontCareLeft.LoadROISetting(0, m_ImgTilt_Top_R.ref_intImageHeight - objCheckAreaSampleROI.ref_ROIHeight, objCheckAreaSampleROI.ref_ROIWidth, objCheckAreaSampleROI.ref_ROIHeight);
                DontCareLeft.AttachImage(m_ImgTilt_Left_B);
                EasyImage.Oper(EArithmeticLogicOperation.Subtract, objCheckAreaSampleROI.ref_ROI, DontCareLeft.ref_ROI, objCheckAreaSampleROI.ref_ROI);
                if (blnDebugImage)
                    objCheckAreaSampleROI.SaveImage("D:\\IsImage2UnitDarkFieldPackageFailed_objCheckAreaSampleROILeft.bmp");
                DontCareLeft.Dispose();
            }
            if (blnDebugImage)
                objCheckAreaSampleROI.SaveImage("D:\\objCheckAreaSampleROI.bmp");   // debug
            int intSelectedObjectNum = 0;

            switch (intImageIndex)
            {
                case 1: // Image 1 (Grab 1 & Grab 2 Merged)
                    {
                        intSelectedObjectNum = m_objImage2SurfaceEBlobs.BuildObjects_Filter_GetElement(objCheckAreaSampleROI, false, true, 0, 125,
                                                m_intBrightFieldMinArea, 999999, false, 0xEF);// 0x0D);

                    }
                    break;
                case 2: // Image 2 (Grab 3)
                    {
                        intSelectedObjectNum = m_objImage2SurfaceEBlobs.BuildObjects_Filter_GetElement(objCheckAreaSampleROI, false, true, 0, 125,
                                                m_intDarkFieldMinArea, 999999, false, 0xEF);// 0x0D);

                    }
                    break;
                case 3: // Image 5 (Grab 5) // 2020-01-09 ZJYEOH : Changed case 4 to 3 
                    {
                        intSelectedObjectNum = m_objImage2SurfaceEBlobs.BuildObjects_Filter_GetElement(objCheckAreaSampleROI, false, true, 0, 125,
                                                m_intDarkFieldMinArea, 999999, false, 0xEF);// 0x0D);

                    }
                    break;
            }

            if (blnDebugImage)
                objCheckAreaSampleROI.SaveImage("D:\\TS\\objCheckAreaSampleROI.bmp");   // debug

            bool blnOverallResult = true;
            if (intSelectedObjectNum > 0)
            {
                float fCenterX = 0, fCenterY = 0, fWidth = 0, fHeight = 0;
                float fStartX, fStartY, fEndX, fEndY, fAngle = 0;
                int intArea = 0;
                float fWidthMM, fHeightMM, fAreaInMM;
                int intFailCount = 0;

                int intTotalArea = 0;
                for (int i = 0; i < intSelectedObjectNum; i++)
                {
                    intArea = m_objImage2SurfaceEBlobs.ref_arrArea[i];
                    if (m_objImage2SurfaceEBlobs.ref_arrRectWidth[i] < m_objImage2SurfaceEBlobs.ref_arrRectHeight[i])
                    {
                        fWidth = m_objImage2SurfaceEBlobs.ref_arrRectWidth[i];
                        fHeight = m_objImage2SurfaceEBlobs.ref_arrRectHeight[i];

                        fAngle = m_objImage2SurfaceEBlobs.ref_arrRectAngle[i];
                        
                        //if (fAngle < 0)
                        //    fAngle = -Math.Abs(fAngle);
                        //else
                        //    fAngle = -fAngle;
                    }
                    else
                    {
                        fWidth = m_objImage2SurfaceEBlobs.ref_arrRectHeight[i];
                        fHeight = m_objImage2SurfaceEBlobs.ref_arrRectWidth[i];

                        fAngle = m_objImage2SurfaceEBlobs.ref_arrRectAngle[i];

                        //if (fAngle < 0)
                        //    fAngle = Math.Abs(fAngle);
                        //else
                        //    fAngle = 90 - (fAngle);

                        if (fAngle >= 10)//&& fAngle <= 80)
                            fAngle = m_objImage2SurfaceEBlobs.ref_arrRectAngle[i] - 90;
                        else
                            fAngle = 90 + m_objImage2SurfaceEBlobs.ref_arrRectAngle[i];

                    }
                    fCenterX = m_objImage2SurfaceEBlobs.ref_arrRectLimitCenterX[i];
                    fCenterY = m_objImage2SurfaceEBlobs.ref_arrRectLimitCenterY[i];

                    intTotalArea += intArea;
                    fCenterX += intStartPixelFromEdgeX;
                    fCenterY += intStartPixelFromEdgeY;
                    fStartX = (float)Math.Floor(fCenterX - (fWidth / 2));
                    fStartY = (float)Math.Floor(fCenterY - (fHeight / 2));
                    fEndX = (float)Math.Ceiling(fCenterX + (fWidth / 2));
                    fEndY = (float)Math.Ceiling(fCenterY + (fHeight / 2));

                    // convert width and height to mm
                    fWidthMM = fWidth / m_fMMToPixelXValue;
                    fHeightMM = fHeight / m_fMMToPixelYValue; // 11-04-2019 ZJYEOH : Changed m_fMMToPixelXValue to m_fMMToPixelYValue
                    fAreaInMM = intArea / m_fMMToPixelXValue / m_fMMToPixelYValue;

                    //if ((fWidthMM > m_fScratchLength) || (fHeightMM > m_fScratchLength) || (fAreaInMM > m_fScratchArea) &&
                    //    ((m_intFailPkgOptionMask & 0x08) > 0 || (m_intFailPkgOptionMask & 0x1000) > 0))
                    {
                        intFailCount++;
                        //0x04
                        m_intFailPkgResultMask |= 0x20000; // Fail image 1 surface contamination

                        Defect objDefect = new Defect();

                        objDefect.ref_strName = "Dark";
                        objDefect.ref_intFailMask = 0x20000;
                        objDefect.ref_fCenterX = intROIStartX + fCenterX;
                        objDefect.ref_fCenterY = intROIStartY + fCenterY;
                        objDefect.ref_fStartX = intROIStartX + fStartX;
                        objDefect.ref_fStartY = intROIStartY + fStartY;
                        objDefect.ref_fEndX = intROIStartX + fEndX;
                        objDefect.ref_fEndY = intROIStartY + fEndY;
                        objDefect.ref_fWidth = fWidth;
                        objDefect.ref_fHeight = fHeight;
                        objDefect.ref_fArea = intArea;
                        objDefect.ref_fAngle = fAngle; // 2019-10-09 ZJYEOH : Need to add angle, if no add, defect in drawing will always draw 0 degree only
                        objDefect.ref_fWidthInMM = fWidthMM;
                        objDefect.ref_fHeightInMM = fHeightMM;
                        objDefect.ref_fAreaInMM2 = fAreaInMM;
                        objDefect.ref_intImageNo = intImageIndex; //2020-01-09 ZJYEOH : Should not fixed to 1

                        if ((m_intFailPkgOptionMask & 0x80000) > 0)
                        {
                            if (m_intDarkDefectDimensionFailCondition == 0)
                            {
                                if (fWidthMM > m_fDarkWidth)
                                {
                                    blnOverallResult = false;
                                    objDefect.ref_fWidthFailValue = fWidthMM;
                                    objDefect.ref_intFailCriteria |= 0x01;
                                }
                                if (fHeightMM > m_fDarkLength)
                                {
                                    blnOverallResult = false;
                                    objDefect.ref_fHeightFailValue = fHeightMM;
                                    objDefect.ref_intFailCriteria |= 0x02;
                                }
                            }
                            else
                            {
                                if ((fWidthMM > m_fDarkWidth) && (fHeightMM > m_fDarkLength))
                                {
                                    blnOverallResult = false;
                                    objDefect.ref_fWidthFailValue = fWidthMM;
                                    objDefect.ref_intFailCriteria |= 0x01;
                                    objDefect.ref_fHeightFailValue = fHeightMM;
                                    objDefect.ref_intFailCriteria |= 0x02;
                                }
                            }
                        }

                        if ((m_intFailPkgOptionMask & 0x40000) > 0)
                        {
                            if (fAreaInMM > m_fDarkArea)
                            {
                                blnOverallResult = false;
                                objDefect.ref_fAreaFailValue = fAreaInMM;
                                objDefect.ref_intFailCriteria |= 0x04;
                            }
                        }

                        m_arrPkgDefectList.Add(objDefect);
                    }

                }

                if ((m_intFailPkgOptionMask & 0x40000) > 0)
                {
                    fAreaInMM = intTotalArea / m_fMMToPixelXValue / m_fMMToPixelYValue;

                    if (fAreaInMM > m_fDarkTotalArea)
                    {
                        Defect objDefect = new Defect();

                        objDefect.ref_strName = "Total Dark";
                        objDefect.ref_intFailMask = 0x20000;
                        objDefect.ref_fCenterX = -1;
                        objDefect.ref_fCenterY = -1;
                        objDefect.ref_fStartX = -1;
                        objDefect.ref_fStartY = -1;
                        objDefect.ref_fEndX = -1;
                        objDefect.ref_fEndY = -1;
                        objDefect.ref_fWidth = -1;
                        objDefect.ref_fHeight = -1;
                        objDefect.ref_fArea = intTotalArea;
                        objDefect.ref_fWidthInMM = -1;
                        objDefect.ref_fHeightInMM = -1;
                        objDefect.ref_fAreaInMM2 = fAreaInMM;
                        objDefect.ref_intImageNo = intImageIndex;

                        blnOverallResult = false;
                        objDefect.ref_fAreaFailValue = fAreaInMM;
                        objDefect.ref_intFailCriteria |= 0x08;

                        m_arrPkgDefectList.Add(objDefect);

                        Defect objDefect2 = new Defect();
                        for (int a = 0; a < m_arrPkgDefectList.Count; a++)
                        {
                            objDefect2 = m_arrPkgDefectList[a];
                            if (objDefect2.ref_strName.Contains("Dark"))
                            {
                                objDefect2.ref_blnFailTotalArea = true;
                                m_arrPkgDefectList[a] = objDefect2;
                            }
                        }

                        m_intFailPkgResultMask |= 0x20000; // Fail image 1 surface total dark field

                        // Collect total extra pad for display error message
                        m_fResultDarkFieldTotalArea = fAreaInMM;
                    }
                }
            }

            objCheckAreaSampleROI.Dispose();
            return blnOverallResult;
        }
        private bool IsImage2UnitDarkFieldPackageFailed_TiltAngle_WithLinkFunction(ROI objSampleROI, int intROIStartX, int intROIStartY, int intImageIndex, int intPadIndex)//, bool blnPadPkg)
        {
            bool blnDebugImage = false;

            if (blnDebugImage)
                objSampleROI.SaveImage("D:\\TS\\objSampleROI.bmp"); // debug

            // Calculate start point from actual measurement package size. Fyi, objSampleROI size is not same as package size, but is PadROI Size
            float fPkgOffsetX = (objSampleROI.ref_ROIWidth - Math.Max(GetResultUpWidth_RectGauge4L(0), GetResultDownWidth_RectGauge4L(0))) / 2;
            float fPkgOffsetY = (objSampleROI.ref_ROIHeight - Math.Max(GetResultLeftHeight_RectGauge4L(0), GetResultRightHeight_RectGauge4L(0))) / 2;

            float fROIToleranceLeft = 0, fROIToleranceTop = 0, fROIToleranceRight = 0, fROIToleranceBottom = 0;
            if (m_blnSeperateBrightDarkROITolerance)
            {
                fROIToleranceLeft = m_fPkgStartPixelFromLeft_Dark;
                fROIToleranceTop = m_fPkgStartPixelFromEdge_Dark;
                fROIToleranceRight = m_fPkgStartPixelFromRight_Dark;
                fROIToleranceBottom = m_fPkgStartPixelFromBottom_Dark;
            }
            else
            {
                fROIToleranceLeft = m_fPkgStartPixelFromLeft;
                fROIToleranceTop = m_fPkgStartPixelFromEdge;
                fROIToleranceRight = m_fPkgStartPixelFromRight;
                fROIToleranceBottom = m_fPkgStartPixelFromBottom;
            }

            int intStartPixelFromEdgeX = (int)Math.Round(fPkgOffsetX + fROIToleranceLeft, 0, MidpointRounding.AwayFromZero);
            int intStartPixelFromEdgeY = (int)Math.Round(fPkgOffsetY + fROIToleranceTop, 0, MidpointRounding.AwayFromZero);
            int intStartPixelFromEdgeX2 = (int)Math.Round(fPkgOffsetX + fROIToleranceRight, 0, MidpointRounding.AwayFromZero);
            int intStartPixelFromEdgeY2 = (int)Math.Round(fPkgOffsetY + fROIToleranceBottom, 0, MidpointRounding.AwayFromZero);

            ROI objCheckAreaSampleROI = new ROI();
            objCheckAreaSampleROI.AttachImage(objSampleROI);
            objCheckAreaSampleROI.LoadROISetting(intStartPixelFromEdgeX, intStartPixelFromEdgeY,
                objSampleROI.ref_ROIWidth - intStartPixelFromEdgeX - intStartPixelFromEdgeX2,
                objSampleROI.ref_ROIHeight - intStartPixelFromEdgeY - intStartPixelFromEdgeY2);

            //2019-09-23 ZJYEOH : Subtract tilt dont care area 
            if (intPadIndex == 1) // Top
            {
                ROI DontCareTop = new ROI();

                DontCareTop.LoadROISetting(0, 0, objCheckAreaSampleROI.ref_ROIWidth, objCheckAreaSampleROI.ref_ROIHeight);
                DontCareTop.AttachImage(m_ImgTilt_Top_L);
                EasyImage.Oper(EArithmeticLogicOperation.Subtract, objCheckAreaSampleROI.ref_ROI, DontCareTop.ref_ROI, objCheckAreaSampleROI.ref_ROI);
                DontCareTop.LoadROISetting(m_ImgTilt_Top_R.ref_intImageWidth - objCheckAreaSampleROI.ref_ROIWidth, 0, objCheckAreaSampleROI.ref_ROIWidth, objCheckAreaSampleROI.ref_ROIHeight);
                DontCareTop.AttachImage(m_ImgTilt_Top_R);
                EasyImage.Oper(EArithmeticLogicOperation.Subtract, objCheckAreaSampleROI.ref_ROI, DontCareTop.ref_ROI, objCheckAreaSampleROI.ref_ROI);
                if (blnDebugImage)
                    objCheckAreaSampleROI.SaveImage("D:\\IsImage2UnitDarkFieldPackageFailed_objCheckAreaSampleROITop.bmp");
                DontCareTop.Dispose();
            }
            if (intPadIndex == 2) // Right
            {
                ROI DontCareRight = new ROI();
                DontCareRight.LoadROISetting(m_ImgTilt_Top_R.ref_intImageWidth - objCheckAreaSampleROI.ref_ROIWidth, 0, objCheckAreaSampleROI.ref_ROIWidth, objCheckAreaSampleROI.ref_ROIHeight);
                DontCareRight.AttachImage(m_ImgTilt_Right_T);
                EasyImage.Oper(EArithmeticLogicOperation.Subtract, objCheckAreaSampleROI.ref_ROI, DontCareRight.ref_ROI, objCheckAreaSampleROI.ref_ROI);
                DontCareRight.LoadROISetting(m_ImgTilt_Top_R.ref_intImageWidth - objCheckAreaSampleROI.ref_ROIWidth, m_ImgTilt_Top_R.ref_intImageHeight - objCheckAreaSampleROI.ref_ROIHeight, objCheckAreaSampleROI.ref_ROIWidth, objCheckAreaSampleROI.ref_ROIHeight);
                DontCareRight.AttachImage(m_ImgTilt_Right_B);
                EasyImage.Oper(EArithmeticLogicOperation.Subtract, objCheckAreaSampleROI.ref_ROI, DontCareRight.ref_ROI, objCheckAreaSampleROI.ref_ROI);
                if (blnDebugImage)
                    objCheckAreaSampleROI.SaveImage("D:\\IsImage2UnitDarkFieldPackageFailed_objCheckAreaSampleROIRight.bmp");
                DontCareRight.Dispose();
            }
            if (intPadIndex == 3) // Bottom
            {
                ROI DontCareBottom = new ROI();

                DontCareBottom.LoadROISetting(0, m_ImgTilt_Top_R.ref_intImageHeight - objCheckAreaSampleROI.ref_ROIHeight, objCheckAreaSampleROI.ref_ROIWidth, objCheckAreaSampleROI.ref_ROIHeight);
                DontCareBottom.AttachImage(m_ImgTilt_Bottom_L);
                EasyImage.Oper(EArithmeticLogicOperation.Subtract, objCheckAreaSampleROI.ref_ROI, DontCareBottom.ref_ROI, objCheckAreaSampleROI.ref_ROI);
                DontCareBottom.LoadROISetting(m_ImgTilt_Top_R.ref_intImageWidth - objCheckAreaSampleROI.ref_ROIWidth, m_ImgTilt_Top_R.ref_intImageHeight - objCheckAreaSampleROI.ref_ROIHeight, objCheckAreaSampleROI.ref_ROIWidth, objCheckAreaSampleROI.ref_ROIHeight);
                DontCareBottom.AttachImage(m_ImgTilt_Bottom_R);
                EasyImage.Oper(EArithmeticLogicOperation.Subtract, objCheckAreaSampleROI.ref_ROI, DontCareBottom.ref_ROI, objCheckAreaSampleROI.ref_ROI);
                if (blnDebugImage)
                    objCheckAreaSampleROI.SaveImage("D:\\IsImage2UnitDarkFieldPackageFailed_objCheckAreaSampleROIBottom.bmp");
                DontCareBottom.Dispose();
            }
            if (intPadIndex == 4) // Left
            {
                ROI DontCareLeft = new ROI();

                DontCareLeft.LoadROISetting(0, 0, objCheckAreaSampleROI.ref_ROIWidth, objCheckAreaSampleROI.ref_ROIHeight);
                DontCareLeft.AttachImage(m_ImgTilt_Left_T);
                EasyImage.Oper(EArithmeticLogicOperation.Subtract, objCheckAreaSampleROI.ref_ROI, DontCareLeft.ref_ROI, objCheckAreaSampleROI.ref_ROI);
                DontCareLeft.LoadROISetting(0, m_ImgTilt_Top_R.ref_intImageHeight - objCheckAreaSampleROI.ref_ROIHeight, objCheckAreaSampleROI.ref_ROIWidth, objCheckAreaSampleROI.ref_ROIHeight);
                DontCareLeft.AttachImage(m_ImgTilt_Left_B);
                EasyImage.Oper(EArithmeticLogicOperation.Subtract, objCheckAreaSampleROI.ref_ROI, DontCareLeft.ref_ROI, objCheckAreaSampleROI.ref_ROI);
                if (blnDebugImage)
                    objCheckAreaSampleROI.SaveImage("D:\\IsImage2UnitDarkFieldPackageFailed_objCheckAreaSampleROILeft.bmp");
                DontCareLeft.Dispose();
            }
            if (blnDebugImage)
                objCheckAreaSampleROI.SaveImage("D:\\objCheckAreaSampleROI.bmp");   // debug
            int intSelectedObjectNum = 0;

            switch (intImageIndex)
            {
                case 1: // Image 1 (Grab 1 & Grab 2 Merged)
                    {
                        intSelectedObjectNum = m_objImage2SurfaceEBlobs.BuildObjects_Filter_GetElement(objCheckAreaSampleROI, false, true, 0, 125,
                                                m_intBrightFieldMinArea, 999999, false, 0xEF);// 0x0D);

                    }
                    break;
                case 2: // Image 2 (Grab 3)
                    {
                        intSelectedObjectNum = m_objImage2SurfaceEBlobs.BuildObjects_Filter_GetElement(objCheckAreaSampleROI, false, true, 0, 125,
                                                m_intDarkFieldMinArea, 999999, false, 0xEF);// 0x0D);

                    }
                    break;
                case 3: // Image 5 (Grab 5) // 2020-01-09 ZJYEOH : Changed case 4 to 3 
                    {
                        intSelectedObjectNum = m_objImage2SurfaceEBlobs.BuildObjects_Filter_GetElement(objCheckAreaSampleROI, false, true, 0, 125,
                                                m_intDarkFieldMinArea, 999999, false, 0xEF);// 0x0D);

                    }
                    break;
            }

            if (blnDebugImage)
                objCheckAreaSampleROI.SaveImage("D:\\TS\\objCheckAreaSampleROI.bmp");   // debug

            bool blnOverallResult = true;
            if (intSelectedObjectNum > 0)
            {
                List<List<System.Windows.Point>> arr2DPoints = new List<List<System.Windows.Point>>();
                List<List<PointF>> arrRotatedPoints = new List<List<PointF>>();
                List<float> fObjectHeightList = new List<float>(), fObjectWidthList = new List<float>(), fObjectCenterXList = new List<float>(), fObjectCenterYList = new List<float>(), fObjectAngleList = new List<float>();
                List<float> fObjectLimitHeightList = new List<float>(), fObjectLimitWidthList = new List<float>(), fObjectLimitCenterXList = new List<float>(), fObjectLimitCenterYList = new List<float>();
                List<int> fObjectAreaList = new List<int>(), fObjectAreaList2 = new List<int>();
                float fCenterX = 0, fCenterY = 0, fWidth = 0, fHeight = 0;
                float fStartX, fStartY, fEndX, fEndY, fAngle = 0;
                int intArea = 0;
                float fWidthMM, fHeightMM, fAreaInMM;
                int intFailCount = 0;
                int intTolerance = m_intDarkDefectLinkTolerance;
                int intTotalArea = 0;
                for (int i = 0; i < intSelectedObjectNum; i++)
                {
                    arrRotatedPoints.Add(new List<PointF>());
                    arr2DPoints.Add(new List<System.Windows.Point>());
                    intArea = m_objImage2SurfaceEBlobs.ref_arrArea[i];
                    if (m_objImage2SurfaceEBlobs.ref_arrRectWidth[i] < m_objImage2SurfaceEBlobs.ref_arrRectHeight[i])
                    {
                        fWidth = m_objImage2SurfaceEBlobs.ref_arrRectWidth[i];
                        fHeight = m_objImage2SurfaceEBlobs.ref_arrRectHeight[i];

                        fAngle = m_objImage2SurfaceEBlobs.ref_arrRectAngle[i];

                        //if (fAngle < 0)
                        //    fAngle = -Math.Abs(fAngle);
                        //else
                        //    fAngle = -fAngle;
                    }
                    else
                    {
                        fWidth = m_objImage2SurfaceEBlobs.ref_arrRectHeight[i];
                        fHeight = m_objImage2SurfaceEBlobs.ref_arrRectWidth[i];

                        fAngle = m_objImage2SurfaceEBlobs.ref_arrRectAngle[i];

                        //if (fAngle < 0)
                        //    fAngle = Math.Abs(fAngle);
                        //else
                        //    fAngle = 90 - (fAngle);

                        if (fAngle >= 10)//&& fAngle <= 80)
                            fAngle = m_objImage2SurfaceEBlobs.ref_arrRectAngle[i] - 90;
                        else
                            fAngle = 90 + m_objImage2SurfaceEBlobs.ref_arrRectAngle[i];

                    }
                    fCenterX = m_objImage2SurfaceEBlobs.ref_arrRectLimitCenterX[i];
                    fCenterY = m_objImage2SurfaceEBlobs.ref_arrRectLimitCenterY[i];

                    intTotalArea += intArea;
                    fCenterX += intStartPixelFromEdgeX;
                    fCenterY += intStartPixelFromEdgeY;
                    //fStartX = (float)Math.Floor(fCenterX - (fWidth / 2));
                    //fStartY = (float)Math.Floor(fCenterY - (fHeight / 2));
                    //fEndX = (float)Math.Ceiling(fCenterX + (fWidth / 2));
                    //fEndY = (float)Math.Ceiling(fCenterY + (fHeight / 2));

                    float newX1 = 0, newY1 = 0;  // new point 1
                    float newX2 = 0, newY2 = 0; // new point 2
                    float newX3 = 0, newY3 = 0; // new point 3
                    float newX4 = 0, newY4 = 0; // new point 4

                    //2020-12-18 ZJYEOH : Change to this format
                    //  Point 1 *-------------* Point 2
                    //          |             |
                    //          |             |
                    //          |             |
                    //  Point 4 *-------------* Point 3

                    Math2.RotateWithAngleAccordingToReferencePoint(fCenterX, fCenterY, (fCenterX - (fWidth / 2)), (fCenterY - (fHeight / 2)), fAngle, ref newX1, ref newY1);
                    Math2.RotateWithAngleAccordingToReferencePoint(fCenterX, fCenterY, (fCenterX + (fWidth / 2)), (fCenterY - (fHeight / 2)), fAngle, ref newX2, ref newY2);
                    Math2.RotateWithAngleAccordingToReferencePoint(fCenterX, fCenterY, (fCenterX + (fWidth / 2)), (fCenterY + (fHeight / 2)), fAngle, ref newX3, ref newY3);
                    Math2.RotateWithAngleAccordingToReferencePoint(fCenterX, fCenterY, (fCenterX - (fWidth / 2)), (fCenterY + (fHeight / 2)), fAngle, ref newX4, ref newY4);


                    arrRotatedPoints[i].Add(new PointF(newX1, newY1));
                    arrRotatedPoints[i].Add(new PointF(newX2, newY2));
                    arrRotatedPoints[i].Add(new PointF(newX3, newY3));
                    arrRotatedPoints[i].Add(new PointF(newX4, newY4));

                    Math2.RotateWithAngleAccordingToReferencePoint(fCenterX, fCenterY, (fCenterX - (fWidth / 2)) - intTolerance, (fCenterY - (fHeight / 2)) - intTolerance, fAngle, ref newX1, ref newY1);
                    Math2.RotateWithAngleAccordingToReferencePoint(fCenterX, fCenterY, (fCenterX + (fWidth / 2)) + intTolerance, (fCenterY - (fHeight / 2)) - intTolerance, fAngle, ref newX2, ref newY2);
                    Math2.RotateWithAngleAccordingToReferencePoint(fCenterX, fCenterY, (fCenterX + (fWidth / 2)) + intTolerance, (fCenterY + (fHeight / 2)) + intTolerance, fAngle, ref newX3, ref newY3);
                    Math2.RotateWithAngleAccordingToReferencePoint(fCenterX, fCenterY, (fCenterX - (fWidth / 2)) - intTolerance, (fCenterY + (fHeight / 2)) + intTolerance, fAngle, ref newX4, ref newY4);

                    arr2DPoints[i].Add(new System.Windows.Point(newX1, newY1));
                    arr2DPoints[i].Add(new System.Windows.Point(newX2, newY2));
                    arr2DPoints[i].Add(new System.Windows.Point(newX3, newY3));
                    arr2DPoints[i].Add(new System.Windows.Point(newX4, newY4));

                    fObjectHeightList.Add(fHeight);
                    fObjectWidthList.Add(fWidth);
                    fObjectCenterXList.Add(fCenterX);
                    fObjectCenterYList.Add(fCenterY);
                    fObjectAngleList.Add(fAngle);
                    fObjectAreaList.Add(intArea);
                    fObjectAreaList2.Add(intArea);

                }
                int intAngleTolerance = 10;
                bool blnDecrement = false;
                if (intTolerance >= 0)
                {
                    for (int i = 0; i < fObjectHeightList.Count; i++)
                    {
                        if (blnDecrement)
                        {
                            blnDecrement = false;
                            if (i > 0)
                                i--;
                        }
                        for (int j = 0; j < fObjectHeightList.Count; j++)
                        {
                            if (i != j && i < fObjectHeightList.Count && j < fObjectHeightList.Count)
                            {
                                if (Intersection.CheckRectRectIntersection(arr2DPoints[i].ToArray(), arr2DPoints[j].ToArray(), intTolerance))
                                {

                                    PointF[] arrPoints = new PointF[8];

                                    arrPoints[0] = arrRotatedPoints[i][0];
                                    arrPoints[1] = arrRotatedPoints[i][1];
                                    arrPoints[2] = arrRotatedPoints[i][2];
                                    arrPoints[3] = arrRotatedPoints[i][3];
                                    arrPoints[4] = arrRotatedPoints[j][0];
                                    arrPoints[5] = arrRotatedPoints[j][1];
                                    arrPoints[6] = arrRotatedPoints[j][2];
                                    arrPoints[7] = arrRotatedPoints[j][3];

                                    float fMinAngle = 0;
                                    List<PointF> arrMinRect = new List<PointF>();
                                    arrMinRect = MinimumBoundingBox.CalculateMinimumBoundingBox(arrPoints, ref fMinAngle);
                                    //fObjectAngleList[i] = 90 + fMinAngle;
                                    if (fMinAngle < 0)
                                        fObjectAngleList[i] = -(90 + fMinAngle);
                                    else
                                        fObjectAngleList[i] = 90 - fMinAngle;

                                    //if (fMinAngle < 0)
                                    //    fObjectAngleList[i] = -(90 + fMinAngle);
                                    //else
                                    //    fObjectAngleList[i] = 90 - fMinAngle;

                                    Line onjLine1 = new Line();
                                    Line onjLine2 = new Line();
                                    onjLine1.CalculateStraightLine(arrMinRect[0], arrMinRect[2]);
                                    onjLine2.CalculateStraightLine(arrMinRect[1], arrMinRect[3]);
                                    PointF pCenter = Line.GetCrossPoint(onjLine1, onjLine2);
                                    float p1X = 0, p1Y = 0;
                                    float p2X = 0, p2Y = 0;
                                    float p3X = 0, p3Y = 0;
                                    float p4X = 0, p4Y = 0;
                                    Math2.RotateWithAngleAccordingToReferencePoint(pCenter.X, pCenter.Y, arrMinRect[0].X, arrMinRect[0].Y, -fObjectAngleList[i], ref p1X, ref p1Y);
                                    Math2.RotateWithAngleAccordingToReferencePoint(pCenter.X, pCenter.Y, arrMinRect[1].X, arrMinRect[1].Y, -fObjectAngleList[i], ref p2X, ref p2Y);
                                    Math2.RotateWithAngleAccordingToReferencePoint(pCenter.X, pCenter.Y, arrMinRect[2].X, arrMinRect[2].Y, -fObjectAngleList[i], ref p3X, ref p3Y);
                                    Math2.RotateWithAngleAccordingToReferencePoint(pCenter.X, pCenter.Y, arrMinRect[3].X, arrMinRect[3].Y, -fObjectAngleList[i], ref p4X, ref p4Y);

                                    float pR1X = 0, pR1Y = 0;
                                    float pR2X = 0, pR2Y = 0;
                                    float pR3X = 0, pR3Y = 0;
                                    float pR4X = 0, pR4Y = 0;
                                    Math2.RotateWithAngleAccordingToReferencePoint(pCenter.X, pCenter.Y, Math.Min(Math.Min(p1X, p2X), Math.Min(p3X, p4X)), Math.Min(Math.Min(p1Y, p2Y), Math.Min(p3Y, p4Y)), fObjectAngleList[i], ref pR1X, ref pR1Y); // Top Left
                                    Math2.RotateWithAngleAccordingToReferencePoint(pCenter.X, pCenter.Y, Math.Max(Math.Max(p1X, p2X), Math.Max(p3X, p4X)), Math.Min(Math.Min(p1Y, p2Y), Math.Min(p3Y, p4Y)), fObjectAngleList[i], ref pR2X, ref pR2Y); // Top Right
                                    Math2.RotateWithAngleAccordingToReferencePoint(pCenter.X, pCenter.Y, Math.Max(Math.Max(p1X, p2X), Math.Max(p3X, p4X)), Math.Max(Math.Max(p1Y, p2Y), Math.Max(p3Y, p4Y)), fObjectAngleList[i], ref pR3X, ref pR3Y); // Bottom Right
                                    Math2.RotateWithAngleAccordingToReferencePoint(pCenter.X, pCenter.Y, Math.Min(Math.Min(p1X, p2X), Math.Min(p3X, p4X)), Math.Max(Math.Max(p1Y, p2Y), Math.Max(p3Y, p4Y)), fObjectAngleList[i], ref pR4X, ref pR4Y); // Bottom Left
                                    arrMinRect[0] = new PointF(pR1X, pR1Y);
                                    arrMinRect[1] = new PointF(pR2X, pR2Y);
                                    arrMinRect[2] = new PointF(pR3X, pR3Y);
                                    arrMinRect[3] = new PointF(pR4X, pR4Y);

                                    arrRotatedPoints[i][0] = arrMinRect[0];
                                    arrRotatedPoints[i][1] = arrMinRect[1];
                                    arrRotatedPoints[i][2] = arrMinRect[2];
                                    arrRotatedPoints[i][3] = arrMinRect[3];

                                    Math2.RotateWithAngleAccordingToReferencePoint(pCenter.X, pCenter.Y, Math.Min(Math.Min(p1X, p2X), Math.Min(p3X, p4X)) - intTolerance, Math.Min(Math.Min(p1Y, p2Y), Math.Min(p3Y, p4Y)) - intTolerance, fObjectAngleList[i], ref pR1X, ref pR1Y); // Top Left
                                    Math2.RotateWithAngleAccordingToReferencePoint(pCenter.X, pCenter.Y, Math.Max(Math.Max(p1X, p2X), Math.Max(p3X, p4X)) + intTolerance, Math.Min(Math.Min(p1Y, p2Y), Math.Min(p3Y, p4Y)) - intTolerance, fObjectAngleList[i], ref pR2X, ref pR2Y); // Top Right
                                    Math2.RotateWithAngleAccordingToReferencePoint(pCenter.X, pCenter.Y, Math.Max(Math.Max(p1X, p2X), Math.Max(p3X, p4X)) + intTolerance, Math.Max(Math.Max(p1Y, p2Y), Math.Max(p3Y, p4Y)) + intTolerance, fObjectAngleList[i], ref pR3X, ref pR3Y); // Bottom Right
                                    Math2.RotateWithAngleAccordingToReferencePoint(pCenter.X, pCenter.Y, Math.Min(Math.Min(p1X, p2X), Math.Min(p3X, p4X)) - intTolerance, Math.Max(Math.Max(p1Y, p2Y), Math.Max(p3Y, p4Y)) + intTolerance, fObjectAngleList[i], ref pR4X, ref pR4Y); // Bottom Left

                                    arr2DPoints[i][0] = new System.Windows.Point(pR1X, pR1Y);
                                    arr2DPoints[i][1] = new System.Windows.Point(pR2X, pR2Y);
                                    arr2DPoints[i][2] = new System.Windows.Point(pR3X, pR3Y);
                                    arr2DPoints[i][3] = new System.Windows.Point(pR4X, pR4Y);

                                    arrRotatedPoints.RemoveAt(j);
                                    arr2DPoints.RemoveAt(j);

                                    float fDiffX = Math.Max(Math.Abs(p1X - p4X), Math.Abs(p2X - p3X));
                                    float fDiffY = Math.Max(Math.Abs(p3Y - p4Y), Math.Abs(p2Y - p1Y));

                                    fObjectWidthList[i] = fDiffX;
                                    fObjectHeightList[i] = fDiffY;

                                    fObjectCenterXList[i] = pCenter.X;
                                    fObjectCenterYList[i] = pCenter.Y;

                                    fObjectAreaList2.RemoveAt(j);
                                    fObjectAreaList[i] = fObjectAreaList[i] + fObjectAreaList[j];

                                    fObjectHeightList.RemoveAt(j);
                                    fObjectWidthList.RemoveAt(j);
                                    fObjectCenterXList.RemoveAt(j);
                                    fObjectCenterYList.RemoveAt(j);
                                    fObjectAngleList.RemoveAt(j);
                                    fObjectAreaList.RemoveAt(j);

                                    if (j > 0)
                                        j = -1;
                                    if (i > 0)
                                    {
                                        i = 0;
                                    }
                                    else
                                        blnDecrement = true;

                                }

                            }
                        }
                    }
                }
                for (int i = 0; i < fObjectHeightList.Count; i++)
                {
                    if (fObjectHeightList[i] < fObjectWidthList[i])
                    {
                        float fObjectWidth = fObjectHeightList[i];
                        float fObjectHeight = fObjectWidthList[i];

                        float fObjectAngle = fObjectAngleList[i];

                        if (fObjectAngle >= 10)//&& fAngle <= 80)
                            fObjectAngle = fObjectAngleList[i] - 90;
                        else
                            fObjectAngle = 90 + fObjectAngleList[i];

                        fObjectWidthList[i] = fObjectWidth;
                        fObjectHeightList[i] = fObjectHeight;
                        fObjectAngleList[i] = fObjectAngle;
                    }
                    else
                    {
                        float fObjectHeight = fObjectHeightList[i];
                        float fObjectWidth = fObjectWidthList[i];

                        float fObjectAngle = fObjectAngleList[i];

                        fObjectWidthList[i] = fObjectWidth;
                        fObjectHeightList[i] = fObjectHeight;
                        fObjectAngleList[i] = fObjectAngle;
                    }

                    // convert width and height to mm
                    fWidthMM = fWidth / m_fMMToPixelXValue;
                    fHeightMM = fHeight / m_fMMToPixelYValue; // 11-04-2019 ZJYEOH : Changed m_fMMToPixelXValue to m_fMMToPixelYValue
                    fAreaInMM = intArea / m_fMMToPixelXValue / m_fMMToPixelYValue;

                    //if ((fWidthMM > m_fScratchLength) || (fHeightMM > m_fScratchLength) || (fAreaInMM > m_fScratchArea) &&
                    //    ((m_intFailPkgOptionMask & 0x08) > 0 || (m_intFailPkgOptionMask & 0x1000) > 0))
                    {
                        intFailCount++;
                        //0x04
                        m_intFailPkgResultMask |= 0x20000; // Fail image 1 surface contamination

                        Defect objDefect = new Defect();

                        objDefect.ref_strName = "Dark";
                        objDefect.ref_intFailMask = 0x20000;
                        objDefect.ref_fCenterX = intROIStartX + fObjectCenterXList[i];
                        objDefect.ref_fCenterY = intROIStartY + fObjectCenterYList[i];
                        objDefect.ref_fStartX = intROIStartX + (float)Math.Floor(fObjectCenterXList[i] - (fObjectWidthList[i] / 2));
                        objDefect.ref_fStartY = intROIStartY + (float)Math.Floor(fObjectCenterYList[i] - (fObjectHeightList[i] / 2));
                        objDefect.ref_fEndX = intROIStartX + (float)Math.Ceiling(fObjectCenterXList[i] + (fObjectWidthList[i] / 2));
                        objDefect.ref_fEndY = intROIStartY + (float)Math.Ceiling(fObjectCenterYList[i] + (fObjectHeightList[i] / 2));
                        objDefect.ref_fWidth = fObjectWidthList[i];
                        objDefect.ref_fHeight = fObjectHeightList[i];
                        objDefect.ref_fArea = fObjectAreaList[i];
                        objDefect.ref_fAngle = fObjectAngleList[i];
                        objDefect.ref_fWidthInMM = fWidthMM;
                        objDefect.ref_fHeightInMM = fHeightMM;
                        objDefect.ref_fAreaInMM2 = fAreaInMM;
                        objDefect.ref_intImageNo = intImageIndex; //2020-01-09 ZJYEOH : Should not fixed to 1

                        if ((m_intFailPkgOptionMask & 0x80000) > 0)
                        {
                            if (m_intDarkDefectDimensionFailCondition == 0)
                            {
                                if (fWidthMM > m_fDarkWidth)
                                {
                                    blnOverallResult = false;
                                    objDefect.ref_fWidthFailValue = fWidthMM;
                                    objDefect.ref_intFailCriteria |= 0x01;
                                }
                                if (fHeightMM > m_fDarkLength)
                                {
                                    blnOverallResult = false;
                                    objDefect.ref_fHeightFailValue = fHeightMM;
                                    objDefect.ref_intFailCriteria |= 0x02;
                                }
                            }
                            else
                            {
                                if ((fWidthMM > m_fDarkWidth) && (fHeightMM > m_fDarkLength))
                                {
                                    blnOverallResult = false;
                                    objDefect.ref_fWidthFailValue = fWidthMM;
                                    objDefect.ref_intFailCriteria |= 0x01;
                                    objDefect.ref_fHeightFailValue = fHeightMM;
                                    objDefect.ref_intFailCriteria |= 0x02;
                                }
                            }
                        }

                        if ((m_intFailPkgOptionMask & 0x40000) > 0)
                        {
                            if (fAreaInMM > m_fDarkArea)
                            {
                                blnOverallResult = false;
                                objDefect.ref_fAreaFailValue = fAreaInMM;
                                objDefect.ref_intFailCriteria |= 0x04;
                            }
                        }

                        m_arrPkgDefectList.Add(objDefect);
                    }

                }

                if ((m_intFailPkgOptionMask & 0x40000) > 0)
                {
                    fAreaInMM = intTotalArea / m_fMMToPixelXValue / m_fMMToPixelYValue;

                    if (fAreaInMM > m_fDarkTotalArea)
                    {
                        Defect objDefect = new Defect();

                        objDefect.ref_strName = "Total Dark";
                        objDefect.ref_intFailMask = 0x20000;
                        objDefect.ref_fCenterX = -1;
                        objDefect.ref_fCenterY = -1;
                        objDefect.ref_fStartX = -1;
                        objDefect.ref_fStartY = -1;
                        objDefect.ref_fEndX = -1;
                        objDefect.ref_fEndY = -1;
                        objDefect.ref_fWidth = -1;
                        objDefect.ref_fHeight = -1;
                        objDefect.ref_fArea = intTotalArea;
                        objDefect.ref_fWidthInMM = -1;
                        objDefect.ref_fHeightInMM = -1;
                        objDefect.ref_fAreaInMM2 = fAreaInMM;
                        objDefect.ref_intImageNo = intImageIndex;

                        blnOverallResult = false;
                        objDefect.ref_fAreaFailValue = fAreaInMM;
                        objDefect.ref_intFailCriteria |= 0x08;

                        m_arrPkgDefectList.Add(objDefect);

                        Defect objDefect2 = new Defect();
                        for (int a = 0; a < m_arrPkgDefectList.Count; a++)
                        {
                            objDefect2 = m_arrPkgDefectList[a];
                            if (objDefect2.ref_strName.Contains("Dark"))
                            {
                                objDefect2.ref_blnFailTotalArea = true;
                                m_arrPkgDefectList[a] = objDefect2;
                            }
                        }

                        m_intFailPkgResultMask |= 0x20000; // Fail image 1 surface total dark field

                        // Collect total extra pad for display error message
                        m_fResultDarkFieldTotalArea = fAreaInMM;
                    }
                }
            }

            objCheckAreaSampleROI.Dispose();
            return blnOverallResult;
        }
        public bool CheckPositionUsingGauge()
        {
            if (GetOverallWantGaugeMeasurePkgSize(false))
            {
                if ((Math.Abs(m_objRectGauge4L.ref_fRectAngle) > m_fAngleTolerance) ||
                ((Math.Abs(m_objRectGauge4L.ref_pRectCenterPoint.X - m_objRectGauge4L.ref_f4LGaugeCenterPointX) * m_fMMPerPixelX * m_fMMToUnitValue) > m_fXTolerance) ||
                ((Math.Abs(m_objRectGauge4L.ref_pRectCenterPoint.Y - m_objRectGauge4L.ref_f4LGaugeCenterPointY) * m_fMMPerPixelY * m_fMMToUnitValue) > m_fYTolerance))
                    return false;
            }
            else
            {
                if ((Math.Abs(m_fUnitAngle) > m_fAngleTolerance) ||
                  ((Math.Abs(m_pUnitCenterPoint.X - m_fUnitMatcherTemplateCenterX) * m_fMMPerPixelX * m_fMMToUnitValue) > m_fXTolerance) ||
                  ((Math.Abs(m_pUnitCenterPoint.Y - m_fUnitMatcherTemplateCenterY) * m_fMMPerPixelY * m_fMMToUnitValue) > m_fYTolerance))
                    return false;
            }
            return true;
        }
        public bool CheckPositionUsingGauge(bool blnCheckAngle, bool blnCheckPosX, bool blnCheckPosY)
        {
            if (GetOverallWantGaugeMeasurePkgSize(false))
            {
                if (((Math.Abs(m_objRectGauge4L.ref_fRectAngle) > m_fAngleTolerance) && blnCheckAngle) ||
                (((Math.Abs(m_objRectGauge4L.ref_pRectCenterPoint.X - m_objRectGauge4L.ref_f4LGaugeCenterPointX) * m_fMMPerPixelX * m_fMMToUnitValue) > m_fXTolerance) && blnCheckPosX) ||
                (((Math.Abs(m_objRectGauge4L.ref_pRectCenterPoint.Y - m_objRectGauge4L.ref_f4LGaugeCenterPointY) * m_fMMPerPixelY * m_fMMToUnitValue) > m_fYTolerance) && blnCheckPosY))
                    return false;
            }
            else
            {
                if (((Math.Abs(m_fUnitAngle) > m_fAngleTolerance) && blnCheckAngle) ||
                  (((Math.Abs(m_pUnitCenterPoint.X - m_fUnitMatcherTemplateCenterX) * m_fMMPerPixelX * m_fMMToUnitValue) > m_fXTolerance) && blnCheckPosX) ||
                  (((Math.Abs(m_pUnitCenterPoint.Y - m_fUnitMatcherTemplateCenterY) * m_fMMPerPixelY * m_fMMToUnitValue) > m_fYTolerance) && blnCheckPosY))
                    return false;
            }
            return true;
        }
        public void GetPositionResult(ref float Angle, ref float XTolerance, ref float YTolerance)
        {
            //2020-06-01 ZJYEOH : Return if pad not found
            if (!m_blnPadFound)
                return;

            if (GetOverallWantGaugeMeasurePkgSize(false))
            {
                Angle = m_objRectGauge4L.ref_fRectAngle;
                XTolerance = (m_objRectGauge4L.ref_pRectCenterPoint.X - m_objRectGauge4L.ref_f4LGaugeCenterPointX) * m_fMMPerPixelX * m_fMMToUnitValue;
                YTolerance = (m_objRectGauge4L.ref_pRectCenterPoint.Y - m_objRectGauge4L.ref_f4LGaugeCenterPointY) * m_fMMPerPixelY * m_fMMToUnitValue;
            }
            else
            {
                Angle = m_fUnitAngle;
                XTolerance = (m_pUnitCenterPoint.X - m_fUnitMatcherTemplateCenterX) * m_fMMPerPixelX * m_fMMToUnitValue;
                YTolerance = (m_pUnitCenterPoint.Y - m_fUnitMatcherTemplateCenterY) * m_fMMPerPixelY * m_fMMToUnitValue;
            }
        }

        public void SetPadFound(bool Found)
        {
            m_blnPadFound = Found;
        }
        public void SetPadInspected(bool Found)
        {
            m_blnPadInspected = Found;
        }
        public void DrawUnitPRResult_Rotated(Graphics g, float fDrawingScaleX, float fDrawingScaleY, Color objColor)
        {
            lock (m_objLockBlobs)
            {
                if (m_blnInspectLock)
                    return;

                try
                {
                    if (m_objMatcher.NumPositions > 0)
                    {
                        float fStartX = (m_pUnitCenterPoint.X - (float)m_objMatcher.PatternWidth / 2) * fDrawingScaleX;
                        float fStartY = (m_pUnitCenterPoint.Y - (float)m_objMatcher.PatternHeight / 2) * fDrawingScaleY;
                        // 2021 03 13 - CCENG: change from Cyan to Yellow because Unit PR Size == Pad ROI Tolerance Size which is yellow also.
                        //                   : When use gauge to find pad unit, then we draw using Pad ROI Toelrance with yellow color.
                        //                   : When no use gauge to find pad unit, then we draw using Unit PR Result with yellow color.
                        g.DrawRectangle(new Pen(objColor), fStartX, fStartY,
                                        (float)m_objMatcher.PatternWidth * fDrawingScaleX,
                                        (float)m_objMatcher.PatternHeight * fDrawingScaleY);
                    }
                }
                catch
                {
                }
            }
        }

        public void DrawUnitPRResult(Graphics g, float fDrawingScaleX, float fDrawingScaleY, Color objColor)
        {
            lock (m_objLockBlobs)
            {
                if (m_blnInspectLock)
                    return;

                try
                {
                    if (m_objMatcher.NumPositions > 0)
                        m_objMatcher.DrawPositions(g, new ERGBColor(objColor.R, objColor.G, objColor.B), false, fDrawingScaleX, fDrawingScaleY, 1f, 1f);
                }
                catch
                {
                }
            }
        }
        public void DrawUnitPRResult_Rotated_ForPadROI(Graphics g, float fDrawingScaleX, float fDrawingScaleY)
        {
            lock (m_objLockBlobs)
            {
                if (m_blnInspectLock)
                    return;

                try
                {
                    if (m_objMatcher.NumPositions > 0)
                    {
                        float fStartX = (m_pUnitCenterPoint.X - m_intPadROIStartPixelFromLeft - (float)m_objMatcher.PatternWidth / 2) * fDrawingScaleX;
                        float fStartY = (m_pUnitCenterPoint.Y - m_intPadROIStartPixelFromTop - (float)m_objMatcher.PatternHeight / 2) * fDrawingScaleY;
                        g.DrawRectangle(new Pen(Color.Yellow), fStartX, fStartY,
                                        (float)(m_objMatcher.PatternWidth + m_intPadROIStartPixelFromLeft + m_intPadROIStartPixelFromRight) * fDrawingScaleX,
                                        (float)(m_objMatcher.PatternHeight + m_intPadROIStartPixelFromTop + m_intPadROIStartPixelFromBottom) * fDrawingScaleY);
                    }
                }
                catch
                {
                }
            }
        }
        
        public float GetBrightLengthLimit(int intValueType)
        {
            switch (intValueType)
            {
                case -1: // Pixel X
                    return m_fBrightLength * m_fMMToPixelXValue;
                case -2: // Pixel Y
                    return m_fBrightLength * m_fMMToPixelYValue;
                case 1: // mm
                case 2: // mil
                case 3: // micron
                    return m_fBrightLength * m_fMMToUnitValue;
                default:
                    return 0;
            }
        }

        public float GetBrightWidthLimit(int intValueType)
        {
            switch (intValueType)
            {
                case -1: // Pixel X
                    return m_fBrightWidth * m_fMMToPixelXValue;
                case -2: // Pixel Y
                    return m_fBrightWidth * m_fMMToPixelYValue;
                case 1: // mm
                case 2: // mil
                case 3: // micron
                    return m_fBrightWidth * m_fMMToUnitValue;
                default:
                    return 0;
            }
        }

        public float GetDarkLengthLimit(int intValueType)
        {
            switch (intValueType)
            {
                case -1: // Pixel X
                    return m_fDarkLength * m_fMMToPixelXValue;
                case -2: // Pixel Y
                    return m_fDarkLength * m_fMMToPixelYValue;
                case 1: // mm
                case 2: // mil
                case 3: // micron
                    return m_fDarkLength * m_fMMToUnitValue;
                default:
                    return 0;
            }
        }
        public float GetDarkWidthLimit(int intValueType)
        {
            switch (intValueType)
            {
                case -1: // Pixel X
                    return m_fDarkWidth * m_fMMToPixelXValue;
                case -2: // Pixel Y
                    return m_fDarkWidth * m_fMMToPixelYValue;
                case 1: // mm
                case 2: // mil
                case 3: // micron
                    return m_fDarkWidth * m_fMMToUnitValue;
                default:
                    return 0;
            }
        }

        public float GetBrightAreaLimit(int intValueType)
        {
            switch (intValueType)
            {
                case 0: // Pixel
                    return m_fBrightArea * m_fMMtoPixelAreaValue;
                case 1: // mm
                case 2: // mil
                case 3: // micron
                    return m_fBrightArea * m_fMMToUnitValueArea;
                default:
                    return 0;
            }
        }

        public float GetBrightTotalAreaLimit(int intValueType)
        {
            switch (intValueType)
            {
                case 0: // Pixel
                    return m_fBrightTotalArea * m_fMMtoPixelAreaValue;
                case 1: // mm
                case 2: // mil
                case 3: // micron
                    return m_fBrightTotalArea * m_fMMToUnitValueArea;
                default:
                    return 0;
            }
        }

        public float GetDarkAreaLimit(int intValueType)
        {
            switch (intValueType)
            {
                case 0: // Pixel
                    return m_fDarkArea * m_fMMtoPixelAreaValue;
                case 1: // mm
                case 2: // mil
                case 3: // micron
                    return m_fDarkArea * m_fMMToUnitValueArea;
                default:
                    return 0;
            }
        }

        public float GetDarkTotalAreaLimit(int intValueType)
        {
            switch (intValueType)
            {
                case 0: // Pixel
                    return m_fDarkTotalArea * m_fMMtoPixelAreaValue;
                case 1: // mm
                case 2: // mil
                case 3: // micron
                    return m_fDarkTotalArea * m_fMMToUnitValueArea;
                default:
                    return 0;
            }
        }

        public float GetBrightChippedOffAreaLimit(int intValueType)
        {
            switch (intValueType)
            {
                case 0: // Pixel
                    return m_fBrightChippedOffArea * m_fMMtoPixelAreaValue;
                case 1: // mm
                case 2: // mil
                case 3: // micron
                    return m_fBrightChippedOffArea * m_fMMToUnitValueArea;
                default:
                    return 0;
            }
        }
        public float GetDarkChippedOffAreaLimit(int intValueType)
        {
            switch (intValueType)
            {
                case 0: // Pixel
                    return m_fDarkChippedOffArea * m_fMMtoPixelAreaValue;
                case 1: // mm
                case 2: // mil
                case 3: // micron
                    return m_fDarkChippedOffArea * m_fMMToUnitValueArea;
                default:
                    return 0;
            }
        }
        public float GetDarkVerticalCrackLimit(int intValueType)
        {
            switch (intValueType)
            {
                case -1: // Pixel X
                    return m_fDarkVerticalCrack * m_fMMToPixelXValue;
                case -2: // Pixel Y
                    return m_fDarkVerticalCrack * m_fMMToPixelYValue;
                case 1: // mm
                case 2: // mil
                case 3: // micron
                    return m_fDarkVerticalCrack * m_fMMToUnitValue;
                default:
                    return 0;
            }
        }

        public float GetDarkHorizontalCrackLimit(int intValueType)
        {
            switch (intValueType)
            {
                case -1: // Pixel X
                    return m_fDarkHorizontalCrack * m_fMMToPixelXValue;
                case -2: // Pixel Y
                    return m_fDarkHorizontalCrack * m_fMMToPixelYValue;
                case 1: // mm
                case 2: // mil
                case 3: // micron
                    return m_fDarkHorizontalCrack * m_fMMToUnitValue;
                default:
                    return 0;
            }
        }

        public float GetBrightVerticalForeignMaterialLimit(int intValueType)
        {
            switch (intValueType)
            {
                case -1: // Pixel X
                    return m_fBrightVerticalForeignMaterial * m_fMMToPixelXValue;
                case -2: // Pixel Y
                    return m_fBrightVerticalForeignMaterial * m_fMMToPixelYValue;
                case 1: // mm
                case 2: // mil
                case 3: // micron
                    return m_fBrightVerticalForeignMaterial * m_fMMToUnitValue;
                default:
                    return 0;
            }
        }

        public float GetBrightHorizontalForeignMaterialLimit(int intValueType)
        {
            switch (intValueType)
            {
                case -1: // Pixel X
                    return m_fBrightHorizontalForeignMaterial * m_fMMToPixelXValue;
                case -2: // Pixel Y
                    return m_fBrightHorizontalForeignMaterial * m_fMMToPixelYValue;
                case 1: // mm
                case 2: // mil
                case 3: // micron
                    return m_fBrightHorizontalForeignMaterial * m_fMMToUnitValue;
                default:
                    return 0;
            }
        }

        public void SetBrightLengthLimit(float fValue, int intFromValueType)
        {
            switch (intFromValueType)
            {
                //Note* fValue should not be converted to pixel unless the m_fMMToPixelXValue == m_fMMToPixelYValue
                //case 0: // Pixel X
                //    m_fScratchLength = fValue / m_fMMToPixelXValue;
                //    break;
                //case 1: // Pixel Y
                //    m_fScratchLength = fValue / m_fMMToPixelYValue;
                //    break;
                case 1: // mm
                case 2: // mil
                case 3: // micron
                default:
                    m_fBrightLength = fValue / m_fMMToUnitValue;
                    break;
            }
        }

        public void SetBrightWidthLimit(float fValue, int intFromValueType)
        {
            switch (intFromValueType)
            {
                //Note* fValue should not be converted to pixel unless the m_fMMToPixelXValue == m_fMMToPixelYValue
                //case 0: // Pixel X
                //    m_fScratchLength = fValue / m_fMMToPixelXValue;
                //    break;
                //case 1: // Pixel Y
                //    m_fScratchLength = fValue / m_fMMToPixelYValue;
                //    break;
                case 1: // mm
                case 2: // mil
                case 3: // micron
                default:
                    m_fBrightWidth = fValue / m_fMMToUnitValue;
                    break;
            }
        }

        public void SetBrightAreaLimit(float fValue, int intFromValueType)
        {
            switch (intFromValueType)
            {
                //Note* fValue should not be converted to pixel unless the m_fMMToPixelXValue == m_fMMToPixelYValue
                //case 0: // Pixel X
                //    m_fScratchLength = fValue / m_fMMToPixelXValue;
                //    break;
                //case 1: // Pixel Y
                //    m_fScratchLength = fValue / m_fMMToPixelYValue;
                //    break;
                case 1: // mm
                case 2: // mil
                case 3: // micron
                default:
                    m_fBrightArea = fValue / m_fMMToUnitValueArea;
                    break;
            }
        }

        public void SetBrightTotalAreaLimit(float fValue, int intFromValueType)
        {
            switch (intFromValueType)
            {
                //Note* fValue should not be converted to pixel unless the m_fMMToPixelXValue == m_fMMToPixelYValue
                //case 0: // Pixel X
                //    m_fScratchLength = fValue / m_fMMToPixelXValue;
                //    break;
                //case 1: // Pixel Y
                //    m_fScratchLength = fValue / m_fMMToPixelYValue;
                //    break;
                case 1: // mm
                case 2: // mil
                case 3: // micron
                default:
                    m_fBrightTotalArea = fValue / m_fMMToUnitValueArea;
                    break;
            }
        }

        public void SetDarkLengthLimit(float fValue, int intFromValueType)
        {
            switch (intFromValueType)
            {
                //Note* fValue should not be converted to pixel unless the m_fMMToPixelXValue == m_fMMToPixelYValue
                //case 0: // Pixel X
                //    m_fScratchLength = fValue / m_fMMToPixelXValue;
                //    break;
                //case 1: // Pixel Y
                //    m_fScratchLength = fValue / m_fMMToPixelYValue;
                //    break;
                case 1: // mm
                case 2: // mil
                case 3: // micron
                default:
                    m_fDarkLength = fValue / m_fMMToUnitValue;
                    break;
            }
        }

        public void SetDarkWidthLimit(float fValue, int intFromValueType)
        {
            switch (intFromValueType)
            {
                //Note* fValue should not be converted to pixel unless the m_fMMToPixelXValue == m_fMMToPixelYValue
                //case 0: // Pixel X
                //    m_fScratchLength = fValue / m_fMMToPixelXValue;
                //    break;
                //case 1: // Pixel Y
                //    m_fScratchLength = fValue / m_fMMToPixelYValue;
                //    break;
                case 1: // mm
                case 2: // mil
                case 3: // micron
                default:
                    m_fDarkWidth = fValue / m_fMMToUnitValue;
                    break;
            }
        }

        public void SetDarkAreaLimit(float fValue, int intFromValueType)
        {
            switch (intFromValueType)
            {
                //Note* fValue should not be converted to pixel unless the m_fMMToPixelXValue == m_fMMToPixelYValue
                //case 0: // Pixel X
                //    m_fScratchLength = fValue / m_fMMToPixelXValue;
                //    break;
                //case 1: // Pixel Y
                //    m_fScratchLength = fValue / m_fMMToPixelYValue;
                //    break;
                case 1: // mm
                case 2: // mil
                case 3: // micron
                default:
                    m_fDarkArea = fValue / m_fMMToUnitValueArea;
                    break;
            }
        }

        public void SetDarkTotalAreaLimit(float fValue, int intFromValueType)
        {
            switch (intFromValueType)
            {
                //Note* fValue should not be converted to pixel unless the m_fMMToPixelXValue == m_fMMToPixelYValue
                //case 0: // Pixel X
                //    m_fScratchLength = fValue / m_fMMToPixelXValue;
                //    break;
                //case 1: // Pixel Y
                //    m_fScratchLength = fValue / m_fMMToPixelYValue;
                //    break;
                case 1: // mm
                case 2: // mil
                case 3: // micron
                default:
                    m_fDarkTotalArea = fValue / m_fMMToUnitValueArea;
                    break;
            }
        }

        public void SetBrightChippedOffAreaLimit(float fValue, int intFromValueType)
        {
            switch (intFromValueType)
            {
                //Note* fValue should not be converted to pixel unless the m_fMMToPixelXValue == m_fMMToPixelYValue
                //case 0: // Pixel X
                //    m_fScratchLength = fValue / m_fMMToPixelXValue;
                //    break;
                //case 1: // Pixel Y
                //    m_fScratchLength = fValue / m_fMMToPixelYValue;
                //    break;
                case 1: // mm
                case 2: // mil
                case 3: // micron
                default:
                    m_fBrightChippedOffArea = fValue / m_fMMToUnitValueArea;
                    break;
            }
        }

        public void SetDarkChippedOffAreaLimit(float fValue, int intFromValueType)
        {
            switch (intFromValueType)
            {
                //Note* fValue should not be converted to pixel unless the m_fMMToPixelXValue == m_fMMToPixelYValue
                //case 0: // Pixel X
                //    m_fScratchLength = fValue / m_fMMToPixelXValue;
                //    break;
                //case 1: // Pixel Y
                //    m_fScratchLength = fValue / m_fMMToPixelYValue;
                //    break;
                case 1: // mm
                case 2: // mil
                case 3: // micron
                default:
                    m_fDarkChippedOffArea = fValue / m_fMMToUnitValueArea;
                    break;
            }
        }
        public void SetDarkVerticalCrackLimit(float fValue, int intFromValueType)
        {
            switch (intFromValueType)
            {
                //Note* fValue should not be converted to pixel unless the m_fMMToPixelXValue == m_fMMToPixelYValue
                //case 0: // Pixel X
                //    m_fScratchLength = fValue / m_fMMToPixelXValue;
                //    break;
                //case 1: // Pixel Y
                //    m_fScratchLength = fValue / m_fMMToPixelYValue;
                //    break;
                case 1: // mm
                case 2: // mil
                case 3: // micron
                default:
                    m_fDarkVerticalCrack = fValue / m_fMMToUnitValue;
                    break;
            }
        }
        public void SetDarkHorizontalCrackLimit(float fValue, int intFromValueType)
        {
            switch (intFromValueType)
            {
                //Note* fValue should not be converted to pixel unless the m_fMMToPixelXValue == m_fMMToPixelYValue
                //case 0: // Pixel X
                //    m_fScratchLength = fValue / m_fMMToPixelXValue;
                //    break;
                //case 1: // Pixel Y
                //    m_fScratchLength = fValue / m_fMMToPixelYValue;
                //    break;
                case 1: // mm
                case 2: // mil
                case 3: // micron
                default:
                    m_fDarkHorizontalCrack = fValue / m_fMMToUnitValue;
                    break;
            }
        }
        public void SetBrightVerticalForeignMaterialLimit(float fValue, int intFromValueType)
        {
            switch (intFromValueType)
            {
                //Note* fValue should not be converted to pixel unless the m_fMMToPixelXValue == m_fMMToPixelYValue
                //case 0: // Pixel X
                //    m_fScratchLength = fValue / m_fMMToPixelXValue;
                //    break;
                //case 1: // Pixel Y
                //    m_fScratchLength = fValue / m_fMMToPixelYValue;
                //    break;
                case 1: // mm
                case 2: // mil
                case 3: // micron
                default:
                    m_fBrightVerticalForeignMaterial = fValue / m_fMMToUnitValue;
                    break;
            }
        }
        public void SetBrightHorizontalForeignMaterialLimit(float fValue, int intFromValueType)
        {
            switch (intFromValueType)
            {
                //Note* fValue should not be converted to pixel unless the m_fMMToPixelXValue == m_fMMToPixelYValue
                //case 0: // Pixel X
                //    m_fScratchLength = fValue / m_fMMToPixelXValue;
                //    break;
                //case 1: // Pixel Y
                //    m_fScratchLength = fValue / m_fMMToPixelYValue;
                //    break;
                case 1: // mm
                case 2: // mil
                case 3: // micron
                default:
                    m_fBrightHorizontalForeignMaterial = fValue / m_fMMToUnitValue;
                    break;
            }
        }
        public float GetPercentageStartX(int i, float StartX, float StartY, float EndX, float EndY, int Linecount)
        {
            if (i > m_arrTemplateBlobPads.Count)
                return 0;

            BlobsFeatures m_stcBlobPad = (BlobsFeatures)m_arrTemplateBlobPads[i - 1];
            float Angle = m_stcBlobPad.fFeretAngle;

            switch (Linecount - 1)
            {
                case 0:
                    if (m_stcBlobPad.intLengthMode == 1 && !m_stcBlobPad.blnFeretActivated)
                    {
                        StartX = m_stcBlobPad.fWidthPercentStart2;
                        EndX = m_stcBlobPad.fWidthPercentEnd2;
                        StartY = m_stcBlobPad.fHeightPercentStart2;
                        EndY = m_stcBlobPad.fHeightPercentEnd2;
                    }
                    else if (m_stcBlobPad.intLengthMode == 2 && !m_stcBlobPad.blnFeretActivated)
                    {
                        StartX = m_stcBlobPad.fWidthPercentStart1;
                        EndX = m_stcBlobPad.fWidthPercentEnd1;
                        StartY = m_stcBlobPad.fHeightPercentStart1;
                        EndY = m_stcBlobPad.fHeightPercentEnd1;
                    }
                    //if ((Angle <= 85 && Angle >= -85) && m_stcBlobPad.blnFeretActivated)
                    //{
                    //    StartX = m_stcBlobPad.fWidthPercentStart2;
                    //    EndX = m_stcBlobPad.fWidthPercentEnd2;
                    //    StartY = m_stcBlobPad.fHeightPercentStart2;
                    //    EndY = m_stcBlobPad.fHeightPercentEnd2;
                    //}
                    //else if ((Angle > 85 || Angle < -85) && m_stcBlobPad.blnFeretActivated)
                    //{
                    //    StartX = m_stcBlobPad.fWidthPercentStart1;
                    //    EndX = m_stcBlobPad.fWidthPercentEnd1;
                    //    StartY = m_stcBlobPad.fHeightPercentStart1;
                    //    EndY = m_stcBlobPad.fHeightPercentEnd1;
                    //}
                    if (m_stcBlobPad.blnFeretActivated)
                    {
                        if (m_stcBlobPad.intLengthMode == 1)
                        {
                            StartX = m_stcBlobPad.fWidthPercentStart2;
                            EndX = m_stcBlobPad.fWidthPercentEnd2;
                            StartY = m_stcBlobPad.fHeightPercentStart2;
                            EndY = m_stcBlobPad.fHeightPercentEnd2;
                        }
                        else
                        {
                            StartX = m_stcBlobPad.fWidthPercentStart1;
                            EndX = m_stcBlobPad.fWidthPercentEnd1;
                            StartY = m_stcBlobPad.fHeightPercentStart1;
                            EndY = m_stcBlobPad.fHeightPercentEnd1;
                        }
                    }
                    break;

                case 1:
                    if (m_stcBlobPad.intLengthMode == 1 && !m_stcBlobPad.blnFeretActivated)
                    {
                        StartX = m_stcBlobPad.fWidthPercentStart1;
                        EndX = m_stcBlobPad.fWidthPercentEnd1;
                        StartY = m_stcBlobPad.fHeightPercentStart1;
                        EndY = m_stcBlobPad.fHeightPercentEnd1;
                    }
                    else if (m_stcBlobPad.intLengthMode == 2 && !m_stcBlobPad.blnFeretActivated)
                    {
                        StartX = m_stcBlobPad.fWidthPercentStart2;
                        EndX = m_stcBlobPad.fWidthPercentEnd2;
                        StartY = m_stcBlobPad.fHeightPercentStart2;
                        EndY = m_stcBlobPad.fHeightPercentEnd2;
                    }
                    //if ((Angle <= 85 && Angle >= -85) && m_stcBlobPad.blnFeretActivated)
                    //{
                    //    StartX = m_stcBlobPad.fWidthPercentStart1;
                    //    EndX = m_stcBlobPad.fWidthPercentEnd1;
                    //    StartY = m_stcBlobPad.fHeightPercentStart1;
                    //    EndY = m_stcBlobPad.fHeightPercentEnd1;
                    //}
                    //else if ((Angle > 85 || Angle < -85) && m_stcBlobPad.blnFeretActivated)
                    //{
                    //    StartX = m_stcBlobPad.fWidthPercentStart2;
                    //    EndX = m_stcBlobPad.fWidthPercentEnd2;
                    //    StartY = m_stcBlobPad.fHeightPercentStart2;
                    //    EndY = m_stcBlobPad.fHeightPercentEnd2;
                    //}
                    if (m_stcBlobPad.blnFeretActivated)
                    {
                        if (m_stcBlobPad.intLengthMode == 1)
                        {
                            StartX = m_stcBlobPad.fWidthPercentStart1;
                            EndX = m_stcBlobPad.fWidthPercentEnd1;
                            StartY = m_stcBlobPad.fHeightPercentStart1;
                            EndY = m_stcBlobPad.fHeightPercentEnd1;
                        }
                        else
                        {
                            StartX = m_stcBlobPad.fWidthPercentStart2;
                            EndX = m_stcBlobPad.fWidthPercentEnd2;
                            StartY = m_stcBlobPad.fHeightPercentStart2;
                            EndY = m_stcBlobPad.fHeightPercentEnd2;
                        }
                    }
                    break;


                case 2:
                    StartX = m_stcBlobPad.fWidthPercentStart3;
                    EndX = m_stcBlobPad.fWidthPercentEnd3;
                    StartY = m_stcBlobPad.fHeightPercentStart3;
                    EndY = m_stcBlobPad.fHeightPercentEnd3;
                    break;

                case 3:
                    StartX = m_stcBlobPad.fWidthPercentStart4;
                    EndX = m_stcBlobPad.fWidthPercentEnd4;
                    StartY = m_stcBlobPad.fHeightPercentStart4;
                    EndY = m_stcBlobPad.fHeightPercentEnd4;
                    break;

                case 4:
                    StartX = m_stcBlobPad.fWidthPercentStart5;
                    EndX = m_stcBlobPad.fWidthPercentEnd5;
                    StartY = m_stcBlobPad.fHeightPercentStart5;
                    EndY = m_stcBlobPad.fHeightPercentEnd5;
                    break;

                case 5:
                    StartX = m_stcBlobPad.fWidthPercentStart6;
                    EndX = m_stcBlobPad.fWidthPercentEnd6;
                    StartY = m_stcBlobPad.fHeightPercentStart6;
                    EndY = m_stcBlobPad.fHeightPercentEnd6;
                    break;

                case 6:
                    StartX = m_stcBlobPad.fWidthPercentStart7;
                    EndX = m_stcBlobPad.fWidthPercentEnd7;
                    StartY = m_stcBlobPad.fHeightPercentStart7;
                    EndY = m_stcBlobPad.fHeightPercentEnd7;
                    break;

                case 7:
                    StartX = m_stcBlobPad.fWidthPercentStart8;
                    EndX = m_stcBlobPad.fWidthPercentEnd8;
                    StartY = m_stcBlobPad.fHeightPercentStart8;
                    EndY = m_stcBlobPad.fHeightPercentEnd8;
                    break;

                case 8:
                    StartX = m_stcBlobPad.fWidthPercentStart9;
                    EndX = m_stcBlobPad.fWidthPercentEnd9;
                    StartY = m_stcBlobPad.fHeightPercentStart9;
                    EndY = m_stcBlobPad.fHeightPercentEnd9;
                    break;

                case 9:
                    StartX = m_stcBlobPad.fWidthPercentStart10;
                    EndX = m_stcBlobPad.fWidthPercentEnd10;
                    StartY = m_stcBlobPad.fHeightPercentStart10;
                    EndY = m_stcBlobPad.fHeightPercentEnd10;
                    break;

                case 10:
                    StartX = m_stcBlobPad.fWidthPercentStart11;
                    EndX = m_stcBlobPad.fWidthPercentEnd11;
                    StartY = m_stcBlobPad.fHeightPercentStart11;
                    EndY = m_stcBlobPad.fHeightPercentEnd11;
                    break;

                case 11:
                    StartX = m_stcBlobPad.fWidthPercentStart12;
                    EndX = m_stcBlobPad.fWidthPercentEnd12;
                    StartY = m_stcBlobPad.fHeightPercentStart12;
                    EndY = m_stcBlobPad.fHeightPercentEnd12;
                    break;
            }
            return StartX;
        }

        public void GetPercentage(int i, ref List<float> StartX, ref List<float> StartY, ref List<float> EndX, ref List<float> EndY, int Linecount, ref List<float> InwardStart, ref List<float> InwardEnd, ref List<int> MeasureMethod)
        {
            if (i > m_arrTemplateBlobPads.Count)
                return;

            BlobsFeatures m_stcBlobPad = (BlobsFeatures)m_arrTemplateBlobPads[i - 1];
            float Angle = m_stcBlobPad.fFeretAngle;

            switch (Linecount - 1)
            {
                case 0:
                    if (m_stcBlobPad.intLengthMode == 1 && !m_stcBlobPad.blnFeretActivated)
                    {
                        StartX[Linecount - 1] = m_stcBlobPad.fWidthPercentStart2;
                        EndX[Linecount - 1] = m_stcBlobPad.fWidthPercentEnd2;
                        StartY[Linecount - 1] = m_stcBlobPad.fHeightPercentStart2;
                        EndY[Linecount - 1] = m_stcBlobPad.fHeightPercentEnd2;
                        InwardStart[Linecount - 1] = m_stcBlobPad.fInwardPercentStart2;
                        InwardEnd[Linecount - 1] = m_stcBlobPad.fInwardPercentEnd2;
                        MeasureMethod[Linecount - 1] = m_stcBlobPad.intMeasureMethod2;
                    }
                    else if (m_stcBlobPad.intLengthMode == 2 && !m_stcBlobPad.blnFeretActivated)
                    {
                        StartX[Linecount - 1] = m_stcBlobPad.fWidthPercentStart1;
                        EndX[Linecount - 1] = m_stcBlobPad.fWidthPercentEnd1;
                        StartY[Linecount - 1] = m_stcBlobPad.fHeightPercentStart1;
                        EndY[Linecount - 1] = m_stcBlobPad.fHeightPercentEnd1;
                        InwardStart[Linecount - 1] = m_stcBlobPad.fInwardPercentStart1;
                        InwardEnd[Linecount - 1] = m_stcBlobPad.fInwardPercentEnd1;
                        MeasureMethod[Linecount - 1] = m_stcBlobPad.intMeasureMethod1;
                    }
                    //if ((Angle <= 85 && Angle >= -85) && m_stcBlobPad.blnFeretActivated)
                    //{
                    //    StartX = m_stcBlobPad.fWidthPercentStart2;
                    //    EndX = m_stcBlobPad.fWidthPercentEnd2;
                    //    StartY = m_stcBlobPad.fHeightPercentStart2;
                    //    EndY = m_stcBlobPad.fHeightPercentEnd2;
                    //}
                    //else if ((Angle > 85 || Angle < -85) && m_stcBlobPad.blnFeretActivated)
                    //{
                    //    StartX = m_stcBlobPad.fWidthPercentStart1;
                    //    EndX = m_stcBlobPad.fWidthPercentEnd1;
                    //    StartY = m_stcBlobPad.fHeightPercentStart1;
                    //    EndY = m_stcBlobPad.fHeightPercentEnd1;
                    //}
                    if (m_stcBlobPad.blnFeretActivated)
                    {
                        //if (m_stcBlobPad.intLengthMode == 1)
                        //{
                        //    StartX[Linecount - 1] = m_stcBlobPad.fHeightPercentStart1;
                        //    EndX[Linecount - 1] = m_stcBlobPad.fHeightPercentEnd1;
                        //    StartY[Linecount - 1] = m_stcBlobPad.fWidthPercentStart1;
                        //    EndY[Linecount - 1] = m_stcBlobPad.fWidthPercentStart1;
                        //}
                        //else
                        {
                            StartX[Linecount - 1] = m_stcBlobPad.fWidthPercentStart1;
                            EndX[Linecount - 1] = m_stcBlobPad.fWidthPercentEnd1;
                            StartY[Linecount - 1] = m_stcBlobPad.fHeightPercentStart1;
                            EndY[Linecount - 1] = m_stcBlobPad.fHeightPercentEnd1;
                            InwardStart[Linecount - 1] = m_stcBlobPad.fInwardPercentStart1;
                            InwardEnd[Linecount - 1] = m_stcBlobPad.fInwardPercentEnd1;
                            MeasureMethod[Linecount - 1] = m_stcBlobPad.intMeasureMethod1;
                        }
                    }
                    break;

                case 1:
                    if (m_stcBlobPad.intLengthMode == 1 && !m_stcBlobPad.blnFeretActivated)
                    {
                        StartX[Linecount - 1] = m_stcBlobPad.fWidthPercentStart1;
                        EndX[Linecount - 1] = m_stcBlobPad.fWidthPercentEnd1;
                        StartY[Linecount - 1] = m_stcBlobPad.fHeightPercentStart1;
                        EndY[Linecount - 1] = m_stcBlobPad.fHeightPercentEnd1;
                        InwardStart[Linecount - 1] = m_stcBlobPad.fInwardPercentStart1;
                        InwardEnd[Linecount - 1] = m_stcBlobPad.fInwardPercentEnd1;
                        MeasureMethod[Linecount - 1] = m_stcBlobPad.intMeasureMethod1;
                    }
                    else if (m_stcBlobPad.intLengthMode == 2 && !m_stcBlobPad.blnFeretActivated)
                    {
                        StartX[Linecount - 1] = m_stcBlobPad.fWidthPercentStart2;
                        EndX[Linecount - 1] = m_stcBlobPad.fWidthPercentEnd2;
                        StartY[Linecount - 1] = m_stcBlobPad.fHeightPercentStart2;
                        EndY[Linecount - 1] = m_stcBlobPad.fHeightPercentEnd2;
                        InwardStart[Linecount - 1] = m_stcBlobPad.fInwardPercentStart2;
                        InwardEnd[Linecount - 1] = m_stcBlobPad.fInwardPercentEnd2;
                        MeasureMethod[Linecount - 1] = m_stcBlobPad.intMeasureMethod2;
                    }
                    //if ((Angle <= 85 && Angle >= -85) && m_stcBlobPad.blnFeretActivated)
                    //{
                    //    StartX = m_stcBlobPad.fWidthPercentStart1;
                    //    EndX = m_stcBlobPad.fWidthPercentEnd1;
                    //    StartY = m_stcBlobPad.fHeightPercentStart1;
                    //    EndY = m_stcBlobPad.fHeightPercentEnd1;
                    //}
                    //else if ((Angle > 85 || Angle < -85) && m_stcBlobPad.blnFeretActivated)
                    //{
                    //    StartX = m_stcBlobPad.fWidthPercentStart2;
                    //    EndX = m_stcBlobPad.fWidthPercentEnd2;
                    //    StartY = m_stcBlobPad.fHeightPercentStart2;
                    //    EndY = m_stcBlobPad.fHeightPercentEnd2;
                    //}
                    if (m_stcBlobPad.blnFeretActivated)
                    {
                        //if (m_stcBlobPad.intLengthMode == 1)
                        //{
                        //    StartX[Linecount - 1] = m_stcBlobPad.fHeightPercentStart2;
                        //    EndX[Linecount - 1] = m_stcBlobPad.fHeightPercentEnd2;
                        //    StartY[Linecount - 1] = m_stcBlobPad.fWidthPercentStart2;
                        //    EndY[Linecount - 1] = m_stcBlobPad.fWidthPercentEnd2;
                        //}
                        //else
                        {
                            StartX[Linecount - 1] = m_stcBlobPad.fWidthPercentStart2;
                            EndX[Linecount - 1] = m_stcBlobPad.fWidthPercentEnd2;
                            StartY[Linecount - 1] = m_stcBlobPad.fHeightPercentStart2;
                            EndY[Linecount - 1] = m_stcBlobPad.fHeightPercentEnd2;
                            InwardStart[Linecount - 1] = m_stcBlobPad.fInwardPercentStart2;
                            InwardEnd[Linecount - 1] = m_stcBlobPad.fInwardPercentEnd2;
                            MeasureMethod[Linecount - 1] = m_stcBlobPad.intMeasureMethod2;
                        }
                    }
                    break;


                case 2:
                    StartX[Linecount - 1] = m_stcBlobPad.fWidthPercentStart3;
                    EndX[Linecount - 1] = m_stcBlobPad.fWidthPercentEnd3;
                    StartY[Linecount - 1] = m_stcBlobPad.fHeightPercentStart3;
                    EndY[Linecount - 1] = m_stcBlobPad.fHeightPercentEnd3;
                    InwardStart[Linecount - 1] = m_stcBlobPad.fInwardPercentStart3;
                    InwardEnd[Linecount - 1] = m_stcBlobPad.fInwardPercentEnd3;
                    MeasureMethod[Linecount - 1] = m_stcBlobPad.intMeasureMethod3;
                    break;

                case 3:
                    StartX[Linecount - 1] = m_stcBlobPad.fWidthPercentStart4;
                    EndX[Linecount - 1] = m_stcBlobPad.fWidthPercentEnd4;
                    StartY[Linecount - 1] = m_stcBlobPad.fHeightPercentStart4;
                    EndY[Linecount - 1] = m_stcBlobPad.fHeightPercentEnd4;
                    InwardStart[Linecount - 1] = m_stcBlobPad.fInwardPercentStart4;
                    InwardEnd[Linecount - 1] = m_stcBlobPad.fInwardPercentEnd4;
                    MeasureMethod[Linecount - 1] = m_stcBlobPad.intMeasureMethod4;
                    break;

                case 4:
                    StartX[Linecount - 1] = m_stcBlobPad.fWidthPercentStart5;
                    EndX[Linecount - 1] = m_stcBlobPad.fWidthPercentEnd5;
                    StartY[Linecount - 1] = m_stcBlobPad.fHeightPercentStart5;
                    EndY[Linecount - 1] = m_stcBlobPad.fHeightPercentEnd5;
                    InwardStart[Linecount - 1] = m_stcBlobPad.fInwardPercentStart5;
                    InwardEnd[Linecount - 1] = m_stcBlobPad.fInwardPercentEnd5;
                    MeasureMethod[Linecount - 1] = m_stcBlobPad.intMeasureMethod5;
                    break;

                case 5:
                    StartX[Linecount - 1] = m_stcBlobPad.fWidthPercentStart6;
                    EndX[Linecount - 1] = m_stcBlobPad.fWidthPercentEnd6;
                    StartY[Linecount - 1] = m_stcBlobPad.fHeightPercentStart6;
                    EndY[Linecount - 1] = m_stcBlobPad.fHeightPercentEnd6;
                    InwardStart[Linecount - 1] = m_stcBlobPad.fInwardPercentStart6;
                    InwardEnd[Linecount - 1] = m_stcBlobPad.fInwardPercentEnd6;
                    MeasureMethod[Linecount - 1] = m_stcBlobPad.intMeasureMethod6;
                    break;

                case 6:
                    StartX[Linecount - 1] = m_stcBlobPad.fWidthPercentStart7;
                    EndX[Linecount - 1] = m_stcBlobPad.fWidthPercentEnd7;
                    StartY[Linecount - 1] = m_stcBlobPad.fHeightPercentStart7;
                    EndY[Linecount - 1] = m_stcBlobPad.fHeightPercentEnd7;
                    InwardStart[Linecount - 1] = m_stcBlobPad.fInwardPercentStart7;
                    InwardEnd[Linecount - 1] = m_stcBlobPad.fInwardPercentEnd7;
                    MeasureMethod[Linecount - 1] = m_stcBlobPad.intMeasureMethod7;
                    break;

                case 7:
                    StartX[Linecount - 1] = m_stcBlobPad.fWidthPercentStart8;
                    EndX[Linecount - 1] = m_stcBlobPad.fWidthPercentEnd8;
                    StartY[Linecount - 1] = m_stcBlobPad.fHeightPercentStart8;
                    EndY[Linecount - 1] = m_stcBlobPad.fHeightPercentEnd8;
                    InwardStart[Linecount - 1] = m_stcBlobPad.fInwardPercentStart8;
                    InwardEnd[Linecount - 1] = m_stcBlobPad.fInwardPercentEnd8;
                    MeasureMethod[Linecount - 1] = m_stcBlobPad.intMeasureMethod8;
                    break;

                case 8:
                    StartX[Linecount - 1] = m_stcBlobPad.fWidthPercentStart9;
                    EndX[Linecount - 1] = m_stcBlobPad.fWidthPercentEnd9;
                    StartY[Linecount - 1] = m_stcBlobPad.fHeightPercentStart9;
                    EndY[Linecount - 1] = m_stcBlobPad.fHeightPercentEnd9;
                    InwardStart[Linecount - 1] = m_stcBlobPad.fInwardPercentStart9;
                    InwardEnd[Linecount - 1] = m_stcBlobPad.fInwardPercentEnd9;
                    MeasureMethod[Linecount - 1] = m_stcBlobPad.intMeasureMethod9;
                    break;

                case 9:
                    StartX[Linecount - 1] = m_stcBlobPad.fWidthPercentStart10;
                    EndX[Linecount - 1] = m_stcBlobPad.fWidthPercentEnd10;
                    StartY[Linecount - 1] = m_stcBlobPad.fHeightPercentStart10;
                    EndY[Linecount - 1] = m_stcBlobPad.fHeightPercentEnd10;
                    InwardStart[Linecount - 1] = m_stcBlobPad.fInwardPercentStart10;
                    InwardEnd[Linecount - 1] = m_stcBlobPad.fInwardPercentEnd10;
                    MeasureMethod[Linecount - 1] = m_stcBlobPad.intMeasureMethod10;
                    break;

                case 10:
                    StartX[Linecount - 1] = m_stcBlobPad.fWidthPercentStart11;
                    EndX[Linecount - 1] = m_stcBlobPad.fWidthPercentEnd11;
                    StartY[Linecount - 1] = m_stcBlobPad.fHeightPercentStart11;
                    EndY[Linecount - 1] = m_stcBlobPad.fHeightPercentEnd11;
                    InwardStart[Linecount - 1] = m_stcBlobPad.fInwardPercentStart11;
                    InwardEnd[Linecount - 1] = m_stcBlobPad.fInwardPercentEnd11;
                    MeasureMethod[Linecount - 1] = m_stcBlobPad.intMeasureMethod11;
                    break;

                case 11:
                    StartX[Linecount - 1] = m_stcBlobPad.fWidthPercentStart12;
                    EndX[Linecount - 1] = m_stcBlobPad.fWidthPercentEnd12;
                    StartY[Linecount - 1] = m_stcBlobPad.fHeightPercentStart12;
                    EndY[Linecount - 1] = m_stcBlobPad.fHeightPercentEnd12;
                    InwardStart[Linecount - 1] = m_stcBlobPad.fInwardPercentStart12;
                    InwardEnd[Linecount - 1] = m_stcBlobPad.fInwardPercentEnd12;
                    MeasureMethod[Linecount - 1] = m_stcBlobPad.intMeasureMethod12;
                    break;
            }
        }


        public void ClearSplitLineDragHandler(Graphics g, ref List<PointF> start, ref List<PointF> end, ref PointF hit)
        {
            //m_objSplitPadLine.DrawLine(g, 1, 1);
            start = m_objSplitPadLine.ref_pStartPoint2;
            end = m_objSplitPadLine.ref_pEndPoint2;
            hit = m_objSplitPadLine.ref_pHitPoint2;
            //SetROI((int)start.X, (int)start.Y, (int)end.X, (int)end.Y);
            m_objSplitPadLine.ClearDragHandler();
        }
        public void SetROI(int x1, int y1, int x2, int y2, int i, float fInwardStart, float fInwardEnd)
        {
            m_objSplitPadLine.SetROIPlacement2(x1, y1, x2, y2, i, fInwardStart, fInwardEnd);
        }
        public void SetInwardPercent(int i, float fInwardStart, float fInwardEnd)
        {
            m_objSplitPadLine.SetInwardPercent(i, fInwardStart, fInwardEnd);
        }
        public void ClearPoints()
        {
            m_objSplitPadLine.ClearAllPoints();
        }
        public void RemoveLine(int intLineCount)
        {
            m_objSplitPadLine.RemoveLastLine(intLineCount);
        }


        public void SetPercentage(int i, float StartX, float StartY, float EndX, float EndY, int Linecount, float InwardStart, float InwardEnd, int intMeasureMethod, float fAngle)
        {
            if (i > m_arrTemplateBlobPads.Count)
                return;
            BlobsFeatures stcBlobsFeatures = new BlobsFeatures();
            BlobsFeatures m_stcBlobPad = (BlobsFeatures)m_arrTemplateBlobPads[i - 1];
            m_stcBlobPad.intLineCount = Linecount + 1;
            m_intMaxExtraLineCount = m_stcBlobPad.intLineCount;
            float Angle = m_stcBlobPad.fFeretAngle;

            switch (Linecount)
            {
                case 0:
                    if (m_stcBlobPad.intLengthMode == 1 && !m_stcBlobPad.blnFeretActivated)
                    {
                        m_stcBlobPad.fWidthPercentStart2 = StartX;//0
                        m_stcBlobPad.fWidthPercentEnd2 = EndX;//0
                        m_stcBlobPad.fHeightPercentStart2 = StartY;
                        m_stcBlobPad.fHeightPercentEnd2 = EndY;
                        m_stcBlobPad.fInwardPercentStart2 = InwardStart;
                        m_stcBlobPad.fInwardPercentEnd2 = InwardEnd;
                        m_stcBlobPad.intMeasureMethod2 = intMeasureMethod;
                    }
                    else if (m_stcBlobPad.intLengthMode == 2 && !m_stcBlobPad.blnFeretActivated)
                    {
                        m_stcBlobPad.fWidthPercentStart1 = StartX;//0
                        m_stcBlobPad.fWidthPercentEnd1 = EndX;//0
                        m_stcBlobPad.fHeightPercentStart1 = StartY;
                        m_stcBlobPad.fHeightPercentEnd1 = EndY;
                        m_stcBlobPad.fInwardPercentStart1 = InwardStart;
                        m_stcBlobPad.fInwardPercentEnd1 = InwardEnd;
                        m_stcBlobPad.intMeasureMethod1 = intMeasureMethod;
                    }
                    //if ((Angle <= 85 && Angle >= -85) && m_stcBlobPad.blnFeretActivated)
                    //{
                    //    //m_stcBlobPad.fWidthPercentStart1 = StartX;
                    //    //m_stcBlobPad.fWidthPercentEnd1 = EndX;
                    //    m_stcBlobPad.fHeightPercentStart2 = StartY;
                    //    m_stcBlobPad.fHeightPercentEnd2 = EndY;
                    //}
                    //else if ((Angle > 85 || Angle < -85) && m_stcBlobPad.blnFeretActivated)
                    //{
                    //    //m_stcBlobPad.fWidthPercentStart1 = StartX;
                    //    //m_stcBlobPad.fWidthPercentEnd1 = EndX;
                    //    m_stcBlobPad.fHeightPercentStart1 = StartY;
                    //    m_stcBlobPad.fHeightPercentEnd1 = EndY;
                    //}
                    if (m_stcBlobPad.blnFeretActivated)
                    {
                        m_stcBlobPad.fWidthPercentStart1 = StartX;
                        m_stcBlobPad.fWidthPercentEnd1 = EndX;
                        m_stcBlobPad.fHeightPercentStart1 = StartY;
                        m_stcBlobPad.fHeightPercentEnd1 = EndY;
                        m_stcBlobPad.fInwardPercentStart1 = InwardStart;
                        m_stcBlobPad.fInwardPercentEnd1 = InwardEnd;
                        m_stcBlobPad.intMeasureMethod1 = intMeasureMethod;
                    }
                    break;

                case 1:
                    if (m_stcBlobPad.intLengthMode == 1 && !m_stcBlobPad.blnFeretActivated)
                    {
                        m_stcBlobPad.fWidthPercentStart1 = StartX;
                        m_stcBlobPad.fWidthPercentEnd1 = EndX;
                        m_stcBlobPad.fHeightPercentStart1 = StartY;//0
                        m_stcBlobPad.fHeightPercentEnd1 = EndY;//0
                        m_stcBlobPad.fInwardPercentStart1 = InwardStart;
                        m_stcBlobPad.fInwardPercentEnd1 = InwardEnd;
                        m_stcBlobPad.intMeasureMethod1 = intMeasureMethod;
                    }
                    else if (m_stcBlobPad.intLengthMode == 2 && !m_stcBlobPad.blnFeretActivated)
                    {
                        m_stcBlobPad.fWidthPercentStart2 = StartX;
                        m_stcBlobPad.fWidthPercentEnd2 = EndX;
                        m_stcBlobPad.fHeightPercentStart2 = StartY;//0
                        m_stcBlobPad.fHeightPercentEnd2 = EndY;//0
                        m_stcBlobPad.fInwardPercentStart2 = InwardStart;
                        m_stcBlobPad.fInwardPercentEnd2 = InwardEnd;
                        m_stcBlobPad.intMeasureMethod2 = intMeasureMethod;
                    }
                    //if ((Angle <= 85 && Angle >= -85) && m_stcBlobPad.blnFeretActivated)
                    //{
                    //    //m_stcBlobPad.fWidthPercentStart1 = StartX;
                    //    //m_stcBlobPad.fWidthPercentEnd1 = EndX;
                    //    m_stcBlobPad.fHeightPercentStart2 = StartY;
                    //    m_stcBlobPad.fHeightPercentEnd2 = EndY;
                    //}
                    //else if ((Angle > 85 || Angle < -85) && m_stcBlobPad.blnFeretActivated)
                    //{
                    //    //m_stcBlobPad.fWidthPercentStart2 = StartX;
                    //    //m_stcBlobPad.fWidthPercentEnd2 = EndX;
                    //    m_stcBlobPad.fHeightPercentStart2 = StartY;
                    //    m_stcBlobPad.fHeightPercentEnd2 = EndY;
                    //}
                    if (m_stcBlobPad.blnFeretActivated)
                    {
                        m_stcBlobPad.fWidthPercentStart2 = StartX;
                        m_stcBlobPad.fWidthPercentEnd2 = EndX;
                        m_stcBlobPad.fHeightPercentStart2 = StartY;
                        m_stcBlobPad.fHeightPercentEnd2 = EndY;
                        m_stcBlobPad.fInwardPercentStart2 = InwardStart;
                        m_stcBlobPad.fInwardPercentEnd2 = InwardEnd;
                        m_stcBlobPad.intMeasureMethod2 = intMeasureMethod;
                    }
                    break;

                case 2:
                    m_stcBlobPad.fWidthPercentStart3 = StartX;
                    m_stcBlobPad.fWidthPercentEnd3 = EndX;
                    m_stcBlobPad.fHeightPercentStart3 = StartY;
                    m_stcBlobPad.fHeightPercentEnd3 = EndY;
                    m_stcBlobPad.fInwardPercentStart3 = InwardStart;
                    m_stcBlobPad.fInwardPercentEnd3 = InwardEnd;
                    m_stcBlobPad.intMeasureMethod3 = intMeasureMethod;
                    break;

                case 3:
                    m_stcBlobPad.fWidthPercentStart4 = StartX;
                    m_stcBlobPad.fWidthPercentEnd4 = EndX;
                    m_stcBlobPad.fHeightPercentStart4 = StartY;
                    m_stcBlobPad.fHeightPercentEnd4 = EndY;
                    m_stcBlobPad.fInwardPercentStart4 = InwardStart;
                    m_stcBlobPad.fInwardPercentEnd4 = InwardEnd;
                    m_stcBlobPad.intMeasureMethod4 = intMeasureMethod;
                    break;

                case 4:
                    m_stcBlobPad.fWidthPercentStart5 = StartX;
                    m_stcBlobPad.fWidthPercentEnd5 = EndX;
                    m_stcBlobPad.fHeightPercentStart5 = StartY;
                    m_stcBlobPad.fHeightPercentEnd5 = EndY;
                    m_stcBlobPad.fInwardPercentStart5 = InwardStart;
                    m_stcBlobPad.fInwardPercentEnd5 = InwardEnd;
                    m_stcBlobPad.intMeasureMethod5 = intMeasureMethod;
                    break;

                case 5:
                    m_stcBlobPad.fWidthPercentStart6 = StartX;
                    m_stcBlobPad.fWidthPercentEnd6 = EndX;
                    m_stcBlobPad.fHeightPercentStart6 = StartY;
                    m_stcBlobPad.fHeightPercentEnd6 = EndY;
                    m_stcBlobPad.fInwardPercentStart6 = InwardStart;
                    m_stcBlobPad.fInwardPercentEnd6 = InwardEnd;
                    m_stcBlobPad.intMeasureMethod6 = intMeasureMethod;
                    break;

                case 6:
                    m_stcBlobPad.fWidthPercentStart7 = StartX;
                    m_stcBlobPad.fWidthPercentEnd7 = EndX;
                    m_stcBlobPad.fHeightPercentStart7 = StartY;
                    m_stcBlobPad.fHeightPercentEnd7 = EndY;
                    m_stcBlobPad.fInwardPercentStart7 = InwardStart;
                    m_stcBlobPad.fInwardPercentEnd7 = InwardEnd;
                    m_stcBlobPad.intMeasureMethod7 = intMeasureMethod;
                    break;

                case 7:
                    m_stcBlobPad.fWidthPercentStart8 = StartX;
                    m_stcBlobPad.fWidthPercentEnd8 = EndX;
                    m_stcBlobPad.fHeightPercentStart8 = StartY;
                    m_stcBlobPad.fHeightPercentEnd8 = EndY;
                    m_stcBlobPad.fInwardPercentStart8 = InwardStart;
                    m_stcBlobPad.fInwardPercentEnd8 = InwardEnd;
                    m_stcBlobPad.intMeasureMethod8 = intMeasureMethod;
                    break;

                case 8:
                    m_stcBlobPad.fWidthPercentStart9 = StartX;
                    m_stcBlobPad.fWidthPercentEnd9 = EndX;
                    m_stcBlobPad.fHeightPercentStart9 = StartY;
                    m_stcBlobPad.fHeightPercentEnd9 = EndY;
                    m_stcBlobPad.fInwardPercentStart9 = InwardStart;
                    m_stcBlobPad.fInwardPercentEnd9 = InwardEnd;
                    m_stcBlobPad.intMeasureMethod9 = intMeasureMethod;
                    break;

                case 9:
                    m_stcBlobPad.fWidthPercentStart10 = StartX;
                    m_stcBlobPad.fWidthPercentEnd10 = EndX;
                    m_stcBlobPad.fHeightPercentStart10 = StartY;
                    m_stcBlobPad.fHeightPercentEnd10 = EndY;
                    m_stcBlobPad.fInwardPercentStart10 = InwardStart;
                    m_stcBlobPad.fInwardPercentEnd10 = InwardEnd;
                    m_stcBlobPad.intMeasureMethod10 = intMeasureMethod;
                    break;

                case 10:
                    m_stcBlobPad.fWidthPercentStart11 = StartX;
                    m_stcBlobPad.fWidthPercentEnd11 = EndX;
                    m_stcBlobPad.fHeightPercentStart11 = StartY;
                    m_stcBlobPad.fHeightPercentEnd11 = EndY;
                    m_stcBlobPad.fInwardPercentStart11 = InwardStart;
                    m_stcBlobPad.fInwardPercentEnd11 = InwardEnd;
                    m_stcBlobPad.intMeasureMethod11 = intMeasureMethod;
                    break;

                case 11:
                    m_stcBlobPad.fWidthPercentStart12 = StartX;
                    m_stcBlobPad.fWidthPercentEnd12 = EndX;
                    m_stcBlobPad.fHeightPercentStart12 = StartY;
                    m_stcBlobPad.fHeightPercentEnd12 = EndY;
                    m_stcBlobPad.fInwardPercentStart12 = InwardStart;
                    m_stcBlobPad.fInwardPercentEnd12 = InwardEnd;
                    m_stcBlobPad.intMeasureMethod12 = intMeasureMethod;
                    break;
            }
            m_stcBlobPad.fAngle = fAngle;
            stcBlobsFeatures = m_stcBlobPad;
            m_arrTemplateBlobPads[i - 1] = stcBlobsFeatures;

            //XmlParser objFile = new XmlParser(strPath, blnNewFile);

            //objFile.WriteSectionElement(strSectionName, blnNewSection);
            //objFile.WriteElement1Value("BlobsFeatures" + (i - 1).ToString(), "");
            //objFile.WriteElement2Value("PercentWidthStart1", m_stcBlobPad.fWidthPercentStart1);
            //objFile.WriteElement2Value("PercentHeightStart1", m_stcBlobPad.fHeightPercentStart1);
            //objFile.WriteElement2Value("PercentWidthEnd1", m_stcBlobPad.fWidthPercentEnd1);
            //objFile.WriteElement2Value("PercentHeightEnd1", m_stcBlobPad.fHeightPercentEnd1);
            //objFile.WriteElement2Value("PercentWidthStart2", m_stcBlobPad.fWidthPercentStart2);
            //objFile.WriteElement2Value("PercentHeightStart2", m_stcBlobPad.fHeightPercentStart2);
            //objFile.WriteElement2Value("PercentWidthEnd2", m_stcBlobPad.fWidthPercentEnd2);
            //objFile.WriteElement2Value("PercentHeightEnd2", m_stcBlobPad.fHeightPercentEnd2);
            //objFile.WriteElement2Value("PercentWidthStart3", m_stcBlobPad.fWidthPercentStart3);
            //objFile.WriteElement2Value("PercentHeightStart3", m_stcBlobPad.fHeightPercentStart3);
            //objFile.WriteElement2Value("PercentWidthEnd3", m_stcBlobPad.fWidthPercentEnd3);
            //objFile.WriteElement2Value("PercentHeightEnd3", m_stcBlobPad.fHeightPercentEnd3);
            //objFile.WriteElement2Value("PercentWidthStart4", m_stcBlobPad.fWidthPercentStart4);
            //objFile.WriteElement2Value("PercentHeightStart4", m_stcBlobPad.fHeightPercentStart4);
            //objFile.WriteElement2Value("PercentWidthEnd4", m_stcBlobPad.fWidthPercentEnd4);
            //objFile.WriteElement2Value("PercentHeightEnd4", m_stcBlobPad.fHeightPercentEnd4);
            //objFile.WriteElement2Value("PercentWidthStart5", m_stcBlobPad.fWidthPercentStart5);
            //objFile.WriteElement2Value("PercentHeightStart5", m_stcBlobPad.fHeightPercentStart5);
            //objFile.WriteElement2Value("PercentWidthEnd5", m_stcBlobPad.fWidthPercentEnd5);
            //objFile.WriteElement2Value("PercentHeightEnd5", m_stcBlobPad.fHeightPercentEnd5);
            //objFile.WriteElement2Value("PercentWidthStart6", m_stcBlobPad.fWidthPercentStart6);
            //objFile.WriteElement2Value("PercentHeightStart6", m_stcBlobPad.fHeightPercentStart6);
            //objFile.WriteElement2Value("PercentWidthEnd6", m_stcBlobPad.fWidthPercentEnd6);
            //objFile.WriteElement2Value("PercentHeightEnd6", m_stcBlobPad.fHeightPercentEnd6);
            //objFile.WriteElement2Value("PercentWidthStart7", m_stcBlobPad.fWidthPercentStart7);
            //objFile.WriteElement2Value("PercentHeightStart7", m_stcBlobPad.fHeightPercentStart7);
            //objFile.WriteElement2Value("PercentWidthEnd7", m_stcBlobPad.fWidthPercentEnd7);
            //objFile.WriteElement2Value("PercentHeightEnd7", m_stcBlobPad.fHeightPercentEnd7);

            //objFile.WriteEndElement();


        }
        public bool SplitLineHitTest(int intPositionX, int intPositionY, Graphics g)
        {
            // if (m_blnIsSplitLineDisplaying)
            // {
            //  m_objSplitPadLine.DrawLine(g, 1, 1);
            if (m_objSplitPadLine.HitTest2(intPositionX, intPositionY))
            {
                //Cursor.Current = Cursors.SizeAll;
                return true;
            }
            else
            {
                Cursor.Current = Cursors.Default;
                return false;
            }

            //return m_objSplitPadLine.HitTest2(intPositionX, intPositionY);
            // }

            //  return false;
        }

        public bool SplitLineWillHitTest(int intPositionX, int intPositionY, Graphics g, int x, int y, int w, int h)
        {
            // if (m_blnIsSplitLineDisplaying)
            // {
            //  m_objSplitPadLine.DrawLine(g, 1, 1);
            if (m_objSplitPadLine.WillHitTest2(intPositionX, intPositionY, x, y, w, h))
            {
                //Cursor.Current = Cursors.SizeAll;
                return true;
            }
            else
            {
                Cursor.Current = Cursors.Default;
                return false;
            }

            //return m_objSplitPadLine.HitTest2(intPositionX, intPositionY);
            // }

            //  return false;
        }

        public void DragSplitLine(int intPositionX, int intPositionY, int intSelectedPadNo, Graphics g, int intRoiOrgX, int intRoiOrgY, int x, int y, int w, int h)
        {
            // if (m_blnIsSplitLineDisplaying)
            // {
            int i = intSelectedPadNo;

            BlobsFeatures m_stcBlobPad = (BlobsFeatures)m_arrTemplateBlobPads[i - 1];
            //System.Drawing.Point p1 = new System.Drawing.Point(intRoiOrgX + (int)Math.Round(m_stcBlobPad.fLimitCenterX - m_stcBlobPad.fWidth / 2), intRoiOrgY + (int)Math.Round(m_stcBlobPad.fLimitCenterY - m_stcBlobPad.fHeight / 2));

            //int intStartX = (int)p1.X;
            //int intStartY = (int)p1.Y;
            //int intEndX = (int)p1.X+(int)Math.Round(m_stcBlobPad.fWidth);
            //int intEndY = (int)p1.Y + (int)Math.Round(m_stcBlobPad.fHeight);

            int intStartX = (int)0;// x;
            int intStartY = (int)0;// y;
            int intEndX = (int)w;// x + w;
            int intEndY = (int)h;// y + h;

            ROI objROI = new ROI();
            objROI.LoadROISetting(intStartX, intStartY, intEndX - intStartX, intEndY - intStartY);
            // if (m_blnSplitHorizontal)
            m_objSplitPadLine.Drag2(objROI, intPositionX, intPositionY);
            // m_objSplitPadLine.DrawLine(g, 1, 1);
            //  else
            //  m_objSplitPadLine.DragY(intStartX, intEndX, intPositionX);
            objROI.Dispose();
            //  m_objSplitPadLine.DrawLine(g, 1, 1);
            //}
        }

        public void DrawLines(Graphics g, float fDrawingScaleX, float fDrawingScaleY, int intRoiOrgX, int intRoiOrgY, int i, bool greenfirst, float fAngle, int intMeasureMethod)
        {

            //m_stcBlobPad = (BlobsFeatures)m_arrTemplateBlobPads[i - 1];

            //System.Drawing.Point p1 = new System.Drawing.Point(intRoiOrgX + (int)Math.Round(m_stcBlobPad.fLimitCenterX - m_stcBlobPad.fWidth / 2), intRoiOrgY + (int)Math.Round(m_stcBlobPad.fLimitCenterY - m_stcBlobPad.fHeight / 2));
            //System.Drawing.Point p2 = new System.Drawing.Point(intRoiOrgX + (int)Math.Round(m_stcBlobPad.fLimitCenterX + m_stcBlobPad.fWidth / 2), intRoiOrgY + (int)Math.Round(m_stcBlobPad.fLimitCenterY - m_stcBlobPad.fHeight / 2));
            //System.Drawing.Point p3 = new System.Drawing.Point(intRoiOrgX + (int)Math.Round(m_stcBlobPad.fLimitCenterX + m_stcBlobPad.fWidth / 2), intRoiOrgY + (int)Math.Round(m_stcBlobPad.fLimitCenterY + m_stcBlobPad.fHeight / 2));
            //System.Drawing.Point p4 = new System.Drawing.Point(intRoiOrgX + (int)Math.Round(m_stcBlobPad.fLimitCenterX - m_stcBlobPad.fWidth / 2), intRoiOrgY + (int)Math.Round(m_stcBlobPad.fLimitCenterY + m_stcBlobPad.fHeight / 2));

            //if (fDrawingScaleX != 1f || fDrawingScaleY != 1f)
            //{
            //    p1.X = (int)Math.Round((float)p1.X * fDrawingScaleX, 0, MidpointRounding.AwayFromZero);
            //    p1.Y = (int)Math.Round((float)p1.Y * fDrawingScaleY, 0, MidpointRounding.AwayFromZero);
            //    p2.X = (int)Math.Round((float)p2.X * fDrawingScaleX, 0, MidpointRounding.AwayFromZero);
            //    p2.Y = (int)Math.Round((float)p2.Y * fDrawingScaleY, 0, MidpointRounding.AwayFromZero);
            //    p3.X = (int)Math.Round((float)p3.X * fDrawingScaleX, 0, MidpointRounding.AwayFromZero);
            //    p3.Y = (int)Math.Round((float)p3.Y * fDrawingScaleY, 0, MidpointRounding.AwayFromZero);
            //    p4.X = (int)Math.Round((float)p4.X * fDrawingScaleX, 0, MidpointRounding.AwayFromZero);
            //    p4.Y = (int)Math.Round((float)p4.Y * fDrawingScaleY, 0, MidpointRounding.AwayFromZero);
            //}

            //if (m_stcBlobPad.intLengthMode == 1)
            //{
            //    g.DrawLine(new Pen(Color.Blue, 2), p1.X, (p1.Y + p4.Y) / 2, p2.X, (p2.Y + p3.Y) / 2);
            //    g.DrawLine(new Pen(Color.Lime, 2), (p1.X + p2.X) / 2, p1.Y, (p3.X + p4.X) / 2, p3.Y);
            //}
            //else
            //{
            //    g.DrawLine(new Pen(Color.Lime, 2), 0, 100, 200, 100);
            //    g.DrawLine(new Pen(Color.Blue, 2), 100, 0, 100, 200);
            //}

            //m_objSplitPadLine.SetROIPlacement(50, 50 + m_intCounttt, 200, 50);
            //m_intCounttt++;
            //if (m_intCounttt > 10)
            //{
            //    m_intCounttt = 0;
            //    if (m_intTurn == 0)
            //        m_intTurn = 1;
            //    else
            //        m_intTurn = 0;
            //}
            //if (m_intTurn == 0)



            m_objSplitPadLine.DrawLine2(g, 1, 1, i, greenfirst, fAngle, intMeasureMethod);
            //else
            // m_objSplitPadLine.DrawLine2(g, 1, 1);

        }

        public void EnableDisableFeret(int intSelectedIndex, bool blnEnable)
        {
            BlobsFeatures m_stcBlobPad = (BlobsFeatures)m_arrTemplateBlobPads[intSelectedIndex];

            m_stcBlobPad.blnFeretActivated = blnEnable;

            m_arrTemplateBlobPads.RemoveAt(intSelectedIndex);
            m_arrTemplateBlobPads.Insert(intSelectedIndex, m_stcBlobPad);
        }

        public bool IsFeretActivated(int intSelectedIndex)
        {
            return ((BlobsFeatures)m_arrTemplateBlobPads[intSelectedIndex]).blnFeretActivated;
        }
        public void LoadTemporaryBlobPadsForReset()
        {
            ClearTemplateBlobsFeatures();

            for (int i = 0; i < m_arrTemporaryBlobPads_ForReset.Count; i++)
            {
                BlobsFeatures stcBlobsFeatures = (BlobsFeatures)m_arrTemporaryBlobPads_ForReset[i];

                m_arrTemplateBlobPads.Add(stcBlobsFeatures);
            }
        }
        public void LoadPercentageTemporary(string strPath, string strSectionName)
        {
            // Load Pad Blobs Features
            int intBlobsCount = Math.Min(m_arrTemporaryBlobPads.Count, m_arrTemplateBlobPads.Count);
            for (int i = 0; i < intBlobsCount; i++)
            {
                BlobsFeatures stcBlobsFeatures = (BlobsFeatures)m_arrTemporaryBlobPads[i];
                BlobsFeatures m_stcBlobPad = (BlobsFeatures)m_arrTemplateBlobPads[i]; //m_arrTemplateBlobPads

                m_stcBlobPad.fWidthPercentStart1 = stcBlobsFeatures.fWidthPercentStart1;
                m_stcBlobPad.fHeightPercentStart1 = stcBlobsFeatures.fHeightPercentStart1;
                m_stcBlobPad.fWidthPercentEnd1 = stcBlobsFeatures.fWidthPercentEnd1;
                m_stcBlobPad.fHeightPercentEnd1 = stcBlobsFeatures.fHeightPercentEnd1;
                m_stcBlobPad.fWidthPercentStart2 = stcBlobsFeatures.fWidthPercentStart2;
                m_stcBlobPad.fHeightPercentStart2 = stcBlobsFeatures.fHeightPercentStart2;
                m_stcBlobPad.fWidthPercentEnd2 = stcBlobsFeatures.fWidthPercentEnd2;
                m_stcBlobPad.fHeightPercentEnd2 = stcBlobsFeatures.fHeightPercentEnd2;
                m_stcBlobPad.fWidthPercentStart3 = stcBlobsFeatures.fWidthPercentStart3;
                m_stcBlobPad.fHeightPercentStart3 = stcBlobsFeatures.fHeightPercentStart3;
                m_stcBlobPad.fWidthPercentEnd3 = stcBlobsFeatures.fWidthPercentEnd3;
                m_stcBlobPad.fHeightPercentEnd3 = stcBlobsFeatures.fHeightPercentEnd3;
                m_stcBlobPad.fWidthPercentStart4 = stcBlobsFeatures.fWidthPercentStart4;
                m_stcBlobPad.fHeightPercentStart4 = stcBlobsFeatures.fHeightPercentStart4;
                m_stcBlobPad.fWidthPercentEnd4 = stcBlobsFeatures.fWidthPercentEnd4;
                m_stcBlobPad.fHeightPercentEnd4 = stcBlobsFeatures.fHeightPercentEnd4;
                m_stcBlobPad.fWidthPercentStart5 = stcBlobsFeatures.fWidthPercentStart5;
                m_stcBlobPad.fHeightPercentStart5 = stcBlobsFeatures.fHeightPercentStart5;
                m_stcBlobPad.fWidthPercentEnd5 = stcBlobsFeatures.fWidthPercentEnd5;
                m_stcBlobPad.fHeightPercentEnd5 = stcBlobsFeatures.fHeightPercentEnd5;
                m_stcBlobPad.fWidthPercentStart6 = stcBlobsFeatures.fWidthPercentStart6;
                m_stcBlobPad.fHeightPercentStart6 = stcBlobsFeatures.fHeightPercentStart6;
                m_stcBlobPad.fWidthPercentEnd6 = stcBlobsFeatures.fWidthPercentEnd6;
                m_stcBlobPad.fHeightPercentEnd6 = stcBlobsFeatures.fHeightPercentEnd6;
                m_stcBlobPad.fWidthPercentStart7 = stcBlobsFeatures.fWidthPercentStart7;
                m_stcBlobPad.fHeightPercentStart7 = stcBlobsFeatures.fHeightPercentStart7;
                m_stcBlobPad.fWidthPercentEnd7 = stcBlobsFeatures.fWidthPercentEnd7;
                m_stcBlobPad.fHeightPercentEnd7 = stcBlobsFeatures.fHeightPercentEnd7;
                m_stcBlobPad.fWidthPercentStart8 = stcBlobsFeatures.fWidthPercentStart8;
                m_stcBlobPad.fHeightPercentStart8 = stcBlobsFeatures.fHeightPercentStart8;
                m_stcBlobPad.fWidthPercentEnd8 = stcBlobsFeatures.fWidthPercentEnd8;
                m_stcBlobPad.fHeightPercentEnd8 = stcBlobsFeatures.fHeightPercentEnd8;
                m_stcBlobPad.fWidthPercentStart9 = stcBlobsFeatures.fWidthPercentStart9;
                m_stcBlobPad.fHeightPercentStart9 = stcBlobsFeatures.fHeightPercentStart9;
                m_stcBlobPad.fWidthPercentEnd9 = stcBlobsFeatures.fWidthPercentEnd9;
                m_stcBlobPad.fHeightPercentEnd9 = stcBlobsFeatures.fHeightPercentEnd9;
                m_stcBlobPad.fWidthPercentStart10 = stcBlobsFeatures.fWidthPercentStart10;
                m_stcBlobPad.fHeightPercentStart10 = stcBlobsFeatures.fHeightPercentStart10;
                m_stcBlobPad.fWidthPercentEnd10 = stcBlobsFeatures.fWidthPercentEnd10;
                m_stcBlobPad.fHeightPercentEnd10 = stcBlobsFeatures.fHeightPercentEnd10;
                m_stcBlobPad.fWidthPercentStart11 = stcBlobsFeatures.fWidthPercentStart11;
                m_stcBlobPad.fHeightPercentStart11 = stcBlobsFeatures.fHeightPercentStart11;
                m_stcBlobPad.fWidthPercentEnd11 = stcBlobsFeatures.fWidthPercentEnd11;
                m_stcBlobPad.fHeightPercentEnd11 = stcBlobsFeatures.fHeightPercentEnd11;
                m_stcBlobPad.fWidthPercentStart12 = stcBlobsFeatures.fWidthPercentStart12;
                m_stcBlobPad.fHeightPercentStart12 = stcBlobsFeatures.fHeightPercentStart12;
                m_stcBlobPad.fWidthPercentEnd12 = stcBlobsFeatures.fWidthPercentEnd12;
                m_stcBlobPad.fHeightPercentEnd12 = stcBlobsFeatures.fHeightPercentEnd12;

                m_stcBlobPad.fInwardPercentStart1 = stcBlobsFeatures.fInwardPercentStart1;
                m_stcBlobPad.fInwardPercentEnd1 = stcBlobsFeatures.fInwardPercentEnd1;
                m_stcBlobPad.fInwardPercentStart2 = stcBlobsFeatures.fInwardPercentStart2;
                m_stcBlobPad.fInwardPercentEnd2 = stcBlobsFeatures.fInwardPercentEnd2;
                m_stcBlobPad.fInwardPercentStart3 = stcBlobsFeatures.fInwardPercentStart3;
                m_stcBlobPad.fInwardPercentEnd3 = stcBlobsFeatures.fInwardPercentEnd3;
                m_stcBlobPad.fInwardPercentStart4 = stcBlobsFeatures.fInwardPercentStart4;
                m_stcBlobPad.fInwardPercentEnd4 = stcBlobsFeatures.fInwardPercentEnd4;
                m_stcBlobPad.fInwardPercentStart5 = stcBlobsFeatures.fInwardPercentStart5;
                m_stcBlobPad.fInwardPercentEnd5 = stcBlobsFeatures.fInwardPercentEnd5;
                m_stcBlobPad.fInwardPercentStart6 = stcBlobsFeatures.fInwardPercentStart6;
                m_stcBlobPad.fInwardPercentEnd6 = stcBlobsFeatures.fInwardPercentEnd6;
                m_stcBlobPad.fInwardPercentStart7 = stcBlobsFeatures.fInwardPercentStart7;
                m_stcBlobPad.fInwardPercentEnd7 = stcBlobsFeatures.fInwardPercentEnd7;
                m_stcBlobPad.fInwardPercentStart8 = stcBlobsFeatures.fInwardPercentStart8;
                m_stcBlobPad.fInwardPercentEnd8 = stcBlobsFeatures.fInwardPercentEnd8;
                m_stcBlobPad.fInwardPercentStart9 = stcBlobsFeatures.fInwardPercentStart9;
                m_stcBlobPad.fInwardPercentEnd9 = stcBlobsFeatures.fInwardPercentEnd9;
                m_stcBlobPad.fInwardPercentStart10 = stcBlobsFeatures.fInwardPercentStart10;
                m_stcBlobPad.fInwardPercentEnd10 = stcBlobsFeatures.fInwardPercentEnd10;
                m_stcBlobPad.fInwardPercentStart11 = stcBlobsFeatures.fInwardPercentStart11;
                m_stcBlobPad.fInwardPercentEnd11 = stcBlobsFeatures.fInwardPercentEnd11;
                m_stcBlobPad.fInwardPercentStart12 = stcBlobsFeatures.fInwardPercentStart12;
                m_stcBlobPad.fInwardPercentEnd12 = stcBlobsFeatures.fInwardPercentEnd12;

                m_stcBlobPad.intMeasureMethod1 = stcBlobsFeatures.intMeasureMethod1;
                m_stcBlobPad.intMeasureMethod2 = stcBlobsFeatures.intMeasureMethod2;
                m_stcBlobPad.intMeasureMethod3 = stcBlobsFeatures.intMeasureMethod3;
                m_stcBlobPad.intMeasureMethod4 = stcBlobsFeatures.intMeasureMethod4;
                m_stcBlobPad.intMeasureMethod5 = stcBlobsFeatures.intMeasureMethod5;
                m_stcBlobPad.intMeasureMethod6 = stcBlobsFeatures.intMeasureMethod6;
                m_stcBlobPad.intMeasureMethod7 = stcBlobsFeatures.intMeasureMethod7;
                m_stcBlobPad.intMeasureMethod8 = stcBlobsFeatures.intMeasureMethod8;
                m_stcBlobPad.intMeasureMethod9 = stcBlobsFeatures.intMeasureMethod9;
                m_stcBlobPad.intMeasureMethod10 = stcBlobsFeatures.intMeasureMethod10;
                m_stcBlobPad.intMeasureMethod11 = stcBlobsFeatures.intMeasureMethod11;
                m_stcBlobPad.intMeasureMethod12 = stcBlobsFeatures.intMeasureMethod12;

                m_stcBlobPad.fAngle = stcBlobsFeatures.fAngle;

                m_stcBlobPad.intLineCount = stcBlobsFeatures.intLineCount;
                m_stcBlobPad.blnFeretActivated = stcBlobsFeatures.blnFeretActivated;
                
                m_stcBlobPad.fMinLine3 = stcBlobsFeatures.fMinLine3;
                m_stcBlobPad.fMaxLine3 = stcBlobsFeatures.fMaxLine3;
                m_stcBlobPad.fMinLine4 = stcBlobsFeatures.fMinLine4;
                m_stcBlobPad.fMaxLine4 = stcBlobsFeatures.fMaxLine4;
                m_stcBlobPad.fMinLine5 = stcBlobsFeatures.fMinLine5;
                m_stcBlobPad.fMaxLine5 = stcBlobsFeatures.fMaxLine5;
                m_stcBlobPad.fMinLine6 = stcBlobsFeatures.fMinLine6;
                m_stcBlobPad.fMaxLine6 = stcBlobsFeatures.fMaxLine6;
                m_stcBlobPad.fMinLine7 = stcBlobsFeatures.fMinLine7;
                m_stcBlobPad.fMaxLine7 = stcBlobsFeatures.fMaxLine7;
                m_stcBlobPad.fMinLine8 = stcBlobsFeatures.fMinLine8;
                m_stcBlobPad.fMaxLine8 = stcBlobsFeatures.fMaxLine8;
                m_stcBlobPad.fMinLine9 = stcBlobsFeatures.fMinLine9;
                m_stcBlobPad.fMaxLine9 = stcBlobsFeatures.fMaxLine9;
                m_stcBlobPad.fMinLine10 = stcBlobsFeatures.fMinLine10;
                m_stcBlobPad.fMaxLine10 = stcBlobsFeatures.fMaxLine10;
                m_stcBlobPad.fMinLine11 = stcBlobsFeatures.fMinLine11;
                m_stcBlobPad.fMaxLine11 = stcBlobsFeatures.fMaxLine11;
                m_stcBlobPad.fMinLine12 = stcBlobsFeatures.fMinLine12;
                m_stcBlobPad.fMaxLine12 = stcBlobsFeatures.fMaxLine12;

                m_stcBlobPad.intReferTopBottom = stcBlobsFeatures.intReferTopBottom;
                m_stcBlobPad.blnCheckTop = stcBlobsFeatures.blnCheckTop;
                m_stcBlobPad.blnCheckBottom = stcBlobsFeatures.blnCheckBottom;
                m_stcBlobPad.intReferLeftRight = stcBlobsFeatures.intReferLeftRight;
                m_stcBlobPad.blnCheckLeft = stcBlobsFeatures.blnCheckLeft;
                m_stcBlobPad.blnCheckRight = stcBlobsFeatures.blnCheckRight;

                // Load previous template length mode to current learnt template length mode
                m_stcBlobPad.intLengthMode = stcBlobsFeatures.intLengthMode;
                m_stcBlobPad.intFeretLengthMode = stcBlobsFeatures.intFeretLengthMode;

                stcBlobsFeatures = m_stcBlobPad;
                m_arrTemplateBlobPads[i] = stcBlobsFeatures;
            }
        }
        public void LoadPercentageTemporary_ByNumber(string strPath, string strSectionName)
        {

            // Load Pad Blobs Features
            int intBlobsCount = Math.Min(m_arrTemporaryBlobPads.Count, m_arrTemplateBlobPads.Count);
            List<int> arrSkip = new List<int>();
            for (int i = 0; i < intBlobsCount; i++)
            {
                if (arrSkip.Contains(i))
                    continue;
                
                BlobsFeatures m_stcBlobPad = (BlobsFeatures)m_arrTemplateBlobPads[i]; //m_arrTemplateBlobPads

                for (int j = 0; j < intBlobsCount; j++)
                {
                    if (arrSkip.Contains(j))
                        continue;
                    BlobsFeatures stcBlobsFeatures = (BlobsFeatures)m_arrTemporaryBlobPads[j];
                    if (m_stcBlobPad.intNoID == stcBlobsFeatures.intNoID)
                    {
                        m_stcBlobPad.fWidthPercentStart1 = stcBlobsFeatures.fWidthPercentStart1;
                        m_stcBlobPad.fHeightPercentStart1 = stcBlobsFeatures.fHeightPercentStart1;
                        m_stcBlobPad.fWidthPercentEnd1 = stcBlobsFeatures.fWidthPercentEnd1;
                        m_stcBlobPad.fHeightPercentEnd1 = stcBlobsFeatures.fHeightPercentEnd1;
                        m_stcBlobPad.fWidthPercentStart2 = stcBlobsFeatures.fWidthPercentStart2;
                        m_stcBlobPad.fHeightPercentStart2 = stcBlobsFeatures.fHeightPercentStart2;
                        m_stcBlobPad.fWidthPercentEnd2 = stcBlobsFeatures.fWidthPercentEnd2;
                        m_stcBlobPad.fHeightPercentEnd2 = stcBlobsFeatures.fHeightPercentEnd2;
                        m_stcBlobPad.fWidthPercentStart3 = stcBlobsFeatures.fWidthPercentStart3;
                        m_stcBlobPad.fHeightPercentStart3 = stcBlobsFeatures.fHeightPercentStart3;
                        m_stcBlobPad.fWidthPercentEnd3 = stcBlobsFeatures.fWidthPercentEnd3;
                        m_stcBlobPad.fHeightPercentEnd3 = stcBlobsFeatures.fHeightPercentEnd3;
                        m_stcBlobPad.fWidthPercentStart4 = stcBlobsFeatures.fWidthPercentStart4;
                        m_stcBlobPad.fHeightPercentStart4 = stcBlobsFeatures.fHeightPercentStart4;
                        m_stcBlobPad.fWidthPercentEnd4 = stcBlobsFeatures.fWidthPercentEnd4;
                        m_stcBlobPad.fHeightPercentEnd4 = stcBlobsFeatures.fHeightPercentEnd4;
                        m_stcBlobPad.fWidthPercentStart5 = stcBlobsFeatures.fWidthPercentStart5;
                        m_stcBlobPad.fHeightPercentStart5 = stcBlobsFeatures.fHeightPercentStart5;
                        m_stcBlobPad.fWidthPercentEnd5 = stcBlobsFeatures.fWidthPercentEnd5;
                        m_stcBlobPad.fHeightPercentEnd5 = stcBlobsFeatures.fHeightPercentEnd5;
                        m_stcBlobPad.fWidthPercentStart6 = stcBlobsFeatures.fWidthPercentStart6;
                        m_stcBlobPad.fHeightPercentStart6 = stcBlobsFeatures.fHeightPercentStart6;
                        m_stcBlobPad.fWidthPercentEnd6 = stcBlobsFeatures.fWidthPercentEnd6;
                        m_stcBlobPad.fHeightPercentEnd6 = stcBlobsFeatures.fHeightPercentEnd6;
                        m_stcBlobPad.fWidthPercentStart7 = stcBlobsFeatures.fWidthPercentStart7;
                        m_stcBlobPad.fHeightPercentStart7 = stcBlobsFeatures.fHeightPercentStart7;
                        m_stcBlobPad.fWidthPercentEnd7 = stcBlobsFeatures.fWidthPercentEnd7;
                        m_stcBlobPad.fHeightPercentEnd7 = stcBlobsFeatures.fHeightPercentEnd7;
                        m_stcBlobPad.fWidthPercentStart8 = stcBlobsFeatures.fWidthPercentStart8;
                        m_stcBlobPad.fHeightPercentStart8 = stcBlobsFeatures.fHeightPercentStart8;
                        m_stcBlobPad.fWidthPercentEnd8 = stcBlobsFeatures.fWidthPercentEnd8;
                        m_stcBlobPad.fHeightPercentEnd8 = stcBlobsFeatures.fHeightPercentEnd8;
                        m_stcBlobPad.fWidthPercentStart9 = stcBlobsFeatures.fWidthPercentStart9;
                        m_stcBlobPad.fHeightPercentStart9 = stcBlobsFeatures.fHeightPercentStart9;
                        m_stcBlobPad.fWidthPercentEnd9 = stcBlobsFeatures.fWidthPercentEnd9;
                        m_stcBlobPad.fHeightPercentEnd9 = stcBlobsFeatures.fHeightPercentEnd9;
                        m_stcBlobPad.fWidthPercentStart10 = stcBlobsFeatures.fWidthPercentStart10;
                        m_stcBlobPad.fHeightPercentStart10 = stcBlobsFeatures.fHeightPercentStart10;
                        m_stcBlobPad.fWidthPercentEnd10 = stcBlobsFeatures.fWidthPercentEnd10;
                        m_stcBlobPad.fHeightPercentEnd10 = stcBlobsFeatures.fHeightPercentEnd10;
                        m_stcBlobPad.fWidthPercentStart11 = stcBlobsFeatures.fWidthPercentStart11;
                        m_stcBlobPad.fHeightPercentStart11 = stcBlobsFeatures.fHeightPercentStart11;
                        m_stcBlobPad.fWidthPercentEnd11 = stcBlobsFeatures.fWidthPercentEnd11;
                        m_stcBlobPad.fHeightPercentEnd11 = stcBlobsFeatures.fHeightPercentEnd11;
                        m_stcBlobPad.fWidthPercentStart12 = stcBlobsFeatures.fWidthPercentStart12;
                        m_stcBlobPad.fHeightPercentStart12 = stcBlobsFeatures.fHeightPercentStart12;
                        m_stcBlobPad.fWidthPercentEnd12 = stcBlobsFeatures.fWidthPercentEnd12;
                        m_stcBlobPad.fHeightPercentEnd12 = stcBlobsFeatures.fHeightPercentEnd12;

                        m_stcBlobPad.fInwardPercentStart1 = stcBlobsFeatures.fInwardPercentStart1;
                        m_stcBlobPad.fInwardPercentEnd1 = stcBlobsFeatures.fInwardPercentEnd1;
                        m_stcBlobPad.fInwardPercentStart2 = stcBlobsFeatures.fInwardPercentStart2;
                        m_stcBlobPad.fInwardPercentEnd2 = stcBlobsFeatures.fInwardPercentEnd2;
                        m_stcBlobPad.fInwardPercentStart3 = stcBlobsFeatures.fInwardPercentStart3;
                        m_stcBlobPad.fInwardPercentEnd3 = stcBlobsFeatures.fInwardPercentEnd3;
                        m_stcBlobPad.fInwardPercentStart4 = stcBlobsFeatures.fInwardPercentStart4;
                        m_stcBlobPad.fInwardPercentEnd4 = stcBlobsFeatures.fInwardPercentEnd4;
                        m_stcBlobPad.fInwardPercentStart5 = stcBlobsFeatures.fInwardPercentStart5;
                        m_stcBlobPad.fInwardPercentEnd5 = stcBlobsFeatures.fInwardPercentEnd5;
                        m_stcBlobPad.fInwardPercentStart6 = stcBlobsFeatures.fInwardPercentStart6;
                        m_stcBlobPad.fInwardPercentEnd6 = stcBlobsFeatures.fInwardPercentEnd6;
                        m_stcBlobPad.fInwardPercentStart7 = stcBlobsFeatures.fInwardPercentStart7;
                        m_stcBlobPad.fInwardPercentEnd7 = stcBlobsFeatures.fInwardPercentEnd7;
                        m_stcBlobPad.fInwardPercentStart8 = stcBlobsFeatures.fInwardPercentStart8;
                        m_stcBlobPad.fInwardPercentEnd8 = stcBlobsFeatures.fInwardPercentEnd8;
                        m_stcBlobPad.fInwardPercentStart9 = stcBlobsFeatures.fInwardPercentStart9;
                        m_stcBlobPad.fInwardPercentEnd9 = stcBlobsFeatures.fInwardPercentEnd9;
                        m_stcBlobPad.fInwardPercentStart10 = stcBlobsFeatures.fInwardPercentStart10;
                        m_stcBlobPad.fInwardPercentEnd10 = stcBlobsFeatures.fInwardPercentEnd10;
                        m_stcBlobPad.fInwardPercentStart11 = stcBlobsFeatures.fInwardPercentStart11;
                        m_stcBlobPad.fInwardPercentEnd11 = stcBlobsFeatures.fInwardPercentEnd11;
                        m_stcBlobPad.fInwardPercentStart12 = stcBlobsFeatures.fInwardPercentStart12;
                        m_stcBlobPad.fInwardPercentEnd12 = stcBlobsFeatures.fInwardPercentEnd12;

                        m_stcBlobPad.intMeasureMethod1 = stcBlobsFeatures.intMeasureMethod1;
                        m_stcBlobPad.intMeasureMethod2 = stcBlobsFeatures.intMeasureMethod2;
                        m_stcBlobPad.intMeasureMethod3 = stcBlobsFeatures.intMeasureMethod3;
                        m_stcBlobPad.intMeasureMethod4 = stcBlobsFeatures.intMeasureMethod4;
                        m_stcBlobPad.intMeasureMethod5 = stcBlobsFeatures.intMeasureMethod5;
                        m_stcBlobPad.intMeasureMethod6 = stcBlobsFeatures.intMeasureMethod6;
                        m_stcBlobPad.intMeasureMethod7 = stcBlobsFeatures.intMeasureMethod7;
                        m_stcBlobPad.intMeasureMethod8 = stcBlobsFeatures.intMeasureMethod8;
                        m_stcBlobPad.intMeasureMethod9 = stcBlobsFeatures.intMeasureMethod9;
                        m_stcBlobPad.intMeasureMethod10 = stcBlobsFeatures.intMeasureMethod10;
                        m_stcBlobPad.intMeasureMethod11 = stcBlobsFeatures.intMeasureMethod11;
                        m_stcBlobPad.intMeasureMethod12 = stcBlobsFeatures.intMeasureMethod12;

                        m_stcBlobPad.fAngle = stcBlobsFeatures.fAngle;

                        m_stcBlobPad.intLineCount = stcBlobsFeatures.intLineCount;
                        m_stcBlobPad.blnFeretActivated = stcBlobsFeatures.blnFeretActivated;
                        
                        m_stcBlobPad.fMinLine3 = stcBlobsFeatures.fMinLine3;
                        m_stcBlobPad.fMaxLine3 = stcBlobsFeatures.fMaxLine3;
                        m_stcBlobPad.fMinLine4 = stcBlobsFeatures.fMinLine4;
                        m_stcBlobPad.fMaxLine4 = stcBlobsFeatures.fMaxLine4;
                        m_stcBlobPad.fMinLine5 = stcBlobsFeatures.fMinLine5;
                        m_stcBlobPad.fMaxLine5 = stcBlobsFeatures.fMaxLine5;
                        m_stcBlobPad.fMinLine6 = stcBlobsFeatures.fMinLine6;
                        m_stcBlobPad.fMaxLine6 = stcBlobsFeatures.fMaxLine6;
                        m_stcBlobPad.fMinLine7 = stcBlobsFeatures.fMinLine7;
                        m_stcBlobPad.fMaxLine7 = stcBlobsFeatures.fMaxLine7;
                        m_stcBlobPad.fMinLine8 = stcBlobsFeatures.fMinLine8;
                        m_stcBlobPad.fMaxLine8 = stcBlobsFeatures.fMaxLine8;
                        m_stcBlobPad.fMinLine9 = stcBlobsFeatures.fMinLine9;
                        m_stcBlobPad.fMaxLine9 = stcBlobsFeatures.fMaxLine9;
                        m_stcBlobPad.fMinLine10 = stcBlobsFeatures.fMinLine10;
                        m_stcBlobPad.fMaxLine10 = stcBlobsFeatures.fMaxLine10;
                        m_stcBlobPad.fMinLine11 = stcBlobsFeatures.fMinLine11;
                        m_stcBlobPad.fMaxLine11 = stcBlobsFeatures.fMaxLine11;
                        m_stcBlobPad.fMinLine12 = stcBlobsFeatures.fMinLine12;
                        m_stcBlobPad.fMaxLine12 = stcBlobsFeatures.fMaxLine12;

                        m_stcBlobPad.intReferTopBottom = stcBlobsFeatures.intReferTopBottom;
                        m_stcBlobPad.blnCheckTop = stcBlobsFeatures.blnCheckTop;
                        m_stcBlobPad.blnCheckBottom = stcBlobsFeatures.blnCheckBottom;
                        m_stcBlobPad.intReferLeftRight = stcBlobsFeatures.intReferLeftRight;
                        m_stcBlobPad.blnCheckLeft = stcBlobsFeatures.blnCheckLeft;
                        m_stcBlobPad.blnCheckRight = stcBlobsFeatures.blnCheckRight;

                        // Load previous template length mode to current learnt template length mode
                        m_stcBlobPad.intLengthMode = stcBlobsFeatures.intLengthMode;
                        m_stcBlobPad.intFeretLengthMode = stcBlobsFeatures.intFeretLengthMode;

                        stcBlobsFeatures = m_stcBlobPad;
                        m_arrTemplateBlobPads[j] = stcBlobsFeatures;
                        arrSkip.Add(j);
                    }
                }
            }

        }
        public void LoadPercentageTemporary_ByPosition(string strPath, string strSectionName)
        {
            float fOptimumOffsetX = 0;
            float fOptimumOffsetY = 0;
            DefinePadPositionOffset(ref fOptimumOffsetX, ref fOptimumOffsetY);

            List<List<float>> arrDistance = new List<List<float>>();
            List<int> arrNearest = new List<int>();
            for (int i = 0; i < m_arrTemporaryBlobPads.Count; i++)
            {
                if (m_arrTemplateBlobPads.Count == 0)
                    break;

                BlobsFeatures stcBlobsFeatures = (BlobsFeatures)m_arrTemporaryBlobPads[i];
                PointF pCenter_Prev = new PointF(stcBlobsFeatures.fCenterX + fOptimumOffsetX, stcBlobsFeatures.fCenterY + fOptimumOffsetY);
                arrDistance.Add(new List<float>());
                int intNearest = -1;
                float fDistance = float.MaxValue;
                for (int j = 0; j < m_arrTemplateBlobPads.Count; j++)
                {
                    BlobsFeatures m_stcBlobPad = (BlobsFeatures)m_arrTemplateBlobPads[j];
                    PointF pCenter = new PointF(m_stcBlobPad.fCenterX, m_stcBlobPad.fCenterY);
                    arrDistance[i].Add(Math2.GetDistanceBtw2Points(pCenter, pCenter_Prev));
                    
                    if (arrDistance[i][j] < fDistance)
                    {
                        fDistance = arrDistance[i][j];
                        intNearest = j;
                    }
                }

                if (!arrNearest.Contains(intNearest))
                    arrNearest.Add(intNearest);
                else
                {
                    SortNearestDistance(i, intNearest, arrDistance, ref arrNearest, true);
                }
            }

            // Load Pad Blobs Features
            for (int i = 0; i < m_arrTemporaryBlobPads.Count; i++)
            {
                if (arrNearest.Count == 0)
                    break;
                if (arrNearest[i] == -1 || arrNearest[i] >= m_arrTemplateBlobPads.Count)
                    continue;

                BlobsFeatures stcBlobsFeatures = (BlobsFeatures)m_arrTemporaryBlobPads[i];
                BlobsFeatures m_stcBlobPad = (BlobsFeatures)m_arrTemplateBlobPads[arrNearest[i]]; //m_arrTemplateBlobPads

                m_stcBlobPad.fWidthPercentStart1 = stcBlobsFeatures.fWidthPercentStart1;
                m_stcBlobPad.fHeightPercentStart1 = stcBlobsFeatures.fHeightPercentStart1;
                m_stcBlobPad.fWidthPercentEnd1 = stcBlobsFeatures.fWidthPercentEnd1;
                m_stcBlobPad.fHeightPercentEnd1 = stcBlobsFeatures.fHeightPercentEnd1;
                m_stcBlobPad.fWidthPercentStart2 = stcBlobsFeatures.fWidthPercentStart2;
                m_stcBlobPad.fHeightPercentStart2 = stcBlobsFeatures.fHeightPercentStart2;
                m_stcBlobPad.fWidthPercentEnd2 = stcBlobsFeatures.fWidthPercentEnd2;
                m_stcBlobPad.fHeightPercentEnd2 = stcBlobsFeatures.fHeightPercentEnd2;
                m_stcBlobPad.fWidthPercentStart3 = stcBlobsFeatures.fWidthPercentStart3;
                m_stcBlobPad.fHeightPercentStart3 = stcBlobsFeatures.fHeightPercentStart3;
                m_stcBlobPad.fWidthPercentEnd3 = stcBlobsFeatures.fWidthPercentEnd3;
                m_stcBlobPad.fHeightPercentEnd3 = stcBlobsFeatures.fHeightPercentEnd3;
                m_stcBlobPad.fWidthPercentStart4 = stcBlobsFeatures.fWidthPercentStart4;
                m_stcBlobPad.fHeightPercentStart4 = stcBlobsFeatures.fHeightPercentStart4;
                m_stcBlobPad.fWidthPercentEnd4 = stcBlobsFeatures.fWidthPercentEnd4;
                m_stcBlobPad.fHeightPercentEnd4 = stcBlobsFeatures.fHeightPercentEnd4;
                m_stcBlobPad.fWidthPercentStart5 = stcBlobsFeatures.fWidthPercentStart5;
                m_stcBlobPad.fHeightPercentStart5 = stcBlobsFeatures.fHeightPercentStart5;
                m_stcBlobPad.fWidthPercentEnd5 = stcBlobsFeatures.fWidthPercentEnd5;
                m_stcBlobPad.fHeightPercentEnd5 = stcBlobsFeatures.fHeightPercentEnd5;
                m_stcBlobPad.fWidthPercentStart6 = stcBlobsFeatures.fWidthPercentStart6;
                m_stcBlobPad.fHeightPercentStart6 = stcBlobsFeatures.fHeightPercentStart6;
                m_stcBlobPad.fWidthPercentEnd6 = stcBlobsFeatures.fWidthPercentEnd6;
                m_stcBlobPad.fHeightPercentEnd6 = stcBlobsFeatures.fHeightPercentEnd6;
                m_stcBlobPad.fWidthPercentStart7 = stcBlobsFeatures.fWidthPercentStart7;
                m_stcBlobPad.fHeightPercentStart7 = stcBlobsFeatures.fHeightPercentStart7;
                m_stcBlobPad.fWidthPercentEnd7 = stcBlobsFeatures.fWidthPercentEnd7;
                m_stcBlobPad.fHeightPercentEnd7 = stcBlobsFeatures.fHeightPercentEnd7;
                m_stcBlobPad.fWidthPercentStart8 = stcBlobsFeatures.fWidthPercentStart8;
                m_stcBlobPad.fHeightPercentStart8 = stcBlobsFeatures.fHeightPercentStart8;
                m_stcBlobPad.fWidthPercentEnd8 = stcBlobsFeatures.fWidthPercentEnd8;
                m_stcBlobPad.fHeightPercentEnd8 = stcBlobsFeatures.fHeightPercentEnd8;
                m_stcBlobPad.fWidthPercentStart9 = stcBlobsFeatures.fWidthPercentStart9;
                m_stcBlobPad.fHeightPercentStart9 = stcBlobsFeatures.fHeightPercentStart9;
                m_stcBlobPad.fWidthPercentEnd9 = stcBlobsFeatures.fWidthPercentEnd9;
                m_stcBlobPad.fHeightPercentEnd9 = stcBlobsFeatures.fHeightPercentEnd9;
                m_stcBlobPad.fWidthPercentStart10 = stcBlobsFeatures.fWidthPercentStart10;
                m_stcBlobPad.fHeightPercentStart10 = stcBlobsFeatures.fHeightPercentStart10;
                m_stcBlobPad.fWidthPercentEnd10 = stcBlobsFeatures.fWidthPercentEnd10;
                m_stcBlobPad.fHeightPercentEnd10 = stcBlobsFeatures.fHeightPercentEnd10;
                m_stcBlobPad.fWidthPercentStart11 = stcBlobsFeatures.fWidthPercentStart11;
                m_stcBlobPad.fHeightPercentStart11 = stcBlobsFeatures.fHeightPercentStart11;
                m_stcBlobPad.fWidthPercentEnd11 = stcBlobsFeatures.fWidthPercentEnd11;
                m_stcBlobPad.fHeightPercentEnd11 = stcBlobsFeatures.fHeightPercentEnd11;
                m_stcBlobPad.fWidthPercentStart12 = stcBlobsFeatures.fWidthPercentStart12;
                m_stcBlobPad.fHeightPercentStart12 = stcBlobsFeatures.fHeightPercentStart12;
                m_stcBlobPad.fWidthPercentEnd12 = stcBlobsFeatures.fWidthPercentEnd12;
                m_stcBlobPad.fHeightPercentEnd12 = stcBlobsFeatures.fHeightPercentEnd12;

                m_stcBlobPad.fInwardPercentStart1 = stcBlobsFeatures.fInwardPercentStart1;
                m_stcBlobPad.fInwardPercentEnd1 = stcBlobsFeatures.fInwardPercentEnd1;
                m_stcBlobPad.fInwardPercentStart2 = stcBlobsFeatures.fInwardPercentStart2;
                m_stcBlobPad.fInwardPercentEnd2 = stcBlobsFeatures.fInwardPercentEnd2;
                m_stcBlobPad.fInwardPercentStart3 = stcBlobsFeatures.fInwardPercentStart3;
                m_stcBlobPad.fInwardPercentEnd3 = stcBlobsFeatures.fInwardPercentEnd3;
                m_stcBlobPad.fInwardPercentStart4 = stcBlobsFeatures.fInwardPercentStart4;
                m_stcBlobPad.fInwardPercentEnd4 = stcBlobsFeatures.fInwardPercentEnd4;
                m_stcBlobPad.fInwardPercentStart5 = stcBlobsFeatures.fInwardPercentStart5;
                m_stcBlobPad.fInwardPercentEnd5 = stcBlobsFeatures.fInwardPercentEnd5;
                m_stcBlobPad.fInwardPercentStart6 = stcBlobsFeatures.fInwardPercentStart6;
                m_stcBlobPad.fInwardPercentEnd6 = stcBlobsFeatures.fInwardPercentEnd6;
                m_stcBlobPad.fInwardPercentStart7 = stcBlobsFeatures.fInwardPercentStart7;
                m_stcBlobPad.fInwardPercentEnd7 = stcBlobsFeatures.fInwardPercentEnd7;
                m_stcBlobPad.fInwardPercentStart8 = stcBlobsFeatures.fInwardPercentStart8;
                m_stcBlobPad.fInwardPercentEnd8 = stcBlobsFeatures.fInwardPercentEnd8;
                m_stcBlobPad.fInwardPercentStart9 = stcBlobsFeatures.fInwardPercentStart9;
                m_stcBlobPad.fInwardPercentEnd9 = stcBlobsFeatures.fInwardPercentEnd9;
                m_stcBlobPad.fInwardPercentStart10 = stcBlobsFeatures.fInwardPercentStart10;
                m_stcBlobPad.fInwardPercentEnd10 = stcBlobsFeatures.fInwardPercentEnd10;
                m_stcBlobPad.fInwardPercentStart11 = stcBlobsFeatures.fInwardPercentStart11;
                m_stcBlobPad.fInwardPercentEnd11 = stcBlobsFeatures.fInwardPercentEnd11;
                m_stcBlobPad.fInwardPercentStart12 = stcBlobsFeatures.fInwardPercentStart12;
                m_stcBlobPad.fInwardPercentEnd12 = stcBlobsFeatures.fInwardPercentEnd12;

                m_stcBlobPad.intMeasureMethod1 = stcBlobsFeatures.intMeasureMethod1;
                m_stcBlobPad.intMeasureMethod2 = stcBlobsFeatures.intMeasureMethod2;
                m_stcBlobPad.intMeasureMethod3 = stcBlobsFeatures.intMeasureMethod3;
                m_stcBlobPad.intMeasureMethod4 = stcBlobsFeatures.intMeasureMethod4;
                m_stcBlobPad.intMeasureMethod5 = stcBlobsFeatures.intMeasureMethod5;
                m_stcBlobPad.intMeasureMethod6 = stcBlobsFeatures.intMeasureMethod6;
                m_stcBlobPad.intMeasureMethod7 = stcBlobsFeatures.intMeasureMethod7;
                m_stcBlobPad.intMeasureMethod8 = stcBlobsFeatures.intMeasureMethod8;
                m_stcBlobPad.intMeasureMethod9 = stcBlobsFeatures.intMeasureMethod9;
                m_stcBlobPad.intMeasureMethod10 = stcBlobsFeatures.intMeasureMethod10;
                m_stcBlobPad.intMeasureMethod11 = stcBlobsFeatures.intMeasureMethod11;
                m_stcBlobPad.intMeasureMethod12 = stcBlobsFeatures.intMeasureMethod12;

                m_stcBlobPad.fAngle = stcBlobsFeatures.fAngle;

                m_stcBlobPad.intLineCount = stcBlobsFeatures.intLineCount;
                m_stcBlobPad.blnFeretActivated = stcBlobsFeatures.blnFeretActivated;
                
                m_stcBlobPad.fMinLine3 = stcBlobsFeatures.fMinLine3;
                m_stcBlobPad.fMaxLine3 = stcBlobsFeatures.fMaxLine3;
                m_stcBlobPad.fMinLine4 = stcBlobsFeatures.fMinLine4;
                m_stcBlobPad.fMaxLine4 = stcBlobsFeatures.fMaxLine4;
                m_stcBlobPad.fMinLine5 = stcBlobsFeatures.fMinLine5;
                m_stcBlobPad.fMaxLine5 = stcBlobsFeatures.fMaxLine5;
                m_stcBlobPad.fMinLine6 = stcBlobsFeatures.fMinLine6;
                m_stcBlobPad.fMaxLine6 = stcBlobsFeatures.fMaxLine6;
                m_stcBlobPad.fMinLine7 = stcBlobsFeatures.fMinLine7;
                m_stcBlobPad.fMaxLine7 = stcBlobsFeatures.fMaxLine7;
                m_stcBlobPad.fMinLine8 = stcBlobsFeatures.fMinLine8;
                m_stcBlobPad.fMaxLine8 = stcBlobsFeatures.fMaxLine8;
                m_stcBlobPad.fMinLine9 = stcBlobsFeatures.fMinLine9;
                m_stcBlobPad.fMaxLine9 = stcBlobsFeatures.fMaxLine9;
                m_stcBlobPad.fMinLine10 = stcBlobsFeatures.fMinLine10;
                m_stcBlobPad.fMaxLine10 = stcBlobsFeatures.fMaxLine10;
                m_stcBlobPad.fMinLine11 = stcBlobsFeatures.fMinLine11;
                m_stcBlobPad.fMaxLine11 = stcBlobsFeatures.fMaxLine11;
                m_stcBlobPad.fMinLine12 = stcBlobsFeatures.fMinLine12;
                m_stcBlobPad.fMaxLine12 = stcBlobsFeatures.fMaxLine12;

                m_stcBlobPad.intReferTopBottom = stcBlobsFeatures.intReferTopBottom;
                m_stcBlobPad.blnCheckTop = stcBlobsFeatures.blnCheckTop;
                m_stcBlobPad.blnCheckBottom = stcBlobsFeatures.blnCheckBottom;
                m_stcBlobPad.intReferLeftRight = stcBlobsFeatures.intReferLeftRight;
                m_stcBlobPad.blnCheckLeft = stcBlobsFeatures.blnCheckLeft;
                m_stcBlobPad.blnCheckRight = stcBlobsFeatures.blnCheckRight;

                // Load previous template length mode to current learnt template length mode
                m_stcBlobPad.intLengthMode = stcBlobsFeatures.intLengthMode;
                m_stcBlobPad.intFeretLengthMode = stcBlobsFeatures.intFeretLengthMode;

                if (m_stcBlobPad.intNoID != stcBlobsFeatures.intNoID && stcBlobsFeatures.intNoID <= m_arrTemplateBlobPads.Count)
                {
                    for (int j = 0; j < m_arrTemplateBlobPads.Count; j++)
                    {
                        BlobsFeatures stcBlobsFeatures2 = (BlobsFeatures)m_arrTemplateBlobPads[j];
                        if (stcBlobsFeatures2.intNoID == stcBlobsFeatures.intNoID)
                        {
                            stcBlobsFeatures2.intNoID = m_stcBlobPad.intNoID;
                            m_arrTemplateBlobPads[j] = stcBlobsFeatures2;
                        }
                    }
                    m_stcBlobPad.intNoID = stcBlobsFeatures.intNoID;

                }

                stcBlobsFeatures = m_stcBlobPad;
                m_arrTemplateBlobPads[arrNearest[i]] = stcBlobsFeatures;
                
            }

            for (int i = 0; i < m_arrTemplateBlobPads.Count; i++)
            {
                if (arrNearest.Contains(i))
                    continue;

                BlobsFeatures m_stcBlobPad = (BlobsFeatures)m_arrTemplateBlobPads[i];
                m_stcBlobPad.blnSelected = false;
                m_arrTemplateBlobPads.RemoveAt(i);
                m_arrTemplateBlobPads.Insert(i, m_stcBlobPad);
            }

            //List<int> arrSkip = new List<int>();
            //for (int i = 0; i < m_arrTemporaryBlobPads.Count; i++)
            //{
            //    if ((arrNearest[i] == -1) || (arrNearest[i] >= m_arrTemplateBlobPads.Count))
            //        continue;

            //    BlobsFeatures stcBlobsFeatures = (BlobsFeatures)m_arrTemporaryBlobPads[i];
            //    BlobsFeatures m_stcBlobPad = (BlobsFeatures)m_arrTemplateBlobPads[arrNearest[i]]; //m_arrTemplateBlobPads

            //    if (!arrSkip.Contains(m_stcBlobPad.intNoID) && 
            //        !arrSkip.Contains(stcBlobsFeatures.intNoID) && 
            //        (stcBlobsFeatures.intNoID - 1 > 0) && 
            //        (stcBlobsFeatures.intNoID - 1 <= m_arrTemplateBlobPads.Count) && 
            //        (m_stcBlobPad.intNoID != stcBlobsFeatures.intNoID))
            //    {
            //        UpdatePadNo(m_stcBlobPad.intNoID - 1, stcBlobsFeatures.intNoID - 1);
            //        arrSkip.Add(m_stcBlobPad.intNoID);
            //        arrSkip.Add(stcBlobsFeatures.intNoID);
            //    }
            //}
        }

        private void SortNearestDistance(int i, int intNearest, List<List<float>> arrDistance, ref List<int> arrNearest, bool blnAssign)
        {
            if (intNearest < 0)
            {
                return;
            }

            if (arrDistance[i][intNearest] < arrDistance[arrNearest.IndexOf(intNearest)][intNearest])
            {
                float fDistance = float.MaxValue;
                int intNearest2 = -1;
                for (int j = 0; j < arrDistance[arrNearest.IndexOf(intNearest)].Count; j++)
                {
                    if (j == intNearest)
                        continue;

                    if (arrDistance[arrNearest.IndexOf(intNearest)][j] < fDistance)
                    {
                        fDistance = arrDistance[arrNearest.IndexOf(intNearest)][j];
                        intNearest2 = j;
                    }
                }

                if (arrNearest.Count <= i)
                    arrNearest.Add(intNearest);
                else
                    arrNearest[i] = intNearest;

                if (!arrNearest.Contains(intNearest2))
                {
                    arrNearest[arrNearest.IndexOf(intNearest)] = intNearest2;
                }
                else
                {
                    if (intNearest2 < 0)
                        arrNearest[arrNearest.IndexOf(intNearest)] = intNearest2;
                    else
                        SortNearestDistance(arrNearest.IndexOf(intNearest), intNearest2, arrDistance, ref arrNearest, true);
                }
            }
            else
            {
                if (blnAssign)
                {
                    float fDistance = float.MaxValue;
                    int intNearest2 = -1;
                    for (int j = 0; j < arrDistance[i].Count; j++)
                    {
                        if (j == intNearest)
                            continue;

                        if (arrDistance[i][j] < fDistance)
                        {
                            fDistance = arrDistance[i][j];
                            intNearest2 = j;
                        }
                    }


                    if (arrNearest.Count <= i)
                        arrNearest.Add(-1);
                    else
                        arrNearest[i] = -1;

                    if (!arrNearest.Contains(intNearest2))
                    {
                        arrNearest[arrNearest.IndexOf(intNearest)] = intNearest2;
                    }
                    else
                    {
                        SortNearestDistance(arrNearest.IndexOf(intNearest2), intNearest2, arrDistance, ref arrNearest, false);
                    }
                }
            }
        }

        public void ResetPercentage()
        {
            for (int i = 0; i < m_arrTemplateBlobPads.Count; i++)
            {
                BlobsFeatures m_stcBlobPad = (BlobsFeatures)m_arrTemplateBlobPads[i]; //m_arrTemplateBlobPads


                m_stcBlobPad.fWidthPercentStart1 = 0;
                m_stcBlobPad.fHeightPercentStart1 = 0;
                m_stcBlobPad.fWidthPercentEnd1 = 0;
                m_stcBlobPad.fHeightPercentEnd1 = 0;
                m_stcBlobPad.fWidthPercentStart2 = 0;
                m_stcBlobPad.fHeightPercentStart2 = 0;
                m_stcBlobPad.fWidthPercentEnd2 = 0;
                m_stcBlobPad.fHeightPercentEnd2 = 0;
                m_stcBlobPad.fWidthPercentStart3 = 0;
                m_stcBlobPad.fHeightPercentStart3 = 0;
                m_stcBlobPad.fWidthPercentEnd3 = 0;
                m_stcBlobPad.fHeightPercentEnd3 = 0;
                m_stcBlobPad.fWidthPercentStart4 = 0;
                m_stcBlobPad.fHeightPercentStart4 = 0;
                m_stcBlobPad.fWidthPercentEnd4 = 0;
                m_stcBlobPad.fHeightPercentEnd4 = 0;
                m_stcBlobPad.fWidthPercentStart5 = 0;
                m_stcBlobPad.fHeightPercentStart5 = 0;
                m_stcBlobPad.fWidthPercentEnd5 = 0;
                m_stcBlobPad.fHeightPercentEnd5 = 0;
                m_stcBlobPad.fWidthPercentStart6 = 0;
                m_stcBlobPad.fHeightPercentStart6 = 0;
                m_stcBlobPad.fWidthPercentEnd6 = 0;
                m_stcBlobPad.fHeightPercentEnd6 = 0;
                m_stcBlobPad.fWidthPercentStart7 = 0;
                m_stcBlobPad.fHeightPercentStart7 = 0;
                m_stcBlobPad.fWidthPercentEnd7 = 0;
                m_stcBlobPad.fHeightPercentEnd7 = 0;
                m_stcBlobPad.fWidthPercentStart8 = 0;
                m_stcBlobPad.fHeightPercentStart8 = 0;
                m_stcBlobPad.fWidthPercentEnd8 = 0;
                m_stcBlobPad.fHeightPercentEnd8 = 0;
                m_stcBlobPad.fWidthPercentStart9 = 0;
                m_stcBlobPad.fHeightPercentStart9 = 0;
                m_stcBlobPad.fWidthPercentEnd9 = 0;
                m_stcBlobPad.fHeightPercentEnd9 = 0;
                m_stcBlobPad.fWidthPercentStart10 = 0;
                m_stcBlobPad.fHeightPercentStart10 = 0;
                m_stcBlobPad.fWidthPercentEnd10 = 0;
                m_stcBlobPad.fHeightPercentEnd10 = 0;
                m_stcBlobPad.fWidthPercentStart11 = 0;
                m_stcBlobPad.fHeightPercentStart11 = 0;
                m_stcBlobPad.fWidthPercentEnd11 = 0;
                m_stcBlobPad.fHeightPercentEnd11 = 0;
                m_stcBlobPad.fWidthPercentStart12 = 0;
                m_stcBlobPad.fHeightPercentStart12 = 0;
                m_stcBlobPad.fWidthPercentEnd12 = 0;
                m_stcBlobPad.fHeightPercentEnd12 = 0;

                m_stcBlobPad.fInwardPercentStart1 = 0;
                m_stcBlobPad.fInwardPercentEnd1 = 0;
                m_stcBlobPad.fInwardPercentStart2 = 0;
                m_stcBlobPad.fInwardPercentEnd2 = 0;
                m_stcBlobPad.fInwardPercentStart3 = 0;
                m_stcBlobPad.fInwardPercentEnd3 = 0;
                m_stcBlobPad.fInwardPercentStart4 = 0;
                m_stcBlobPad.fInwardPercentEnd4 = 0;
                m_stcBlobPad.fInwardPercentStart5 = 0;
                m_stcBlobPad.fInwardPercentEnd5 = 0;
                m_stcBlobPad.fInwardPercentStart6 = 0;
                m_stcBlobPad.fInwardPercentEnd6 = 0;
                m_stcBlobPad.fInwardPercentStart7 = 0;
                m_stcBlobPad.fInwardPercentEnd7 = 0;
                m_stcBlobPad.fInwardPercentStart8 = 0;
                m_stcBlobPad.fInwardPercentEnd8 = 0;
                m_stcBlobPad.fInwardPercentStart9 = 0;
                m_stcBlobPad.fInwardPercentEnd9 = 0;
                m_stcBlobPad.fInwardPercentStart10 = 0;
                m_stcBlobPad.fInwardPercentEnd10 = 0;
                m_stcBlobPad.fInwardPercentStart11 = 0;
                m_stcBlobPad.fInwardPercentEnd11 = 0;
                m_stcBlobPad.fInwardPercentStart12 = 0;
                m_stcBlobPad.fInwardPercentEnd12 = 0;

                m_stcBlobPad.intMeasureMethod1 = 0;
                m_stcBlobPad.intMeasureMethod2 = 0;
                m_stcBlobPad.intMeasureMethod3 = 0;
                m_stcBlobPad.intMeasureMethod4 = 0;
                m_stcBlobPad.intMeasureMethod5 = 0;
                m_stcBlobPad.intMeasureMethod6 = 0;
                m_stcBlobPad.intMeasureMethod7 = 0;
                m_stcBlobPad.intMeasureMethod8 = 0;
                m_stcBlobPad.intMeasureMethod9 = 0;
                m_stcBlobPad.intMeasureMethod10 = 0;
                m_stcBlobPad.intMeasureMethod11 = 0;
                m_stcBlobPad.intMeasureMethod12 = 0;

                m_stcBlobPad.fAngle = 0;

                m_stcBlobPad.intLineCount = 2;
                m_stcBlobPad.blnFeretActivated = false;

                if (m_intPadWidthLengthMode == 0)
                {
                    if (m_stcBlobPad.fWidth < m_stcBlobPad.fHeight)  // width shorter then height
                    {
                        m_stcBlobPad.intLengthMode = 1;   // 1 mean length == height
                    }
                    else
                    {
                        m_stcBlobPad.intLengthMode = 2;   // 2 mean length == width
                    }
                }
                else if (m_intPadWidthLengthMode == 1)
                {
                    if (m_intPadROIDirection == 0 || m_intPadROIDirection == 1 || m_intPadROIDirection == 3)
                        m_stcBlobPad.intLengthMode = 1;   // 1 mean length == height
                    else
                        m_stcBlobPad.intLengthMode = 2;   // 2 mean length == width
                }
                else
                {
                    if (m_intPadROIDirection == 0 || m_intPadROIDirection == 1 || m_intPadROIDirection == 3)
                        m_stcBlobPad.intLengthMode = 2;   // 2 mean length == width
                    else
                        m_stcBlobPad.intLengthMode = 1;   // 1 mean length == height
                }

                BlobsFeatures stcBlobsFeatures = m_stcBlobPad;
                m_arrTemplateBlobPads[i] = stcBlobsFeatures;
            }

        }
        public void ResetPointGaugeInwardPercentage()
        {
            for (int i = 0; i < m_arrTemplateBlobPads.Count; i++)
            {
                BlobsFeatures m_stcBlobPad = (BlobsFeatures)m_arrTemplateBlobPads[i]; //m_arrTemplateBlobPads
                if (i >= m_arrSampleBlobPads.Length)
                    break;

                if (m_stcBlobPad.intLengthMode == 1)
                {
                    if (m_arrSampleBlobPads[i].fStartYLine1 >= 0)
                        m_stcBlobPad.fInwardPercentStart1 = Math.Min(99, (int)Math.Round(Math.Abs(m_arrSampleBlobPads[i].fStartYLine1 - m_stcBlobPad.intStartY) * 100 / m_stcBlobPad.fHeight, 0, MidpointRounding.AwayFromZero));
                    if (m_arrSampleBlobPads[i].fEndYLine1 >= 0)
                        m_stcBlobPad.fInwardPercentEnd1 = Math.Min(99, (int)Math.Round(Math.Abs(m_stcBlobPad.intEndY - m_arrSampleBlobPads[i].fEndYLine1) * 100 / m_stcBlobPad.fHeight, 0, MidpointRounding.AwayFromZero));
                    if (m_arrSampleBlobPads[i].fStartXLine2 >= 0)
                        m_stcBlobPad.fInwardPercentStart2 = Math.Min(99, (int)Math.Round(Math.Abs(m_arrSampleBlobPads[i].fStartXLine2 - m_stcBlobPad.intStartX) * 100 / m_stcBlobPad.fWidth, 0, MidpointRounding.AwayFromZero));
                    if (m_arrSampleBlobPads[i].fEndXLine2 >= 0)
                        m_stcBlobPad.fInwardPercentEnd2 = Math.Min(99, (int)Math.Round(Math.Abs(m_stcBlobPad.intEndX - m_arrSampleBlobPads[i].fEndXLine2) * 100 / m_stcBlobPad.fWidth, 0, MidpointRounding.AwayFromZero));
                }
                else
                {
                    if (m_arrSampleBlobPads[i].fStartXLine1 >= 0)
                        m_stcBlobPad.fInwardPercentStart1 = Math.Min(99, (int)Math.Round(Math.Abs(m_arrSampleBlobPads[i].fStartXLine1 - m_stcBlobPad.intStartX) * 100 / m_stcBlobPad.fWidth, 0, MidpointRounding.AwayFromZero));
                    if (m_arrSampleBlobPads[i].fEndXLine1 >= 0)
                        m_stcBlobPad.fInwardPercentEnd1 = Math.Min(99, (int)Math.Round(Math.Abs(m_stcBlobPad.intEndX - m_arrSampleBlobPads[i].fEndXLine1) * 100 / m_stcBlobPad.fWidth, 0, MidpointRounding.AwayFromZero));
                    if (m_arrSampleBlobPads[i].fStartYLine2 >= 0)
                        m_stcBlobPad.fInwardPercentStart2 = Math.Min(99, (int)Math.Round(Math.Abs(m_arrSampleBlobPads[i].fStartYLine2 - m_stcBlobPad.intStartY) * 100 / m_stcBlobPad.fHeight, 0, MidpointRounding.AwayFromZero));
                    if (m_arrSampleBlobPads[i].fEndYLine2 >= 0)
                        m_stcBlobPad.fInwardPercentEnd2 = Math.Min(99, (int)Math.Round(Math.Abs(m_stcBlobPad.intEndY - m_arrSampleBlobPads[i].fEndYLine2) * 100 / m_stcBlobPad.fHeight, 0, MidpointRounding.AwayFromZero));
                }

                if ((m_stcBlobPad.fInwardPercentStart1 + m_stcBlobPad.fInwardPercentEnd1) > 100)
                    m_stcBlobPad.fInwardPercentEnd1 = 100 - m_stcBlobPad.fInwardPercentStart1;
                if ((m_stcBlobPad.fInwardPercentStart2 + m_stcBlobPad.fInwardPercentEnd2) > 100)
                    m_stcBlobPad.fInwardPercentEnd2 = 100 - m_stcBlobPad.fInwardPercentStart2;

                BlobsFeatures stcBlobsFeatures = m_stcBlobPad;
                m_arrTemplateBlobPads[i] = stcBlobsFeatures;
            }

        }
        public void LoadGroupNoTemporary()
        {

            // Load Pad Blobs Features
            int intBlobsCount = Math.Min(m_arrTemporaryBlobPads.Count, m_arrTemplateBlobPads.Count);

            for (int i = 0; i < intBlobsCount; i++)
            {
                BlobsFeatures stcBlobsFeatures = (BlobsFeatures)m_arrTemporaryBlobPads[i];
                BlobsFeatures m_stcBlobPad = (BlobsFeatures)m_arrTemplateBlobPads[i]; //m_arrTemplateBlobPads
                
                m_stcBlobPad.intGroupID = stcBlobsFeatures.intGroupID;
                
                //stcBlobsFeatures = m_stcBlobPad;
                m_arrTemplateBlobPads[i] = m_stcBlobPad;
            }
            
        }
        public void LoadPitchGapLinkTemporary()
        {
            //int intPitchGapCount = Math.Min(m_arrBackupPitchGap.Count, m_arrPitchGap.Count);
            m_arrPitchGap.Clear();

            //for (int i = 0; i < m_arrBackupPitchGap.Count; i++)
            //{
            //    PitchGap stcPitchGapPrev = (PitchGap)m_arrBackupPitchGap[i];

            //    if (stcPitchGapPrev.intFromPadNo >= m_arrTemplateBlobPads.Count || stcPitchGapPrev.intToPadNo >= m_arrTemplateBlobPads.Count)
            //        continue;

            //    if (m_arrPitchGap.Count <= i)
            //        m_arrPitchGap.Add(stcPitchGapPrev);

            //    PitchGap stcPitchGap = (PitchGap)m_arrPitchGap[i]; //m_arrTemplateBlobPads

            //    stcPitchGap.intFromPadNo = stcPitchGapPrev.intFromPadNo;
            //    stcPitchGap.intToPadNo = stcPitchGapPrev.intToPadNo;

            //    //stcPitchGapPrev = stcPitchGap;
            //    m_arrPitchGap[i] = stcPitchGap;
            //}

            for (int i = 0; i < m_arrBackupPitchGap.Count; i++)
            {
                PitchGap stcPitchGapPrev = (PitchGap)m_arrBackupPitchGap[i];

                if (stcPitchGapPrev.intFromPadNo >= m_arrTemplateBlobPads.Count || stcPitchGapPrev.intToPadNo >= m_arrTemplateBlobPads.Count)
                    continue;

                int intFormPadNo = stcPitchGapPrev.intFromPadNo;

                bool blnAllowChange = true;
                int intToPadNo = stcPitchGapPrev.intToPadNo;

                if (intFormPadNo == intToPadNo)
                {

                    blnAllowChange = false;
                }
                else if (CheckPitchGapLinkExist(intFormPadNo, intToPadNo))
                {
                    blnAllowChange = false;
                }
                else if (CheckPitchGapLinkInPadAlready(intFormPadNo))
                {
                    //blnAllowChange = false;
                }
                else if (!CheckPitchGapLinkAvailable_LinkDifferentGroup(intFormPadNo, intToPadNo))
                {
                    blnAllowChange = false;
                }

                if (blnAllowChange)
                {
                    SetPitchGap(i, intFormPadNo, intToPadNo);
                }
            }
        }
        public void LoadPitchGapLinkFromTemplate()
        {
            //int intPitchGapCount = Math.Min(m_arrBackupPitchGap.Count, m_arrPitchGap.Count);
            m_arrPitchGap.Clear();

            //for (int i = 0; i < m_arrBackupPitchGap.Count; i++)
            //{
            //    PitchGap stcPitchGapPrev = (PitchGap)m_arrBackupPitchGap[i];

            //    if (stcPitchGapPrev.intFromPadNo >= m_arrTemplateBlobPads.Count || stcPitchGapPrev.intToPadNo >= m_arrTemplateBlobPads.Count)
            //        continue;

            //    if (m_arrPitchGap.Count <= i)
            //        m_arrPitchGap.Add(stcPitchGapPrev);

            //    PitchGap stcPitchGap = (PitchGap)m_arrPitchGap[i]; //m_arrTemplateBlobPads

            //    stcPitchGap.intFromPadNo = stcPitchGapPrev.intFromPadNo;
            //    stcPitchGap.intToPadNo = stcPitchGapPrev.intToPadNo;

            //    //stcPitchGapPrev = stcPitchGap;
            //    m_arrPitchGap[i] = stcPitchGap;
            //}

            for (int i = 0; i < m_arrBackupPitchGap.Count; i++)
            {
                PitchGap stcPitchGapPrev = (PitchGap)m_arrBackupPitchGap[i];

                if (stcPitchGapPrev.intFromPadNo >= m_arrTemplateBlobPads.Count || stcPitchGapPrev.intToPadNo >= m_arrTemplateBlobPads.Count)
                    continue;

                int intFormPadNo = stcPitchGapPrev.intFromPadNo;

                bool blnAllowChange = true;
                int intToPadNo = stcPitchGapPrev.intToPadNo;

                if (intFormPadNo == intToPadNo)
                {

                    blnAllowChange = false;
                }
                else if (CheckPitchGapLinkExist(intFormPadNo, intToPadNo))
                {
                    blnAllowChange = false;
                }
                else if (CheckPitchGapLinkInPadAlready(intFormPadNo))
                {
                    //blnAllowChange = false;
                }
                else if (!CheckPitchGapLinkAvailable_LinkDifferentGroup(intFormPadNo, intToPadNo))
                {
                    blnAllowChange = false;
                }

                if (blnAllowChange)
                {
                    SetPitchGap(intFormPadNo, intToPadNo);
                }
            }
        }
        public void SetMaxExtraLineCount(int count)
        {
            if (count >= m_intMaxExtraLineCount)
            {
                m_intMaxExtraLineCount = count;
            }
        }

        public void CopySettingToSettingPointGauge()
        {
            m_objSettingPointGauge.ref_objPointGauge.SetCenterXY(m_objPointGauge.ref_objPointGauge.CenterX, m_objPointGauge.ref_objPointGauge.CenterY);
            m_objSettingPointGauge.ref_objPointGauge.MinAmplitude = m_objPointGauge.ref_objPointGauge.MinAmplitude;
            m_objSettingPointGauge.ref_objPointGauge.MinArea = m_objPointGauge.ref_objPointGauge.MinArea;
            m_objSettingPointGauge.ref_objPointGauge.Smoothing = m_objPointGauge.ref_objPointGauge.Smoothing;
            m_objSettingPointGauge.ref_objPointGauge.Thickness = m_objPointGauge.ref_objPointGauge.Thickness;
            m_objSettingPointGauge.ref_objPointGauge.Threshold = m_objPointGauge.ref_objPointGauge.Threshold;
            m_objSettingPointGauge.ref_objPointGauge.TransitionType = m_objPointGauge.ref_objPointGauge.TransitionType;
            m_objSettingPointGauge.ref_objPointGauge.TransitionChoice = m_objPointGauge.ref_objPointGauge.TransitionChoice;
            m_objSettingPointGauge.ref_objPointGauge.Tolerance = m_objPointGauge.ref_objPointGauge.Tolerance;
            m_objSettingPointGauge.ref_objPointGauge.Angle = m_objPointGauge.ref_objPointGauge.Angle;
        }

        public bool SensitivityOnPadROI(ImageDrawing objSourceImage, ref ImageDrawing objDestImage, ROI objSearchROI)
        {
            try
            {
#if (Debug_2_12 || Release_2_12)
                if (m_intSensitivityOnPadMethod == 1)   // Sensitivity On Pad - Split
                {
                    ROI objDestROI = new ROI();

                    objSearchROI.AttachImage(objSourceImage);
                    objDestROI.AttachImage(objDestImage);
                    objDestROI.LoadROISetting(objSearchROI.ref_ROIPositionX, objSearchROI.ref_ROIPositionY, objSearchROI.ref_ROIWidth, objSearchROI.ref_ROIHeight);

                    EasyImage.OpenDisk(objSearchROI.ref_ROI, objDestROI.ref_ROI, (uint)m_intSensitivityOnPadValue);

                    objDestROI.Dispose();
                }
                else if (m_intSensitivityOnPadMethod == 2)  // Sensitivity On Pad - Merge
                {
                    ROI objDestROI = new ROI();

                    objSearchROI.AttachImage(objSourceImage);
                    objDestROI.AttachImage(objDestImage);

                    EasyImage.CloseDisk(objSearchROI.ref_ROI, objDestROI.ref_ROI, (uint)m_intSensitivityOnPadValue);

                    objDestROI.Dispose();
                }
#elif (DEBUG || RELEASE || RTXRelease || RTXDebug)
                if (m_intSensitivityOnPadMethod == 1)   // Sensitivity On Pad - Split
                {
                    ROI objDestROI = new ROI();

                    objSearchROI.AttachImage(objSourceImage);
                    objDestROI.AttachImage(objDestImage);
                    objDestROI.LoadROISetting(objSearchROI.ref_ROIPositionX, objSearchROI.ref_ROIPositionY, objSearchROI.ref_ROIWidth, objSearchROI.ref_ROIHeight);

                    EasyImage.OpenDisk(objSearchROI.ref_ROI, objDestROI.ref_ROI, m_intSensitivityOnPadValue);

                    objDestROI.Dispose();
                }
                else if (m_intSensitivityOnPadMethod == 2)  // Sensitivity On Pad - Merge
                {
                    ROI objDestROI = new ROI();

                    objSearchROI.AttachImage(objSourceImage);
                    objDestROI.AttachImage(objDestImage);

                    EasyImage.CloseDisk(objSearchROI.ref_ROI, objDestROI.ref_ROI, m_intSensitivityOnPadValue);

                    objDestROI.Dispose();
                }
#endif

            }
            catch
            {
                return false;
            }

            return true;
        }

        public void DrawEdgeROI(Graphics g, ImageDrawing objImage, float fDrawingScaleX, float fDrawingScaleY, Color objColor)
        {
            m_objRectGauge4L.AttachEdgeROI(objImage);
            m_objRectGauge4L.DrawEdgeROI(g, fDrawingScaleX, fDrawingScaleY, m_intSelectedGaugeEdgeMask, objColor);

        }

        public void AddGainForEdgeROI(ref ImageDrawing objSourceImage, ref ImageDrawing objDestinationImage)
        {
            m_objRectGauge4L.AddGainForEdgeROI(ref objSourceImage, ref objDestinationImage);
        }

        public void AddGainForEdgeROI(ref ImageDrawing objSourceImage, ref ImageDrawing objDestinationImage, int intSelectedEdgeROI)
        {
            m_objRectGauge4L.AddGainForEdgeROI(ref objSourceImage, ref objDestinationImage, intSelectedEdgeROI);
        }

        public void AddPrewittForEdgeROI(ref ImageDrawing objSourceImage, ref ImageDrawing objDestinationImage, int intSelectedEdgeROI)
        {
            m_objRectGauge4L.AddPrewittForEdgeROI(ref objSourceImage, ref objDestinationImage, intSelectedEdgeROI);
        }

        public int GetEdgeImageViewNo(int intSelectedEdgeROI)
        {
            return m_objRectGauge4L.GetGaugeImageNo(intSelectedEdgeROI);
        }

        public int[] GetEdgeImageViewNo()
        {
            return m_objRectGauge4L.GetGaugeImageNoList();
        }

        public void SetEdgeImageViewNo(int intImageViewNo, int intSelectedEdgeROI)
        {
            m_objRectGauge4L.SetGaugeImageNo(intImageViewNo, intSelectedEdgeROI);
        }

        public void TrimPadROIUsingTiltedAngle(ROI objROI)
        {
            bool blnDebugImage = false;
            //2019-09-23 ZJYEOH : Subtract tilt dont care area 
            if (m_intPadROIDirection == 1) // Top
            {
                ROI DontCareTop = new ROI();

                DontCareTop.LoadROISetting(0, 0, objROI.ref_ROIWidth, objROI.ref_ROIHeight);
                DontCareTop.AttachImage(m_ImgTilt_Top_L);
                EasyImage.Oper(EArithmeticLogicOperation.Subtract, objROI.ref_ROI, DontCareTop.ref_ROI, objROI.ref_ROI);
                DontCareTop.LoadROISetting(m_ImgTilt_Top_R.ref_intImageWidth - objROI.ref_ROIWidth, 0, objROI.ref_ROIWidth, objROI.ref_ROIHeight);
                DontCareTop.AttachImage(m_ImgTilt_Top_R);
                EasyImage.Oper(EArithmeticLogicOperation.Subtract, objROI.ref_ROI, DontCareTop.ref_ROI, objROI.ref_ROI);
                if (blnDebugImage)
                    objROI.SaveImage("D:\\objROITop.bmp");
                DontCareTop.Dispose();
            }
            if (m_intPadROIDirection == 2) // Right
            {
                ROI DontCareRight = new ROI();
                DontCareRight.LoadROISetting(m_ImgTilt_Top_R.ref_intImageWidth - objROI.ref_ROIWidth, 0, objROI.ref_ROIWidth, objROI.ref_ROIHeight);
                DontCareRight.AttachImage(m_ImgTilt_Right_T);
                EasyImage.Oper(EArithmeticLogicOperation.Subtract, objROI.ref_ROI, DontCareRight.ref_ROI, objROI.ref_ROI);
                DontCareRight.LoadROISetting(m_ImgTilt_Top_R.ref_intImageWidth - objROI.ref_ROIWidth, m_ImgTilt_Top_R.ref_intImageHeight - objROI.ref_ROIHeight, objROI.ref_ROIWidth, objROI.ref_ROIHeight);
                DontCareRight.AttachImage(m_ImgTilt_Right_B);
                EasyImage.Oper(EArithmeticLogicOperation.Subtract, objROI.ref_ROI, DontCareRight.ref_ROI, objROI.ref_ROI);
                if (blnDebugImage)
                    objROI.SaveImage("D:\\objROIRight.bmp");
                DontCareRight.Dispose();
            }
            if (m_intPadROIDirection == 3) // Bottom
            {
                ROI DontCareBottom = new ROI();

                DontCareBottom.LoadROISetting(0, m_ImgTilt_Top_R.ref_intImageHeight - objROI.ref_ROIHeight, objROI.ref_ROIWidth, objROI.ref_ROIHeight);
                DontCareBottom.AttachImage(m_ImgTilt_Bottom_L);
                EasyImage.Oper(EArithmeticLogicOperation.Subtract, objROI.ref_ROI, DontCareBottom.ref_ROI, objROI.ref_ROI);
                DontCareBottom.LoadROISetting(m_ImgTilt_Top_R.ref_intImageWidth - objROI.ref_ROIWidth, m_ImgTilt_Top_R.ref_intImageHeight - objROI.ref_ROIHeight, objROI.ref_ROIWidth, objROI.ref_ROIHeight);
                DontCareBottom.AttachImage(m_ImgTilt_Bottom_R);
                EasyImage.Oper(EArithmeticLogicOperation.Subtract, objROI.ref_ROI, DontCareBottom.ref_ROI, objROI.ref_ROI);
                if (blnDebugImage)
                    objROI.SaveImage("D:\\objROIBottom.bmp");
                DontCareBottom.Dispose();
            }
            if (m_intPadROIDirection == 4) // Left
            {
                ROI DontCareLeft = new ROI();

                DontCareLeft.LoadROISetting(0, 0, objROI.ref_ROIWidth, objROI.ref_ROIHeight);
                DontCareLeft.AttachImage(m_ImgTilt_Left_T);
                EasyImage.Oper(EArithmeticLogicOperation.Subtract, objROI.ref_ROI, DontCareLeft.ref_ROI, objROI.ref_ROI);
                DontCareLeft.LoadROISetting(0, m_ImgTilt_Top_R.ref_intImageHeight - objROI.ref_ROIHeight, objROI.ref_ROIWidth, objROI.ref_ROIHeight);
                DontCareLeft.AttachImage(m_ImgTilt_Left_B);
                EasyImage.Oper(EArithmeticLogicOperation.Subtract, objROI.ref_ROI, DontCareLeft.ref_ROI, objROI.ref_ROI);
                if (blnDebugImage)
                    objROI.SaveImage("D:\\objROILeft.bmp");
                DontCareLeft.Dispose();
            }
        }
        public int CheckInspectionAreaSettingError(int intSelectedIndex)
        {
            if (intSelectedIndex >= m_arrTemplateBlobPads.Count)
                return 0;

            int intError = 0; // 0x01 = Top & Bottom, 0x02 = Left & Right, 0x04 = Top, 0x08 = Right, 0x10 = Bottom, 0x20 = Left
            float fWidth = ((BlobsFeatures)m_arrTemplateBlobPads[intSelectedIndex]).fWidth;
            float fHeight = ((BlobsFeatures)m_arrTemplateBlobPads[intSelectedIndex]).fHeight;

            float fTop = ((BlobsFeatures)m_arrTemplateBlobPads[intSelectedIndex]).fPadInspectionAreaFromTop * m_fMMToPixelYValue;
            float fRight = ((BlobsFeatures)m_arrTemplateBlobPads[intSelectedIndex]).fPadInspectionAreaFromRight * m_fMMToPixelXValue;
            float fBottom = ((BlobsFeatures)m_arrTemplateBlobPads[intSelectedIndex]).fPadInspectionAreaFromBottom * m_fMMToPixelYValue;
            float fLeft = ((BlobsFeatures)m_arrTemplateBlobPads[intSelectedIndex]).fPadInspectionAreaFromLeft * m_fMMToPixelXValue;

            if (fTop >= 0 && fBottom >= 0)
            {
                if ((fTop + fBottom) > (fHeight - 1))
                {
                    intError |= 0x01;
                }

            }

            if (fLeft >= 0 && fRight >= 0)
            {
                if ((fLeft + fRight) > (fWidth - 1))
                {
                    intError |= 0x02;
                }

            }

            if (fTop >= 0 && fBottom < 0)
            {
                if (fTop > (fHeight - 1))
                {
                    intError |= 0x04;
                }

            }

            if (fLeft < 0 && fRight >= 0)
            {
                if (fRight > (fWidth - 1))
                {
                    intError |= 0x08;
                }

            }

            if (fTop < 0 && fBottom >= 0)
            {
                if (fBottom > (fHeight - 1))
                {
                    intError |= 0x10;
                }

            }

            if (fLeft >= 0 && fRight < 0)
            {
                if (fLeft > (fWidth - 1))
                {
                    intError |= 0x20;
                }

            }

            return intError;
        }
        public bool InspectPad_Eblob(ref ImageDrawing objImage, ref ImageDrawing objTemporaryImage, ROI objSearchROI, ROI objROI, ROI objUnitSurfaceROI, List<ROI> arrPadROIs, List<List<PointF>> arrDontCare, bool blnCheckContamination,
                                          CROI objCROI, bool blnCheckColor, List<CImageDrawing> arrColorImages, ImageDrawing objBlackImage)
        {
            //m_blnInspectLock = true;
            //m_strTrack2 += "T2,";
            lock (m_objLockBlobs)
            {
                m_intSensitivityOnPadValue_Current = m_intSensitivityOnPadValue;
                int intSensitivityValueChangeDirection = 0; // -1=decrease, 0=no change yet, 1 = increase
                int intLoopCount = 0;
                bool blnReverse = false;
                bool blnLast = false;

                // ------------------- checking loop timeout ---------------------------------------------------
                HiPerfTimer timeout = new HiPerfTimer();
                timeout.Start();

                while (true)
                {

                    // ------------------- checking loop timeout ---------------------------------------------------
                    if (timeout.Timing > 10000)
                    {
                        STTrackLog.WriteLine(">>>>>>>>>>>>> time out 500");
                        break;
                    }
                    // ---------------------------------------------------------------------------------------------

                    //if (Math.Abs(m_intSensitivityOnPadValue_Current - m_intSensitivityOnPadValue) >= 3)
                    //{
                    //    blnHaveNextChance = false;
                    //}

                    m_T2.Start();
                    m_fTiming2 = 0;
                    m_fTimingPrev2 = 0;
                    m_strTrack = "";

                    intLoopCount++;
                    m_fSmallestFailWidthLengthValue = -float.MaxValue;

                    //Subtract Pad Dont Care Area
                    if (m_blnWantDontCareArea_Pad)
                    {
                        ROI objDontCareROI = new ROI();
                        objDontCareROI.LoadROISetting(0, 0, objUnitSurfaceROI.ref_ROIWidth, objUnitSurfaceROI.ref_ROIHeight);
                        objDontCareROI.AttachImage(m_objPadDontCareImage);
                        ROI.SubtractROI(objUnitSurfaceROI, objDontCareROI);
                        objDontCareROI.Dispose();
                    }
#if (Debug_2_12 || Release_2_12)
                    if (m_intSensitivityOnPadMethod == 1)   // Split or segment object
                    {
                        //objROI.ref_ROI.TopParent.Save("D:\\TS\\1_TopParent.bmp");
                        //objROI.ref_ROI.Save("D:\\TS\\objROI.bmp");
                        if (m_intInspectPadMode == 1 && m_intSensitivityOnPadMethod != 0)//2021-08-02 ZJYEOH : blnAutoSensitivity
                            EasyImage.OpenBox(objSearchROI.ref_ROI, objSearchROI.ref_ROI, (uint)m_intSensitivityOnPadValue_Current);
                        else
                            EasyImage.OpenBox(objROI.ref_ROI, objROI.ref_ROI, (uint)m_intSensitivityOnPadValue);
                    }
                    else if (m_intSensitivityOnPadMethod == 2)  // Merge object
                    {
                        if (m_intInspectPadMode == 1 && m_intSensitivityOnPadMethod != 0)//2021-08-02 ZJYEOH : blnAutoSensitivity
                            EasyImage.CloseBox(objSearchROI.ref_ROI, objSearchROI.ref_ROI, (uint)m_intSensitivityOnPadValue_Current);
                        else
                            EasyImage.CloseBox(objROI.ref_ROI, objROI.ref_ROI, (uint)m_intSensitivityOnPadValue_Current);
                    }

#elif (DEBUG || RELEASE || RTXRelease || RTXDebug)
                    if (m_intSensitivityOnPadMethod == 1)   // Split or segment object
                    {
                        //objROI.ref_ROI.TopParent.Save("D:\\TS\\1_TopParent.bmp");
                        //objROI.ref_ROI.Save("D:\\TS\\objROI.bmp");
                        if (m_intInspectPadMode == 1 && m_intSensitivityOnPadMethod != 0)//2021-08-02 ZJYEOH : blnAutoSensitivity
                            EasyImage.OpenBox(objSearchROI.ref_ROI, objSearchROI.ref_ROI, m_intSensitivityOnPadValue_Current);
                        else
                            EasyImage.OpenBox(objROI.ref_ROI, objROI.ref_ROI, m_intSensitivityOnPadValue);
                    }
                    else if (m_intSensitivityOnPadMethod == 2)  // Merge object
                    { 
                        if (m_intInspectPadMode == 1 && m_intSensitivityOnPadMethod != 0)//2021-08-02 ZJYEOH : blnAutoSensitivity
                            EasyImage.CloseBox(objSearchROI.ref_ROI, objSearchROI.ref_ROI, m_intSensitivityOnPadValue_Current);
                        else
                            EasyImage.CloseBox(objROI.ref_ROI, objROI.ref_ROI, m_intSensitivityOnPadValue);
                    }

#endif

                    //Draw don't care ROI edge to make sure Don't Care Area is not inspected
                    //for (int k = 4; k < arrPadROIs.Count; k++)
                    //{
                    //    arrPadROIs[k].AttachImage(objROI);    // objROI == m_smVisionInfo.g_arrInspectROI[intPadIndex]
                    //    arrPadROIs[k].DrawDontCareEdge(0);
                    //}

                    //System.Threading.Thread.Sleep(3);   // 2018 06 06 - CCENG: not sure why need to slepp 3ms. I am hiding it to save inspection time. 

                    // Define actual threshold value
                    m_intThresholdValuePrev = m_intThresholdValue;
                    if (m_intThresholdValue == -4)
                        m_intThresholdValue = GetAutoThresholdValue(objROI, 3);

                    if (m_blnWantTightSetting)
                    {
                        /*
                         * When Setting is tight, mean unit easiy fail.
                         *  - When test run for Pass unit, set tight to true for the first time filtering. and set tight to false for the subsequence 3x test run.
                         *     - when setting is tight, minus 25 to current threshold value for white area inspection (Foreignn Material, Excess Area, dimension)
                         *     - when setting is tight, add 25 to current threshold value for black area inspection (Pad broken Area)
                         */
                        m_intDarkThresholdValue = m_intThresholdValue + m_intTightSettingThresholdTolerance;
                        if (m_intDarkThresholdValue > 254)
                            m_intDarkThresholdValue = 254;

                        m_intThresholdValue -= m_intTightSettingThresholdTolerance;
                        if (m_intThresholdValue < 1)
                            m_intThresholdValue = 1;
                    }
                    else
                    {
                        m_intDarkThresholdValue = m_intThresholdValue;
                    }

                    m_fTiming2 = m_T2.Timing;
                    m_strTrack += "AA=" + (m_fTiming2 - m_fTimingPrev2).ToString();
                    m_fTimingPrev2 = m_fTiming2;

                    //WriteDebug("B");
                    // Define blobs min area
                    //DefineBlobsMinArea();     // 2018 11 08 Not need define. Direct use fBlobsMinAreaMM which is set by user in Advance Setting Form.

                    // Build Pad as blobs objects and holes
                    //m_objBlobs.ref_Blob.RemoveAllObjects();
                    if (m_fPadImageGain != 1f)
                    {
                        ROI objROI2 = new ROI();
                        objROI2.LoadROISetting(objROI.ref_ROITotalX, objROI.ref_ROITotalY, objROI.ref_ROIWidth, objROI.ref_ROIHeight);
                        ImageDrawing objImage2 = new ImageDrawing(objROI.ref_ROI.TopParent.Width, objROI.ref_ROI.TopParent.Height);
                        EasyImage.Copy(objROI.ref_ROI.TopParent, objImage2.ref_objMainImage);
                        objROI2.AttachImage(objImage2);

                        EasyImage.GainOffset(objROI2.ref_ROI, objROI2.ref_ROI, m_fPadImageGain);

                        m_objEBlobs.BuildObjects_Filter_GetElement(objROI2, !m_blnWhiteOnBlack, true, 0, m_intThresholdValue,
                     (int)Math.Floor(m_fBlobsMinArea), m_intMaxArea, false, 0xFF);

                        objROI2.Dispose();
                        objImage2.Dispose();
                    }
                    else
                    {
                        m_objEBlobs.BuildObjects_Filter_GetElement(objROI, !m_blnWhiteOnBlack, true, 0, m_intThresholdValue,
                    (int)Math.Floor(m_fBlobsMinArea), m_intMaxArea, false, 0xFF);
                    }

                    m_fTiming2 = m_T2.Timing;
                    m_strTrack += ", A=" + (m_fTiming2 - m_fTimingPrev2).ToString();
                    m_fTimingPrev2 = m_fTiming2;

                    //WriteDebug("A");
                    // Init data base on ROI and Blobs size
                    int intNumSelectedObject = m_objEBlobs.ref_intNumSelectedObject;
                    if (intNumSelectedObject == 0 && m_arrTemplateBlobPads.Count > 0)   // Missing pad if template got pads but sample is empty
                    {
                        for (int i = 0; i < m_arrTemplateBlobPads.Count; i++)
                        {
                            if (((BlobsFeatures)m_arrTemplateBlobPads[i]).blnEnable)
                            {
                                m_intFailResultMask |= 0x04;
                                m_arrSampleBlobPads[i].intFailMask |= 0x04;
                            }
                        }
                        //m_blnInspectLock = false;
                        //m_strTrack2 += "F1,";
                        return false;
                    }

                    InitPadInspectionData(objROI, intNumSelectedObject);

                    m_fTiming2 = m_T2.Timing;
                    m_strTrack += ", D=" + (m_fTiming2 - m_fTimingPrev2).ToString();
                    m_fTimingPrev2 = m_fTiming2;

                    //WriteDebug("D");

                    //CheckPadHole(objROI, intNumSelectedObject);

                    try
                    {
                        PadTestStage1_Eblob(objROI, objUnitSurfaceROI, arrDontCare, blnCheckContamination);

                    }
                    catch (Exception ex)
                    {

                    }

                    m_fTiming2 = m_T2.Timing;
                    m_strTrack += ", E=" + (m_fTiming2 - m_fTimingPrev2).ToString();
                    m_fTimingPrev2 = m_fTiming2;

                    //WriteDebug("E");
                    CheckBrokenMissingPad2_EBlob(objROI, intNumSelectedObject, blnCheckContamination);

                    m_fTiming2 = m_T2.Timing;
                    m_strTrack += ", F=" + (m_fTiming2 - m_fTimingPrev2).ToString();
                    m_fTimingPrev2 = m_fTiming2;

                    //WriteDebug("F");
                    CheckDimention(objROI);

                    CheckSpan();

                    m_fTiming2 = m_T2.Timing;
                    m_strTrack += ", G=" + (m_fTiming2 - m_fTimingPrev2).ToString();
                    m_fTimingPrev2 = m_fTiming2;

                    //WriteDebug("G");
                    CheckPitchGap(objROI);

                    m_fTiming2 = m_T2.Timing;
                    m_strTrack += ", H=" + (m_fTiming2 - m_fTimingPrev2).ToString();
                    m_fTimingPrev2 = m_fTiming2;

                    //Excess Pad
                    //WriteDebug("H");
                    if (m_intFailResultMask == 0 && (m_intFailOptionMask & 0x800) > 0)
                    {
                        if (m_intPadSubtractMethod == 1) // 2021-02-09 ZJYEOH : Optimum pad offset
                            CheckExcessPad2(objROI);
                        else
                            CheckExcessPad(objROI);
                        m_blnExcessPadInspected = true;
                    }

                    m_fTiming2 = m_T2.Timing;
                    m_strTrack += ", I=" + (m_fTiming2 - m_fTimingPrev2).ToString();
                    m_fTimingPrev2 = m_fTiming2;

                    //WriteDebug("I");
                    // Broken Pad (Scratch/Broken/Incomplete Plate)
                    if (m_intFailResultMask == 0 && (m_intFailOptionMask & 0x08) > 0)
                    {
                        CheckImage1PadDefect_PadUse(objROI);
                        m_blnBrokenPadInspected = true;
                    }

                    m_fTiming2 = m_T2.Timing;
                    m_strTrack += ", J=" + (m_fTiming2 - m_fTimingPrev2).ToString();
                    m_fTimingPrev2 = m_fTiming2;

                    //WriteDebug("J");
                    // Check extra pad using unit surface threshold
                    if ((m_intFailResultMask == 0 && (m_intFailOptionMask & 0x1001) > 0) && blnCheckContamination)
                    {
                        CheckExtraObjectOnUnitSurface2(objROI, objUnitSurfaceROI, arrDontCare);//CheckExtraObjectOnUnitSurface
                    }

                    //Smear Pad
                    if ((m_intFailOptionMask & 0x2000) > 0)
                    {
                        CheckSmear(objROI);
                    }


                    Line objLineTop = new Line();
                    Line objLineRight = new Line();
                    Line objLineBottom = new Line();
                    Line objLineLeft = new Line();
                    if (((((m_intFailOptionMask & 0x4000) > 0) && m_blnWantEdgeLimit_Pad) ||
                        (((m_intFailOptionMask & 0x8000) > 0) && m_blnWantStandOff_Pad) ||
                        (((m_intFailOptionMask & 0x10000) > 0) && m_blnWantEdgeDistance_Pad)) &&
                        m_blnWantRotateSidePadImage)
                    {
                        PointF pTemp = new PointF();
                        Math2.GetNewXYAfterRotate_360deg(m_objRectGauge4L.ref_pRectCenterPoint.X, m_objRectGauge4L.ref_pRectCenterPoint.Y,
                                                         m_objRectGauge4L.ref_arrRectCornerPoints[0],
                                                         -m_objRectGauge4L.ref_fRectAngle,
                                                         ref pTemp);
                        PointF pTL = new PointF(pTemp.X, pTemp.Y);

                        Math2.GetNewXYAfterRotate_360deg(m_objRectGauge4L.ref_pRectCenterPoint.X, m_objRectGauge4L.ref_pRectCenterPoint.Y,
                                                         m_objRectGauge4L.ref_arrRectCornerPoints[1],
                                                         -m_objRectGauge4L.ref_fRectAngle,
                                                         ref pTemp);
                        PointF pTR = new PointF(pTemp.X, pTemp.Y);

                        Math2.GetNewXYAfterRotate_360deg(m_objRectGauge4L.ref_pRectCenterPoint.X, m_objRectGauge4L.ref_pRectCenterPoint.Y,
                                                         m_objRectGauge4L.ref_arrRectCornerPoints[2],
                                                         -m_objRectGauge4L.ref_fRectAngle,
                                                         ref pTemp);
                        PointF pBR = new PointF(pTemp.X, pTemp.Y);

                        Math2.GetNewXYAfterRotate_360deg(m_objRectGauge4L.ref_pRectCenterPoint.X, m_objRectGauge4L.ref_pRectCenterPoint.Y,
                                                         m_objRectGauge4L.ref_arrRectCornerPoints[3],
                                                         -m_objRectGauge4L.ref_fRectAngle,
                                                         ref pTemp);
                        PointF pBL = new PointF(pTemp.X, pTemp.Y);

                        objLineTop.CalculateStraightLine(pTL, pTR);
                        objLineRight.CalculateStraightLine(pTR, pBR);
                        objLineBottom.CalculateStraightLine(pBL, pBR);
                        objLineLeft.CalculateStraightLine(pTL, pBL);

                    }

                    // Pad Edge Limit
                    if (((m_intFailOptionMask & 0x4000) > 0) && m_blnWantEdgeLimit_Pad)
                    {
                        if (m_blnWantRotateSidePadImage)
                        {
                            //CheckPadEdgeLimit(objROI, objUnitSurfaceROI);
                            CheckPadEdgeLimit_Rotate(objROI, objLineTop, objLineRight, objLineBottom, objLineLeft);
                        }
                        else
                            CheckPadEdgeLimit_WithoutRotate(objROI);
                    }

                    // Pad Stand Off
                    if (((m_intFailOptionMask & 0x8000) > 0) && m_blnWantStandOff_Pad)
                    {
                        if (m_blnWantRotateSidePadImage)
                        {
                            //CheckPadStandOffLimit(objROI, objUnitSurfaceROI);
                            CheckPadStandOffLimit_Rotate(objROI, objLineTop, objLineRight, objLineBottom, objLineLeft);
                        }
                        else
                            CheckPadStandOffLimit_WithoutRotate(objROI);
                    }

                    // Pad Edge Distance
                    if (((m_intFailOptionMask & 0x10000) > 0) && m_blnWantEdgeDistance_Pad)
                    {
                        if (m_blnWantRotateSidePadImage)
                        {
                            //CheckPadEdgeDistance(objROI, objUnitSurfaceROI);
                            CheckPadEdgeDistance_Rotate(objROI, objLineTop, objLineRight, objLineBottom, objLineLeft);
                        }
                        else
                            CheckPadEdgeDistance_WithoutRotate(objROI);
                    }

                    // Pad Color Defect
                    if (blnCheckColor && (m_intFailResultMask & 0x1001) == 0) // 2020-10-19 ZJYEOH : wil not check color when extra fail, because they sharing same table
                    {
                        if (m_objRectGauge4L.GetGaugeTiltAngle() == 0)
                        {
                            if (m_intColorDefectLinkMethod == 1)
                                CheckColorDefect_CombineSameName_LinkNearest(objCROI, arrColorImages, objROI, objBlackImage);
                            else
                                CheckColorDefect_CombineSameName(objCROI, arrColorImages, objROI, objBlackImage);
                        }
                        else
                        {
                            if (m_intColorDefectLinkMethod == 1)
                                CheckColorDefect_TiltAngle_CombineSameName_LinkNearest(objCROI, arrColorImages, objROI, objBlackImage);
                            else
                                CheckColorDefect_TiltAngle_CombineSameName(objCROI, arrColorImages, objROI, objBlackImage);
                        }
                    }

                    // Create a blobs backup for inspection result drawing
                    m_intThresholdValue = m_intThresholdValuePrev;

                    m_fTiming2 = m_T2.Timing;
                    m_strTrack += ", K=" + (m_fTiming2 - m_fTimingPrev2).ToString();
                    m_fTimingPrev2 = m_fTiming2;

                    WriteDebug(m_strTrack);

                    //m_blnInspectLock = false;
                    //m_strTrack2 += "F2,";
                    if (m_intFailResultMask == 0)
                    {
                        if (!blnCheckColor)
                            return true;
                        else
                        {
                            if (m_intFailColorResultMask == 0)
                                return true;
                            else
                                return false;
                        }
                    }
                    else
                    {
                        if (m_intInspectPadMode == 1 && m_intSensitivityOnPadMethod != 0)//2021-08-02 ZJYEOH : blnAutoSensitivity
                        {
                            if (!m_blnWantUseBorderLimitAsOffset && (m_intFailResultMask & 0x100) > 0)   // Offset pad
                            {
                                if (blnReverse)
                                {
                                    if (intSensitivityValueChangeDirection > 0)
                                    {
                                        m_intSensitivityOnPadValue_Current--;
                                        intSensitivityValueChangeDirection = -1;
                                        if (m_intSensitivityOnPadValue_Current > 0)
                                        {
                                            if (Math.Abs(m_intSensitivityOnPadValue_Current - m_intSensitivityOnPadValue) < 4)
                                            {
                                                objSearchROI.AttachImage(objImage);
                                                objSearchROI.CopyTo_ROIToROISamePosition(ref objTemporaryImage);

                                                objSearchROI.AttachImage(objTemporaryImage);
                                                objROI.AttachImage(objTemporaryImage);

                                                m_intFailResultMask = 0;
                                                blnLast = true;
                                                continue;
                                            }
                                        }
                                    }
                                    else if (intSensitivityValueChangeDirection < 0)
                                    {
                                        m_intSensitivityOnPadValue_Current++;
                                        intSensitivityValueChangeDirection = 1;
                                        if (m_intSensitivityOnPadValue_Current > 0)
                                        {
                                            if (Math.Abs(m_intSensitivityOnPadValue_Current - m_intSensitivityOnPadValue) < 4)
                                            {
                                                objSearchROI.AttachImage(objImage);
                                                objSearchROI.CopyTo_ROIToROISamePosition(ref objTemporaryImage);

                                                objSearchROI.AttachImage(objTemporaryImage);
                                                objROI.AttachImage(objTemporaryImage);

                                                m_intFailResultMask = 0;
                                                blnLast = true;
                                                continue;
                                            }
                                        }
                                    }

                                }
                                else
                                {
                                    if (intSensitivityValueChangeDirection <= 0)
                                    {
                                        m_intSensitivityOnPadValue_Current--;
                                        intSensitivityValueChangeDirection = -1;
                                        if (m_intSensitivityOnPadValue_Current > 0)
                                        {
                                            if (Math.Abs(m_intSensitivityOnPadValue_Current - m_intSensitivityOnPadValue) < 4)
                                            {
                                                objSearchROI.AttachImage(objImage);
                                                objSearchROI.CopyTo_ROIToROISamePosition(ref objTemporaryImage);

                                                objSearchROI.AttachImage(objTemporaryImage);
                                                objROI.AttachImage(objTemporaryImage);

                                                m_intFailResultMask = 0;
                                                continue;
                                            }
                                        }
                                    }
                                }
                            }
                            else if ((m_intFailResultMask & 0x04) > 0)   // Missing pad
                            {
                                if (blnReverse)
                                {
                                    if (intSensitivityValueChangeDirection > 0)
                                    {
                                        m_intSensitivityOnPadValue_Current--;
                                        intSensitivityValueChangeDirection = -1;
                                        if (m_intSensitivityOnPadValue_Current > 0)
                                        {
                                            if (Math.Abs(m_intSensitivityOnPadValue_Current - m_intSensitivityOnPadValue) < 4)
                                            {
                                                objSearchROI.AttachImage(objImage);
                                                objSearchROI.CopyTo_ROIToROISamePosition(ref objTemporaryImage);

                                                objSearchROI.AttachImage(objTemporaryImage);
                                                objROI.AttachImage(objTemporaryImage);

                                                m_intFailResultMask = 0;
                                                blnLast = true;
                                                continue;
                                            }
                                        }
                                    }
                                    else if (intSensitivityValueChangeDirection < 0)
                                    {
                                        m_intSensitivityOnPadValue_Current++;
                                        intSensitivityValueChangeDirection = 1;
                                        if (m_intSensitivityOnPadValue_Current > 0)
                                        {
                                            if (Math.Abs(m_intSensitivityOnPadValue_Current - m_intSensitivityOnPadValue) < 4)
                                            {
                                                objSearchROI.AttachImage(objImage);
                                                objSearchROI.CopyTo_ROIToROISamePosition(ref objTemporaryImage);

                                                objSearchROI.AttachImage(objTemporaryImage);
                                                objROI.AttachImage(objTemporaryImage);

                                                m_intFailResultMask = 0;
                                                blnLast = true;
                                                continue;
                                            }
                                        }
                                    }

                                }
                                else
                                {
                                    if (intSensitivityValueChangeDirection <= 0)
                                    {
                                        m_intSensitivityOnPadValue_Current--;
                                        intSensitivityValueChangeDirection = -1;
                                        if (m_intSensitivityOnPadValue_Current > 0)
                                        {
                                            if (Math.Abs(m_intSensitivityOnPadValue_Current - m_intSensitivityOnPadValue) < 4)
                                            {
                                                objSearchROI.AttachImage(objImage);
                                                objSearchROI.CopyTo_ROIToROISamePosition(ref objTemporaryImage);

                                                objSearchROI.AttachImage(objTemporaryImage);
                                                objROI.AttachImage(objTemporaryImage);

                                                m_intFailResultMask = 0;
                                                continue;
                                            }
                                        }
                                    }
                                }
                            }
                            else if (!blnLast && (m_intFailResultMask & 0x40) > 0)   // Width Fail
                            {
                                if (m_fSmallestFailWidthLengthValue < 0)
                                {
                                    if (intSensitivityValueChangeDirection > 0)
                                    {
                                        if (blnReverse) // Reverse sensitivity checking and then finish
                                        {
                                            if (intSensitivityValueChangeDirection > 0)     // Previsou sensitivity is ++, so need to -- and finish
                                            {
                                                m_intSensitivityOnPadValue_Current--;
                                                intSensitivityValueChangeDirection = -1;
                                                if (m_intSensitivityOnPadValue_Current > 0)
                                                {
                                                    if (Math.Abs(m_intSensitivityOnPadValue_Current - m_intSensitivityOnPadValue) < 4)
                                                    {
                                                        objSearchROI.AttachImage(objImage);
                                                        objSearchROI.CopyTo_ROIToROISamePosition(ref objTemporaryImage);

                                                        objSearchROI.AttachImage(objTemporaryImage);
                                                        objROI.AttachImage(objTemporaryImage);

                                                        m_intFailResultMask = 0;
                                                        blnLast = true;
                                                        continue;
                                                    }
                                                }
                                            }
                                            else if (intSensitivityValueChangeDirection < 0)    // Previsou sensitivity is --, so need to ++ and finish
                                            {
                                                m_intSensitivityOnPadValue_Current++;
                                                intSensitivityValueChangeDirection = 1;
                                                if (m_intSensitivityOnPadValue_Current > 0)
                                                {
                                                    if (Math.Abs(m_intSensitivityOnPadValue_Current - m_intSensitivityOnPadValue) < 4)
                                                    {
                                                        objSearchROI.AttachImage(objImage);
                                                        objSearchROI.CopyTo_ROIToROISamePosition(ref objTemporaryImage);

                                                        objSearchROI.AttachImage(objTemporaryImage);
                                                        objROI.AttachImage(objTemporaryImage);

                                                        m_intFailResultMask = 0;
                                                        blnLast = true;
                                                        continue;
                                                    }
                                                }
                                            }

                                        }
                                    }
                                    else
                                    {
                                        m_intSensitivityOnPadValue_Current--;
                                        intSensitivityValueChangeDirection = -1;
                                        if (m_intSensitivityOnPadValue_Current > 0)
                                        {
                                            if (Math.Abs(m_intSensitivityOnPadValue_Current - m_intSensitivityOnPadValue) < 4)
                                            {
                                                objSearchROI.AttachImage(objImage);
                                                objSearchROI.CopyTo_ROIToROISamePosition(ref objTemporaryImage);

                                                objSearchROI.AttachImage(objTemporaryImage);
                                                objROI.AttachImage(objTemporaryImage);
                                                blnReverse = true;
                                                m_intFailResultMask = 0;
                                                continue;
                                            }
                                        }
                                    }
                                }
                                else if (m_fSmallestFailWidthLengthValue > 0)
                                {
                                    if (intSensitivityValueChangeDirection < 0)
                                    {
                                        if (blnReverse) // Reverse sensitivity checking and then finish
                                        {
                                            if (intSensitivityValueChangeDirection > 0)     // Previsou sensitivity is ++, so need to -- and finish
                                            {
                                                m_intSensitivityOnPadValue_Current--;
                                                intSensitivityValueChangeDirection = -1;
                                                if (m_intSensitivityOnPadValue_Current > 0)
                                                {
                                                    if (Math.Abs(m_intSensitivityOnPadValue_Current - m_intSensitivityOnPadValue) < 4)
                                                    {
                                                        objSearchROI.AttachImage(objImage);
                                                        objSearchROI.CopyTo_ROIToROISamePosition(ref objTemporaryImage);

                                                        objSearchROI.AttachImage(objTemporaryImage);
                                                        objROI.AttachImage(objTemporaryImage);

                                                        m_intFailResultMask = 0;
                                                        blnLast = true;
                                                        continue;
                                                    }
                                                }
                                            }
                                            else if (intSensitivityValueChangeDirection < 0)    // Previsou sensitivity is --, so need to ++ and finish
                                            {
                                                m_intSensitivityOnPadValue_Current++;
                                                intSensitivityValueChangeDirection = 1;
                                                if (m_intSensitivityOnPadValue_Current > 0)
                                                {
                                                    if (Math.Abs(m_intSensitivityOnPadValue_Current - m_intSensitivityOnPadValue) < 4)
                                                    {
                                                        objSearchROI.AttachImage(objImage);
                                                        objSearchROI.CopyTo_ROIToROISamePosition(ref objTemporaryImage);

                                                        objSearchROI.AttachImage(objTemporaryImage);
                                                        objROI.AttachImage(objTemporaryImage);

                                                        m_intFailResultMask = 0;
                                                        blnLast = true;
                                                        continue;
                                                    }
                                                }
                                            }

                                        }
                                    }
                                    else
                                    {
                                        m_intSensitivityOnPadValue_Current++;
                                        intSensitivityValueChangeDirection = 1;
                                        if (m_intSensitivityOnPadValue_Current > 0)
                                        {
                                            if (Math.Abs(m_intSensitivityOnPadValue_Current - m_intSensitivityOnPadValue) < 4)
                                            {
                                                objSearchROI.AttachImage(objImage);
                                                objSearchROI.CopyTo_ROIToROISamePosition(ref objTemporaryImage);

                                                objSearchROI.AttachImage(objTemporaryImage);
                                                objROI.AttachImage(objTemporaryImage);
                                                blnReverse = true;
                                                m_intFailResultMask = 0;
                                                continue;
                                            }
                                        }
                                    }
                                }
                            }
                            else if (!blnLast && (m_intFailResultMask & 0x80) > 0)   // Width Length
                            {
                                if (m_fSmallestFailWidthLengthValue < 0)    // Fail Min Length
                                {
                                    if (intSensitivityValueChangeDirection > 0) // Previous is Fail max Length/width
                                    {
                                        if (blnReverse) // Reverse sensitivity checking and then finish
                                        {
                                            if (intSensitivityValueChangeDirection > 0)     // Previsou sensitivity is ++, so need to -- and finish
                                            {
                                                m_intSensitivityOnPadValue_Current--;
                                                intSensitivityValueChangeDirection = -1;
                                                if (m_intSensitivityOnPadValue_Current > 0)
                                                {
                                                    if (Math.Abs(m_intSensitivityOnPadValue_Current - m_intSensitivityOnPadValue) < 4)
                                                    {
                                                        objSearchROI.AttachImage(objImage);
                                                        objSearchROI.CopyTo_ROIToROISamePosition(ref objTemporaryImage);

                                                        objSearchROI.AttachImage(objTemporaryImage);
                                                        objROI.AttachImage(objTemporaryImage);

                                                        m_intFailResultMask = 0;
                                                        blnLast = true;
                                                        continue;
                                                    }
                                                }
                                            }
                                            else if (intSensitivityValueChangeDirection < 0)    // Previsou sensitivity is --, so need to ++ and finish
                                            {
                                                m_intSensitivityOnPadValue_Current++;
                                                intSensitivityValueChangeDirection = 1;
                                                if (m_intSensitivityOnPadValue_Current > 0)
                                                {
                                                    if (Math.Abs(m_intSensitivityOnPadValue_Current - m_intSensitivityOnPadValue) < 4)
                                                    {
                                                        objSearchROI.AttachImage(objImage);
                                                        objSearchROI.CopyTo_ROIToROISamePosition(ref objTemporaryImage);

                                                        objSearchROI.AttachImage(objTemporaryImage);
                                                        objROI.AttachImage(objTemporaryImage);

                                                        m_intFailResultMask = 0;
                                                        blnLast = true;
                                                        continue;
                                                    }
                                                }
                                            }

                                        }
                                    }
                                    else // Previous is fail min length/width also. So continue -- to prevent fail min length/width
                                    {
                                        m_intSensitivityOnPadValue_Current--;
                                        intSensitivityValueChangeDirection = -1;
                                        if (m_intSensitivityOnPadValue_Current > 0)
                                        {
                                            if (Math.Abs(m_intSensitivityOnPadValue_Current - m_intSensitivityOnPadValue) < 4)
                                            {
                                                objSearchROI.AttachImage(objImage);
                                                objSearchROI.CopyTo_ROIToROISamePosition(ref objTemporaryImage);

                                                objSearchROI.AttachImage(objTemporaryImage);
                                                objROI.AttachImage(objTemporaryImage);
                                                blnReverse = true;
                                                m_intFailResultMask = 0;
                                                continue;
                                            }
                                        }
                                    }
                                }
                                else if (m_fSmallestFailWidthLengthValue > 0)   // Fail Max length/width
                                {
                                    if (intSensitivityValueChangeDirection < 0) // Previous is Fail min Length/width
                                    {
                                        if (blnReverse) // Reverse sensitivity checking and then finish
                                        {
                                            if (intSensitivityValueChangeDirection > 0)     // Previsou sensitivity is ++, so need to -- and finish
                                            {
                                                m_intSensitivityOnPadValue_Current--;
                                                intSensitivityValueChangeDirection = -1;
                                                if (m_intSensitivityOnPadValue_Current > 0)
                                                {
                                                    if (Math.Abs(m_intSensitivityOnPadValue_Current - m_intSensitivityOnPadValue) < 4)
                                                    {
                                                        objSearchROI.AttachImage(objImage);
                                                        objSearchROI.CopyTo_ROIToROISamePosition(ref objTemporaryImage);

                                                        objSearchROI.AttachImage(objTemporaryImage);
                                                        objROI.AttachImage(objTemporaryImage);

                                                        m_intFailResultMask = 0;
                                                        blnLast = true;
                                                        continue;
                                                    }
                                                }
                                            }
                                            else if (intSensitivityValueChangeDirection < 0)    // Previsou sensitivity is --, so need to ++ and finish
                                            {
                                                m_intSensitivityOnPadValue_Current++;
                                                intSensitivityValueChangeDirection = 1;
                                                if (m_intSensitivityOnPadValue_Current > 0)
                                                {
                                                    if (Math.Abs(m_intSensitivityOnPadValue_Current - m_intSensitivityOnPadValue) < 4)
                                                    {
                                                        objSearchROI.AttachImage(objImage);
                                                        objSearchROI.CopyTo_ROIToROISamePosition(ref objTemporaryImage);

                                                        objSearchROI.AttachImage(objTemporaryImage);
                                                        objROI.AttachImage(objTemporaryImage);

                                                        m_intFailResultMask = 0;
                                                        blnLast = true;
                                                        continue;
                                                    }
                                                }
                                            }

                                        }
                                    }
                                    else // Previous is fail max length/width also. So contiue to ++ to prevent fail max length/width
                                    {
                                        m_intSensitivityOnPadValue_Current++;
                                        intSensitivityValueChangeDirection = 1;

                                        if (m_intSensitivityOnPadValue_Current > 0)
                                        {
                                            if (Math.Abs(m_intSensitivityOnPadValue_Current - m_intSensitivityOnPadValue) < 4)
                                            {
                                                objSearchROI.AttachImage(objImage);
                                                objSearchROI.CopyTo_ROIToROISamePosition(ref objTemporaryImage);

                                                objSearchROI.AttachImage(objTemporaryImage);
                                                objROI.AttachImage(objTemporaryImage);
                                                blnReverse = true;
                                                m_intFailResultMask = 0;
                                                continue;
                                            }
                                        }
                                    }
                                }
                            }
                            return false;
                        }
                        else
                            return false;
                    }
                }
                timeout.Stop(); // ------------------- checking loop timeout ---------------------------------------------------
            }

            return false;

        }
        
        public float GetResultWidth_RectGauge4L(int intValueType)
        {
            switch (intValueType)
            {
                case 0: // Pixel
                    return m_objRectGauge4L.ref_fRectWidth;
                case 1: // mm
                case 2: // mil
                case 3: // micron
                    return m_objRectGauge4L.ref_fRectWidth * m_fMMPerPixelX * m_fMMToUnitValue;
                default:
                    return 0;
            }
        }

        public float GetResultHeight_RectGauge4L(int intValueType)
        {
            switch (intValueType)
            {
                case 0: // Pixel
                    return m_objRectGauge4L.ref_fRectHeight;
                case 1: // mm
                case 2: // mil
                case 3: // micron
                    return m_objRectGauge4L.ref_fRectHeight * m_fMMPerPixelY * m_fMMToUnitValue;
                default:
                    return 0;
            }
        }

        public int GetReferDirection(int intBlobsFeatureIndex, bool blnReferTopBottom)
        {
            if (m_arrTemplateBlobPads.Count <= intBlobsFeatureIndex)
                return 0;

            if (blnReferTopBottom)
                return ((BlobsFeatures)m_arrTemplateBlobPads[intBlobsFeatureIndex]).intReferTopBottom;
            else
                return ((BlobsFeatures)m_arrTemplateBlobPads[intBlobsFeatureIndex]).intReferLeftRight;
        }

        public bool GetWantCheckStandOff(int intDirection)
        {
            bool blnWantCheck = false;
            switch (intDirection)
            {
                case 0: // Top
                    for (int i =0; i< m_arrTemplateBlobPads.Count;i++)
                    {
                        if (((BlobsFeatures)m_arrTemplateBlobPads[i]).blnCheckTop)
                            blnWantCheck = true;
                    }
                    break;
                case 1: // Bottom
                    for (int i = 0; i < m_arrTemplateBlobPads.Count; i++)
                    {
                        if (((BlobsFeatures)m_arrTemplateBlobPads[i]).blnCheckBottom)
                            blnWantCheck = true;
                    }
                    break;
                case 2: // Left
                    for (int i = 0; i < m_arrTemplateBlobPads.Count; i++)
                    {
                        if (((BlobsFeatures)m_arrTemplateBlobPads[i]).blnCheckLeft)
                            blnWantCheck = true;
                    }
                    break;
                case 3: // Right
                    for (int i = 0; i < m_arrTemplateBlobPads.Count; i++)
                    {
                        if (((BlobsFeatures)m_arrTemplateBlobPads[i]).blnCheckRight)
                            blnWantCheck = true;
                    }
                    break;
            }
            return blnWantCheck;
        }

        private void DefinePadSubtractOffset(ROI objTemplateROI, int intToleSize, int intUnitTemplateLimitX, int intUnitTemplateLimitY,
            ref int[] arrTemplateStartX, ref int[] arrTemplateStartY, ref int[] arrTemplateEndX, ref int[] arrTemplateEndY,
            ref int[] arrSampleStartX, ref int[] arrSampleStartY, ref int[] arrSampleEndX, ref int[] arrSampleEndY,
            ref int[] arrTemplateSampleWidth, ref int[] arrTemplateSampleHeight,
            ref int[] arrDifferentSizeX, ref int[] arrDifferentSizeY,
            ref int[] arrOffsetStartX, ref int[] arrOffsetStartY, bool blnForLearning)
        {
            int intEndX, intEndY, intAdjustX, intAdjustY;
            float fSampleCenterX = 0, fSampleCenterY = 0, fSampleWidth = 0, fSampleHeight = 0;
            float fTemplateCenterX = 0, fTemplateCenterY = 0, fTemplateWidth = 0, fTemplateHeight = 0;
            for (int i = 0; i < m_arrTemplateBlobPads.Count; i++)
            {
                if (blnForLearning)
                {
                    if ((m_arrSampleBlobPads[i].intFailMask & 0x02) > 0)
                        continue;
                }
                else
                {
                    if (m_arrSampleBlobPads[i].intFailMask != 0)
                        continue;
                }

                if (!((BlobsFeatures)m_arrTemplateBlobPads[i]).blnFeretActivated)
                {
                    fSampleCenterX = m_arrSampleBlobPads[i].fCenterX;
                    fSampleCenterY = m_arrSampleBlobPads[i].fCenterY;
                    fSampleWidth = m_arrSampleBlobPads[i].fWidth;
                    fSampleHeight = m_arrSampleBlobPads[i].fHeight;

                    fTemplateCenterX = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fLimitCenterX;
                    fTemplateCenterY = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fLimitCenterY;
                    fTemplateWidth = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fWidth;
                    fTemplateHeight = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fHeight;
                }
                else
                {
                    int MinX, MinY, MaxX, MaxY;
                    
                    System.Drawing.Point p1 = new System.Drawing.Point((int)Math.Round(m_arrSampleBlobPads[i].fFeretCenterX - m_arrSampleBlobPads[i].fFeretWidth / 2), (int)Math.Round(m_arrSampleBlobPads[i].fFeretCenterY - m_arrSampleBlobPads[i].fFeretHeight / 2));
                    System.Drawing.Point p2 = new System.Drawing.Point((int)Math.Round(m_arrSampleBlobPads[i].fFeretCenterX + m_arrSampleBlobPads[i].fFeretWidth / 2), (int)Math.Round(m_arrSampleBlobPads[i].fFeretCenterY - m_arrSampleBlobPads[i].fFeretHeight / 2));
                    System.Drawing.Point p3 = new System.Drawing.Point((int)Math.Round(m_arrSampleBlobPads[i].fFeretCenterX + m_arrSampleBlobPads[i].fFeretWidth / 2), (int)Math.Round(m_arrSampleBlobPads[i].fFeretCenterY + m_arrSampleBlobPads[i].fFeretHeight / 2));
                    System.Drawing.Point p4 = new System.Drawing.Point((int)Math.Round(m_arrSampleBlobPads[i].fFeretCenterX - m_arrSampleBlobPads[i].fFeretWidth / 2), (int)Math.Round(m_arrSampleBlobPads[i].fFeretCenterY + m_arrSampleBlobPads[i].fFeretHeight / 2));


                    float newX1 = 0, newY1 = 0;  // new point 1 = p1
                    float newX2 = 0, newY2 = 0; // new point 2 = p4
                    float newX3 = 0, newY3 = 0; // new point 3  = p2
                    float newX4 = 0, newY4 = 0; // new point 4 = p3


                    float Angle = m_arrSampleBlobPads[i].fFeretAngle;


                    Math2.NewXYAfterRotate1(m_arrSampleBlobPads[i].fFeretCenterX, m_arrSampleBlobPads[i].fFeretCenterY, (float)p1.X, (float)p1.Y, Angle, ref newX1, ref newY1);
                    Math2.NewXYAfterRotate2(m_arrSampleBlobPads[i].fFeretCenterX, m_arrSampleBlobPads[i].fFeretCenterY, (float)p4.X, (float)p4.Y, Angle, ref newX4, ref newY4);
                    Math2.NewXYAfterRotate3(m_arrSampleBlobPads[i].fFeretCenterX, m_arrSampleBlobPads[i].fFeretCenterY, (float)p2.X, (float)p2.Y, Angle, ref newX2, ref newY2);
                    Math2.NewXYAfterRotate4(m_arrSampleBlobPads[i].fFeretCenterX, m_arrSampleBlobPads[i].fFeretCenterY, (float)p3.X, (float)p3.Y, Angle, ref newX3, ref newY3);
                    p1.X = (int)newX1;
                    p1.Y = (int)newY1;
                    p2.X = (int)newX2;
                    p2.Y = (int)newY2;
                    p3.X = (int)newX3;
                    p3.Y = (int)newY3;
                    p4.X = (int)newX4;
                    p4.Y = (int)newY4;
                    
                    if (p1.X > p2.X && p1.X > p3.X && p1.X > p4.X)
                        MaxX = p1.X;
                    else if (p2.X > p1.X && p2.X > p3.X && p2.X > p4.X)
                        MaxX = p2.X;
                    else if (p3.X > p1.X && p3.X > p2.X && p3.X > p4.X)
                        MaxX = p3.X;
                    else
                        MaxX = p4.X;

                    if (p1.Y > p2.Y && p1.Y > p3.Y && p1.Y > p4.Y)
                        MaxY = p1.Y;
                    else if (p2.Y > p1.Y && p2.Y > p3.Y && p2.Y > p4.Y)
                        MaxY = p2.Y;
                    else if (p3.Y > p1.Y && p3.Y > p2.Y && p3.Y > p4.Y)
                        MaxY = p3.Y;
                    else
                        MaxY = p4.Y;

                    if (p1.X < p2.X && p1.X < p3.X && p1.X < p4.X)
                        MinX = p1.X;
                    else if (p2.X < p1.X && p2.X < p3.X && p2.X < p4.X)
                        MinX = p2.X;
                    else if (p3.X < p1.X && p3.X < p2.X && p3.X < p4.X)
                        MinX = p3.X;
                    else
                        MinX = p4.X;

                    if (p1.Y < p2.Y && p1.Y < p3.Y && p1.Y < p4.Y)
                        MinY = p1.Y;
                    else if (p2.Y < p1.Y && p2.Y < p3.Y && p2.Y < p4.Y)
                        MinY = p2.Y;
                    else if (p3.Y < p1.Y && p3.Y < p2.Y && p3.Y < p4.Y)
                        MinY = p3.Y;
                    else
                        MinY = p4.Y;
                    
                    fSampleCenterX = m_arrSampleBlobPads[i].fFeretCenterX;
                    fSampleCenterY = m_arrSampleBlobPads[i].fFeretCenterY;
                    fSampleWidth = MaxX - MinX;// m_arrSampleBlobPads[i].fFeretWidth;
                    fSampleHeight = MaxY - MinY;// m_arrSampleBlobPads[i].fFeretHeight;



                    p1 = new System.Drawing.Point((int)Math.Round(((BlobsFeatures)m_arrTemplateBlobPads[i]).fFeretCenterX - ((BlobsFeatures)m_arrTemplateBlobPads[i]).fFeretWidth / 2), (int)Math.Round(((BlobsFeatures)m_arrTemplateBlobPads[i]).fFeretCenterY - ((BlobsFeatures)m_arrTemplateBlobPads[i]).fFeretHeight / 2));
                    p2 = new System.Drawing.Point((int)Math.Round(((BlobsFeatures)m_arrTemplateBlobPads[i]).fFeretCenterX + ((BlobsFeatures)m_arrTemplateBlobPads[i]).fFeretWidth / 2), (int)Math.Round(((BlobsFeatures)m_arrTemplateBlobPads[i]).fFeretCenterY - ((BlobsFeatures)m_arrTemplateBlobPads[i]).fFeretHeight / 2));
                    p3 = new System.Drawing.Point((int)Math.Round(((BlobsFeatures)m_arrTemplateBlobPads[i]).fFeretCenterX + ((BlobsFeatures)m_arrTemplateBlobPads[i]).fFeretWidth / 2), (int)Math.Round(((BlobsFeatures)m_arrTemplateBlobPads[i]).fFeretCenterY + ((BlobsFeatures)m_arrTemplateBlobPads[i]).fFeretHeight / 2));
                    p4 = new System.Drawing.Point((int)Math.Round(((BlobsFeatures)m_arrTemplateBlobPads[i]).fFeretCenterX - ((BlobsFeatures)m_arrTemplateBlobPads[i]).fFeretWidth / 2), (int)Math.Round(((BlobsFeatures)m_arrTemplateBlobPads[i]).fFeretCenterY + ((BlobsFeatures)m_arrTemplateBlobPads[i]).fFeretHeight / 2));
                    
                    Angle = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fFeretAngle;


                    Math2.NewXYAfterRotate1(((BlobsFeatures)m_arrTemplateBlobPads[i]).fFeretCenterX, ((BlobsFeatures)m_arrTemplateBlobPads[i]).fFeretCenterY, (float)p1.X, (float)p1.Y, Angle, ref newX1, ref newY1);
                    Math2.NewXYAfterRotate2(((BlobsFeatures)m_arrTemplateBlobPads[i]).fFeretCenterX, ((BlobsFeatures)m_arrTemplateBlobPads[i]).fFeretCenterY, (float)p4.X, (float)p4.Y, Angle, ref newX4, ref newY4);
                    Math2.NewXYAfterRotate3(((BlobsFeatures)m_arrTemplateBlobPads[i]).fFeretCenterX, ((BlobsFeatures)m_arrTemplateBlobPads[i]).fFeretCenterY, (float)p2.X, (float)p2.Y, Angle, ref newX2, ref newY2);
                    Math2.NewXYAfterRotate4(((BlobsFeatures)m_arrTemplateBlobPads[i]).fFeretCenterX, ((BlobsFeatures)m_arrTemplateBlobPads[i]).fFeretCenterY, (float)p3.X, (float)p3.Y, Angle, ref newX3, ref newY3);
                    p1.X = (int)newX1;
                    p1.Y = (int)newY1;
                    p2.X = (int)newX2;
                    p2.Y = (int)newY2;
                    p3.X = (int)newX3;
                    p3.Y = (int)newY3;
                    p4.X = (int)newX4;
                    p4.Y = (int)newY4;

                    if (p1.X > p2.X && p1.X > p3.X && p1.X > p4.X)
                        MaxX = p1.X;
                    else if (p2.X > p1.X && p2.X > p3.X && p2.X > p4.X)
                        MaxX = p2.X;
                    else if (p3.X > p1.X && p3.X > p2.X && p3.X > p4.X)
                        MaxX = p3.X;
                    else
                        MaxX = p4.X;

                    if (p1.Y > p2.Y && p1.Y > p3.Y && p1.Y > p4.Y)
                        MaxY = p1.Y;
                    else if (p2.Y > p1.Y && p2.Y > p3.Y && p2.Y > p4.Y)
                        MaxY = p2.Y;
                    else if (p3.Y > p1.Y && p3.Y > p2.Y && p3.Y > p4.Y)
                        MaxY = p3.Y;
                    else
                        MaxY = p4.Y;

                    if (p1.X < p2.X && p1.X < p3.X && p1.X < p4.X)
                        MinX = p1.X;
                    else if (p2.X < p1.X && p2.X < p3.X && p2.X < p4.X)
                        MinX = p2.X;
                    else if (p3.X < p1.X && p3.X < p2.X && p3.X < p4.X)
                        MinX = p3.X;
                    else
                        MinX = p4.X;

                    if (p1.Y < p2.Y && p1.Y < p3.Y && p1.Y < p4.Y)
                        MinY = p1.Y;
                    else if (p2.Y < p1.Y && p2.Y < p3.Y && p2.Y < p4.Y)
                        MinY = p2.Y;
                    else if (p3.Y < p1.Y && p3.Y < p2.Y && p3.Y < p4.Y)
                        MinY = p3.Y;
                    else
                        MinY = p4.Y;

                    fTemplateCenterX = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fFeretCenterX;
                    fTemplateCenterY = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fFeretCenterY;
                    fTemplateWidth = MaxX - MinX;// ((BlobsFeatures)m_arrTemplateBlobPads[i]).fFeretWidth;
                    fTemplateHeight = MaxY - MinY;// ((BlobsFeatures)m_arrTemplateBlobPads[i]).fFeretHeight;
                }
                // check the different size between sample pad and template pad
                arrDifferentSizeX[i] = (int)Math.Round((fSampleWidth - fTemplateWidth) / 2, 0, MidpointRounding.AwayFromZero);
                arrDifferentSizeY[i] = (int)Math.Round((fSampleHeight - fTemplateHeight) / 2, 0, MidpointRounding.AwayFromZero);

                // set one of the size (width or height) to zero if one side is bigger and another side is smaller
                if ((arrDifferentSizeX[i] > 0 && arrDifferentSizeY[i] < 0) || (arrDifferentSizeY[i] > 0 && arrDifferentSizeX[i] < 0))
                {
                    if (Math.Abs(arrDifferentSizeX[i]) > Math.Abs(arrDifferentSizeY[i]))    // the bigger value will set to 0
                        arrDifferentSizeY[i] = 0;
                    else
                        arrDifferentSizeX[i] = 0;
                }

                float fWidth, fHeight;
                // get bigger size from sample pad or template pad
                if ((arrDifferentSizeX[i] > 0) || (arrDifferentSizeY[i] > 0))
                {
                    // Use sample size
                    fWidth = fSampleWidth;
                    fHeight = fSampleHeight;
                }
                else
                {
                    // Use template size
                    fWidth = fTemplateWidth;
                    fHeight = fTemplateHeight;
                }

                // Get "template" pad start and end corner point with tolerance size added.
                intAdjustX = 0;
                intAdjustY = 0;
                arrTemplateStartX[i] = (int)Math.Round(fTemplateCenterX - fWidth / 2 - intToleSize, 0, MidpointRounding.AwayFromZero);
                if (arrTemplateStartX[i] < 0)  // Set to zero if value smaller than zero
                {
                    intAdjustX = arrTemplateStartX[i]; // add adjust value when intStartX change from negative to 0
                    arrTemplateStartX[i] = 0;
                }
                arrTemplateStartY[i] = (int)Math.Round(fTemplateCenterY - fHeight / 2 - intToleSize, 0, MidpointRounding.AwayFromZero);
                if (arrTemplateStartY[i] < 0)  // Set to zero if value smaller than zero
                {
                    intAdjustY = arrTemplateStartY[i]; // add adjust value when intStartY change from negative to 0
                    arrTemplateStartY[i] = 0;
                }

                // Get "sample" pad start and end corner point with tolerance size added.
                arrSampleStartX[i] = (int)Math.Round(fSampleCenterX - fWidth / 2 - intToleSize, 0, MidpointRounding.AwayFromZero);
                if (arrSampleStartX[i] < 0) // Set to zero if value smaller than zero
                {
                    if (arrSampleStartX[i] > intAdjustX)    // set bigger value in adjust value // Why is bigger, not smaller?
                        intAdjustX = arrSampleStartX[i];
                    arrSampleStartX[i] = 0;
                }
                arrSampleStartY[i] = (int)Math.Round(fSampleCenterY - fHeight / 2 - intToleSize, 0, MidpointRounding.AwayFromZero);
                if (arrSampleStartY[i] < 0) // Set to zero if value smaller than zero
                {
                    if (arrSampleStartY[i] > intAdjustY)    // set bigger value in adjust value // Why is bigger, not smaller?
                        intAdjustY = arrSampleStartY[i];
                    arrSampleStartY[i] = 0;
                }

                // Set "template" pad width with tolerance size and adjust value added
                arrTemplateSampleWidth[i] = (int)Math.Round(fWidth + intToleSize * 2, 0, MidpointRounding.AwayFromZero);
                intEndX = arrTemplateStartX[i] + arrTemplateSampleWidth[i] + intAdjustX;
                int intEndAdjustX = 0;
                if (intEndX > objTemplateROI.ref_ROIWidth - 1)
                {
                    intEndAdjustX = (intEndX - (objTemplateROI.ref_ROIWidth - 1));  // Set end adjust value if endx bigger than roi area
                }
                arrTemplateSampleHeight[i] = (int)Math.Round(fHeight + intToleSize * 2, 0, MidpointRounding.AwayFromZero);
                intEndY = arrTemplateStartY[i] + arrTemplateSampleHeight[i] + intAdjustY;
                int intEndAdjustY = 0;
                if (intEndY > objTemplateROI.ref_ROIHeight - 1)
                {
                    intEndAdjustY = (intEndY - (objTemplateROI.ref_ROIHeight)); // Set end adjust value if endx bigger than roi area
                }

                // set pad corner end point value
                intEndX = arrSampleStartX[i] + arrTemplateSampleWidth[i] + intAdjustX;
                if (intEndX > intUnitTemplateLimitX)
                {
                    if (intEndAdjustX < (intEndX - intUnitTemplateLimitX))
                        intEndAdjustX = (intEndX - intUnitTemplateLimitX);
                }
                intEndY = arrSampleStartY[i] + arrTemplateSampleHeight[i] + intAdjustY;
                if (intEndY > intUnitTemplateLimitY)
                {
                    if (intEndAdjustY < (intEndY - intUnitTemplateLimitY))
                        intEndAdjustY = (intEndY - intUnitTemplateLimitY);
                }

                arrTemplateSampleWidth[i] -= intEndAdjustX;
                arrTemplateSampleHeight[i] -= intEndAdjustY;
            }

            // Calculate Min, optimum, average or individual offset of each pad
            arrOffsetStartX = new int[m_arrTemplateBlobPads.Count];
            arrOffsetStartY = new int[m_arrTemplateBlobPads.Count];
            switch (m_intPadSubtractMethod)
            {
                case 0: // Subtract Individual Pad Offset (default)
                    {

                    }
                    break;
                case 1: // Use Optimum Offset
                    {
                        List<int> arrLocalOffsetStartX = new List<int>();
                        List<int> arrLocalOffsetStartY = new List<int>();
                        for (int i = 0; i < m_arrTemplateBlobPads.Count; i++)
                        {
                            if (m_arrSampleBlobPads[i].intFailMask != 0)
                                continue;

                            arrOffsetStartX[i] = arrTemplateStartX[i] - arrSampleStartX[i];
                            arrOffsetStartY[i] = arrTemplateStartY[i] - arrSampleStartY[i];
                            arrLocalOffsetStartX.Add(arrTemplateStartX[i] - arrSampleStartX[i]);
                            arrLocalOffsetStartY.Add(arrTemplateStartY[i] - arrSampleStartY[i]);
                        }

                        List<int> arrLocalOffsetStartX_Sorted = new List<int>();
                        List<int> arrLocalOffsetStartY_Sorted = new List<int>();
                        Math2.SortData(arrLocalOffsetStartX.ToArray(), Math2.Sorting.Increase, ref arrLocalOffsetStartX_Sorted);
                        Math2.SortData(arrLocalOffsetStartY.ToArray(), Math2.Sorting.Increase, ref arrLocalOffsetStartY_Sorted);
                        int intOptimumOffsetX = Math2.GetModeValue(arrLocalOffsetStartX_Sorted.ToArray(), 1);
                        int intOptimumOffsetY = Math2.GetModeValue(arrLocalOffsetStartY_Sorted.ToArray(), 1);

                        for (int i = 0; i < m_arrTemplateBlobPads.Count; i++)
                        {
                            if (m_arrSampleBlobPads[i].intFailMask != 0)
                                continue;

                            arrOffsetStartX[i] -= intOptimumOffsetX;
                            arrOffsetStartY[i] -= intOptimumOffsetY;
                        }
                    }
                    break;
                case 2: // Avergage the offset (no Release)
                    {
                        int intTotalOffsetX = 0;
                        int intTotalOffsetY = 0;
                        int intRecordedCount = 0;
                        for (int i = 0; i < m_arrTemplateBlobPads.Count; i++)
                        {
                            if (i != 2)
                                continue;

                            if (m_arrSampleBlobPads[i].intFailMask != 0)
                                continue;

                            arrOffsetStartX[i] = arrTemplateStartX[i] - arrSampleStartX[i];
                            arrOffsetStartY[i] = arrTemplateStartY[i] - arrSampleStartY[i];

                            //arrOffsetStartX[i] = arrSampleStartX[i] - arrTemplateStartX[i];
                            //arrOffsetStartY[i] = arrSampleStartY[i] - arrTemplateStartY[i];
                            intTotalOffsetX += arrOffsetStartX[i];
                            intTotalOffsetY += arrOffsetStartY[i];
                            intRecordedCount++;
                        }
                        int intAverageOffsetX = intTotalOffsetX / intRecordedCount;
                        int intAverageOffsetY = intTotalOffsetY / intRecordedCount;

                        for (int i = 0; i < m_arrTemplateBlobPads.Count; i++)
                        {
                            if (m_arrSampleBlobPads[i].intFailMask != 0)
                                continue;

                            arrOffsetStartX[i] = intAverageOffsetX;
                            arrOffsetStartY[i] = intAverageOffsetY;
                        }
                    }
                    break;
                case 3: // Refer 1 pad offset as note (no release)
                    {
                        {
                            int intTotalOffsetX = 0;
                            int intTotalOffsetY = 0;
                            int intRecordedCount = 0;
                            for (int i = 0; i < m_arrTemplateBlobPads.Count; i++)
                            {
                                if (m_arrSampleBlobPads[i].intFailMask != 0)
                                    continue;

                                arrOffsetStartX[i] = arrTemplateStartX[i] - arrSampleStartX[i];
                                arrOffsetStartY[i] = arrTemplateStartY[i] - arrSampleStartY[i];

                                //arrOffsetStartX[i] = arrSampleStartX[i] - arrTemplateStartX[i];
                                //arrOffsetStartY[i] = arrSampleStartY[i] - arrTemplateStartY[i];
                                intTotalOffsetX += arrOffsetStartX[i];
                                intTotalOffsetY += arrOffsetStartY[i];
                                intRecordedCount++;
                            }
                            int intAverageOffsetX = intTotalOffsetX / intRecordedCount;
                            int intAverageOffsetY = intTotalOffsetY / intRecordedCount;

                            int intRefer = 1;
                            int intCompensateOffsetX = arrOffsetStartX[intRefer];
                            int intCompensateOffsetY = arrOffsetStartY[intRefer];
                            for (int i = 0; i < m_arrTemplateBlobPads.Count; i++)
                            {
                                if (m_arrSampleBlobPads[i].intFailMask != 0)
                                    continue;

                                arrOffsetStartX[i] -= intCompensateOffsetX;
                                arrOffsetStartY[i] -= intCompensateOffsetY;
                            }

                        }
                    }
                    break;
            }
        }
        private void DefinePadPositionOffset(ref float fOptimumOffsetX, ref float fOptimumOffsetY)
        {
            List<List<float>> arrOffsetCenterX = new List<List<float>>();
            List<List<float>> arrOffsetCenterY = new List<List<float>>();

            List<List<float>> arrLocalOffsetCenterX = new List<List<float>>();
            List<List<float>> arrLocalOffsetCenterY = new List<List<float>>();
            fOptimumOffsetX = 0;
            fOptimumOffsetY = 0;
            List<float> arrAverageX = new List<float>();
            List<float> arrAverageY = new List<float>();
            //List<float> arrAverageX_Sorted = new List<float>();
            //List<float> arrAverageY_Sorted = new List<float>();
            float fAverageX = 0;
            float fAverageY = 0;
            List<float> arrScoreX = new List<float>();
            List<float> arrScoreY = new List<float>();
            List<float> arrScoreX_Sorted = new List<float>();
            List<float> arrScoreY_Sorted = new List<float>();
            int intScoreXCounter = 0;
            int intScoreYCounter = 0;
            List<int> arrMinXIndex = new List<int>();
            List<int> arrMinYIndex = new List<int>();
            for (int i = 0; i < m_arrTemplateBlobPads.Count; i++)
            {
                arrOffsetCenterX.Add(new List<float>());
                arrOffsetCenterY.Add(new List<float>());
                arrLocalOffsetCenterX.Add(new List<float>());
                arrLocalOffsetCenterY.Add(new List<float>());
                float fMinX = float.MaxValue;
                float fMinY = float.MaxValue;

                for (int j = 0; j < m_arrTemporaryBlobPads.Count; j++)
                {
                    float fDiffX = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fCenterX - ((BlobsFeatures)m_arrTemporaryBlobPads[j]).fCenterX;
                    float fDiffY = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fCenterY - ((BlobsFeatures)m_arrTemporaryBlobPads[j]).fCenterY;
                    arrOffsetCenterX[i].Add(fDiffX);
                    arrOffsetCenterY[i].Add(fDiffY);
                    arrLocalOffsetCenterX[i].Add(Math.Abs(fDiffX));
                    arrLocalOffsetCenterY[i].Add(Math.Abs(fDiffY));
                    if (Math.Abs(fDiffX) < fMinX)
                    {
                        fMinX = Math.Abs(fDiffX);
                    }
                    if (Math.Abs(fDiffY) < fMinY)
                    {
                        fMinY = Math.Abs(fDiffY);
                    }
                }

                fAverageX += fMinX;
                fAverageY += fMinY;

                if (!arrMinXIndex.Contains(arrLocalOffsetCenterX[i].IndexOf(fMinX)))
                    intScoreXCounter++;
                if (!arrMinYIndex.Contains(arrLocalOffsetCenterY[i].IndexOf(fMinY)))
                    intScoreYCounter++;
                arrMinXIndex.Add(arrLocalOffsetCenterX[i].IndexOf(fMinX));
                arrMinYIndex.Add(arrLocalOffsetCenterY[i].IndexOf(fMinY));
            }
            arrScoreX.Add((float)intScoreXCounter / m_arrTemplateBlobPads.Count * 100);
            arrScoreY.Add((float)intScoreYCounter / m_arrTemplateBlobPads.Count * 100);
            arrScoreX_Sorted.Add(arrScoreX[arrScoreX.Count - 1]);
            arrScoreY_Sorted.Add(arrScoreY[arrScoreY.Count - 1]);
            arrAverageX.Add(fAverageX / m_arrTemplateBlobPads.Count);
            arrAverageY.Add(fAverageY / m_arrTemplateBlobPads.Count);
            //arrAverageX_Sorted.Add(arrAverageX[arrAverageX.Count - 1]);
            //arrAverageY_Sorted.Add(arrAverageY[arrAverageY.Count - 1]);
            for (int a = 0; a < arrLocalOffsetCenterX.Count; a++)
            {
                for (int b = 0; b < arrLocalOffsetCenterX[a].Count; b++)
                {
                    intScoreXCounter = 0;
                    intScoreYCounter = 0;
                    arrMinXIndex = new List<int>();
                    arrMinYIndex = new List<int>();
                    fAverageX = 0;
                    fAverageY = 0;
                    List<List<float>> arrLocalOffsetCenterX2 = new List<List<float>>();
                    List<List<float>> arrLocalOffsetCenterY2 = new List<List<float>>();
                    for (int i = 0; i < arrLocalOffsetCenterX.Count; i++)
                    {
                        arrLocalOffsetCenterX2.Add(new List<float>());
                        arrLocalOffsetCenterY2.Add(new List<float>());
                        float fMinX = float.MaxValue;
                        float fMinY = float.MaxValue;
                        for (int j = 0; j < arrLocalOffsetCenterX[i].Count; j++)
                        {
                            float fDiffX = arrLocalOffsetCenterX[i][j] - arrLocalOffsetCenterX[a][b];
                            float fDiffY = arrLocalOffsetCenterY[i][j] - arrLocalOffsetCenterY[a][b];
                            arrLocalOffsetCenterX2[i].Add(Math.Abs(fDiffX));
                            arrLocalOffsetCenterY2[i].Add(Math.Abs(fDiffY));
                            if (Math.Abs(fDiffX) < fMinX)
                            {
                                fMinX = Math.Abs(fDiffX);
                            }
                            if (Math.Abs(fDiffY) < fMinY)
                            {
                                fMinY = Math.Abs(fDiffY);
                            }
                        }
                        fAverageX += fMinX;
                        fAverageY += fMinY;

                        if (!arrMinXIndex.Contains(arrLocalOffsetCenterX2[i].IndexOf(fMinX)))
                            intScoreXCounter++;
                        if (!arrMinYIndex.Contains(arrLocalOffsetCenterY2[i].IndexOf(fMinY)))
                            intScoreYCounter++;
                        arrMinXIndex.Add(arrLocalOffsetCenterX2[i].IndexOf(fMinX));
                        arrMinYIndex.Add(arrLocalOffsetCenterY2[i].IndexOf(fMinY));
                    }
                    arrScoreX.Add((float)intScoreXCounter / m_arrTemplateBlobPads.Count * 100);
                    arrScoreY.Add((float)intScoreYCounter / m_arrTemplateBlobPads.Count * 100);
                    arrScoreX_Sorted.Add(arrScoreX[arrScoreX.Count - 1]);
                    arrScoreY_Sorted.Add(arrScoreY[arrScoreY.Count - 1]);
                    arrAverageX.Add(fAverageX / m_arrTemplateBlobPads.Count);
                    arrAverageY.Add(fAverageY / m_arrTemplateBlobPads.Count);
                    //arrAverageX_Sorted.Add(arrAverageX[arrAverageX.Count - 1]);
                    //arrAverageY_Sorted.Add(arrAverageY[arrAverageY.Count - 1]);
                }
            }
            arrScoreX_Sorted.Sort();
            arrScoreY_Sorted.Sort();
            //arrAverageX_Sorted.Sort();
            //arrAverageY_Sorted.Sort();

            List<int> arrHighScoreX = Enumerable.Range(0, arrScoreX.Count).Where(i => arrScoreX[i] == arrScoreX_Sorted[arrScoreX_Sorted.Count - 1]).ToList();
            List<int> arrHighScoreY = Enumerable.Range(0, arrScoreY.Count).Where(i => arrScoreY[i] == arrScoreY_Sorted[arrScoreY_Sorted.Count - 1]).ToList();
            float fMinAverage = float.MaxValue;
            int intMinAverageXIndex = 0;
            for (int i = 0; i < arrHighScoreX.Count; i++)
            {
                if (arrAverageX[arrHighScoreX[i]] < fMinAverage)
                {
                    fMinAverage = arrAverageX[arrHighScoreX[i]];
                    intMinAverageXIndex = arrHighScoreX[i];
                }
            }
            fMinAverage = float.MaxValue;
            int intMinAverageYIndex = 0;
            for (int i = 0; i < arrHighScoreY.Count; i++)
            {
                if (arrAverageY[arrHighScoreY[i]] < fMinAverage)
                {
                    fMinAverage = arrAverageY[arrHighScoreY[i]];
                    intMinAverageYIndex = arrHighScoreY[i];
                }
            }

            List<int> arrLowAveX = Enumerable.Range(0, arrAverageX.Count).Where(i => arrAverageX[i] == arrAverageX[intMinAverageXIndex]).ToList();
            List<int> arrLowAveY = Enumerable.Range(0, arrAverageY.Count).Where(i => arrAverageY[i] == arrAverageY[intMinAverageYIndex]).ToList();

            if (m_arrTemporaryBlobPads.Count > 0)
            {
                for (int i = 0; i < arrLowAveX.Count; i++)
                {
                    //int intIndexX = arrAverageX.IndexOf(arrAverageX_Sorted[0]);
                    int intIndexX = arrLowAveX[i];
                    if (intIndexX > 0)
                    {
                        int intA = (intIndexX - 1) / m_arrTemporaryBlobPads.Count;
                        int intB = (intIndexX - 1) % m_arrTemporaryBlobPads.Count;

                        if (i == 0 || (Math.Abs(arrOffsetCenterX[intA][intB]) < Math.Abs(fOptimumOffsetX)))
                            fOptimumOffsetX = arrOffsetCenterX[intA][intB];
                    }
                }

                for (int i = 0; i < arrLowAveY.Count; i++)
                {
                    //int intIndexY = arrAverageY.IndexOf(arrAverageY_Sorted[0]);
                    int intIndexY = arrLowAveY[i];
                    if (intIndexY > 0)
                    {
                        int intA = (intIndexY - 1) / m_arrTemporaryBlobPads.Count;
                        int intB = (intIndexY - 1) % m_arrTemporaryBlobPads.Count;

                        if (i == 0 || (Math.Abs(arrOffsetCenterY[intA][intB]) < Math.Abs(fOptimumOffsetY)))
                            fOptimumOffsetY = arrOffsetCenterY[intA][intB];
                    }
                }
            }
        }

        public void ResetColorThresholdData()
        {
            m_arrDefectColorThresName.Clear();
            m_arrDefectColorSystem.Clear();
            m_arrDefectCloseIteration.Clear();
            m_arrDefectInvertBlackWhite.Clear();
            m_arrDefectColor.Clear();
            m_arrDefectColorTolerance.Clear();
            m_arrDefectColorMinArea.Clear();
            m_arrDefectType.Clear();
            m_arrDefectImageNo.Clear();
            m_arrDefectDontCareMode.Clear();
            m_arrDefectColorInspection_Top.Clear();
            m_arrDefectColorInspection_Right.Clear();
            m_arrDefectColorInspection_Bottom.Clear();
            m_arrDefectColorInspection_Left.Clear();
            m_arrDefectColorInspectionFailCondition.Clear();
            m_arrDefectColorInspectionWidth.Clear();
            m_arrDefectColorInspectionLength.Clear();
            m_arrDefectColorInspectionMinArea.Clear();
            m_arrDefectColorInspectionMaxArea.Clear();
            m_arrDefectColorInspectionTotalArea.Clear();
        }
        public void ResetColorThresholdDataToMinCount(int intMinCount)
        {
            for (int i = m_arrDefectColorThresName.Count; i > intMinCount; i--)
            {
                m_arrDefectColorThresName.RemoveAt(i - 1);
            }
            for (int i = m_arrDefectColorSystem.Count; i > intMinCount; i--)
            {
                m_arrDefectColorSystem.RemoveAt(i - 1);
            }
            for (int i = m_arrDefectCloseIteration.Count; i > intMinCount; i--)
            {
                m_arrDefectCloseIteration.RemoveAt(i - 1);
            }
            for(int i = m_arrDefectInvertBlackWhite.Count; i > intMinCount; i--)
            {
                m_arrDefectInvertBlackWhite.RemoveAt(i - 1);
            }
            for (int i = m_arrDefectColor.Count; i > intMinCount; i--)
            {
                m_arrDefectColor.RemoveAt(i - 1);
            }
            for (int i = m_arrDefectColorTolerance.Count; i > intMinCount; i--)
            {
                m_arrDefectColorTolerance.RemoveAt(i - 1);
            }
            for (int i = m_arrDefectColorMinArea.Count; i > intMinCount; i--)
            {
                m_arrDefectColorMinArea.RemoveAt(i - 1);
            }
            for (int i = m_arrDefectType.Count; i > intMinCount; i--)
            {
                m_arrDefectType.RemoveAt(i - 1);
            }
            for (int i = m_arrDefectImageNo.Count; i > intMinCount; i--)
            {
                m_arrDefectImageNo.RemoveAt(i - 1);
            }
            for (int i = m_arrDefectDontCareMode.Count; i > intMinCount; i--)
            {
                m_arrDefectDontCareMode.RemoveAt(i - 1);
            }
            for (int i = m_arrDefectColorInspection_Top.Count; i > intMinCount; i--)
            {
                m_arrDefectColorInspection_Top.RemoveAt(i - 1);
            }
            for (int i = m_arrDefectColorInspection_Right.Count; i > intMinCount; i--)
            {
                m_arrDefectColorInspection_Right.RemoveAt(i - 1);
            }
            for (int i = m_arrDefectColorInspection_Bottom.Count; i > intMinCount; i--)
            {
                m_arrDefectColorInspection_Bottom.RemoveAt(i - 1);
            }
            for (int i = m_arrDefectColorInspection_Left.Count; i > intMinCount; i--)
            {
                m_arrDefectColorInspection_Left.RemoveAt(i - 1);
            }
            for (int i = m_arrDefectColorInspectionLength.Count; i > intMinCount; i--)
            {
                m_arrDefectColorInspectionLength.RemoveAt(i - 1);
            }
            for (int i = m_arrDefectColorInspectionFailCondition.Count; i > intMinCount; i--)
            {
                m_arrDefectColorInspectionFailCondition.RemoveAt(i - 1);
            }
            for (int i = m_arrDefectColorInspectionWidth.Count; i > intMinCount; i--)
            {
                m_arrDefectColorInspectionWidth.RemoveAt(i - 1);
            }
            for (int i = m_arrDefectColorInspectionMinArea.Count; i > intMinCount; i--)
            {
                m_arrDefectColorInspectionMinArea.RemoveAt(i - 1);
            }
            for (int i = m_arrDefectColorInspectionMaxArea.Count; i > intMinCount; i--)
            {
                m_arrDefectColorInspectionMaxArea.RemoveAt(i - 1);
            }
            for (int i = m_arrDefectColorInspectionTotalArea.Count; i > intMinCount; i--)
            {
                m_arrDefectColorInspectionTotalArea.RemoveAt(i - 1);
            }
        }
        public bool AddColorThresholdData(string strDefectThresName, int intDefectSystemColor, int intDefectCloseIteration, bool blnDefectInvertBlackWhite,
                                                        int intColorThreshold1, int intColorThreshold2, int intColorThreshold3,
                                                        int intColorThresholdTolerance1, int intColorThresholdTolerance2, int intColorThresholdTolerance3,
                                                        int intDefectMinArea, int intDefectType, int intDefectImageNo, int intDontCareMode,
                                                        int intDefectColorInspection_Top, int intDefectColorInspection_Right, int intDefectColorInspection_Bottom, int intDefectColorInspection_Left)
        {
            try
            {
                m_arrDefectColorThresName.Add(strDefectThresName);
                m_arrDefectColorSystem.Add(intDefectSystemColor);
                m_arrDefectCloseIteration.Add(intDefectCloseIteration);
                m_arrDefectInvertBlackWhite.Add(blnDefectInvertBlackWhite);

                int intIndex = m_arrDefectColor.Count;
                m_arrDefectColor.Add(new int[3]);
                m_arrDefectColor[intIndex][0] = intColorThreshold1;
                m_arrDefectColor[intIndex][1] = intColorThreshold2;
                m_arrDefectColor[intIndex][2] = intColorThreshold3;

                m_arrDefectColorTolerance.Add(new int[3]);
                m_arrDefectColorTolerance[intIndex][0] = intColorThresholdTolerance1;
                m_arrDefectColorTolerance[intIndex][1] = intColorThresholdTolerance2;
                m_arrDefectColorTolerance[intIndex][2] = intColorThresholdTolerance3;

                m_arrDefectColorMinArea.Add(intDefectMinArea);

                m_arrDefectType.Add(intDefectType);
                m_arrDefectImageNo.Add(intDefectImageNo);
                m_arrDefectDontCareMode.Add(intDontCareMode);
                m_arrDefectColorInspection_Top.Add(intDefectColorInspection_Top);
                m_arrDefectColorInspection_Right.Add(intDefectColorInspection_Right);
                m_arrDefectColorInspection_Bottom.Add(intDefectColorInspection_Bottom);
                m_arrDefectColorInspection_Left.Add(intDefectColorInspection_Left);

                m_arrDefectColorInspectionFailCondition.Add(0);
                m_arrDefectColorInspectionWidth.Add(0);
                m_arrDefectColorInspectionLength.Add(0);
                m_arrDefectColorInspectionMinArea.Add(0);
                m_arrDefectColorInspectionMaxArea.Add(0);
                m_arrDefectColorInspectionTotalArea.Add(0);
                return true;
            }
            catch
            {
                return false;
            }
        }
        public bool AddColorThresholdData(string strDefectThresName, int intDefectSystemColor, int intDefectCloseIteration, bool blnDefectInvertBlackWhite,
                                               int intColorThreshold1, int intColorThreshold2, int intColorThreshold3,
                                               int intColorThresholdTolerance1, int intColorThresholdTolerance2, int intColorThresholdTolerance3,
                                               int intDefectMinArea, int intDefectType, int intDefectImageNo, int intDontCareMode, int intInspectFailCondition,
                                               float m_intInspectWidth, float m_intInspectLength, float m_intInspectMinArea, float m_intInspectMaxArea, float m_intInspectTotalArea,
                                               int intDefectColorInspection_Top, int intDefectColorInspection_Right, int intDefectColorInspection_Bottom, int intDefectColorInspection_Left)
        {
            try
            {
                m_arrDefectColorThresName.Add(strDefectThresName);
                m_arrDefectColorSystem.Add(intDefectSystemColor);
                m_arrDefectCloseIteration.Add(intDefectCloseIteration);
                m_arrDefectInvertBlackWhite.Add(blnDefectInvertBlackWhite);

                int intIndex = m_arrDefectColor.Count;
                m_arrDefectColor.Add(new int[3]);
                m_arrDefectColor[intIndex][0] = intColorThreshold1;
                m_arrDefectColor[intIndex][1] = intColorThreshold2;
                m_arrDefectColor[intIndex][2] = intColorThreshold3;

                m_arrDefectColorTolerance.Add(new int[3]);
                m_arrDefectColorTolerance[intIndex][0] = intColorThresholdTolerance1;
                m_arrDefectColorTolerance[intIndex][1] = intColorThresholdTolerance2;
                m_arrDefectColorTolerance[intIndex][2] = intColorThresholdTolerance3;

                m_arrDefectColorMinArea.Add(intDefectMinArea);

                m_arrDefectType.Add(intDefectType);
                m_arrDefectImageNo.Add(intDefectImageNo);
                m_arrDefectDontCareMode.Add(intDontCareMode);
                m_arrDefectColorInspection_Top.Add(intDefectColorInspection_Top);
                m_arrDefectColorInspection_Right.Add(intDefectColorInspection_Right);
                m_arrDefectColorInspection_Bottom.Add(intDefectColorInspection_Bottom);
                m_arrDefectColorInspection_Left.Add(intDefectColorInspection_Left);

                m_arrDefectColorInspectionFailCondition.Add(intInspectFailCondition);
                m_arrDefectColorInspectionWidth.Add(m_intInspectWidth);
                m_arrDefectColorInspectionLength.Add(m_intInspectLength);
                m_arrDefectColorInspectionMinArea.Add(m_intInspectMinArea);
                m_arrDefectColorInspectionMaxArea.Add(m_intInspectMaxArea);
                m_arrDefectColorInspectionTotalArea.Add(m_intInspectTotalArea);
                return true;
            }
            catch
            {
                return false;
            }
        }
        public void DeleteColorThresholdData(int intIndex)
        {
            try
            {
                m_arrDefectColorThresName.RemoveAt(intIndex);
                m_arrDefectColorSystem.RemoveAt(intIndex);
                m_arrDefectCloseIteration.RemoveAt(intIndex);
                m_arrDefectInvertBlackWhite.RemoveAt(intIndex);

                m_arrDefectColor.RemoveAt(intIndex);

                m_arrDefectColorTolerance.RemoveAt(intIndex);

                m_arrDefectColorMinArea.RemoveAt(intIndex);

                m_arrDefectType.RemoveAt(intIndex);
                m_arrDefectImageNo.RemoveAt(intIndex);
                m_arrDefectDontCareMode.RemoveAt(intIndex);
                m_arrDefectColorInspection_Top.RemoveAt(intIndex);
                m_arrDefectColorInspection_Right.RemoveAt(intIndex);
                m_arrDefectColorInspection_Bottom.RemoveAt(intIndex);
                m_arrDefectColorInspection_Left.RemoveAt(intIndex);

                m_arrDefectColorInspectionFailCondition.RemoveAt(intIndex);
                m_arrDefectColorInspectionWidth.RemoveAt(intIndex);
                m_arrDefectColorInspectionLength.RemoveAt(intIndex);
                m_arrDefectColorInspectionMinArea.RemoveAt(intIndex);
                m_arrDefectColorInspectionMaxArea.RemoveAt(intIndex);
                m_arrDefectColorInspectionTotalArea.RemoveAt(intIndex);

            }
            catch
            {

            }
        }
        public float GetColorDefectInspectionLengthLimit(int intValueType, int intIndex)
        {
            if (m_arrDefectColorInspectionLength.Count > intIndex)
            {
                switch (intValueType)
                {
                    case -1: // Pixel X
                        return m_arrDefectColorInspectionLength[intIndex] * m_fMMToPixelXValue;
                    case -2: // Pixel Y
                        return m_arrDefectColorInspectionLength[intIndex] * m_fMMToPixelYValue;
                    case 1: // mm
                    case 2: // mil
                    case 3: // micron
                        return m_arrDefectColorInspectionLength[intIndex] * m_fMMToUnitValue;
                    default:
                        return 0;
                }
            }
            else
                return 0;
        }

        public int GetColorDefectInspection_Top(int intIndex)
        {
            if (m_arrDefectColorInspection_Top.Count > intIndex && intIndex != -1)
            {
                return m_arrDefectColorInspection_Top[intIndex];
            }
            else
                return 0;
        }
        public int GetColorDefectInspection_Right(int intIndex)
        {
            if (m_arrDefectColorInspection_Right.Count > intIndex && intIndex != -1)
            {
                return m_arrDefectColorInspection_Right[intIndex];
            }
            else
                return 0;
        }
        public int GetColorDefectInspection_Bottom(int intIndex)
        {
            if (m_arrDefectColorInspection_Bottom.Count > intIndex && intIndex != -1)
            {
                return m_arrDefectColorInspection_Bottom[intIndex];
            }
            else
                return 0;
        }
        public int GetColorDefectInspection_Left(int intIndex)
        {
            if (m_arrDefectColorInspection_Left.Count > intIndex && intIndex != -1)
            {
                return m_arrDefectColorInspection_Left[intIndex];
            }
            else
                return 0;
        }

        public int GetColorDefectInspectionFailCondition(int intIndex)
        {
            if (m_arrDefectColorInspectionFailCondition.Count > intIndex)
            {
                return m_arrDefectColorInspectionFailCondition[intIndex];
            }
            else
                return 0;
        }
        public float GetColorDefectInspectionWidthLimit(int intValueType, int intIndex)
        {
            if (m_arrDefectColorInspectionWidth.Count > intIndex)
            {
                switch (intValueType)
                {
                    case -1: // Pixel X
                        return m_arrDefectColorInspectionWidth[intIndex] * m_fMMToPixelXValue;
                    case -2: // Pixel Y
                        return m_arrDefectColorInspectionWidth[intIndex] * m_fMMToPixelYValue;
                    case 1: // mm
                    case 2: // mil
                    case 3: // micron
                        return m_arrDefectColorInspectionWidth[intIndex] * m_fMMToUnitValue;
                    default:
                        return 0;
                }
            }
            else
                return 0;
        }
        public float GetColorDefectInspectionMinAreaLimit(int intValueType, int intIndex)
        {
            if (m_arrDefectType.Count > intIndex)
            {
                if (m_arrDefectType[intIndex] == 0)
                {
                    return 0;
                }
            }

            if (m_arrDefectColorInspectionMinArea.Count > intIndex)
            {
                switch (intValueType)
                {
                    case 0: // Pixel
                        return m_arrDefectColorInspectionMinArea[intIndex] * m_fMMtoPixelAreaValue;
                    case 1: // mm
                    case 2: // mil
                    case 3: // micron
                        return m_arrDefectColorInspectionMinArea[intIndex] * m_fMMToUnitValueArea;
                    default:
                        return 0;
                }
            }
            else
                return 0;
        }
        public float GetColorDefectInspectionMaxAreaLimit(int intValueType, int intIndex)
        {
            if (m_arrDefectColorInspectionMaxArea.Count > intIndex)
            {
                switch (intValueType)
                {
                    case 0: // Pixel
                        return m_arrDefectColorInspectionMaxArea[intIndex] * m_fMMtoPixelAreaValue;
                    case 1: // mm
                    case 2: // mil
                    case 3: // micron
                        return m_arrDefectColorInspectionMaxArea[intIndex] * m_fMMToUnitValueArea;
                    default:
                        return 0;
                }
            }
            else
                return 0;
        }

        public float GetColorDefectInspectionTotalAreaLimit(int intValueType, int intIndex)
        {
            if (m_arrDefectColorInspectionTotalArea.Count > intIndex)
            {
                switch (intValueType)
                {
                    case 0: // Pixel
                        return m_arrDefectColorInspectionTotalArea[intIndex] * m_fMMtoPixelAreaValue;
                    case 1: // mm
                    case 2: // mil
                    case 3: // micron
                        return m_arrDefectColorInspectionTotalArea[intIndex] * m_fMMToUnitValueArea;
                    default:
                        return 0;
                }
            }
            else
                return 0;
        }
        public void SetColorDefectInspectionLengthLimit(float fValue, int intFromValueType, int intIndex)
        {
            if (m_arrDefectColorInspectionLength.Count > intIndex)
            {
                switch (intFromValueType)
                {
                    //Note* fValue should not be converted to pixel unless the m_fMMToPixelXValue == m_fMMToPixelYValue
                    //case 0: // Pixel X
                    //    m_fScratchLength = fValue / m_fMMToPixelXValue;
                    //    break;
                    //case 1: // Pixel Y
                    //    m_fScratchLength = fValue / m_fMMToPixelYValue;
                    //    break;
                    case 1: // mm
                    case 2: // mil
                    case 3: // micron
                    default:
                        m_arrDefectColorInspectionLength[intIndex] = fValue / m_fMMToUnitValue;
                        break;
                }
            }
        }

        public void SetColorDefectInspectionFailCondition(int intValue, int intIndex)
        {
            if (m_arrDefectColorInspectionFailCondition.Count > intIndex)
            {
                m_arrDefectColorInspectionFailCondition[intIndex] = intValue;
            }
        }
        public void SetColorDefectInspectionWidthLimit(float fValue, int intFromValueType, int intIndex)
        {
            if (m_arrDefectColorInspectionWidth.Count > intIndex)
            {
                switch (intFromValueType)
                {
                    //Note* fValue should not be converted to pixel unless the m_fMMToPixelXValue == m_fMMToPixelYValue
                    //case 0: // Pixel X
                    //    m_fScratchLength = fValue / m_fMMToPixelXValue;
                    //    break;
                    //case 1: // Pixel Y
                    //    m_fScratchLength = fValue / m_fMMToPixelYValue;
                    //    break;
                    case 1: // mm
                    case 2: // mil
                    case 3: // micron
                    default:
                        m_arrDefectColorInspectionWidth[intIndex] = fValue / m_fMMToUnitValue;
                        break;
                }
            }
        }
        public void SetColorDefectInspectionMinAreaLimit(float fValue, int intFromValueType, int intIndex)
        {
            if (m_arrDefectColorInspectionMinArea.Count > intIndex)
            {
                switch (intFromValueType)
                {
                    //Note* fValue should not be converted to pixel unless the m_fMMToPixelXValue == m_fMMToPixelYValue
                    //case 0: // Pixel X
                    //    m_fScratchLength = fValue / m_fMMToPixelXValue;
                    //    break;
                    //case 1: // Pixel Y
                    //    m_fScratchLength = fValue / m_fMMToPixelYValue;
                    //    break;
                    case 1: // mm
                    case 2: // mil
                    case 3: // micron
                    default:
                        m_arrDefectColorInspectionMinArea[intIndex] = fValue / m_fMMToUnitValueArea;
                        break;
                }
            }
        }
        public void SetColorDefectInspectionMaxAreaLimit(float fValue, int intFromValueType, int intIndex)
        {
            if (m_arrDefectColorInspectionMaxArea.Count > intIndex)
            {
                switch (intFromValueType)
                {
                    //Note* fValue should not be converted to pixel unless the m_fMMToPixelXValue == m_fMMToPixelYValue
                    //case 0: // Pixel X
                    //    m_fScratchLength = fValue / m_fMMToPixelXValue;
                    //    break;
                    //case 1: // Pixel Y
                    //    m_fScratchLength = fValue / m_fMMToPixelYValue;
                    //    break;
                    case 1: // mm
                    case 2: // mil
                    case 3: // micron
                    default:
                        m_arrDefectColorInspectionMaxArea[intIndex] = fValue / m_fMMToUnitValueArea;
                        break;
                }
            }
        }

        public void SetColorDefectInspectionTotalAreaLimit(float fValue, int intFromValueType, int intIndex)
        {
            if (m_arrDefectColorInspectionTotalArea.Count > intIndex)
            {
                switch (intFromValueType)
                {
                    //Note* fValue should not be converted to pixel unless the m_fMMToPixelXValue == m_fMMToPixelYValue
                    //case 0: // Pixel X
                    //    m_fScratchLength = fValue / m_fMMToPixelXValue;
                    //    break;
                    //case 1: // Pixel Y
                    //    m_fScratchLength = fValue / m_fMMToPixelYValue;
                    //    break;
                    case 1: // mm
                    case 2: // mil
                    case 3: // micron
                    default:
                        m_arrDefectColorInspectionTotalArea[intIndex] = fValue / m_fMMToUnitValueArea;
                        break;
                }
            }
        }
        public void SetColorDefectInspectionLengthLimit(float fValue, int intFromValueType, string strName)
        {
            for (int i = 0; i < m_arrDefectColorInspectionLength.Count; i++)
            {
                if (m_arrDefectColorThresName.Count > i && m_arrDefectColorThresName[i] == strName)
                {
                    switch (intFromValueType)
                    {
                        //Note* fValue should not be converted to pixel unless the m_fMMToPixelXValue == m_fMMToPixelYValue
                        //case 0: // Pixel X
                        //    m_fScratchLength = fValue / m_fMMToPixelXValue;
                        //    break;
                        //case 1: // Pixel Y
                        //    m_fScratchLength = fValue / m_fMMToPixelYValue;
                        //    break;
                        case 1: // mm
                        case 2: // mil
                        case 3: // micron
                        default:
                            m_arrDefectColorInspectionLength[i] = fValue / m_fMMToUnitValue;
                            break;
                    }
                }
            }
        }

        public void SetColorDefectInspectionFailCondition(int intValue, string strName)
        {
            for (int i = 0; i < m_arrDefectColorInspectionFailCondition.Count; i++)
            {
                if (m_arrDefectColorThresName.Count > i && m_arrDefectColorThresName[i] == strName)
                {
                    m_arrDefectColorInspectionFailCondition[i] = intValue;
                }
            }
        }
        public void SetColorDefectInspectionWidthLimit(float fValue, int intFromValueType, string strName)
        {
            for (int i = 0; i < m_arrDefectColorInspectionWidth.Count; i++)
            {
                if (m_arrDefectColorThresName.Count > i && m_arrDefectColorThresName[i] == strName)
                {
                    switch (intFromValueType)
                    {
                        //Note* fValue should not be converted to pixel unless the m_fMMToPixelXValue == m_fMMToPixelYValue
                        //case 0: // Pixel X
                        //    m_fScratchLength = fValue / m_fMMToPixelXValue;
                        //    break;
                        //case 1: // Pixel Y
                        //    m_fScratchLength = fValue / m_fMMToPixelYValue;
                        //    break;
                        case 1: // mm
                        case 2: // mil
                        case 3: // micron
                        default:
                            m_arrDefectColorInspectionWidth[i] = fValue / m_fMMToUnitValue;
                            break;
                    }
                }
            }
        }
        public void SetColorDefectInspectionMinAreaLimit(float fValue, int intFromValueType, string strName)
        {
            for (int i = 0; i < m_arrDefectColorInspectionMinArea.Count; i++)
            {
                if (m_arrDefectColorThresName.Count > i && m_arrDefectColorThresName[i] == strName)
                {
                    switch (intFromValueType)
                    {
                        //Note* fValue should not be converted to pixel unless the m_fMMToPixelXValue == m_fMMToPixelYValue
                        //case 0: // Pixel X
                        //    m_fScratchLength = fValue / m_fMMToPixelXValue;
                        //    break;
                        //case 1: // Pixel Y
                        //    m_fScratchLength = fValue / m_fMMToPixelYValue;
                        //    break;
                        case 1: // mm
                        case 2: // mil
                        case 3: // micron
                        default:
                            m_arrDefectColorInspectionMinArea[i] = fValue / m_fMMToUnitValueArea;
                            break;
                    }
                }
            }
        }
        public void SetColorDefectInspectionMaxAreaLimit(float fValue, int intFromValueType, string strName)
        {
            for (int i = 0; i < m_arrDefectColorInspectionMaxArea.Count; i++)
            {
                if (m_arrDefectColorThresName.Count > i && m_arrDefectColorThresName[i] == strName)
                {
                    switch (intFromValueType)
                    {
                        //Note* fValue should not be converted to pixel unless the m_fMMToPixelXValue == m_fMMToPixelYValue
                        //case 0: // Pixel X
                        //    m_fScratchLength = fValue / m_fMMToPixelXValue;
                        //    break;
                        //case 1: // Pixel Y
                        //    m_fScratchLength = fValue / m_fMMToPixelYValue;
                        //    break;
                        case 1: // mm
                        case 2: // mil
                        case 3: // micron
                        default:
                            m_arrDefectColorInspectionMaxArea[i] = fValue / m_fMMToUnitValueArea;
                            break;
                    }
                }
            }
        }

        public void SetColorDefectInspectionTotalAreaLimit(float fValue, int intFromValueType, string strName)
        {
            for (int i = 0; i < m_arrDefectColorInspectionTotalArea.Count; i++)
            {
                if (m_arrDefectColorThresName.Count > i && m_arrDefectColorThresName[i] == strName)
                {
                    switch (intFromValueType)
                    {
                        //Note* fValue should not be converted to pixel unless the m_fMMToPixelXValue == m_fMMToPixelYValue
                        //case 0: // Pixel X
                        //    m_fScratchLength = fValue / m_fMMToPixelXValue;
                        //    break;
                        //case 1: // Pixel Y
                        //    m_fScratchLength = fValue / m_fMMToPixelYValue;
                        //    break;
                        case 1: // mm
                        case 2: // mil
                        case 3: // micron
                        default:
                            m_arrDefectColorInspectionTotalArea[i] = fValue / m_fMMToUnitValueArea;
                            break;
                    }
                }
            }
        }
        public void DrawColorDefect(Graphics g, float fDrawingScaleX, float fDrawingScaleY, int intDefectSelectingNumber)
        {
            lock (m_objLockBlobs)
            {
                /*
                 * Why add value 1 to Center X/Y , and minus value 1 to size?
                 * DrawRectangle tool will draw rectangle with start x y line outer the object, and end X Y line inner the object.
                 * Adding value 1 to center X and y will make sure rectangle is drawed with start xy inner the object.
                 * Reduct 1 value to size will make sure the end XY keep inner the object.
                 */
                if (m_blnInspectLock)
                    return;

                Pen pen = new Pen(Color.Red, 1);
                Pen penLime = new Pen(Color.Lime, 1);

                for (int i = 0; i < m_arrColorDefectList.Count; i++)
                {
                    if (m_blnInspectLock)
                        return;

                    if (intDefectSelectingNumber == i)
                        pen = new Pen(Color.Yellow, 1);
                    else
                    {
                        if (m_arrColorDefectList[i].ref_intFailCriteria > 0 || m_arrColorDefectList[i].ref_blnFailTotalArea)
                        {
                            pen = new Pen(Color.Red, 1);
                        }
                        else
                        {
                            pen = new Pen(Color.Lime, 1);
                        }
                    }

                    float newX1 = 0, newY1 = 0;  // new point 1
                    float newX2 = 0, newY2 = 0; // new point 2
                    float newX3 = 0, newY3 = 0; // new point 3
                    float newX4 = 0, newY4 = 0; // new point 4

                    if (m_intColorDefectLinkMethod == 1)
                    {
                        Math2.NewXYAfterRotate1(m_arrColorDefectList[i].ref_fCenterX, m_arrColorDefectList[i].ref_fCenterY, (m_arrColorDefectList[i].ref_fCenterX - (m_arrColorDefectList[i].ref_fWidth / 2)), (m_arrColorDefectList[i].ref_fCenterY - (m_arrColorDefectList[i].ref_fHeight / 2)), m_arrColorDefectList[i].ref_fAngle, ref newX1, ref newY1);
                        Math2.NewXYAfterRotate2(m_arrColorDefectList[i].ref_fCenterX, m_arrColorDefectList[i].ref_fCenterY, (m_arrColorDefectList[i].ref_fCenterX - (m_arrColorDefectList[i].ref_fWidth / 2)), (m_arrColorDefectList[i].ref_fCenterY + (m_arrColorDefectList[i].ref_fHeight / 2)), m_arrColorDefectList[i].ref_fAngle, ref newX2, ref newY2);
                        Math2.NewXYAfterRotate3(m_arrColorDefectList[i].ref_fCenterX, m_arrColorDefectList[i].ref_fCenterY, (m_arrColorDefectList[i].ref_fCenterX + (m_arrColorDefectList[i].ref_fWidth / 2)), (m_arrColorDefectList[i].ref_fCenterY - (m_arrColorDefectList[i].ref_fHeight / 2)), m_arrColorDefectList[i].ref_fAngle, ref newX3, ref newY3);
                        Math2.NewXYAfterRotate4(m_arrColorDefectList[i].ref_fCenterX, m_arrColorDefectList[i].ref_fCenterY, (m_arrColorDefectList[i].ref_fCenterX + (m_arrColorDefectList[i].ref_fWidth / 2)), (m_arrColorDefectList[i].ref_fCenterY + (m_arrColorDefectList[i].ref_fHeight / 2)), m_arrColorDefectList[i].ref_fAngle, ref newX4, ref newY4);
                    }
                    else
                    {
                        Math2.NewXYAfterRotate1(m_arrColorDefectList[i].ref_fCenterX, m_arrColorDefectList[i].ref_fCenterY, (m_arrColorDefectList[i].ref_fCenterX - (m_arrColorDefectList[i].ref_fWidth / 2)), (m_arrColorDefectList[i].ref_fCenterY - (m_arrColorDefectList[i].ref_fHeight / 2)), -m_arrColorDefectList[i].ref_fAngle, ref newX1, ref newY1);
                        Math2.NewXYAfterRotate2(m_arrColorDefectList[i].ref_fCenterX, m_arrColorDefectList[i].ref_fCenterY, (m_arrColorDefectList[i].ref_fCenterX - (m_arrColorDefectList[i].ref_fWidth / 2)), (m_arrColorDefectList[i].ref_fCenterY + (m_arrColorDefectList[i].ref_fHeight / 2)), -m_arrColorDefectList[i].ref_fAngle, ref newX2, ref newY2);
                        Math2.NewXYAfterRotate3(m_arrColorDefectList[i].ref_fCenterX, m_arrColorDefectList[i].ref_fCenterY, (m_arrColorDefectList[i].ref_fCenterX + (m_arrColorDefectList[i].ref_fWidth / 2)), (m_arrColorDefectList[i].ref_fCenterY - (m_arrColorDefectList[i].ref_fHeight / 2)), -m_arrColorDefectList[i].ref_fAngle, ref newX3, ref newY3);
                        Math2.NewXYAfterRotate4(m_arrColorDefectList[i].ref_fCenterX, m_arrColorDefectList[i].ref_fCenterY, (m_arrColorDefectList[i].ref_fCenterX + (m_arrColorDefectList[i].ref_fWidth / 2)), (m_arrColorDefectList[i].ref_fCenterY + (m_arrColorDefectList[i].ref_fHeight / 2)), -m_arrColorDefectList[i].ref_fAngle, ref newX4, ref newY4);
                    }

                    g.DrawLine(pen, newX1 * fDrawingScaleX, newY1 * fDrawingScaleY, (newX3) * fDrawingScaleX, (newY3) * fDrawingScaleY);
                    g.DrawLine(pen, newX2 * fDrawingScaleX, newY2 * fDrawingScaleY, (newX1) * fDrawingScaleX, (newY1) * fDrawingScaleY);
                    g.DrawLine(pen, newX2 * fDrawingScaleX, newY2 * fDrawingScaleY, (newX4) * fDrawingScaleX, (newY4) * fDrawingScaleY);
                    g.DrawLine(pen, newX4 * fDrawingScaleX, newY4 * fDrawingScaleY, (newX3) * fDrawingScaleX, (newY3) * fDrawingScaleY);

                }
            }
        }

        public void SubtractColorDontCareImage(ROI objROI, ROI objResultROI, int intDontCareMode, ImageDrawing objPadColorDontCareImage)
        {
            if (intDontCareMode == 0)
                return;
            //ROI objROI2 = new ROI();
            //objROI2.LoadROISetting(objROI.ref_ROITotalX, objROI.ref_ROITotalY, objROI.ref_ROIWidth, objROI.ref_ROIHeight);
            //ImageDrawing objImage = new ImageDrawing(objROI.ref_ROI.TopParent.Width, objROI.ref_ROI.TopParent.Height);
            //EasyImage.Copy(objROI.ref_ROI.TopParent, objImage.ref_objMainImage);
            //objROI2.AttachImage(objImage);

            //EasyImage.Threshold(objROI2.ref_ROI, objROI2.ref_ROI, m_intThresholdValue);
            //if (!blnPadChecked)
            //{
            //    EasyImage.Oper(EArithmeticLogicOperation.Invert, objROI2.ref_ROI, objROI2.ref_ROI);
            //}

            //EasyImage.Oper(EArithmeticLogicOperation.Multiply, objResultROI.ref_ROI, objROI2.ref_ROI, objResultROI.ref_ROI);

            //objROI2.Dispose();
            //objImage.Dispose();
            bool blnDebugImage = false;
            if (intDontCareMode != 3)
            {


                // Find a suitable Unit Size for both template and sample ROI (Solution: Use Learn Package ROI size)
                int intTestUnitWidth = m_ImgUnitTemplateImage.Width;
                int intTestUnitHeight = m_ImgUnitTemplateImage.Height;
                // Get threshold value
                int intThresholdValue;
                if (m_intThresholdValue < 0)
                {
                    EBW8 objBW8 = EasyImage.AutoThreshold(objROI.ref_ROI, EThresholdMode.MinResidue);
                    intThresholdValue = objBW8.Value;
                }
                else
                    intThresholdValue = m_intThresholdValue;
                //ImageDrawing objTempImage = new ImageDrawing(true, m_objInsPadPkgImage1.ref_intCameraResolutionWidth, m_objInsPadPkgImage1.ref_intCameraResolutionHeight);
                //// ---- Sample -------
                //// Get ready sample ROI,
                //ROI objThresholdSampleROI = new ROI();
                //objThresholdSampleROI.AttachImage(objTempImage); // Attach sample ROI to ori size image. m_objInsPadPkgImage1 is a ori size image used to keep the sample image temporary for modification such as double threshold
                //objThresholdSampleROI.LoadROISetting(0, 0,
                //                                     intTestUnitWidth, intTestUnitHeight);
                ////objThresholdSampleROI.LoadROISetting(objResultROI.ref_ROIPositionX, objResultROI.ref_ROIPositionY,
                ////                                     objResultROI.ref_ROIWidth, objResultROI.ref_ROIHeight);
//#if (Debug_2_12 || Release_2_12)
//                // Threshold sample unit using Pad Threshold
//                if (m_fPadImageGain != 1f)
//                {
//                    ROI objROI2 = new ROI();
//                    objROI2.LoadROISetting(objROI.ref_ROITotalX, objROI.ref_ROITotalY, objROI.ref_ROIWidth, objROI.ref_ROIHeight);
//                    ImageDrawing objImage2 = new ImageDrawing(objROI.ref_ROI.TopParent.Width, objROI.ref_ROI.TopParent.Height);
//                    EasyImage.Copy(objROI.ref_ROI.TopParent, objImage2.ref_objMainImage);
//                    objROI2.AttachImage(objImage2);

//                    EasyImage.GainOffset(objROI2.ref_ROI, objROI2.ref_ROI, m_fPadImageGain);

//                    EasyImage.Threshold(objROI2.ref_ROI, objThresholdSampleROI.ref_ROI, (uint)intThresholdValue);

//                    objROI2.Dispose();
//                    objImage2.Dispose();
//                }
//                else
//                {
//                    EasyImage.Threshold(objROI.ref_ROI, objThresholdSampleROI.ref_ROI, (uint)intThresholdValue);   // error happen when set 255, 0);
//                }
//#elif (DEBUG || RELEASE || RTXRelease || RTXDebug)
//                // Threshold sample unit using Pad Threshold
//                if (m_fPadImageGain != 1f)
//                {
//                    ROI objROI2 = new ROI();
//                    objROI2.LoadROISetting(objROI.ref_ROITotalX, objROI.ref_ROITotalY, objROI.ref_ROIWidth, objROI.ref_ROIHeight);
//                    ImageDrawing objImage2 = new ImageDrawing(objROI.ref_ROI.TopParent.Width, objROI.ref_ROI.TopParent.Height);
//                    EasyImage.Copy(objROI.ref_ROI.TopParent, objImage2.ref_objMainImage);
//                    objROI2.AttachImage(objImage2);

//                    EasyImage.GainOffset(objROI2.ref_ROI, objROI2.ref_ROI, m_fPadImageGain);

//                    EasyImage.Threshold(objROI2.ref_ROI, objThresholdSampleROI.ref_ROI, intThresholdValue);

//                    objROI2.Dispose();
//                    objImage2.Dispose();
//                }
//                else
//                {
//                    EasyImage.Threshold(objROI.ref_ROI, objThresholdSampleROI.ref_ROI, intThresholdValue);   // error happen when set 255, 0);
//                                                                                                         //EasyImage.Oper(EArithmeticLogicOperation.Invert, objThresholdSampleROI.ref_ROI, objThresholdSampleROI.ref_ROI);
//                }
//#endif
//                EasyImage.Oper(EArithmeticLogicOperation.Invert, objThresholdSampleROI.ref_ROI, objThresholdSampleROI.ref_ROI);

                if (blnDebugImage)
                {
                    objROI.SaveImage("D:\\TS\\01_objImage1SampleUnitROI.bmp"); // debug
                    //objThresholdSampleROI.SaveImage("D:\\TS\\02_objThresholdSampleROI.bmp");   // debug
                }

                // ---- Template ------
                // Get ready template ROI
                ROI objThresholdTemplateROI = new ROI();
                if ((m_ImgTUnitErodeThresImage.Width != m_ImgUnitTemplateImage.Width) || (m_ImgTUnitErodeThresImage.Height != m_ImgUnitTemplateImage.Height))
                    m_ImgTUnitErodeThresImage.SetSize(m_ImgUnitTemplateImage.Width, m_ImgUnitTemplateImage.Height);
#if (Debug_2_12 || Release_2_12)
                if (m_fPadImageGain != 1f)
                {
                    ROI objROI2 = new ROI();
                    objROI2.LoadROISetting(objROI.ref_ROITotalX, objROI.ref_ROITotalY, objROI.ref_ROIWidth, objROI.ref_ROIHeight);
                    ImageDrawing objImage2 = new ImageDrawing(objROI.ref_ROI.TopParent.Width, objROI.ref_ROI.TopParent.Height);
                    EasyImage.Copy(objROI.ref_ROI.TopParent, objImage2.ref_objMainImage);
                    objROI2.AttachImage(objImage2);

                    EasyImage.GainOffset(m_ImgUnitTemplateImage, m_ImgTUnitErodeThresImage, m_fPadImageGain);

                    EasyImage.Threshold(m_ImgTUnitErodeThresImage, m_ImgTUnitErodeThresImage, (uint)intThresholdValue);

                    objROI2.Dispose();
                    objImage2.Dispose();
                }
                else
                {
                    EasyImage.Threshold(m_ImgUnitTemplateImage, m_ImgTUnitErodeThresImage, (uint)intThresholdValue);
                }
#elif (DEBUG || RELEASE || RTXRelease || RTXDebug)
                if (m_fPadImageGain != 1f)
                {
                    ROI objROI2 = new ROI();
                    objROI2.LoadROISetting(objROI.ref_ROITotalX, objROI.ref_ROITotalY, objROI.ref_ROIWidth, objROI.ref_ROIHeight);
                    ImageDrawing objImage2 = new ImageDrawing(objROI.ref_ROI.TopParent.Width, objROI.ref_ROI.TopParent.Height);
                    EasyImage.Copy(objROI.ref_ROI.TopParent, objImage2.ref_objMainImage);
                    objROI2.AttachImage(objImage2);

                    EasyImage.GainOffset(m_ImgUnitTemplateImage, m_ImgTUnitErodeThresImage, m_fPadImageGain);

                    EasyImage.Threshold(m_ImgTUnitErodeThresImage, m_ImgTUnitErodeThresImage, intThresholdValue);

                    objROI2.Dispose();
                    objImage2.Dispose();
                }
                else
                {
                    EasyImage.Threshold(m_ImgUnitTemplateImage, m_ImgTUnitErodeThresImage, intThresholdValue);
                }
#endif

                objThresholdTemplateROI.ref_ROI.Detach();
                objThresholdTemplateROI.ref_ROI.Attach(m_ImgTUnitErodeThresImage);
                objThresholdTemplateROI.LoadROISetting((int)Math.Round((float)m_ImgTUnitErodeThresImage.Width / 2 - (float)intTestUnitWidth / 2, 0, MidpointRounding.AwayFromZero),
                                     (int)Math.Round((float)m_ImgTUnitErodeThresImage.Height / 2 - (float)intTestUnitHeight / 2, 0, MidpointRounding.AwayFromZero),
                                     intTestUnitWidth, intTestUnitHeight);

                if (blnDebugImage)
                {
                    m_ImgUnitTemplateImage.Save("D:\\TS\\03_ImgUnitTemplateImage.bmp");                   // debug
                    m_ImgTUnitErodeThresImage.Save("D:\\TS\\04_ImgTUnitErodeThresImage.bmp");        // debug
                    objThresholdTemplateROI.SaveImage("D:\\TS\\05_objThresholdTemplateROI.bmp");     // debug
                }

                // ---- White Background --------------
                m_ImgWhiteUnitTemplateImage2.SetSize(m_ImgWhiteUnitTemplateImage.Width, m_ImgWhiteUnitTemplateImage.Height);
                m_ImgWhiteUnitTemplateImage.CopyTo(m_ImgWhiteUnitTemplateImage2);
                ROI objWhiteBgTemplateROI = new ROI();
                objWhiteBgTemplateROI.ref_ROI.Detach();
                objWhiteBgTemplateROI.ref_ROI.Attach(m_ImgWhiteUnitTemplateImage2);
                objWhiteBgTemplateROI.LoadROISetting(0, 0, intTestUnitWidth, intTestUnitHeight);

                if (blnDebugImage)
                {
                    objWhiteBgTemplateROI.SaveImage("D:\\TS\\06_objWhiteBgTemplateROI.bmp");     // debug
                }

                int[] arrTemplateStartX = new int[m_arrTemplateBlobPads.Count];
                int[] arrTemplateStartY = new int[m_arrTemplateBlobPads.Count];
                int[] arrTemplateEndX = new int[m_arrTemplateBlobPads.Count];
                int[] arrTemplateEndY = new int[m_arrTemplateBlobPads.Count];
                int[] arrSampleStartX = new int[m_arrTemplateBlobPads.Count];
                int[] arrSampleStartY = new int[m_arrTemplateBlobPads.Count];
                int[] arrSampleEndX = new int[m_arrTemplateBlobPads.Count];
                int[] arrSampleEndY = new int[m_arrTemplateBlobPads.Count];
                int[] arrTemplateSampleWidth = new int[m_arrTemplateBlobPads.Count];
                int[] arrTemplateSampleHeight = new int[m_arrTemplateBlobPads.Count];
                int[] arrDifferentSizeX = new int[m_arrTemplateBlobPads.Count]; // Template and sample different size
                int[] arrDifferentSizeY = new int[m_arrTemplateBlobPads.Count]; // Template and sample different size
                int[] arrOffsetStartX = new int[m_arrTemplateBlobPads.Count];
                int[] arrOffsetStartY = new int[m_arrTemplateBlobPads.Count];

                DefinePadSubtractOffset(objThresholdTemplateROI, m_intMPDilateHalfWidth, m_ImgWhiteUnitTemplateImage2.Width - 1, m_ImgWhiteUnitTemplateImage2.Height - 1,
                    ref arrTemplateStartX, ref arrTemplateStartY, ref arrTemplateEndX, ref arrTemplateEndY,
                    ref arrSampleStartX, ref arrSampleStartY, ref arrSampleEndX, ref arrSampleEndY,
                    ref arrTemplateSampleWidth, ref arrTemplateSampleHeight,
                    ref arrDifferentSizeX, ref arrDifferentSizeY,
                    ref arrOffsetStartX, ref arrOffsetStartY, true);

                int intToleSize = 0;// m_intMPDilateHalfWidth; // intToleSize is use to wider the Pad ROI size.
                for (int i = 0; i < m_arrTemplateBlobPads.Count; i++)
                {
                    if ((m_arrSampleBlobPads[i].intFailMask & 0x02) > 0)
                        continue;
                    
                    // Get template pad roi
                    ROI objTemplatePadROI = new ROI();
                    objTemplatePadROI.AttachImage(objThresholdTemplateROI);
                    objTemplatePadROI.LoadROISetting(arrTemplateStartX[i], arrTemplateStartY[i], arrTemplateSampleWidth[i], arrTemplateSampleHeight[i]);

                    m_ImgMPUnitTemplateImage.SetSize(objTemplatePadROI.ref_ROIWidth, objTemplatePadROI.ref_ROIHeight);

                    if ((arrDifferentSizeX[i] > 0) || (arrDifferentSizeY[i] > 0))
                    {
                        if ((arrDifferentSizeX[i] > 0 && arrDifferentSizeY[i] < 0) || (arrDifferentSizeY[i] > 0 && arrDifferentSizeX[i] < 0))
                        {
                            if (Math.Abs(arrDifferentSizeY[i]) > Math.Abs(arrDifferentSizeY[i]))
                                arrDifferentSizeY[i] = 0;
                            else
                                arrDifferentSizeX[i] = 0;
                        }
#if (Debug_2_12 || Release_2_12)
                        // Reduce template size follow the m_intMPErodeHalfWidth setting.    
                        if (intDontCareMode == 1)
                        {
                            EasyImage.DilateBox(objTemplatePadROI.ref_ROI, m_ImgMPUnitTemplateImage, (uint)Math.Abs(m_intMPDilateHalfWidth), (uint)Math.Abs(m_intMPDilateHalfWidth));
                        }
                        else
                        {
                            EasyImage.ErodeBox(objTemplatePadROI.ref_ROI, m_ImgMPUnitTemplateImage, (uint)Math.Abs(m_intMPErodeHalfWidth), (uint)Math.Abs(m_intMPErodeHalfWidth));
                        }
                        EasyImage.Copy(m_ImgMPUnitTemplateImage, objTemplatePadROI.ref_ROI);
#elif (DEBUG || RELEASE || RTXRelease || RTXDebug)
                        // Reduce template size follow the m_intMPErodeHalfWidth setting.    
                        if (intDontCareMode == 1)
                        {
                            EasyImage.DilateBox(objTemplatePadROI.ref_ROI, m_ImgMPUnitTemplateImage, Math.Abs(m_intMPDilateHalfWidth), Math.Abs(m_intMPDilateHalfWidth));
                        }
                        else
                        {
                            EasyImage.ErodeBox(objTemplatePadROI.ref_ROI, m_ImgMPUnitTemplateImage, Math.Abs(m_intMPErodeHalfWidth), Math.Abs(m_intMPErodeHalfWidth));
                        }
                        EasyImage.Copy(m_ImgMPUnitTemplateImage, objTemplatePadROI.ref_ROI);
#endif

                    }
                    else
                    {
                        // ErodeBox will make the pad size smaller.
                        if ((Math.Abs(arrDifferentSizeX[i]) + m_intMPErodeHalfWidth) > 0 || (Math.Abs(arrDifferentSizeY[i]) + m_intMPErodeHalfWidth) > 0)
                        {
#if (Debug_2_12 || Release_2_12)
                            //EasyImage.ErodeBox(objTemplatePadROI.ref_ROI, m_ImgMPUnitTemplateImage, Math.Abs(intDiffSizeWidth) + m_intMPErodeHalfWidth, Math.Abs(intDiffSizeHeight) + m_intMPErodeHalfWidth);
                            if (intDontCareMode == 1)
                            {
                                EasyImage.DilateBox(objTemplatePadROI.ref_ROI, m_ImgMPUnitTemplateImage, (uint)m_intMPDilateHalfWidth, (uint)m_intMPDilateHalfWidth);
                            }
                            else
                            {
                                EasyImage.ErodeBox(objTemplatePadROI.ref_ROI, m_ImgMPUnitTemplateImage, (uint)m_intMPErodeHalfWidth, (uint)m_intMPErodeHalfWidth);
                            }
                            EasyImage.Copy(m_ImgMPUnitTemplateImage, objTemplatePadROI.ref_ROI);
#elif (DEBUG || RELEASE || RTXRelease || RTXDebug)
                            //EasyImage.ErodeBox(objTemplatePadROI.ref_ROI, m_ImgMPUnitTemplateImage, Math.Abs(intDiffSizeWidth) + m_intMPErodeHalfWidth, Math.Abs(intDiffSizeHeight) + m_intMPErodeHalfWidth);
                            if (intDontCareMode == 1)
                            {
                                EasyImage.DilateBox(objTemplatePadROI.ref_ROI, m_ImgMPUnitTemplateImage, m_intMPDilateHalfWidth, m_intMPDilateHalfWidth);
                            }
                            else
                            {
                                EasyImage.ErodeBox(objTemplatePadROI.ref_ROI, m_ImgMPUnitTemplateImage, m_intMPErodeHalfWidth, m_intMPErodeHalfWidth);
                            }
                            EasyImage.Copy(m_ImgMPUnitTemplateImage, objTemplatePadROI.ref_ROI);
#endif

                        }
                    }

                    //int intOffsetX = 0;
                    //int intOffsetY = 0;
                    //if (!GetOverallWantGaugeMeasurePkgSize(false))
                    //{
                    //    intOffsetX = (int)Math.Round(GetResultCenterPoint_UnitMatcher().X - GetResultCenterPoint_RectGauge4L().X);
                    //    intOffsetY = (int)Math.Round(GetResultCenterPoint_UnitMatcher().Y - GetResultCenterPoint_RectGauge4L().Y);
                    //}

                    // Get Sample pad ROI
                    ROI objTemplate2PadROI = new ROI();
                    objTemplate2PadROI.ref_ROI.Detach();
                    objTemplate2PadROI.ref_ROI.Attach(m_ImgWhiteUnitTemplateImage2);
                    objTemplate2PadROI.LoadROISetting(arrSampleStartX[i] + arrOffsetStartX[i], arrSampleStartY[i] + arrOffsetStartY[i], arrTemplateSampleWidth[i], arrTemplateSampleHeight[i]);

                    if (blnDebugImage)
                    {
                        m_ImgMPUnitTemplateImage.Save("D:\\TS\\08_" + i.ToString() + "_BfMPTemplateImage.bmp");// debug
                        objTemplatePadROI.SaveImage("D:\\TS\\09_" + i.ToString() + "_AfMPTemplateImage.bmp");// debug
                        objTemplate2PadROI.SaveImage("D:\\TS\\10_" + i.ToString() + "_BfSBTemplate2PadImage.bmp");// debug
                    }
                    //objTemplate2PadROI.ref_ROI.SetSize(objTemplatePadROI.ref_ROI.Width, objTemplatePadROI.ref_ROI.Height);

                    if (objTemplatePadROI.ref_ROIWidth != objTemplate2PadROI.ref_ROIWidth)
                    {
                        int intSmallWidth = Math.Min(objTemplatePadROI.ref_ROIWidth, objTemplate2PadROI.ref_ROIWidth);
                        objTemplatePadROI.LoadROISetting(objTemplatePadROI.ref_ROIPositionX, objTemplatePadROI.ref_ROIPositionY, intSmallWidth, objTemplatePadROI.ref_ROIHeight);
                        objTemplate2PadROI.LoadROISetting(objTemplate2PadROI.ref_ROIPositionX, objTemplate2PadROI.ref_ROIPositionY, intSmallWidth, objTemplate2PadROI.ref_ROIHeight);
                    }

                    if (objTemplatePadROI.ref_ROIHeight != objTemplate2PadROI.ref_ROIHeight)
                    {
                        int intSmallHeight = Math.Min(objTemplatePadROI.ref_ROIHeight, objTemplate2PadROI.ref_ROIHeight);
                        objTemplatePadROI.LoadROISetting(objTemplatePadROI.ref_ROIPositionX, objTemplatePadROI.ref_ROIPositionY, objTemplatePadROI.ref_ROIWidth, intSmallHeight);
                        objTemplate2PadROI.LoadROISetting(objTemplate2PadROI.ref_ROIPositionX, objTemplate2PadROI.ref_ROIPositionY, objTemplate2PadROI.ref_ROIWidth, intSmallHeight);
                    }

                    // subtract sample pad roi - template pad roi
                    EasyImage.Oper(EArithmeticLogicOperation.Subtract, objTemplate2PadROI.ref_ROI, objTemplatePadROI.ref_ROI, objTemplate2PadROI.ref_ROI);

                    if (blnDebugImage)
                        objTemplate2PadROI.SaveImage("D:\\TS\\11_" + i.ToString() + "_AfSBTemplate2PadImage.bmp");// debug

                    objTemplate2PadROI.Dispose();
                    objTemplatePadROI.Dispose();
                }

                if (intDontCareMode == 2)
                {
                    EasyImage.Oper(EArithmeticLogicOperation.Invert, objWhiteBgTemplateROI.ref_ROI, objWhiteBgTemplateROI.ref_ROI);
                }

                // Subtract sample ROI - template ROI
                if (blnDebugImage)
                {
                    //objThresholdSampleROI.SaveImage("D:\\TS\\12_BfSBSampleROI.bmp");// debug   // sample: Background white color, pad black color, defect on pad is white color
                    objWhiteBgTemplateROI.SaveImage("D:\\TS\\13_objTemplate2ROI.bmp");// debug // template: Background white color, pad black color.
                }

                ////objWhiteBgTemplateROI.ref_ROI.SetSize(objThresholdSampleROI.ref_ROI.Width, objThresholdSampleROI.ref_ROI.Height);

                //if (objThresholdSampleROI.ref_ROIWidth != objWhiteBgTemplateROI.ref_ROIWidth)
                //{
                //    int intSmallWidth = Math.Min(objThresholdSampleROI.ref_ROIWidth, objWhiteBgTemplateROI.ref_ROIWidth);
                //    objThresholdSampleROI.LoadROISetting(objThresholdSampleROI.ref_ROIPositionX, objThresholdSampleROI.ref_ROIPositionY, intSmallWidth, objThresholdSampleROI.ref_ROIHeight);
                //    objWhiteBgTemplateROI.LoadROISetting(objWhiteBgTemplateROI.ref_ROIPositionX, objWhiteBgTemplateROI.ref_ROIPositionY, intSmallWidth, objWhiteBgTemplateROI.ref_ROIHeight);
                //}

                //if (objThresholdSampleROI.ref_ROIHeight != objWhiteBgTemplateROI.ref_ROIHeight)
                //{
                //    int intSmallHeight = Math.Min(objThresholdSampleROI.ref_ROIHeight, objWhiteBgTemplateROI.ref_ROIHeight);
                //    objThresholdSampleROI.LoadROISetting(objThresholdSampleROI.ref_ROIPositionX, objThresholdSampleROI.ref_ROIPositionY, objThresholdSampleROI.ref_ROIWidth, intSmallHeight);
                //    objWhiteBgTemplateROI.LoadROISetting(objWhiteBgTemplateROI.ref_ROIPositionX, objWhiteBgTemplateROI.ref_ROIPositionY, objWhiteBgTemplateROI.ref_ROIWidth, intSmallHeight);
                //}

                ////EasyImage.Oper(EArithmeticLogicOperation.Subtract, objThresholdSampleROI.ref_ROI, objWhiteBgTemplateROI.ref_ROI, objThresholdSampleROI.ref_ROI);

                if (objResultROI.ref_ROIWidth != objWhiteBgTemplateROI.ref_ROIWidth)
                {
                    int intSmallWidth = Math.Min(objResultROI.ref_ROIWidth, objWhiteBgTemplateROI.ref_ROIWidth);
                    objResultROI.LoadROISetting(objResultROI.ref_ROIPositionX, objResultROI.ref_ROIPositionY, intSmallWidth, objResultROI.ref_ROIHeight);
                    objWhiteBgTemplateROI.LoadROISetting(objWhiteBgTemplateROI.ref_ROIPositionX, objWhiteBgTemplateROI.ref_ROIPositionY, intSmallWidth, objWhiteBgTemplateROI.ref_ROIHeight);
                }

                if (objResultROI.ref_ROIHeight != objWhiteBgTemplateROI.ref_ROIHeight)
                {
                    int intSmallHeight = Math.Min(objResultROI.ref_ROIHeight, objWhiteBgTemplateROI.ref_ROIHeight);
                    objResultROI.LoadROISetting(objResultROI.ref_ROIPositionX, objResultROI.ref_ROIPositionY, objResultROI.ref_ROIWidth, intSmallHeight);
                    objWhiteBgTemplateROI.LoadROISetting(objWhiteBgTemplateROI.ref_ROIPositionX, objWhiteBgTemplateROI.ref_ROIPositionY, objWhiteBgTemplateROI.ref_ROIWidth, intSmallHeight);
                }

                if (blnDebugImage)
                    objResultROI.SaveImage("D:\\TS\\14_BfobjResultROI.bmp");

                EasyImage.Oper(EArithmeticLogicOperation.Multiply, objResultROI.ref_ROI, objWhiteBgTemplateROI.ref_ROI, objResultROI.ref_ROI);
                //objTempImage.Dispose();
            }
            else
            {
                if (blnDebugImage)
                {
                    objPadColorDontCareImage.SaveImage("D:\\TS\\objPadColorDontCareImage.bmp");
                }

                if (objPadColorDontCareImage != null)
                {
                    ROI objDontCareROI = new ROI();
                    objDontCareROI.LoadROISetting(0, 0, objResultROI.ref_ROIWidth, objResultROI.ref_ROIHeight);
                    objDontCareROI.AttachImage(objPadColorDontCareImage);
                    ROI.SubtractROI(objResultROI, objDontCareROI);
                    objDontCareROI.Dispose();
                }
            }

            //if (blnDebugImage)
            //    objThresholdSampleROI.SaveImage("D:\\TS\\14_AfSBSampleROI.bmp");// debug

            if (blnDebugImage)
            {
                objROI.SaveImage("D:\\TS\\15_objROI.bmp");
                objResultROI.SaveImage("D:\\TS\\16_objResultROI.bmp");
            }

        }
        public void SubtractColorDontCareImage2(ROI objROI, ROI objResultROI, int intDontCareMode, ImageDrawing objPadColorDontCareImage)
        {
            if (intDontCareMode == 0)
                return;
            //ROI objROI2 = new ROI();
            //objROI2.LoadROISetting(objROI.ref_ROITotalX, objROI.ref_ROITotalY, objROI.ref_ROIWidth, objROI.ref_ROIHeight);
            //ImageDrawing objImage = new ImageDrawing(objROI.ref_ROI.TopParent.Width, objROI.ref_ROI.TopParent.Height);
            //EasyImage.Copy(objROI.ref_ROI.TopParent, objImage.ref_objMainImage);
            //objROI2.AttachImage(objImage);

            //EasyImage.Threshold(objROI2.ref_ROI, objROI2.ref_ROI, m_intThresholdValue);
            //if (!blnPadChecked)
            //{
            //    EasyImage.Oper(EArithmeticLogicOperation.Invert, objROI2.ref_ROI, objROI2.ref_ROI);
            //}

            //EasyImage.Oper(EArithmeticLogicOperation.Multiply, objResultROI.ref_ROI, objROI2.ref_ROI, objResultROI.ref_ROI);

            //objROI2.Dispose();
            //objImage.Dispose();
            bool blnDebugImage = false;
            if (intDontCareMode != 3)
            {


                // Find a suitable Unit Size for both template and sample ROI (Solution: Use Learn Package ROI size)
                int intTestUnitWidth = m_ImgUnitTemplateImage.Width;
                int intTestUnitHeight = m_ImgUnitTemplateImage.Height;
                // Get threshold value
                int intThresholdValue;
                if (m_intThresholdValue < 0)
                {
                    EBW8 objBW8 = EasyImage.AutoThreshold(objROI.ref_ROI, EThresholdMode.MinResidue);
                    intThresholdValue = objBW8.Value;
                }
                else
                    intThresholdValue = m_intThresholdValue;
                ImageDrawing objTempImage = new ImageDrawing(true, m_objInsPadPkgImage1.ref_intCameraResolutionWidth, m_objInsPadPkgImage1.ref_intCameraResolutionHeight);
                // ---- Sample -------
                // Get ready sample ROI,
                ROI objThresholdSampleROI = new ROI();
                objThresholdSampleROI.AttachImage(objTempImage); // Attach sample ROI to ori size image. m_objInsPadPkgImage1 is a ori size image used to keep the sample image temporary for modification such as double threshold
                //objThresholdSampleROI.LoadROISetting(0, 0,
                //                                     intTestUnitWidth, intTestUnitHeight);
                objThresholdSampleROI.LoadROISetting(objResultROI.ref_ROIPositionX, objResultROI.ref_ROIPositionY,
                                                     objResultROI.ref_ROIWidth, objResultROI.ref_ROIHeight);
#if (Debug_2_12 || Release_2_12)
                // Threshold sample unit using Pad Threshold
                if (m_fPadImageGain != 1f)
                {
                    ROI objROI2 = new ROI();
                    objROI2.LoadROISetting(objROI.ref_ROITotalX, objROI.ref_ROITotalY, objROI.ref_ROIWidth, objROI.ref_ROIHeight);
                    ImageDrawing objImage2 = new ImageDrawing(objROI.ref_ROI.TopParent.Width, objROI.ref_ROI.TopParent.Height);
                    EasyImage.Copy(objROI.ref_ROI.TopParent, objImage2.ref_objMainImage);
                    objROI2.AttachImage(objImage2);

                    EasyImage.GainOffset(objROI2.ref_ROI, objROI2.ref_ROI, m_fPadImageGain);

                    EasyImage.Threshold(objROI2.ref_ROI, objThresholdSampleROI.ref_ROI, (uint)intThresholdValue);

                    objROI2.Dispose();
                    objImage2.Dispose();
                }
                else
                {
                    EasyImage.Threshold(objROI.ref_ROI, objThresholdSampleROI.ref_ROI, (uint)intThresholdValue);   // error happen when set 255, 0);
                }
#elif (DEBUG || RELEASE || RTXRelease || RTXDebug)
                // Threshold sample unit using Pad Threshold
                if (m_fPadImageGain != 1f)
                {
                    ROI objROI2 = new ROI();
                    objROI2.LoadROISetting(objROI.ref_ROITotalX, objROI.ref_ROITotalY, objROI.ref_ROIWidth, objROI.ref_ROIHeight);
                    ImageDrawing objImage2 = new ImageDrawing(objROI.ref_ROI.TopParent.Width, objROI.ref_ROI.TopParent.Height);
                    EasyImage.Copy(objROI.ref_ROI.TopParent, objImage2.ref_objMainImage);
                    objROI2.AttachImage(objImage2);

                    EasyImage.GainOffset(objROI2.ref_ROI, objROI2.ref_ROI, m_fPadImageGain);

                    EasyImage.Threshold(objROI2.ref_ROI, objThresholdSampleROI.ref_ROI, intThresholdValue);

                    objROI2.Dispose();
                    objImage2.Dispose();
                }
                else
                {
                    EasyImage.Threshold(objROI.ref_ROI, objThresholdSampleROI.ref_ROI, intThresholdValue);   // error happen when set 255, 0);
                                                                                                         //EasyImage.Oper(EArithmeticLogicOperation.Invert, objThresholdSampleROI.ref_ROI, objThresholdSampleROI.ref_ROI);
                }
#endif
                EasyImage.Oper(EArithmeticLogicOperation.Invert, objThresholdSampleROI.ref_ROI, objThresholdSampleROI.ref_ROI);

                if (blnDebugImage)
                {
                    objROI.SaveImage("D:\\TS\\01_objImage1SampleUnitROI.bmp"); // debug
                    objThresholdSampleROI.SaveImage("D:\\TS\\02_objThresholdSampleROI.bmp");   // debug
                }

                // ---- Template ------
                // Get ready template ROI
                ROI objThresholdTemplateROI = new ROI();
                if ((m_ImgTUnitErodeThresImage.Width != m_ImgUnitTemplateImage.Width) || (m_ImgTUnitErodeThresImage.Height != m_ImgUnitTemplateImage.Height))
                    m_ImgTUnitErodeThresImage.SetSize(m_ImgUnitTemplateImage.Width, m_ImgUnitTemplateImage.Height);
#if (Debug_2_12 || Release_2_12)
                if (m_fPadImageGain != 1f)
                {
                    ROI objROI2 = new ROI();
                    objROI2.LoadROISetting(objROI.ref_ROITotalX, objROI.ref_ROITotalY, objROI.ref_ROIWidth, objROI.ref_ROIHeight);
                    ImageDrawing objImage2 = new ImageDrawing(objROI.ref_ROI.TopParent.Width, objROI.ref_ROI.TopParent.Height);
                    EasyImage.Copy(objROI.ref_ROI.TopParent, objImage2.ref_objMainImage);
                    objROI2.AttachImage(objImage2);

                    EasyImage.GainOffset(m_ImgUnitTemplateImage, m_ImgTUnitErodeThresImage, m_fPadImageGain);

                    EasyImage.Threshold(m_ImgTUnitErodeThresImage, m_ImgTUnitErodeThresImage, (uint)intThresholdValue);

                    objROI2.Dispose();
                    objImage2.Dispose();
                }
                else
                {
                    EasyImage.Threshold(m_ImgUnitTemplateImage, m_ImgTUnitErodeThresImage, (uint)intThresholdValue);
                }
#elif (DEBUG || RELEASE || RTXRelease || RTXDebug)
                if (m_fPadImageGain != 1f)
                {
                    ROI objROI2 = new ROI();
                    objROI2.LoadROISetting(objROI.ref_ROITotalX, objROI.ref_ROITotalY, objROI.ref_ROIWidth, objROI.ref_ROIHeight);
                    ImageDrawing objImage2 = new ImageDrawing(objROI.ref_ROI.TopParent.Width, objROI.ref_ROI.TopParent.Height);
                    EasyImage.Copy(objROI.ref_ROI.TopParent, objImage2.ref_objMainImage);
                    objROI2.AttachImage(objImage2);

                    EasyImage.GainOffset(m_ImgUnitTemplateImage, m_ImgTUnitErodeThresImage, m_fPadImageGain);

                    EasyImage.Threshold(m_ImgTUnitErodeThresImage, m_ImgTUnitErodeThresImage, intThresholdValue);

                    objROI2.Dispose();
                    objImage2.Dispose();
                }
                else
                {
                    EasyImage.Threshold(m_ImgUnitTemplateImage, m_ImgTUnitErodeThresImage, intThresholdValue);
                }
#endif

                objThresholdTemplateROI.ref_ROI.Detach();
                objThresholdTemplateROI.ref_ROI.Attach(m_ImgTUnitErodeThresImage);
                objThresholdTemplateROI.LoadROISetting((int)Math.Round((float)m_ImgTUnitErodeThresImage.Width / 2 - (float)intTestUnitWidth / 2, 0, MidpointRounding.AwayFromZero),
                                     (int)Math.Round((float)m_ImgTUnitErodeThresImage.Height / 2 - (float)intTestUnitHeight / 2, 0, MidpointRounding.AwayFromZero),
                                     intTestUnitWidth, intTestUnitHeight);

                if (blnDebugImage)
                {
                    m_ImgUnitTemplateImage.Save("D:\\TS\\03_ImgUnitTemplateImage.bmp");                   // debug
                    m_ImgTUnitErodeThresImage.Save("D:\\TS\\04_ImgTUnitErodeThresImage.bmp");        // debug
                    objThresholdTemplateROI.SaveImage("D:\\TS\\05_objThresholdTemplateROI.bmp");     // debug
                }

                // ---- White Background --------------
                m_ImgWhiteUnitTemplateImage2.SetSize(m_ImgWhiteUnitTemplateImage.Width, m_ImgWhiteUnitTemplateImage.Height);
                m_ImgWhiteUnitTemplateImage.CopyTo(m_ImgWhiteUnitTemplateImage2);
                ROI objWhiteBgTemplateROI = new ROI();
                objWhiteBgTemplateROI.ref_ROI.Detach();
                objWhiteBgTemplateROI.ref_ROI.Attach(m_ImgWhiteUnitTemplateImage2);
                objWhiteBgTemplateROI.LoadROISetting(0, 0, intTestUnitWidth, intTestUnitHeight);

                if (blnDebugImage)
                {
                    objWhiteBgTemplateROI.SaveImage("D:\\TS\\06_objWhiteBgTemplateROI.bmp");     // debug
                }

                int intToleSize = 0;// m_intMPDilateHalfWidth; // intToleSize is use to wider the Pad ROI size.
                for (int i = 0; i < m_arrTemplateBlobPads.Count; i++)
                {
                    if ((m_arrSampleBlobPads[i].intFailMask & 0x02) > 0)
                        continue;

                    // check the different size between sample and template blobs
                    int intDiffSizeWidth = (int)Math.Round((m_arrSampleBlobPads[i].fWidth - ((BlobsFeatures)m_arrTemplateBlobPads[i]).fWidth) / 2, 0, MidpointRounding.AwayFromZero);
                    int intDiffSizeHeight = (int)Math.Round((m_arrSampleBlobPads[i].fHeight - ((BlobsFeatures)m_arrTemplateBlobPads[i]).fHeight) / 2, 0, MidpointRounding.AwayFromZero);

                    // set the smaller Diff Value to 0 if one is positive value and another one is negative value
                    if ((intDiffSizeWidth > 0 && intDiffSizeHeight < 0) || (intDiffSizeHeight > 0 && intDiffSizeWidth < 0))
                    {
                        if (Math.Abs(intDiffSizeWidth) > Math.Abs(intDiffSizeHeight))
                            intDiffSizeHeight = 0;
                        else
                            intDiffSizeWidth = 0;
                    }

                    // Get biggest size of width and height based on DiffSize value
                    float fWidth, fHeight;
                    if ((intDiffSizeWidth > 0) || (intDiffSizeHeight > 0))
                    {
                        fWidth = m_arrSampleBlobPads[i].fWidth;
                        fHeight = m_arrSampleBlobPads[i].fHeight;
                    }
                    else
                    {
                        fWidth = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fWidth;
                        fHeight = ((BlobsFeatures)m_arrTemplateBlobPads[i]).fHeight;
                    }


                    int intAdjustX = 0, intAdjustY = 0;
                    int intStartX = (int)Math.Round(((BlobsFeatures)m_arrTemplateBlobPads[i]).fLimitCenterX - fWidth / 2 - intToleSize, 0, MidpointRounding.AwayFromZero);
                    if (intStartX < 0)
                    {
                        intAdjustX = intStartX; // Keep the minus value
                        intStartX = 0;  // Set start value to 0 if smaller than 0.
                    }
                    int intStartY = (int)Math.Round(((BlobsFeatures)m_arrTemplateBlobPads[i]).fLimitCenterY - fHeight / 2 - intToleSize, 0, MidpointRounding.AwayFromZero);
                    if (intStartY < 0)
                    {
                        intAdjustY = intStartY; // Keep the minus value
                        intStartY = 0;          // Set start value to 0 if smaller than 0
                    }

                    //int intStartX2 = (int)Math.Round(m_arrSampleBlobPads[i].fGravityCenterX - fWidth / 2, 0, MidpointRounding.AwayFromZero);  // 2018 10 05 - CCENG: change from fGravityCenterX to fCenterX. The GravityCenterX is too much different compare to centerX especially when pad shape is not rectangle or square.
                    int intStartX2 = (int)Math.Round(m_arrSampleBlobPads[i].fCenterX - fWidth / 2, 0, MidpointRounding.AwayFromZero);
                    intStartX2 -= intToleSize;
                    if (intStartX2 < 0)
                    {
                        if (intStartX2 > intAdjustX)
                            intAdjustX = intStartX2;
                        intStartX2 = 0;
                    }
                    //int intStartY2 = (int)Math.Round(m_arrSampleBlobPads[i].fGravityCenterY - fHeight / 2, 0, MidpointRounding.AwayFromZero); // 2018 10 05 - CCENG: change from fGravityCenterY to fCenterY. The GravityCenterY is too much different compare to centerY especially when pad shape is not rectangle or square.
                    int intStartY2 = (int)Math.Round(m_arrSampleBlobPads[i].fCenterY - fHeight / 2, 0, MidpointRounding.AwayFromZero);
                    intStartY2 -= intToleSize;
                    if (intStartY2 < 0)
                    {
                        if (intStartY2 > intAdjustY)
                            intAdjustY = intStartY2;
                        intStartY2 = 0;
                    }

                    int intWidth = (int)Math.Round(fWidth, 0, MidpointRounding.AwayFromZero) + intToleSize * 2;
                    int intEndX = intStartX + intWidth + intAdjustX;
                    int intEndAdjustX = 0;
                    if (intEndX > objThresholdTemplateROI.ref_ROIWidth - 1)
                    {
                        intEndAdjustX = (intEndX - (objThresholdTemplateROI.ref_ROIWidth - 1));
                    }
                    int intHeight = (int)Math.Round(fHeight, 0, MidpointRounding.AwayFromZero) + intToleSize * 2;
                    int intEndY = intStartY + intHeight + intAdjustY;
                    int intEndAdjustY = 0;
                    if (intEndY > objThresholdTemplateROI.ref_ROIHeight - 1)
                    {
                        intEndAdjustY = (intEndY - (objThresholdTemplateROI.ref_ROIHeight - 1));
                    }

                    //intEndX = intStartX2 + intWidth + intToleSize * 2 + intAdjustX;
                    intEndX = intStartX2 + intWidth + intAdjustX;
                    if (intEndX > m_ImgWhiteUnitTemplateImage2.Width - 1)
                    {
                        if (intEndAdjustX < (intEndX - (m_ImgWhiteUnitTemplateImage2.Width - 1)))
                            intEndAdjustX = (intEndX - (m_ImgWhiteUnitTemplateImage2.Width - 1));
                    }
                    //intEndY = intStartY2 + intHeight + intToleSize * 2 + intAdjustY;
                    intEndY = intStartY2 + intHeight + intAdjustY;
                    if (intEndY > m_ImgWhiteUnitTemplateImage2.Height - 1)
                    {
                        if (intEndAdjustY < (intEndY - (m_ImgWhiteUnitTemplateImage2.Height - 1)))
                            intEndAdjustY = (intEndY - (m_ImgWhiteUnitTemplateImage2.Height - 1));
                    }

                    intWidth -= intEndAdjustX;
                    intHeight -= intEndAdjustY;

                    // Get template pad roi
                    ROI objTemplatePadROI = new ROI();
                    objTemplatePadROI.AttachImage(objThresholdTemplateROI);
                    objTemplatePadROI.LoadROISetting(intStartX, intStartY, intWidth, intHeight);

                    m_ImgMPUnitTemplateImage.SetSize(objTemplatePadROI.ref_ROIWidth, objTemplatePadROI.ref_ROIHeight);


                    //                    if ((intDiffSizeWidth > 0) || (intDiffSizeHeight > 0))
                    //                    {
                    //                        if ((intDiffSizeWidth > 0 && intDiffSizeHeight < 0) || (intDiffSizeHeight > 0 && intDiffSizeWidth < 0))
                    //                        {
                    //                            if (Math.Abs(intDiffSizeWidth) > Math.Abs(intDiffSizeHeight))
                    //                                intDiffSizeHeight = 0;
                    //                            else
                    //                                intDiffSizeWidth = 0;
                    //                        }
                    //#if (Debug_2_12 || Release_2_12)
                    //                        // Reduce template size follow the m_intMPErodeHalfWidth setting.    
                    //                        EasyImage.ErodeBox(objTemplatePadROI.ref_ROI, m_ImgMPUnitTemplateImage, (uint)Math.Abs(m_intMPErodeHalfWidth), (uint)Math.Abs(m_intMPErodeHalfWidth));
                    //                        EasyImage.Copy(m_ImgMPUnitTemplateImage, objTemplatePadROI.ref_ROI);
                    //#elif (DEBUG || RELEASE || RTXRelease || RTXDebug)
                    //                        // Reduce template size follow the m_intMPErodeHalfWidth setting.    
                    //                        EasyImage.ErodeBox(objTemplatePadROI.ref_ROI, m_ImgMPUnitTemplateImage, Math.Abs(m_intMPErodeHalfWidth), Math.Abs(m_intMPErodeHalfWidth));
                    //                        EasyImage.Copy(m_ImgMPUnitTemplateImage, objTemplatePadROI.ref_ROI);
                    //#endif

                    //                    }
                    //                    else
                    //                    {
                    //                        // ErodeBox will make the pad size smaller.
                    //                        if ((Math.Abs(intDiffSizeWidth) + m_intMPErodeHalfWidth) > 0 || (Math.Abs(intDiffSizeHeight) + m_intMPErodeHalfWidth) > 0)
                    //                        {
                    //#if (Debug_2_12 || Release_2_12)
                    //                            //EasyImage.ErodeBox(objTemplatePadROI.ref_ROI, m_ImgMPUnitTemplateImage, Math.Abs(intDiffSizeWidth) + m_intMPErodeHalfWidth, Math.Abs(intDiffSizeHeight) + m_intMPErodeHalfWidth);
                    //                            EasyImage.ErodeBox(objTemplatePadROI.ref_ROI, m_ImgMPUnitTemplateImage, (uint)m_intMPErodeHalfWidth, (uint)m_intMPErodeHalfWidth);
                    //                            EasyImage.Copy(m_ImgMPUnitTemplateImage, objTemplatePadROI.ref_ROI);
                    //#elif (DEBUG || RELEASE || RTXRelease || RTXDebug)
                    //                            //EasyImage.ErodeBox(objTemplatePadROI.ref_ROI, m_ImgMPUnitTemplateImage, Math.Abs(intDiffSizeWidth) + m_intMPErodeHalfWidth, Math.Abs(intDiffSizeHeight) + m_intMPErodeHalfWidth);
                    //                            EasyImage.ErodeBox(objTemplatePadROI.ref_ROI, m_ImgMPUnitTemplateImage, m_intMPErodeHalfWidth, m_intMPErodeHalfWidth);
                    //                            EasyImage.Copy(m_ImgMPUnitTemplateImage, objTemplatePadROI.ref_ROI);
                    //#endif

                    //                        }
                    //                    }

                    if (!GetOverallWantGaugeMeasurePkgSize(false))
                    {
                        intStartX2 += (int)Math.Round(GetResultCenterPoint_UnitMatcher().X - GetResultCenterPoint_RectGauge4L().X);
                        intStartY2 += (int)Math.Round(GetResultCenterPoint_UnitMatcher().Y - GetResultCenterPoint_RectGauge4L().Y);
                    }

                    // Get Sample pad ROI
                    ROI objTemplate2PadROI = new ROI();
                    objTemplate2PadROI.ref_ROI.Detach();
                    objTemplate2PadROI.ref_ROI.Attach(m_ImgWhiteUnitTemplateImage2);
                    objTemplate2PadROI.LoadROISetting(intStartX2, intStartY2, intWidth, intHeight);

                    if (blnDebugImage)
                    {
                        m_ImgMPUnitTemplateImage.Save("D:\\TS\\08_" + i.ToString() + "_BfMPTemplateImage.bmp");// debug
                        objTemplatePadROI.SaveImage("D:\\TS\\09_" + i.ToString() + "_AfMPTemplateImage.bmp");// debug
                        objTemplate2PadROI.SaveImage("D:\\TS\\10_" + i.ToString() + "_BfSBTemplate2PadImage.bmp");// debug
                    }
                    //objTemplate2PadROI.ref_ROI.SetSize(objTemplatePadROI.ref_ROI.Width, objTemplatePadROI.ref_ROI.Height);

                    if (objTemplatePadROI.ref_ROIWidth != objTemplate2PadROI.ref_ROIWidth)
                    {
                        int intSmallWidth = Math.Min(objTemplatePadROI.ref_ROIWidth, objTemplate2PadROI.ref_ROIWidth);
                        objTemplatePadROI.LoadROISetting(objTemplatePadROI.ref_ROIPositionX, objTemplatePadROI.ref_ROIPositionY, intSmallWidth, objTemplatePadROI.ref_ROIHeight);
                        objTemplate2PadROI.LoadROISetting(objTemplate2PadROI.ref_ROIPositionX, objTemplate2PadROI.ref_ROIPositionY, intSmallWidth, objTemplate2PadROI.ref_ROIHeight);
                    }

                    if (objTemplatePadROI.ref_ROIHeight != objTemplate2PadROI.ref_ROIHeight)
                    {
                        int intSmallHeight = Math.Min(objTemplatePadROI.ref_ROIHeight, objTemplate2PadROI.ref_ROIHeight);
                        objTemplatePadROI.LoadROISetting(objTemplatePadROI.ref_ROIPositionX, objTemplatePadROI.ref_ROIPositionY, objTemplatePadROI.ref_ROIWidth, intSmallHeight);
                        objTemplate2PadROI.LoadROISetting(objTemplate2PadROI.ref_ROIPositionX, objTemplate2PadROI.ref_ROIPositionY, objTemplate2PadROI.ref_ROIWidth, intSmallHeight);
                    }

                    // subtract sample pad roi - template pad roi
                    EasyImage.Oper(EArithmeticLogicOperation.Subtract, objTemplate2PadROI.ref_ROI, objTemplatePadROI.ref_ROI, objTemplate2PadROI.ref_ROI);

                    if (blnDebugImage)
                        objTemplate2PadROI.SaveImage("D:\\TS\\11_" + i.ToString() + "_AfSBTemplate2PadImage.bmp");// debug

                    objTemplate2PadROI.Dispose();
                    objTemplatePadROI.Dispose();
                }

                if (intDontCareMode == 1)
                {
                    EasyImage.Oper(EArithmeticLogicOperation.Invert, objWhiteBgTemplateROI.ref_ROI, objWhiteBgTemplateROI.ref_ROI);
                }

                // Subtract sample ROI - template ROI
                if (blnDebugImage)
                {
                    objThresholdSampleROI.SaveImage("D:\\TS\\12_BfSBSampleROI.bmp");// debug   // sample: Background white color, pad black color, defect on pad is white color
                    objWhiteBgTemplateROI.SaveImage("D:\\TS\\13_objTemplate2ROI.bmp");// debug // template: Background white color, pad black color.
                }

                //objWhiteBgTemplateROI.ref_ROI.SetSize(objThresholdSampleROI.ref_ROI.Width, objThresholdSampleROI.ref_ROI.Height);

                if (objThresholdSampleROI.ref_ROIWidth != objWhiteBgTemplateROI.ref_ROIWidth)
                {
                    int intSmallWidth = Math.Min(objThresholdSampleROI.ref_ROIWidth, objWhiteBgTemplateROI.ref_ROIWidth);
                    objThresholdSampleROI.LoadROISetting(objThresholdSampleROI.ref_ROIPositionX, objThresholdSampleROI.ref_ROIPositionY, intSmallWidth, objThresholdSampleROI.ref_ROIHeight);
                    objWhiteBgTemplateROI.LoadROISetting(objWhiteBgTemplateROI.ref_ROIPositionX, objWhiteBgTemplateROI.ref_ROIPositionY, intSmallWidth, objWhiteBgTemplateROI.ref_ROIHeight);
                }

                if (objThresholdSampleROI.ref_ROIHeight != objWhiteBgTemplateROI.ref_ROIHeight)
                {
                    int intSmallHeight = Math.Min(objThresholdSampleROI.ref_ROIHeight, objWhiteBgTemplateROI.ref_ROIHeight);
                    objThresholdSampleROI.LoadROISetting(objThresholdSampleROI.ref_ROIPositionX, objThresholdSampleROI.ref_ROIPositionY, objThresholdSampleROI.ref_ROIWidth, intSmallHeight);
                    objWhiteBgTemplateROI.LoadROISetting(objWhiteBgTemplateROI.ref_ROIPositionX, objWhiteBgTemplateROI.ref_ROIPositionY, objWhiteBgTemplateROI.ref_ROIWidth, intSmallHeight);
                }

                //EasyImage.Oper(EArithmeticLogicOperation.Subtract, objThresholdSampleROI.ref_ROI, objWhiteBgTemplateROI.ref_ROI, objThresholdSampleROI.ref_ROI);
                if (blnDebugImage)
                    objResultROI.SaveImage("D:\\TS\\14_BfobjResultROI.bmp");

                EasyImage.Oper(EArithmeticLogicOperation.Multiply, objResultROI.ref_ROI, objWhiteBgTemplateROI.ref_ROI, objResultROI.ref_ROI);
                objTempImage.Dispose();
            }
            else
            {
                if (blnDebugImage)
                {
                    objPadColorDontCareImage.SaveImage("D:\\TS\\objPadColorDontCareImage.bmp");
                }

                if (objPadColorDontCareImage != null)
                {
                    ROI objDontCareROI = new ROI();
                    objDontCareROI.LoadROISetting(0, 0, objResultROI.ref_ROIWidth, objResultROI.ref_ROIHeight);
                    objDontCareROI.AttachImage(objPadColorDontCareImage);
                    ROI.SubtractROI(objResultROI, objDontCareROI);
                    objDontCareROI.Dispose();
                }
            }

            //if (blnDebugImage)
            //    objThresholdSampleROI.SaveImage("D:\\TS\\14_AfSBSampleROI.bmp");// debug

            if (blnDebugImage)
            {
                objROI.SaveImage("D:\\TS\\15_objROI.bmp");
                objResultROI.SaveImage("D:\\TS\\16_objResultROI.bmp");
            }

        }
        public bool GetOverallWantGaugeMeasurePkgSize(bool bFromPackage)
        {
            /*
             * if from pad inspection, then need to check WantGaugeMeasurePkgSize or not.
             * if from pkg inspeciton, no need to check WantGaugeMeasurePkgSize.
             */
            if (!bFromPackage)
            {
                if (!m_blnWantGaugeMeasurePkgSize)
                    return false;
            }

            if ((m_intFailPkgOptionMask & 0x01) > 0)    // return true if check package size ON
                return true;

            if (m_blnInspectPackage)
            {
                if ((m_intFailPkgOptionMask & 0xFFFFFD) > 0)    // return true if check package defect criteria ON
                    return true;
            }

            if (m_blnWantCheckPadEdgeLimit && ((m_intFailOptionMask & 0x4000) > 0)) // return true if pad edge limit ON. Pad edge limit rely on package edge.
            {
                return true;
            }

            if (m_blnWantCheckPadStandOff && ((m_intFailOptionMask & 0x8000) > 0)) // return true if pad standoff ON. Pad standoff rely on package edge.
            {
                return true;
            }

            if (m_blnWantCheckPadEdgeDistance && ((m_intFailOptionMask & 0x10000) > 0)) // return true if pad edge distance ON. Pad edge distance rely on package edge.
            {
                return true;
            }

            if (m_blnMeasureCenterPkgSizeUsingSidePkg)  // return true if center pkg rely on side package edge.
            {
                return true;
            }

            return false;
        }
        public bool WantCheckPad(bool blnCheckContamination)
        {
            bool blnCheckPad = false;
            if ((m_intFailOptionMask & 0x2FF8) > 0)
                blnCheckPad = true;

            if (m_blnWantEdgeLimit_Pad && ((m_intFailOptionMask & 0x4000) > 0))
                blnCheckPad = true;

            if (m_blnWantStandOff_Pad && ((m_intFailOptionMask & 0x8000) > 0))
                blnCheckPad = true;

            if (m_blnWantEdgeDistance_Pad && ((m_intFailOptionMask & 0x10000) > 0))
                blnCheckPad = true;

            if (m_blnWantSpan_Pad && ((m_intFailOptionMask & 0x20000) > 0))
                blnCheckPad = true;

            if (blnCheckContamination && ((m_intFailOptionMask & 0x1001) > 0))
                blnCheckPad = true;

            if (m_blnInspectPackage && m_blnWantDontCarePadForPackage)
            {
                if ((m_intFailPkgOptionMask & 0xFFFFFD) > 0)    // return true if check package defect criteria ON
                    return true;
            }

            return blnCheckPad;
        }

        public bool WantPadReturnFailResultOrShowDrawing(bool blnCheckContamination)
        {
            bool blnCheckPad = false;
            if ((m_intFailOptionMask & 0x2FF8) > 0)
                blnCheckPad = true;

            if (m_blnWantEdgeLimit_Pad && ((m_intFailOptionMask & 0x4000) > 0))
                blnCheckPad = true;

            if (m_blnWantStandOff_Pad && ((m_intFailOptionMask & 0x8000) > 0))
                blnCheckPad = true;

            if (m_blnWantEdgeDistance_Pad && ((m_intFailOptionMask & 0x10000) > 0))
                blnCheckPad = true;

            if (m_blnWantSpan_Pad && ((m_intFailOptionMask & 0x20000) > 0))
                blnCheckPad = true;

            if (blnCheckContamination && ((m_intFailOptionMask & 0x1001) > 0))
                blnCheckPad = true;

            return blnCheckPad;
        }

        public int GetColorDefectCount(ref List<int> arrColorDefectSkipNo)
        {
            int intCount = m_arrDefectColorThresName.Count;
            arrColorDefectSkipNo = new List<int>();
            for (int i = 0; i < m_arrDefectColorThresName.Count; i++)
            {
                if (!arrColorDefectSkipNo.Contains(i))
                {
                    for (int j = 0; j < m_arrDefectColorThresName.Count; j++)
                    {
                        if (i == j)
                            continue;

                        if (m_arrDefectColorThresName[i] == m_arrDefectColorThresName[j])
                        {
                            if (!arrColorDefectSkipNo.Contains(j))
                                arrColorDefectSkipNo.Add(j);

                        }
                    }
                }
            }
            
            return intCount - arrColorDefectSkipNo.Count;
        }

        public void SwapColorDefect(int intFrom, int intTo)
        {
            string arrDefectColorThresName = m_arrDefectColorThresName[intTo];
            int arrDefectColorSystem = m_arrDefectColorSystem[intTo];
            int arrDefectCloseIteration = m_arrDefectCloseIteration[intTo];
            bool arrDefectInvertBlackWhite = m_arrDefectInvertBlackWhite[intTo];
            int[] arrDefectColor = m_arrDefectColor[intTo];
            int[] arrDefectColorTolerance = m_arrDefectColorTolerance[intTo];
            int arrDefectColorMinArea = m_arrDefectColorMinArea[intTo];
            int arrDefectType = m_arrDefectType[intTo];
            int arrDefectImageNo = m_arrDefectImageNo[intTo];
            int arrDefectDontCareMode = m_arrDefectDontCareMode[intTo];
            int arrDefectColorInspection_Top = m_arrDefectColorInspection_Top[intTo];
            int arrDefectColorInspection_Right = m_arrDefectColorInspection_Right[intTo];
            int arrDefectColorInspection_Bottom = m_arrDefectColorInspection_Bottom[intTo];
            int arrDefectColorInspection_Left = m_arrDefectColorInspection_Left[intTo];
            int arrDefectColorInspectionFailCondition = m_arrDefectColorInspectionFailCondition[intTo];
            float arrDefectColorInspectionWidth = m_arrDefectColorInspectionWidth[intTo];
            float arrDefectColorInspectionLength = m_arrDefectColorInspectionLength[intTo];
            float arrDefectColorInspectionMinArea = m_arrDefectColorInspectionMinArea[intTo];
            float arrDefectColorInspectionMaxArea = m_arrDefectColorInspectionMaxArea[intTo];
            float arrDefectColorInspectionTotalArea = m_arrDefectColorInspectionTotalArea[intTo];

            m_arrDefectColorThresName[intTo] = m_arrDefectColorThresName[intFrom];
            m_arrDefectColorSystem[intTo] = m_arrDefectColorSystem[intFrom];
            m_arrDefectCloseIteration[intTo] = m_arrDefectCloseIteration[intFrom];
            m_arrDefectInvertBlackWhite[intTo] = m_arrDefectInvertBlackWhite[intFrom];
            m_arrDefectColor[intTo] = m_arrDefectColor[intFrom];
            m_arrDefectColorTolerance[intTo] = m_arrDefectColorTolerance[intFrom];
            m_arrDefectColorMinArea[intTo] = m_arrDefectColorMinArea[intFrom];
            m_arrDefectType[intTo] = m_arrDefectType[intFrom];
            m_arrDefectImageNo[intTo] = m_arrDefectImageNo[intFrom];
            m_arrDefectDontCareMode[intTo] = m_arrDefectDontCareMode[intFrom];
            m_arrDefectColorInspection_Top[intTo] = m_arrDefectColorInspection_Top[intFrom];
            m_arrDefectColorInspection_Right[intTo] = m_arrDefectColorInspection_Right[intFrom];
            m_arrDefectColorInspection_Bottom[intTo] = m_arrDefectColorInspection_Bottom[intFrom];
            m_arrDefectColorInspection_Left[intTo] = m_arrDefectColorInspection_Left[intFrom];
            m_arrDefectColorInspectionFailCondition[intTo] = m_arrDefectColorInspectionFailCondition[intFrom];
            m_arrDefectColorInspectionWidth[intTo] = m_arrDefectColorInspectionWidth[intFrom];
            m_arrDefectColorInspectionLength[intTo] = m_arrDefectColorInspectionLength[intFrom];
            m_arrDefectColorInspectionMinArea[intTo] = m_arrDefectColorInspectionMinArea[intFrom];
            m_arrDefectColorInspectionMaxArea[intTo] = m_arrDefectColorInspectionMaxArea[intFrom];
            m_arrDefectColorInspectionTotalArea[intTo] = m_arrDefectColorInspectionTotalArea[intFrom];

            m_arrDefectColorThresName[intFrom] = arrDefectColorThresName;
            m_arrDefectColorSystem[intFrom] = arrDefectColorSystem;
            m_arrDefectCloseIteration[intFrom] = arrDefectCloseIteration;
            m_arrDefectInvertBlackWhite[intFrom] = arrDefectInvertBlackWhite;
            m_arrDefectColor[intFrom] = arrDefectColor;
            m_arrDefectColorTolerance[intFrom] = arrDefectColorTolerance;
            m_arrDefectColorMinArea[intFrom] = arrDefectColorMinArea;
            m_arrDefectType[intFrom] = arrDefectType;
            m_arrDefectImageNo[intFrom] = arrDefectImageNo;
            m_arrDefectDontCareMode[intFrom] = arrDefectDontCareMode;
            m_arrDefectColorInspection_Top[intFrom] = arrDefectColorInspection_Top;
            m_arrDefectColorInspection_Right[intFrom] = arrDefectColorInspection_Right;
            m_arrDefectColorInspection_Bottom[intFrom] = arrDefectColorInspection_Bottom;
            m_arrDefectColorInspection_Left[intFrom] = arrDefectColorInspection_Left;
            m_arrDefectColorInspectionFailCondition[intFrom] = arrDefectColorInspectionFailCondition;
            m_arrDefectColorInspectionWidth[intFrom] = arrDefectColorInspectionWidth;
            m_arrDefectColorInspectionLength[intFrom] = arrDefectColorInspectionLength;
            m_arrDefectColorInspectionMinArea[intFrom] = arrDefectColorInspectionMinArea;
            m_arrDefectColorInspectionMaxArea[intFrom] = arrDefectColorInspectionMaxArea;
            m_arrDefectColorInspectionTotalArea[intFrom] = arrDefectColorInspectionTotalArea;

        }
    }
}

